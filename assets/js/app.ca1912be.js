(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],l=e[1],c=e[2],d=0,p=[];d<s.length;d++)i=s[d],Object.prototype.hasOwnProperty.call(o,i)&&o[i]&&p.push(o[i][0]),o[i]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(u&&u(e);p.length;)p.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==o[l]&&(r=!1)}r&&(a.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},o={1:0},a=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=o[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=o[n]=[e,r]}));e.push(t[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"37ecbe42",3:"a94bca7d",4:"3c076cc1",5:"3dee0b9e",6:"0dcf2416",7:"a75b65b8",8:"582cb1a2",9:"f40f686d",10:"2ad00bc5",11:"e24d2f56",12:"3a27f131",13:"b6c6f6ed",14:"1383a07d",15:"6dce59fe",16:"cc0de160",17:"21cffd14",18:"412c079a",19:"f7ec127c",20:"ee23c0a2",21:"6996f638",22:"fb5cb604",23:"9a79f539",24:"c4098bb2",25:"26896566",26:"b3b7b1f8",27:"2f4919b8",28:"41ce159e",29:"857c5a00",30:"73ac0d38",31:"e96f7fa9",32:"f0d079fc",33:"57ada703",34:"8ef1ee2e",35:"0172bc08",36:"8b609cff",37:"05a3472a",38:"8fc94eac",39:"1364ec49",40:"642118ec",41:"b73ba281",42:"3d43de4e",43:"7c72be71",44:"e6fd7e4c",45:"80270188",46:"20881084",47:"975d4d88",48:"74b7de4e",49:"badbc0fd",50:"4c105fff",51:"25618f4f",52:"24235da6",53:"bac66d66",54:"117a0bb3",55:"0829c544",56:"684c301f",57:"5c65fff0",58:"361747fe",59:"99e7433b",60:"db51bb23",61:"c9388467",62:"73be41ca",63:"42267e85",64:"6e55cf49",65:"7bd0e226",66:"46825ce5",67:"e276ad2d",68:"9e00518b",69:"d03e9c5a",70:"a448d15a",71:"b4778cbc",72:"7663bb72",73:"35693a6f",74:"6d9cec5f",75:"26a8fef6",76:"26904992",77:"089f5015",78:"825deb78",79:"8ac0a277",80:"35039c22",81:"527864c6",82:"3713630e",83:"d8654624",84:"ea03a364",85:"1169f938",86:"96946ce2",87:"6fb1e0a8",88:"db7ce45e",89:"ae4b6ca3",90:"1c88216c",91:"2e73462f",92:"965b6ed1",93:"494f97bf",94:"a9757aab",95:"3512cd58",96:"ca19c3ce",97:"1a66afdc",98:"e9e54416",99:"01a5f660",100:"cff83e16",101:"af5089f1",102:"81995db6",103:"c943a5f6",104:"ce2ad0f3",105:"1696773d",106:"a07ceca8",107:"bfb7f78f",108:"59f0a0d6",109:"1bf5c0bb",110:"cfe0a758",111:"62e94687",112:"d45fb7d0",113:"dc814acb",114:"b44a2b77",115:"4f2cc537",116:"eaceb24a",117:"85b5e167",118:"8af761ee",119:"1025fe9b",120:"1affad3e",121:"f1700b48",122:"3936e268",123:"7da9c65e",124:"8173a20f",125:"66c21c7b",126:"6fce0578",127:"a8c9a0a5",128:"b177933f",129:"fe4f9bc1",130:"02e75196",131:"09677d21",132:"508c2407",133:"1b66877a",134:"fd563475",135:"f384514b",136:"885853d4",137:"aee09014",138:"11973b09",139:"1d9322fe",140:"d75c01e5",141:"2c0d8203",142:"85455350",143:"9941bb73",144:"b8c6c02e",145:"83acaa33",146:"09c690f8",147:"1081f9ee",148:"4fefd78f"}[n]+".js"}(n);var l=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=o[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",l.name="ChunkLoadError",l.type=r,l.request=a,t[1](l)}o[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var u=l;a.push([237,0]),t()}([function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var r=t(0),o=t(38).f,a=t(27),i=t(14),s=t(112),l=t(119),c=t(105);n.exports=function(n,e){var t,u,d,p,m,f=n.target,h=n.global,g=n.stat;if(t=h?r:g?r[f]||s(f,{}):(r[f]||{}).prototype)for(u in e){if(p=e[u],d=n.noTargetGet?(m=o(t,u))&&m.value:t[u],!c(h?u:f+(g?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;l(p,d)}(n.sham||d&&d.sham)&&a(p,"sham",!0),i(t,u,p,n)}}},function(n,e,t){var r=t(63),o=Function.prototype,a=o.bind,i=o.call,s=r&&a.bind(i,i);n.exports=r?function(n){return n&&s(n)}:function(n){return n&&function(){return i.apply(n,arguments)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r=t(123),o=t(14),a=t(253);r||o(Object.prototype,"toString",a,{unsafe:!0})},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var r=t(0),o=t(79),a=t(10),i=t(80),s=t(113),l=t(156),c=o("wks"),u=r.Symbol,d=u&&u.for,p=l?u:u&&u.withoutSetter||i;n.exports=function(n){if(!a(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&a(u,n)?c[n]=u[n]:c[n]=l&&d?d(e):p(e)}return c[n]}},function(n,e,t){var r=t(3);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(0),o=t(9),a=r.String,i=r.TypeError;n.exports=function(n){if(o(n))return n;throw i(a(n)+" is not an object")}},function(n,e,t){var r=t(5);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(2),o=t(15),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(o(n),e)}},function(n,e,t){var r=t(63),o=Function.prototype.call;n.exports=r?o.bind(o):function(){return o.apply(o,arguments)}},function(n,e,t){var r=t(0),o=t(76),a=r.String;n.exports=function(n){if("Symbol"===o(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var r=t(0),o=t(7),a=t(158),i=t(157),s=t(8),l=t(82),c=r.TypeError,u=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=o?i?function(n,e,t){if(s(n),e=l(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=d(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return u(n,e,t)}:u:function(n,e,t){if(s(n),e=l(e),s(t),a)try{return u(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(0),o=t(5),a=t(10),i=t(27),s=t(112),l=t(87),c=t(39),u=t(66).CONFIGURABLE,d=c.get,p=c.enforce,m=String(String).split("String");(n.exports=function(n,e,t,l){var c,d=!!l&&!!l.unsafe,f=!!l&&!!l.enumerable,h=!!l&&!!l.noTargetGet,g=l&&void 0!==l.name?l.name:e;o(t)&&("Symbol("===String(g).slice(0,7)&&(g="["+String(g).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!a(t,"name")||u&&t.name!==g)&&i(t,"name",g),(c=p(t)).source||(c.source=m.join("string"==typeof g?g:""))),n!==r?(d?!h&&n[e]&&(f=!0):delete n[e],f?n[e]=t:i(n,e,t)):f?n[e]=t:s(e,t)})(Function.prototype,"toString",(function(){return o(this)&&d(this).source||l(this)}))},function(n,e,t){var r=t(0),o=t(18),a=r.Object;n.exports=function(n){return a(o(n))}},function(n,e,t){var r=t(0),o=t(5),a=function(n){return o(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e,t){"use strict";var r=t(1),o=t(93);r({target:"RegExp",proto:!0,forced:/./.exec!==o},{exec:o})},function(n,e,t){var r=t(0).TypeError;n.exports=function(n){if(null==n)throw r("Can't call method on "+n);return n}},function(n,e,t){var r=t(62),o=t(18);n.exports=function(n){return r(o(n))}},function(n,e,t){"use strict";function r(n,e,t,r,o,a,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),o&&o.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):o&&(l=s?function(){o.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:o),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(174).charAt,o=t(12),a=t(39),i=t(162),s=a.set,l=a.getterFor("String Iterator");i(String,"String",(function(n){s(this,{type:"String Iterator",string:o(n),index:0})}),(function(){var n,e=l(this),t=e.string,o=e.index;return o>=t.length?{value:void 0,done:!0}:(n=r(t,o),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var r=t(52);n.exports=function(n){return r(n.length)}},function(n,e,t){"use strict";var r=t(1),o=t(57).filter;r({target:"Array",proto:!0,forced:!t(91)("filter")},{filter:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(0),o=t(175),a=t(176),i=t(144),s=t(27),l=t(6),c=l("iterator"),u=l("toStringTag"),d=i.values,p=function(n,e){if(n){if(n[c]!==d)try{s(n,c,d)}catch(e){n[c]=d}if(n[u]||s(n,u,e),o[e])for(var t in i)if(n[t]!==i[t])try{s(n,t,i[t])}catch(e){n[t]=i[t]}}};for(var m in o)p(r[m]&&r[m].prototype,m);p(a,"DOMTokenList")},function(n,e,t){var r=t(2),o=r({}.toString),a=r("".slice);n.exports=function(n){return a(o(n),8,-1)}},function(n,e){n.exports=!1},function(n,e,t){var r=t(7),o=t(13),a=t(48);n.exports=r?function(n,e,t){return o.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";var r=t(1),o=t(182);r({target:"Array",proto:!0,forced:[].forEach!=o},{forEach:o})},function(n,e,t){var r=t(0),o=t(175),a=t(176),i=t(182),s=t(27),l=function(n){if(n&&n.forEach!==i)try{s(n,"forEach",i)}catch(e){n.forEach=i}};for(var c in o)o[c]&&l(r[c]&&r[c].prototype);l(a)},function(n,e,t){var r=t(14),o=t(268),a=Error.prototype;a.toString!==o&&r(a,"toString",o)},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(16);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(192),o="object"==typeof self&&self&&self.Object===Object&&self,a=r||o||Function("return this")();n.exports=a},function(n,e,t){var r,o=t(8),a=t(114),i=t(117),s=t(64),l=t(161),c=t(81),u=t(86),d=u("IE_PROTO"),p=function(){},m=function(n){return"<script>"+n+"<\/script>"},f=function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e},h=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,e;h="undefined"!=typeof document?document.domain&&r?f(r):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F):f(r);for(var t=i.length;t--;)delete h.prototype[i[t]];return h()};s[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=o(n),t=new p,p.prototype=null,t[d]=n):t=h(),void 0===e?t:a.f(t,e)}},function(n,e,t){var r=t(2);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(63),o=Function.prototype,a=o.apply,i=o.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?i.bind(a):function(){return i.apply(a,arguments)})},function(n,e,t){var r=t(0),o=t(5),a=t(84),i=r.TypeError;n.exports=function(n){if(o(n))return n;throw i(a(n)+" is not a function")}},function(n,e,t){var r=t(7),o=t(11),a=t(118),i=t(48),s=t(19),l=t(82),c=t(10),u=t(158),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=s(n),e=l(e),u)try{return d(n,e)}catch(n){}if(c(n,e))return i(!o(a.f,n,e),n[e])}},function(n,e,t){var r,o,a,i=t(239),s=t(0),l=t(2),c=t(9),u=t(27),d=t(10),p=t(111),m=t(86),f=t(64),h=s.TypeError,g=s.WeakMap;if(i||p.state){var b=p.state||(p.state=new g),y=l(b.get),v=l(b.has),x=l(b.set);r=function(n,e){if(v(b,n))throw new h("Object already initialized");return e.facade=n,x(b,n,e),e},o=function(n){return y(b,n)||{}},a=function(n){return v(b,n)}}else{var w=m("state");f[w]=!0,r=function(n,e){if(d(n,w))throw new h("Object already initialized");return e.facade=n,u(n,w,e),e},o=function(n){return d(n,w)?n[w]:{}},a=function(n){return d(n,w)}}n.exports={set:r,get:o,has:a,enforce:function(n){return a(n)?o(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=o(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(1),o=t(0),a=t(36),i=t(264),s=o.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=i(n,e,l),r({global:!0,forced:l},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var r=t(288),o=t(291);n.exports=function(n,e){var t=o(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";var r=t(1),o=t(0),a=t(60),i=t(88),s=t(9),l=t(116),c=t(22),u=t(19),d=t(69),p=t(6),m=t(91),f=t(68),h=m("slice"),g=p("species"),b=o.Array,y=Math.max;r({target:"Array",proto:!0,forced:!h},{slice:function(n,e){var t,r,o,p=u(this),m=c(p),h=l(n,m),v=l(void 0===e?m:e,m);if(a(p)&&(t=p.constructor,(i(t)&&(t===b||a(t.prototype))||s(t)&&null===(t=t[g]))&&(t=void 0),t===b||void 0===t))return f(p,h,v);for(r=new(void 0===t?b:t)(y(v-h,0)),o=0;h<v;h++,o++)h in p&&d(r,o,p[h]);return r.length=o,r}})},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return i})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return u})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return f})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return b})),t.d(e,"n",(function(){return y})),t.d(e,"a",(function(){return x}));t(17),t(45),t(140),t(74),t(103),t(110),t(44),t(28),t(4),t(29),t(23),t(77),t(104),t(155),t(53),t(212),t(30),t(143);var r=/#.*$/,o=/\.(md|html)$/,a=/\/$/,i=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(o,"")}function l(n){return i.test(n)}function c(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;var e=n.match(r),t=e?e[0]:"",o=s(n);return a.test(o)?n:o+".html"+t}function p(n,e){var t=n.hash,o=function(n){var e=n.match(r);if(e)return e[0]}(e);return(!o||t===o)&&s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var o=e.split("/");t&&o[o.length-1]||o.pop();for(var a=n.replace(/^\//,"").split("/"),i=0;i<a.length;i++){var s=a[i];".."===s?o.pop():"."!==s&&o.push(s)}""!==o[0]&&o.unshift("");return o.join("/")}(e,t));for(var r=s(e),o=0;o<n.length;o++)if(s(n[o].regularPath)===r)return Object.assign({},n[o],{type:"page",path:d(n[o].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function f(n,e,t,r){var o=t.pages,a=t.themeConfig,i=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||i.sidebar||a.sidebar))return h(n);var s=i.sidebar||a.sidebar;if(s){var l=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(r=n,/(\.html|\/)$/.test(r)?r:r+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var r;return{}}(e,s),c=l.base,u=l.config;return"auto"===u?h(n):u?u.map((function(n){return function n(e,t,r){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return m(t,e,r);if(Array.isArray(e))return Object.assign(m(t,e[0],r),{title:e[1]});o>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var a=e.children||[];return 0===a.length&&e.path?Object.assign(m(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map((function(e){return n(e,t,r,o+1)})),collapsable:!1!==e.collapsable}}(n,o,c)})):[]}return[]}function h(n){var e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}function g(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function b(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function y(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function v(n){var e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return v(e)-v(n)}},function(n,e,t){"use strict";var r=t(1),o=t(57).map;r({target:"Array",proto:!0,forced:!t(91)("map")},{map:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(36),o=t(11),a=t(2),i=t(108),s=t(3),l=t(8),c=t(5),u=t(55),d=t(52),p=t(12),m=t(18),f=t(127),h=t(47),g=t(269),b=t(109),y=t(6)("replace"),v=Math.max,x=Math.min,w=a([].concat),k=a([].push),S=a("".indexOf),j=a("".slice),E="$0"==="a".replace(/./,"$0"),A=!!/./[y]&&""===/./[y]("a","$0");i("replace",(function(n,e,t){var a=A?"$":"$0";return[function(n,t){var r=m(this),a=null==n?void 0:h(n,y);return a?o(a,n,r,t):o(e,p(r),n,t)},function(n,o){var i=l(this),s=p(n);if("string"==typeof o&&-1===S(o,a)&&-1===S(o,"$<")){var m=t(e,i,s,o);if(m.done)return m.value}var h=c(o);h||(o=p(o));var y=i.global;if(y){var E=i.unicode;i.lastIndex=0}for(var A=[];;){var I=b(i,s);if(null===I)break;if(k(A,I),!y)break;""===p(I[0])&&(i.lastIndex=f(s,d(i.lastIndex),E))}for(var T,z="",_=0,C=0;C<A.length;C++){for(var P=p((I=A[C])[0]),O=v(x(u(I.index),s.length),0),M=[],D=1;D<I.length;D++)k(M,void 0===(T=I[D])?T:String(T));var R=I.groups;if(h){var B=w([P],M,O,s);void 0!==R&&k(B,R);var L=p(r(o,void 0,B))}else L=g(P,s,O,M,R,o);O>=_&&(z+=j(s,_,O)+L,_=O+P.length)}return z+j(s,_)}]}),!!s((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!E||A)},function(n,e,t){"use strict";var r=t(3);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){throw 1},1)}))}},function(n,e,t){var r=t(37);n.exports=function(n,e){var t=n[e];return null==t?void 0:r(t)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(75),t(70),t(23),t(4),t(380),t(28),t(29),t(177),t(381),t(99);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function a(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}},function(n,e,t){var r,o,a=t(0),i=t(32),s=a.process,l=a.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(o=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!o&&i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(o=+r[1]),n.exports=o},function(n,e,t){var r=t(55),o=Math.min;n.exports=function(n){return n>0?o(r(n),9007199254740991):0}},function(n,e,t){"use strict";var r=t(1),o=t(0),a=t(3),i=t(60),s=t(9),l=t(15),c=t(22),u=t(69),d=t(147),p=t(91),m=t(6),f=t(51),h=m("isConcatSpreadable"),g=o.TypeError,b=f>=51||!a((function(){var n=[];return n[h]=!1,n.concat()[0]!==n})),y=p("concat"),v=function(n){if(!s(n))return!1;var e=n[h];return void 0!==e?!!e:i(n)};r({target:"Array",proto:!0,forced:!b||!y},{concat:function(n){var e,t,r,o,a,i=l(this),s=d(i,0),p=0;for(e=-1,r=arguments.length;e<r;e++)if(v(a=-1===e?i:arguments[e])){if(p+(o=c(a))>9007199254740991)throw g("Maximum allowed index exceeded");for(t=0;t<o;t++,p++)t in a&&u(s,p,a[t])}else{if(p>=9007199254740991)throw g("Maximum allowed index exceeded");u(s,p++,a)}return s.length=p,s}})},function(n,e,t){var r=t(1),o=t(0),a=t(36),i=t(5),s=t(32),l=t(68),c=t(146),u=/MSIE .\./.test(s),d=o.Function,p=function(n){return function(e,t){var r=c(arguments.length,1)>2,o=i(e)?e:d(e),s=r?l(arguments,2):void 0;return n(r?function(){a(o,this,s)}:o,t)}};r({global:!0,bind:!0,forced:u},{setTimeout:p(o.setTimeout),setInterval:p(o.setInterval)})},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){var e=+n;return e!=e||0===e?0:(e>0?r:t)(e)}},function(n,e,t){var r=t(2),o=t(37),a=t(63),i=r(r.bind);n.exports=function(n,e){return o(n),void 0===e?n:a?i(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){var r=t(56),o=t(2),a=t(62),i=t(15),s=t(22),l=t(147),c=o([].push),u=function(n){var e=1==n,t=2==n,o=3==n,u=4==n,d=6==n,p=7==n,m=5==n||d;return function(f,h,g,b){for(var y,v,x=i(f),w=a(x),k=r(h,g),S=s(w),j=0,E=b||l,A=e?E(f,S):t||p?E(f,0):void 0;S>j;j++)if((m||j in w)&&(v=k(y=w[j],j,x),n))if(e)A[j]=v;else if(v)switch(n){case 3:return!0;case 5:return y;case 6:return j;case 2:c(A,y)}else switch(n){case 4:return!1;case 7:c(A,y)}return d?-1:o||u?u:A}};n.exports={forEach:u(0),map:u(1),filter:u(2),some:u(3),every:u(4),find:u(5),findIndex:u(6),filterReject:u(7)}},function(n,e,t){var r=t(160),o=t(117).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,o)}},function(n,e,t){var r=t(13).f,o=t(10),a=t(6)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!o(n,a)&&r(n,a,{configurable:!0,value:e})}},function(n,e,t){var r=t(25);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e,t){var r=t(71),o=t(273),a=t(274),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?o(n):a(n)}},function(n,e,t){var r=t(0),o=t(2),a=t(3),i=t(25),s=r.Object,l=o("".split);n.exports=a((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?l(n,""):s(n)}:s},function(n,e,t){var r=t(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var r=t(7),o=t(10),a=Function.prototype,i=r&&Object.getOwnPropertyDescriptor,s=o(a,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&i(a,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(2),o=t(8),a=t(240);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return o(t),a(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e,t){var r=t(2);n.exports=r([].slice)},function(n,e,t){"use strict";var r=t(82),o=t(13),a=t(48);n.exports=function(n,e,t){var i=r(e);i in n?o.f(n,i,a(0,t)):n[i]=t}},function(n,e,t){"use strict";var r=t(1),o=t(0),a=t(16),i=t(36),s=t(11),l=t(2),c=t(26),u=t(7),d=t(113),p=t(3),m=t(10),f=t(60),h=t(5),g=t(9),b=t(35),y=t(83),v=t(8),x=t(15),w=t(19),k=t(82),S=t(12),j=t(48),E=t(34),A=t(85),I=t(58),T=t(184),z=t(121),_=t(38),C=t(13),P=t(114),O=t(118),M=t(68),D=t(14),R=t(79),B=t(86),L=t(64),N=t(80),F=t(6),q=t(185),$=t(186),G=t(59),U=t(39),H=t(57).forEach,J=B("hidden"),W=F("toPrimitive"),V=U.set,K=U.getterFor("Symbol"),Z=Object.prototype,Y=o.Symbol,X=Y&&Y.prototype,Q=o.TypeError,nn=o.QObject,en=a("JSON","stringify"),tn=_.f,rn=C.f,on=T.f,an=O.f,sn=l([].push),ln=R("symbols"),cn=R("op-symbols"),un=R("string-to-symbol-registry"),dn=R("symbol-to-string-registry"),pn=R("wks"),mn=!nn||!nn.prototype||!nn.prototype.findChild,fn=u&&p((function(){return 7!=E(rn({},"a",{get:function(){return rn(this,"a",{value:7}).a}})).a}))?function(n,e,t){var r=tn(Z,e);r&&delete Z[e],rn(n,e,t),r&&n!==Z&&rn(Z,e,r)}:rn,hn=function(n,e){var t=ln[n]=E(X);return V(t,{type:"Symbol",tag:n,description:e}),u||(t.description=e),t},gn=function(n,e,t){n===Z&&gn(cn,e,t),v(n);var r=k(e);return v(t),m(ln,r)?(t.enumerable?(m(n,J)&&n[J][r]&&(n[J][r]=!1),t=E(t,{enumerable:j(0,!1)})):(m(n,J)||rn(n,J,j(1,{})),n[J][r]=!0),fn(n,r,t)):rn(n,r,t)},bn=function(n,e){v(n);var t=w(e),r=A(t).concat(wn(t));return H(r,(function(e){u&&!s(yn,t,e)||gn(n,e,t[e])})),n},yn=function(n){var e=k(n),t=s(an,this,e);return!(this===Z&&m(ln,e)&&!m(cn,e))&&(!(t||!m(this,e)||!m(ln,e)||m(this,J)&&this[J][e])||t)},vn=function(n,e){var t=w(n),r=k(e);if(t!==Z||!m(ln,r)||m(cn,r)){var o=tn(t,r);return!o||!m(ln,r)||m(t,J)&&t[J][r]||(o.enumerable=!0),o}},xn=function(n){var e=on(w(n)),t=[];return H(e,(function(n){m(ln,n)||m(L,n)||sn(t,n)})),t},wn=function(n){var e=n===Z,t=on(e?cn:w(n)),r=[];return H(t,(function(n){!m(ln,n)||e&&!m(Z,n)||sn(r,ln[n])})),r};(d||(D(X=(Y=function(){if(b(X,this))throw Q("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?S(arguments[0]):void 0,e=N(n),t=function(n){this===Z&&s(t,cn,n),m(this,J)&&m(this[J],e)&&(this[J][e]=!1),fn(this,e,j(1,n))};return u&&mn&&fn(Z,e,{configurable:!0,set:t}),hn(e,n)}).prototype,"toString",(function(){return K(this).tag})),D(Y,"withoutSetter",(function(n){return hn(N(n),n)})),O.f=yn,C.f=gn,P.f=bn,_.f=vn,I.f=T.f=xn,z.f=wn,q.f=function(n){return hn(F(n),n)},u&&(rn(X,"description",{configurable:!0,get:function(){return K(this).description}}),c||D(Z,"propertyIsEnumerable",yn,{unsafe:!0}))),r({global:!0,wrap:!0,forced:!d,sham:!d},{Symbol:Y}),H(A(pn),(function(n){$(n)})),r({target:"Symbol",stat:!0,forced:!d},{for:function(n){var e=S(n);if(m(un,e))return un[e];var t=Y(e);return un[e]=t,dn[t]=e,t},keyFor:function(n){if(!y(n))throw Q(n+" is not a symbol");if(m(dn,n))return dn[n]},useSetter:function(){mn=!0},useSimple:function(){mn=!1}}),r({target:"Object",stat:!0,forced:!d,sham:!u},{create:function(n,e){return void 0===e?E(n):bn(E(n),e)},defineProperty:gn,defineProperties:bn,getOwnPropertyDescriptor:vn}),r({target:"Object",stat:!0,forced:!d},{getOwnPropertyNames:xn,getOwnPropertySymbols:wn}),r({target:"Object",stat:!0,forced:p((function(){z.f(1)}))},{getOwnPropertySymbols:function(n){return z.f(x(n))}}),en)&&r({target:"JSON",stat:!0,forced:!d||p((function(){var n=Y();return"[null]"!=en([n])||"{}"!=en({a:n})||"{}"!=en(Object(n))}))},{stringify:function(n,e,t){var r=M(arguments),o=e;if((g(e)||void 0!==n)&&!y(n))return f(e)||(e=function(n,e){if(h(o)&&(e=s(o,this,n,e)),!y(e))return e}),r[1]=e,i(en,null,r)}});if(!X[W]){var kn=X.valueOf;D(X,W,(function(n){return s(kn,this)}))}G(Y,"Symbol"),L[J]=!0},function(n,e,t){var r=t(33).Symbol;n.exports=r},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(77);var r=t(73);t(70),t(92),t(4),t(126),t(21),t(24),t(187);var o=t(100);t(40),t(30);function a(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(o.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";t(17);var r,o,a=t(1),i=t(0),s=t(11),l=t(2),c=t(5),u=t(9),d=(r=!1,(o=/[ac]/).exec=function(){return r=!0,/./.exec.apply(this,arguments)},!0===o.test("abc")&&r),p=i.Error,m=l(/./.test);a({target:"RegExp",proto:!0,forced:!d},{test:function(n){var e=this.exec;if(!c(e))return m(this,n);var t=s(e,this,n);if(null!==t&&!u(t))throw new p("RegExp exec method returned something other than an Object or null");return!!t}})},function(n,e,t){var r=t(1),o=t(15),a=t(85);r({target:"Object",stat:!0,forced:t(3)((function(){a(1)}))},{keys:function(n){return a(o(n))}})},function(n,e,t){var r=t(0),o=t(123),a=t(5),i=t(25),s=t(6)("toStringTag"),l=r.Object,c="Arguments"==i(function(){return arguments}());n.exports=o?i:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=l(n),s))?t:c?i(e):"Object"==(r=i(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){t(1)({target:"Array",stat:!0},{isArray:t(60)})},function(n,e,t){var r=t(7),o=t(66).EXISTS,a=t(2),i=t(13).f,s=Function.prototype,l=a(s.toString),c=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,u=a(c.exec);r&&!o&&i(s,"name",{configurable:!0,get:function(){try{return u(c,l(this))[1]}catch(n){return""}}})},function(n,e,t){var r=t(26),o=t(111);(n.exports=function(n,e){return o[n]||(o[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.21.0",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.21.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){var r=t(2),o=0,a=Math.random(),i=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++o+a,36)}},function(n,e,t){var r=t(0),o=t(9),a=r.document,i=o(a)&&o(a.createElement);n.exports=function(n){return i?a.createElement(n):{}}},function(n,e,t){var r=t(159),o=t(83);n.exports=function(n){var e=r(n,"string");return o(e)?e:e+""}},function(n,e,t){var r=t(0),o=t(16),a=t(5),i=t(35),s=t(156),l=r.Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=o("Symbol");return a(e)&&i(e.prototype,l(n))}},function(n,e,t){var r=t(0).String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(160),o=t(117);n.exports=Object.keys||function(n){return r(n,o)}},function(n,e,t){var r=t(79),o=t(80),a=r("keys");n.exports=function(n){return a[n]||(a[n]=o(n))}},function(n,e,t){var r=t(2),o=t(5),a=t(111),i=r(Function.toString);o(a.inspectSource)||(a.inspectSource=function(n){return i(n)}),n.exports=a.inspectSource},function(n,e,t){var r=t(2),o=t(3),a=t(5),i=t(76),s=t(16),l=t(87),c=function(){},u=[],d=s("Reflect","construct"),p=/^\s*(?:class|function)\b/,m=r(p.exec),f=!p.exec(c),h=function(n){if(!a(n))return!1;try{return d(c,u,n),!0}catch(n){return!1}},g=function(n){if(!a(n))return!1;switch(i(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return f||!!m(p,l(n))}catch(n){return!0}};g.sham=!0,n.exports=!d||o((function(){var n;return h(h.call)||!h(Object)||!h((function(){n=!0}))||n}))?g:h},function(n,e,t){var r=t(25),o=t(0);n.exports="process"==r(o.process)},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(4);function r(n,e,t,r,o,a,i){try{var s=n[a](i),l=s.value}catch(n){return void t(n)}s.done?e(l):Promise.resolve(l).then(r,o)}function o(n){return function(){var e=this,t=arguments;return new Promise((function(o,a){var i=n.apply(e,t);function s(n){r(i,o,a,s,l,"next",n)}function l(n){r(i,o,a,s,l,"throw",n)}s(void 0)}))}}},function(n,e,t){var r=t(3),o=t(6),a=t(51),i=o("species");n.exports=function(n){return a>=51||!r((function(){var e=[];return(e.constructor={})[i]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){"use strict";var r=t(1),o=t(7),a=t(0),i=t(2),s=t(10),l=t(5),c=t(35),u=t(12),d=t(13).f,p=t(119),m=a.Symbol,f=m&&m.prototype;if(o&&l(m)&&(!("description"in f)||void 0!==m().description)){var h={},g=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:u(arguments[0]),e=c(f,this)?new m(n):void 0===n?m():m(n);return""===n&&(h[e]=!0),e};p(g,m),g.prototype=f,f.constructor=g;var b="Symbol(test)"==String(m("test")),y=i(f.toString),v=i(f.valueOf),x=/^Symbol\((.*)\)[^)]+$/,w=i("".replace),k=i("".slice);d(f,"description",{configurable:!0,get:function(){var n=v(this),e=y(n);if(s(h,n))return"";var t=b?k(e,7,-1):w(e,x,"$1");return""===t?void 0:t}}),r({global:!0,forced:!0},{Symbol:g})}},function(n,e,t){"use strict";var r,o,a=t(11),i=t(2),s=t(12),l=t(149),c=t(107),u=t(79),d=t(34),p=t(39).get,m=t(225),f=t(230),h=u("native-string-replace",String.prototype.replace),g=RegExp.prototype.exec,b=g,y=i("".charAt),v=i("".indexOf),x=i("".replace),w=i("".slice),k=(o=/b*/g,a(g,r=/a/,"a"),a(g,o,"a"),0!==r.lastIndex||0!==o.lastIndex),S=c.BROKEN_CARET,j=void 0!==/()??/.exec("")[1];(k||j||S||m||f)&&(b=function(n){var e,t,r,o,i,c,u,m=this,f=p(m),E=s(n),A=f.raw;if(A)return A.lastIndex=m.lastIndex,e=a(b,A,E),m.lastIndex=A.lastIndex,e;var I=f.groups,T=S&&m.sticky,z=a(l,m),_=m.source,C=0,P=E;if(T&&(z=x(z,"y",""),-1===v(z,"g")&&(z+="g"),P=w(E,m.lastIndex),m.lastIndex>0&&(!m.multiline||m.multiline&&"\n"!==y(E,m.lastIndex-1))&&(_="(?: "+_+")",P=" "+P,C++),t=new RegExp("^(?:"+_+")",z)),j&&(t=new RegExp("^"+_+"$(?!\\s)",z)),k&&(r=m.lastIndex),o=a(g,T?t:m,P),T?o?(o.input=w(o.input,C),o[0]=w(o[0],C),o.index=m.lastIndex,m.lastIndex+=o[0].length):m.lastIndex=0:k&&o&&(m.lastIndex=m.global?o.index+o[0].length:r),j&&o&&o.length>1&&a(h,o[0],t,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(o[i]=void 0)})),o&&I)for(o.groups=c=d(null),i=0;i<I.length;i++)c[(u=I[i])[0]]=o[u[1]];return o}),n.exports=b},function(n,e,t){var r=t(278),o=t(279),a=t(280),i=t(281),s=t(282);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(194);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(41)(Object,"create");n.exports=r},function(n,e,t){var r=t(300);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(135);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r=t(1),o=t(7),a=t(13).f;r({target:"Object",stat:!0,forced:Object.defineProperty!==a,sham:!o},{defineProperty:a})},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(42),t(4),t(78),t(187),t(21),t(17),t(74);var r=t(73);function o(n,e){if(n){if("string"==typeof n)return Object(r.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(r.a)(n,e):void 0}}},function(n,e,t){var r,o;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(o="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function o(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=o(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),u=r.speed,d=r.easing;return l.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var o;return(o="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,o}(n,u,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*o(Math.random()*e,.1,.95)),e=o(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var o,i=e.querySelector(r.barSelector),l=n?"-100":a(t.status||0),u=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(o=e.querySelector(r.spinnerSelector))&&p(o),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,o=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);o--;)if((r=n[o]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,o,a=arguments;if(2==a.length)for(t in e)void 0!==(o=e[t])&&e.hasOwnProperty(t)&&r(n,t,o);else r(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function u(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=o)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment","version":"0.7.3","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"}}')},function(n,e,t){"use strict";var r=t(36),o=t(11),a=t(2),i=t(108),s=t(148),l=t(8),c=t(18),u=t(124),d=t(127),p=t(52),m=t(12),f=t(47),h=t(125),g=t(109),b=t(93),y=t(107),v=t(3),x=y.UNSUPPORTED_Y,w=Math.min,k=[].push,S=a(/./.exec),j=a(k),E=a("".slice);i("split",(function(n,e,t){var a;return a="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var a=m(c(this)),i=void 0===t?4294967295:t>>>0;if(0===i)return[];if(void 0===n)return[a];if(!s(n))return o(e,a,n,i);for(var l,u,d,p=[],f=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),g=0,y=new RegExp(n.source,f+"g");(l=o(b,y,a))&&!((u=y.lastIndex)>g&&(j(p,E(a,g,l.index)),l.length>1&&l.index<a.length&&r(k,p,h(l,1)),d=l[0].length,g=u,p.length>=i));)y.lastIndex===l.index&&y.lastIndex++;return g===a.length?!d&&S(y,"")||j(p,""):j(p,E(a,g)),p.length>i?h(p,0,i):p}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:o(e,this,n,t)}:e,[function(e,t){var r=c(this),i=null==e?void 0:f(e,n);return i?o(i,e,r,t):o(a,m(r),e,t)},function(n,r){var o=l(this),i=m(n),s=t(a,o,i,r,a!==e);if(s.done)return s.value;var c=u(o,RegExp),f=o.unicode,h=(o.ignoreCase?"i":"")+(o.multiline?"m":"")+(o.unicode?"u":"")+(x?"g":"y"),b=new c(x?"^(?:"+o.source+")":o,h),y=void 0===r?4294967295:r>>>0;if(0===y)return[];if(0===i.length)return null===g(b,i)?[i]:[];for(var v=0,k=0,S=[];k<i.length;){b.lastIndex=x?0:k;var A,I=g(b,x?E(i,k):i);if(null===I||(A=w(p(b.lastIndex+(x?k:0)),i.length))===v)k=d(i,k,f);else{if(j(S,E(i,v,k)),S.length===y)return S;for(var T=1;T<=I.length-1;T++)if(j(S,I[T]),S.length===y)return S;k=v=A}}return j(S,E(i,v)),S}]}),!!v((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),x)},function(n,e,t){"use strict";var r=t(1),o=t(2),a=t(115).indexOf,i=t(46),s=o([].indexOf),l=!!s&&1/s([1],1,-0)<0,c=i("indexOf");r({target:"Array",proto:!0,forced:l||!c},{indexOf:function(n){var e=arguments.length>1?arguments[1]:void 0;return l?s(this,n,e)||0:a(this,n,e)}})},function(n,e,t){var r=t(3),o=t(5),a=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t==u||t!=c&&(o(e)?r(e):!!e)},s=i.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",u=i.POLYFILL="P";n.exports=i},function(n,e,t){var r=t(76),o=t(47),a=t(65),i=t(6)("iterator");n.exports=function(n){if(null!=n)return o(n,i)||o(n,"@@iterator")||a[r(n)]}},function(n,e,t){var r=t(3),o=t(0).RegExp,a=r((function(){var n=o("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),i=a||r((function(){return!o("a","y").sticky})),s=a||r((function(){var n=o("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:s,MISSED_STICKY:i,UNSUPPORTED_Y:a}},function(n,e,t){"use strict";t(17);var r=t(2),o=t(14),a=t(93),i=t(3),s=t(6),l=t(27),c=s("species"),u=RegExp.prototype;n.exports=function(n,e,t,d){var p=s(n),m=!i((function(){var e={};return e[p]=function(){return 7},7!=""[n](e)})),f=m&&!i((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[c]=function(){return t},t.flags="",t[p]=/./[p]),t.exec=function(){return e=!0,null},t[p](""),!e}));if(!m||!f||t){var h=r(/./[p]),g=e(p,""[n],(function(n,e,t,o,i){var s=r(n),l=e.exec;return l===a||l===u.exec?m&&!i?{done:!0,value:h(e,t,o)}:{done:!0,value:s(t,e,o)}:{done:!1}}));o(String.prototype,n,g[0]),o(u,p,g[1])}d&&l(u[p],"sham",!0)}},function(n,e,t){var r=t(0),o=t(11),a=t(8),i=t(5),s=t(25),l=t(93),c=r.TypeError;n.exports=function(n,e){var t=n.exec;if(i(t)){var r=o(t,n,e);return null!==r&&a(r),r}if("RegExp"===s(n))return o(l,n,e);throw c("RegExp#exec called on incompatible receiver")}},function(n,e,t){"use strict";var r=t(1),o=t(2),a=t(62),i=t(19),s=t(46),l=o([].join),c=a!=Object,u=s("join",",");r({target:"Array",proto:!0,forced:c||!u},{join:function(n){return l(i(this),void 0===n?",":n)}})},function(n,e,t){var r=t(0),o=t(112),a=r["__core-js_shared__"]||o("__core-js_shared__",{});n.exports=a},function(n,e,t){var r=t(0),o=Object.defineProperty;n.exports=function(n,e){try{o(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(51),o=t(3);n.exports=!!Object.getOwnPropertySymbols&&!o((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r=t(7),o=t(157),a=t(13),i=t(8),s=t(19),l=t(85);e.f=r&&!o?Object.defineProperties:function(n,e){i(n);for(var t,r=s(e),o=l(e),c=o.length,u=0;c>u;)a.f(n,t=o[u++],r[t]);return n}},function(n,e,t){var r=t(19),o=t(116),a=t(22),i=function(n){return function(e,t,i){var s,l=r(e),c=a(l),u=o(i,c);if(n&&t!=t){for(;c>u;)if((s=l[u++])!=s)return!0}else for(;c>u;u++)if((n||u in l)&&l[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){var r=t(55),o=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?o(t+e,0):a(t,e)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,o=Object.getOwnPropertyDescriptor,a=o&&!r.call({1:2},1);e.f=a?function(n){var e=o(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(10),o=t(120),a=t(38),i=t(13);n.exports=function(n,e,t){for(var s=o(e),l=i.f,c=a.f,u=0;u<s.length;u++){var d=s[u];r(n,d)||t&&r(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var r=t(16),o=t(2),a=t(58),i=t(121),s=t(8),l=o([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(0),o=t(10),a=t(5),i=t(15),s=t(86),l=t(164),c=s("IE_PROTO"),u=r.Object,d=u.prototype;n.exports=l?u.getPrototypeOf:function(n){var e=i(n);if(o(e,c))return e[c];var t=e.constructor;return a(t)&&e instanceof t?t.prototype:e instanceof u?d:null}},function(n,e,t){var r={};r[t(6)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(8),o=t(169),a=t(6)("species");n.exports=function(n,e){var t,i=r(n).constructor;return void 0===i||null==(t=r(i)[a])?e:o(t)}},function(n,e,t){var r=t(0),o=t(116),a=t(22),i=t(69),s=r.Array,l=Math.max;n.exports=function(n,e,t){for(var r=a(n),c=o(e,r),u=o(void 0===t?r:t,r),d=s(l(u-c,0)),p=0;c<u;c++,p++)i(d,p,n[c]);return d.length=p,d}},function(n,e,t){t(186)("iterator")},function(n,e,t){"use strict";var r=t(174).charAt;n.exports=function(n,e,t){return e+(t?r(n,e).length:1)}},function(n,e,t){var r=t(272),o=t(49),a=Object.prototype,i=a.hasOwnProperty,s=a.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return o(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(41)(t(33),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(292),o=t(299),a=t(301),i=t(302),s=t(303);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(31),o=t(135),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!o(n))||(i.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(61),o=t(49);n.exports=function(n){return"symbol"==typeof n||o(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(1),o=t(0),a=t(59);r({global:!0},{Reflect:{}}),a(o.Reflect,"Reflect",!0)},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(77);t(70),t(92),t(4),t(126),t(21),t(24);var r=t(100);t(40),t(30);function o(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var r,o,a=[],i=!0,s=!1;try{for(t=t.call(n);!(i=(r=t.next()).done)&&(a.push(r.value),!e||a.length!==e);i=!0);}catch(n){s=!0,o=n}finally{try{i||null==t.return||t.return()}finally{if(s)throw o}}return a}}(n,e)||Object(r.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";var r=t(1),o=t(57).some;r({target:"Array",proto:!0,forced:!t(46)("some")},{some:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(11),o=t(108),a=t(8),i=t(52),s=t(12),l=t(18),c=t(47),u=t(127),d=t(109);o("match",(function(n,e,t){return[function(e){var t=l(this),o=null==e?void 0:c(e,n);return o?r(o,e,t):new RegExp(e)[n](s(t))},function(n){var r=a(this),o=s(n),l=t(e,r,o);if(l.done)return l.value;if(!r.global)return d(r,o);var c=r.unicode;r.lastIndex=0;for(var p,m=[],f=0;null!==(p=d(r,o));){var h=s(p[0]);m[f]=h,""===h&&(r.lastIndex=u(o,i(r.lastIndex),c)),f++}return 0===f?null:m}]}))},function(n,e,t){var r=t(6),o=t(34),a=t(13),i=r("unscopables"),s=Array.prototype;null==s[i]&&a.f(s,i,{configurable:!0,value:o(null)}),n.exports=function(n){s[i][n]=!0}},function(n,e,t){var r=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},o=r.iterator||"@@iterator",a=r.asyncIterator||"@@asyncIterator",i=r.toStringTag||"@@toStringTag";function s(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{s({},"")}catch(n){s=function(n,e,t){return n[e]=t}}function l(n,e,t,r){var o=e&&e.prototype instanceof d?e:d,a=Object.create(o.prototype),i=new S(r||[]);return a._invoke=function(n,e,t){var r="suspendedStart";return function(o,a){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===o)throw a;return E()}for(t.method=o,t.arg=a;;){var i=t.delegate;if(i){var s=x(i,t);if(s){if(s===u)continue;return s}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var l=c(n,e,t);if("normal"===l.type){if(r=t.done?"completed":"suspendedYield",l.arg===u)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(r="completed",t.method="throw",t.arg=l.arg)}}}(n,t,i),a}function c(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=l;var u={};function d(){}function p(){}function m(){}var f={};s(f,o,(function(){return this}));var h=Object.getPrototypeOf,g=h&&h(h(j([])));g&&g!==e&&t.call(g,o)&&(f=g);var b=m.prototype=d.prototype=Object.create(f);function y(n){["next","throw","return"].forEach((function(e){s(n,e,(function(n){return this._invoke(e,n)}))}))}function v(n,e){var r;this._invoke=function(o,a){function i(){return new e((function(r,i){!function r(o,a,i,s){var l=c(n[o],n,a);if("throw"!==l.type){var u=l.arg,d=u.value;return d&&"object"==typeof d&&t.call(d,"__await")?e.resolve(d.__await).then((function(n){r("next",n,i,s)}),(function(n){r("throw",n,i,s)})):e.resolve(d).then((function(n){u.value=n,i(u)}),(function(n){return r("throw",n,i,s)}))}s(l.arg)}(o,a,r,i)}))}return r=r?r.then(i,i):i()}}function x(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,x(n,e),"throw"===e.method))return u;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return u}var r=c(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,u;var o=r.arg;return o?o.done?(e[n.resultName]=o.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,u):o:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,u)}function w(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function k(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function S(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(w,this),this.reset(!0)}function j(n){if(n){var e=n[o];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,a=function e(){for(;++r<n.length;)if(t.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return a.next=a}}return{next:E}}function E(){return{value:void 0,done:!0}}return p.prototype=m,s(b,"constructor",m),s(m,"constructor",p),p.displayName=s(m,i,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===p||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,m):(n.__proto__=m,s(n,i,"GeneratorFunction")),n.prototype=Object.create(b),n},n.awrap=function(n){return{__await:n}},y(v.prototype),s(v.prototype,a,(function(){return this})),n.AsyncIterator=v,n.async=function(e,t,r,o,a){void 0===a&&(a=Promise);var i=new v(l(e,t,r,o),a);return n.isGeneratorFunction(t)?i:i.next().then((function(n){return n.done?n.value:i.next()}))},y(b),s(b,i,"Generator"),s(b,o,(function(){return this})),s(b,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=j,S.prototype={constructor:S,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(k),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(t,r){return i.type="throw",i.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o],i=a.completion;if("root"===a.tryLoc)return r("end");if(a.tryLoc<=this.prev){var s=t.call(a,"catchLoc"),l=t.call(a,"finallyLoc");if(s&&l){if(this.prev<a.catchLoc)return r(a.catchLoc,!0);if(this.prev<a.finallyLoc)return r(a.finallyLoc)}else if(s){if(this.prev<a.catchLoc)return r(a.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return r(a.finallyLoc)}}}},abrupt:function(n,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&t.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var a=o;break}}a&&("break"===n||"continue"===n)&&a.tryLoc<=e&&e<=a.finallyLoc&&(a=null);var i=a?a.completion:{};return i.type=n,i.arg=e,a?(this.method="next",this.next=a.finallyLoc,u):this.complete(i)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),u},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),k(t),u}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var o=r.arg;k(t)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:j(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),u}},n}(n.exports);try{regeneratorRuntime=r}catch(n){"object"==typeof globalThis?globalThis.regeneratorRuntime=r:Function("r","regeneratorRuntime = r")(r)}},function(n,e,t){"use strict";var r=t(2),o=t(66).PROPER,a=t(14),i=t(8),s=t(35),l=t(12),c=t(3),u=t(149),d=RegExp.prototype,p=d.toString,m=r(u),f=c((function(){return"/a/b"!=p.call({source:"a",flags:"b"})})),h=o&&"toString"!=p.name;(f||h)&&a(RegExp.prototype,"toString",(function(){var n=i(this),e=l(n.source),t=n.flags;return"/"+e+"/"+l(void 0===t&&s(d,n)&&!("flags"in d)?m(n):t)}),{unsafe:!0})},function(n,e,t){"use strict";var r=t(19),o=t(141),a=t(65),i=t(39),s=t(13).f,l=t(162),c=t(26),u=t(7),d=i.set,p=i.getterFor("Array Iterator");n.exports=l(Array,"Array",(function(n,e){d(this,{type:"Array Iterator",target:r(n),index:0,kind:e})}),(function(){var n=p(this),e=n.target,t=n.kind,r=n.index++;return!e||r>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:r,done:!1}:"values"==t?{value:e[r],done:!1}:{value:[r,e[r]],done:!1}}),"values");var m=a.Arguments=a.Array;if(o("keys"),o("values"),o("entries"),!c&&u&&"values"!==m.name)try{s(m,"name",{value:"values"})}catch(n){}},function(n,e,t){var r=t(0),o=t(11),a=t(37),i=t(8),s=t(84),l=t(106),c=r.TypeError;n.exports=function(n,e){var t=arguments.length<2?l(n):e;if(a(t))return i(o(t,n));throw c(s(n)+" is not iterable")}},function(n,e,t){var r=t(0).TypeError;n.exports=function(n,e){if(n<e)throw r("Not enough arguments");return n}},function(n,e,t){var r=t(254);n.exports=function(n,e){return new(r(n))(0===e?0:e)}},function(n,e,t){var r=t(9),o=t(25),a=t(6)("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[a])?!!e:"RegExp"==o(n))}},function(n,e,t){"use strict";var r=t(8);n.exports=function(){var n=r(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var r=t(5),o=t(9),a=t(67);n.exports=function(n,e,t){var i,s;return a&&r(i=e.constructor)&&i!==t&&o(s=i.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,o=/^0b[01]+$/i,a=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),u=Object.prototype.toString,d=Math.max,p=Math.min,m=function(){return c.Date.now()};function f(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function h(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(f(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=f(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=o.test(n);return s||a.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,o,a,i,s,l,c=0,u=!1,g=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function y(e){var t=r,a=o;return r=o=void 0,c=e,i=n.apply(a,t)}function v(n){return c=n,s=setTimeout(w,e),u?y(n):i}function x(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=a}function w(){var n=m();if(x(n))return k(n);s=setTimeout(w,function(n){var t=e-(n-l);return g?p(t,a-(n-c)):t}(n))}function k(n){return s=void 0,b&&r?y(n):(r=o=void 0,i)}function S(){var n=m(),t=x(n);if(r=arguments,o=this,l=n,t){if(void 0===s)return v(l);if(g)return s=setTimeout(w,e),y(l)}return void 0===s&&(s=setTimeout(w,e)),i}return e=h(e)||0,f(t)&&(u=!!t.leading,a=(g="maxWait"in t)?d(h(t.maxWait)||0,e):a,b="trailing"in t?!!t.trailing:b),S.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=o=s=void 0},S.flush=function(){return void 0===s?i:k(m())},S}},function(n,e,t){var r=t(2),o=t(18),a=t(12),i=t(154),s=r("".replace),l="["+i+"]",c=RegExp("^"+l+l+"*"),u=RegExp(l+l+"*$"),d=function(n){return function(e){var t=a(o(e));return 1&n&&(t=s(t,c,"")),2&n&&(t=s(t,u,"")),t}};n.exports={start:d(1),end:d(2),trim:d(3)}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){var r=t(2),o=t(14),a=Date.prototype,i=r(a.toString),s=r(a.getTime);"Invalid Date"!=String(new Date(NaN))&&o(a,"toString",(function(){var n=s(this);return n==n?i(this):"Invalid Date"}))},function(n,e,t){var r=t(113);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(7),o=t(3);n.exports=r&&o((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(7),o=t(3),a=t(81);n.exports=!r&&!o((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(0),o=t(11),a=t(9),i=t(83),s=t(47),l=t(238),c=t(6),u=r.TypeError,d=c("toPrimitive");n.exports=function(n,e){if(!a(n)||i(n))return n;var t,r=s(n,d);if(r){if(void 0===e&&(e="default"),t=o(r,n,e),!a(t)||i(t))return t;throw u("Can't convert object to primitive value")}return void 0===e&&(e="number"),l(n,e)}},function(n,e,t){var r=t(2),o=t(10),a=t(19),i=t(115).indexOf,s=t(64),l=r([].push);n.exports=function(n,e){var t,r=a(n),c=0,u=[];for(t in r)!o(s,t)&&o(r,t)&&l(u,t);for(;e.length>c;)o(r,t=e[c++])&&(~i(u,t)||l(u,t));return u}},function(n,e,t){var r=t(16);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(1),o=t(11),a=t(26),i=t(66),s=t(5),l=t(226),c=t(122),u=t(67),d=t(59),p=t(27),m=t(14),f=t(6),h=t(65),g=t(163),b=i.PROPER,y=i.CONFIGURABLE,v=g.IteratorPrototype,x=g.BUGGY_SAFARI_ITERATORS,w=f("iterator"),k=function(){return this};n.exports=function(n,e,t,i,f,g,S){l(t,e,i);var j,E,A,I=function(n){if(n===f&&P)return P;if(!x&&n in _)return _[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},T=e+" Iterator",z=!1,_=n.prototype,C=_[w]||_["@@iterator"]||f&&_[f],P=!x&&C||I(f),O="Array"==e&&_.entries||C;if(O&&(j=c(O.call(new n)))!==Object.prototype&&j.next&&(a||c(j)===v||(u?u(j,v):s(j[w])||m(j,w,k)),d(j,T,!0,!0),a&&(h[T]=k)),b&&"values"==f&&C&&"values"!==C.name&&(!a&&y?p(_,"name","values"):(z=!0,P=function(){return o(C,this)})),f)if(E={values:I("values"),keys:g?P:I("keys"),entries:I("entries")},S)for(A in E)(x||z||!(A in _))&&m(_,A,E[A]);else r({target:e,proto:!0,forced:x||z},E);return a&&!S||_[w]===P||m(_,w,P,{name:f}),h[e]=P,E}},function(n,e,t){"use strict";var r,o,a,i=t(3),s=t(5),l=t(34),c=t(122),u=t(14),d=t(6),p=t(26),m=d("iterator"),f=!1;[].keys&&("next"in(a=[].keys())?(o=c(c(a)))!==Object.prototype&&(r=o):f=!0),null==r||i((function(){var n={};return r[m].call(n)!==n}))?r={}:p&&(r=l(r)),s(r[m])||u(r,m,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:f}},function(n,e,t){var r=t(3);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var r=t(0);n.exports=r.Promise},function(n,e,t){var r=t(6),o=t(65),a=r("iterator"),i=Array.prototype;n.exports=function(n){return void 0!==n&&(o.Array===n||i[a]===n)}},function(n,e,t){var r=t(11),o=t(8),a=t(47);n.exports=function(n,e,t){var i,s;o(n);try{if(!(i=a(n,"return"))){if("throw"===e)throw t;return t}i=r(i,n)}catch(n){s=!0,i=n}if("throw"===e)throw t;if(s)throw i;return o(i),t}},function(n,e,t){var r=t(6)("iterator"),o=!1;try{var a=0,i={next:function(){return{done:!!a++}},return:function(){o=!0}};i[r]=function(){return this},Array.from(i,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!o)return!1;var t=!1;try{var a={};a[r]=function(){return{next:function(){return{done:t=!0}}}},n(a)}catch(n){}return t}},function(n,e,t){var r=t(0),o=t(88),a=t(84),i=r.TypeError;n.exports=function(n){if(o(n))return n;throw i(a(n)+" is not a constructor")}},function(n,e,t){var r,o,a,i,s=t(0),l=t(36),c=t(56),u=t(5),d=t(10),p=t(3),m=t(161),f=t(68),h=t(81),g=t(146),b=t(171),y=t(89),v=s.setImmediate,x=s.clearImmediate,w=s.process,k=s.Dispatch,S=s.Function,j=s.MessageChannel,E=s.String,A=0,I={};try{r=s.location}catch(n){}var T=function(n){if(d(I,n)){var e=I[n];delete I[n],e()}},z=function(n){return function(){T(n)}},_=function(n){T(n.data)},C=function(n){s.postMessage(E(n),r.protocol+"//"+r.host)};v&&x||(v=function(n){g(arguments.length,1);var e=u(n)?n:S(n),t=f(arguments,1);return I[++A]=function(){l(e,void 0,t)},o(A),A},x=function(n){delete I[n]},y?o=function(n){w.nextTick(z(n))}:k&&k.now?o=function(n){k.now(z(n))}:j&&!b?(i=(a=new j).port2,a.port1.onmessage=_,o=c(i.postMessage,i)):s.addEventListener&&u(s.postMessage)&&!s.importScripts&&r&&"file:"!==r.protocol&&!p(C)?(o=C,s.addEventListener("message",_,!1)):o="onreadystatechange"in h("script")?function(n){m.appendChild(h("script")).onreadystatechange=function(){m.removeChild(this),T(n)}}:function(n){setTimeout(z(n),0)}),n.exports={set:v,clear:x}},function(n,e,t){var r=t(32);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(r)},function(n,e,t){var r=t(8),o=t(9),a=t(173);n.exports=function(n,e){if(r(n),o(e)&&e.constructor===n)return e;var t=a.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){"use strict";var r=t(37),o=function(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)};n.exports.f=function(n){return new o(n)}},function(n,e,t){var r=t(2),o=t(55),a=t(12),i=t(18),s=r("".charAt),l=r("".charCodeAt),c=r("".slice),u=function(n){return function(e,t){var r,u,d=a(i(e)),p=o(t),m=d.length;return p<0||p>=m?n?"":void 0:(r=l(d,p))<55296||r>56319||p+1===m||(u=l(d,p+1))<56320||u>57343?n?s(d,p):r:n?c(d,p,p+2):u-56320+(r-55296<<10)+65536}};n.exports={codeAt:u(!1),charAt:u(!0)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var r=t(81)("span").classList,o=r&&r.constructor&&r.constructor.prototype;n.exports=o===Object.prototype?void 0:o},function(n,e,t){var r=t(1),o=t(7),a=t(120),i=t(19),s=t(38),l=t(69);r({target:"Object",stat:!0,sham:!o},{getOwnPropertyDescriptors:function(n){for(var e,t,r=i(n),o=s.f,c=a(r),u={},d=0;c.length>d;)void 0!==(t=o(r,e=c[d++]))&&l(u,e,t);return u}})},function(n,e,t){var r=t(1),o=t(3),a=t(15),i=t(122),s=t(164);r({target:"Object",stat:!0,forced:o((function(){i(1)})),sham:!s},{getPrototypeOf:function(n){return i(a(n))}})},function(n,e,t){"use strict";var r,o=t(1),a=t(2),i=t(38).f,s=t(52),l=t(12),c=t(180),u=t(18),d=t(181),p=t(26),m=a("".startsWith),f=a("".slice),h=Math.min,g=d("startsWith");o({target:"String",proto:!0,forced:!!(p||g||(r=i(String.prototype,"startsWith"),!r||r.writable))&&!g},{startsWith:function(n){var e=l(u(this));c(n);var t=s(h(arguments.length>1?arguments[1]:void 0,e.length)),r=l(n);return m?m(e,r,t):f(e,t,t+r.length)===r}})},function(n,e,t){var r=t(0),o=t(148),a=r.TypeError;n.exports=function(n){if(o(n))throw a("The method doesn't accept regular expressions");return n}},function(n,e,t){var r=t(6)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){"use strict";var r=t(57).forEach,o=t(46)("forEach");n.exports=o?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var r=t(3);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var r=t(25),o=t(19),a=t(58).f,i=t(125),s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return s&&"Window"==r(n)?function(n){try{return a(n)}catch(n){return i(s)}}(n):a(o(n))}},function(n,e,t){var r=t(6);e.f=r},function(n,e,t){var r=t(261),o=t(10),a=t(185),i=t(13).f;n.exports=function(n){var e=r.Symbol||(r.Symbol={});o(e,n)||i(e,n,{value:a.f(n)})}},function(n,e,t){var r=t(1),o=t(262);r({target:"Array",stat:!0,forced:!t(168)((function(n){Array.from(n)}))},{from:o})},function(n,e,t){var r=t(12);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){t(1)({target:"Object",stat:!0,sham:!t(7)},{create:t(34)})},function(n,e,t){var r=t(1),o=t(0),a=t(16),i=t(36),s=t(2),l=t(3),c=o.Array,u=a("JSON","stringify"),d=s(/./.exec),p=s("".charAt),m=s("".charCodeAt),f=s("".replace),h=s(1..toString),g=/[\uD800-\uDFFF]/g,b=/^[\uD800-\uDBFF]$/,y=/^[\uDC00-\uDFFF]$/,v=function(n,e,t){var r=p(t,e-1),o=p(t,e+1);return d(b,n)&&!d(y,o)||d(y,n)&&!d(b,r)?"\\u"+h(m(n,0),16):n},x=l((function(){return'"\\udf06\\ud834"'!==u("\udf06\ud834")||'"\\udead"'!==u("\udead")}));u&&r({target:"JSON",stat:!0,forced:x},{stringify:function(n,e,t){for(var r=0,o=arguments.length,a=c(o);r<o;r++)a[r]=arguments[r];var s=i(u,null,a);return"string"==typeof s?f(s,g,v):s}})},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,o=n.length;++t<r;)n[o+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(94),o=t(283),a=t(284),i=t(285),s=t(286),l=t(287);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=o,c.prototype.delete=a,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(61),o=t(130);n.exports=function(n){if(!o(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(304),o=t(49);n.exports=function n(e,t,a,i,s){return e===t||(null==e||null==t||!o(e)&&!o(t)?e!=e&&t!=t:r(e,t,a,i,n,s))}},function(n,e,t){var r=t(199),o=t(307),a=t(200);n.exports=function(n,e,t,i,s,l){var c=1&t,u=n.length,d=e.length;if(u!=d&&!(c&&d>u))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var f=-1,h=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++f<u;){var b=n[f],y=e[f];if(i)var v=c?i(y,b,f,e,n,l):i(b,y,f,n,e,l);if(void 0!==v){if(v)continue;h=!1;break}if(g){if(!o(e,(function(n,e){if(!a(g,e)&&(b===n||s(b,n,t,i,l)))return g.push(e)}))){h=!1;break}}else if(b!==y&&!s(b,y,t,i,l)){h=!1;break}}return l.delete(n),l.delete(e),h}},function(n,e,t){var r=t(131),o=t(305),a=t(306);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=o,i.prototype.has=a,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(317),o=t(323),a=t(205);n.exports=function(n){return a(n)?r(n):o(n)}},function(n,e,t){(function(n){var r=t(33),o=t(319),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===a?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||o;n.exports=l}).call(this,t(151)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(320),o=t(321),a=t(322),i=a&&a.isTypedArray,s=i?o(i):r;n.exports=s},function(n,e,t){var r=t(195),o=t(133);n.exports=function(n){return null!=n&&o(n.length)&&!r(n)}},function(n,e,t){var r=t(41)(t(33),"Set");n.exports=r},function(n,e,t){var r=t(130);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(210),o=t(98);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[o(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(31),o=t(134),a=t(334),i=t(337);n.exports=function(n,e){return r(n)?n:o(n,e)?[n]:a(i(n))}},function(n,e,t){"use strict";var r=t(0),o=t(2),a=t(37),i=t(9),s=t(10),l=t(68),c=t(63),u=r.Function,d=o([].concat),p=o([].join),m={},f=function(n,e,t){if(!s(m,e)){for(var r=[],o=0;o<e;o++)r[o]="a["+o+"]";m[e]=u("C,a","return new C("+p(r,",")+")")}return m[e](n,t)};n.exports=c?u.bind:function(n){var e=a(this),t=e.prototype,r=l(arguments,1),o=function(){var t=d(r,l(arguments));return this instanceof o?f(e,t.length,t):e.apply(n,t)};return i(t)&&(o.prototype=t),o}},function(n,e,t){"use strict";var r=t(1),o=t(369).start;r({target:"String",proto:!0,forced:t(371)},{padStart:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){},function(n,e,t){},function(n,e,t){t(1)({target:"Object",stat:!0},{setPrototypeOf:t(67)})},function(n,e,t){var r=t(1),o=t(16),a=t(36),i=t(211),s=t(169),l=t(8),c=t(9),u=t(34),d=t(3),p=o("Reflect","construct"),m=Object.prototype,f=[].push,h=d((function(){function n(){}return!(p((function(){}),[],n)instanceof n)})),g=!d((function(){p((function(){}))})),b=h||g;r({target:"Reflect",stat:!0,forced:b,sham:b},{construct:function(n,e){s(n),l(e);var t=arguments.length<3?n:s(arguments[2]);if(g&&!h)return p(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var r=[null];return a(f,r,e),new(a(i,n,r))}var o=t.prototype,d=u(c(o)?o:m),b=a(n,d,e);return c(b)?b:d}})},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(270),o=t(275),a=t(346),i=t(354),s=t(363),l=t(233),c=a((function(n){var e=l(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),o(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,o=r.exec(t);if(!o)return t;var a="",i=0,s=0;for(i=o.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(a+=t.substring(s,i)),s=i+1,a+=e}return s!==i?a+t.substring(s,i):a}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(383),o=t(384),a=t(385),i=!1,s=t(386).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),u=/^\uFEFF/;function d(n,t){var o,a,i=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)o=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(a=e.resolveInclude(n,t.filename),r.existsSync(a)&&(o=a)),o||Array.isArray(i)&&i.some((function(t){return a=e.resolveInclude(n,t,!0),r.existsSync(a)}))&&(o=a),!o)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return o}function p(n,t){var r,o=n.filename,a=arguments.length>1;if(n.cache){if(!o)throw new Error("cache option requires a filename");if(r=e.cache.get(o))return r;a||(t=f(o).toString().replace(u,""))}else if(!a){if(!o)throw new Error("Internal EJS error: no file name or template provided");t=f(o).toString().replace(u,"")}return r=e.compile(t,n),n.cache&&e.cache.set(o,r),r}function m(n,t,r){var o;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(o=p(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{o=p(n)(t)}catch(n){return r(n)}r(null,o)}function f(n){return e.fileLoader(n)}function h(n,e,t,r,o){var a=e.split("\n"),i=Math.max(r-3,0),s=Math.min(a.length,r+3),l=o(t),c=a.slice(i,s).map((function(n,e){var t=e+i+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+r+"\n"+c+"\n\n"+n.message,n}function g(n){return n.replace(/;(\s*$)/,"$1")}function b(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||a.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=a.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=o.dirname,a=o.extname,i=(0,o.resolve)(t?e:r(e),n);return a(n)||(i+=".ejs"),i},e.compile=function(n,e){return e&&e.scope&&(i||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),i=!0),e.context||(e.context=e.scope),delete e.scope),new b(n,e).compile()},e.render=function(n,e,t){var r=e||{},o=t||{};return 2==arguments.length&&a.shallowCopyFromList(o,r,l),p(o,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),o=r.shift(),i={filename:o};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?a.shallowCopy(i,r.pop()):(e.settings&&(e.settings.views&&(i.views=e.settings.views),e.settings["view cache"]&&(i.cache=!0),(t=e.settings["view options"])&&a.shallowCopy(i,t)),a.shallowCopyFromList(i,e,c)),i.filename=o):e={},m(i,e,n)},e.Template=b,e.clearCache=function(){e.cache.reset()},b.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},b.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=a.escapeRegExpChars(this.opts.delimiter),t=a.escapeRegExpChars(this.opts.openDelimiter),r=a.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,i="",s="",l=r.escapeFunction;if(!this.source){if(this.generateSource(),i+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(i+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var c="  var __locals = ("+r.localsName+" || {}),\n",u=0;u<r.destructuredLocals.length;u++){var m=r.destructuredLocals[u];u>0&&(c+=",\n  "),c+=m+" = __locals."+m}i+=c+";\n"}!1!==r._with&&(i+="  with ("+r.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=i+this.source+s}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+h.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var f=r.client?e:function(n){return e.apply(r.context,[n||{},l,function(e,t){var o=a.shallowCopy({},n);return t&&(o=a.shallowCopy(o,t)),function(n,e){var t=a.shallowCopy({},e);return t.filename=d(n,t),p(t)}(e,r)(o)},h])};if(f.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var g=r.filename,b=o.basename(g,o.extname(g));try{Object.defineProperty(f,"name",{value:b,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return f},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),o=this.opts.delimiter,i=this.opts.openDelimiter,s=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(l,c){var p,m,h,g,y,v;if(0===l.indexOf(i+o)&&0!==l.indexOf(i+o+o)&&(m=r[c+2])!=o+s&&m!="-"+o+s&&m!="_"+o+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(h=l.match(/^\s*include\s+(\S+)/))&&(p=r[c-1])&&(p==i+o||p==i+o+"-"||p==i+o+"_"))return g=a.shallowCopy({},t.opts),y=function(n,e){var t,r,o=a.shallowCopy({},e);r=f(t=d(n,o)).toString().replace(u,""),o.filename=t;var i=new b(r,o);return i.generateSource(),{source:i.source,filename:t,template:r}}(h[1],g),v=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(y.template)+"\n      , __filename = "+JSON.stringify(y.filename)+";\n      try {\n"+y.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+y.source+"    ; }).call(this)\n",t.source+=v,void t.dependencies.push(e.resolveInclude(h[1],g.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),o=[];r;)0!==(n=r.index)&&(o.push(e.substring(0,n)),e=e.slice(n)),o.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&o.push(e),o},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,o=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=b.modes.EVAL;break;case r+t+"=":this.mode=b.modes.ESCAPED;break;case r+t+"-":this.mode=b.modes.RAW;break;case r+t+"#":this.mode=b.modes.COMMENT;break;case r+t+t:this.mode=b.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+o:this.mode=b.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+o,t+o)+'")\n';break;case t+o:case"-"+t+o:case"_"+t+o:this.mode==b.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case b.modes.EVAL:case b.modes.ESCAPED:case b.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case b.modes.EVAL:this.source+="    ; "+n+"\n";break;case b.modes.ESCAPED:this.source+="    ; __append(escapeFn("+g(n)+"))\n";break;case b.modes.RAW:this.source+="    ; __append("+g(n)+")\n";break;case b.modes.COMMENT:break;case b.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=a.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},o=(t(372),t(20)),a=Object(o.a)(r,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);t(28),t(4),t(29),t(44),t(23);var r={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(e,t){return""===e.componentOptions.propsData.active&&(n.activeCodeTabIndex=t),{title:e.componentOptions.propsData.title,elm:e.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},o=(t(373),t(20)),a=Object(o.a)(r,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(e,r){return t("li",{key:e.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(e.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=a.exports},function(n,e,t){"use strict";var r=t(7),o=t(0),a=t(2),i=t(105),s=t(14),l=t(10),c=t(150),u=t(35),d=t(83),p=t(159),m=t(3),f=t(58).f,h=t(38).f,g=t(13).f,b=t(368),y=t(153).trim,v=o.Number,x=v.prototype,w=o.TypeError,k=a("".slice),S=a("".charCodeAt),j=function(n){var e=p(n,"number");return"bigint"==typeof e?e:E(e)},E=function(n){var e,t,r,o,a,i,s,l,c=p(n,"number");if(d(c))throw w("Cannot convert a Symbol value to a number");if("string"==typeof c&&c.length>2)if(c=y(c),43===(e=S(c,0))||45===e){if(88===(t=S(c,2))||120===t)return NaN}else if(48===e){switch(S(c,1)){case 66:case 98:r=2,o=49;break;case 79:case 111:r=8,o=55;break;default:return+c}for(i=(a=k(c,2)).length,s=0;s<i;s++)if((l=S(a,s))<48||l>o)return NaN;return parseInt(a,r)}return+c};if(i("Number",!v(" 0o1")||!v("0b1")||v("+0x1"))){for(var A,I=function(n){var e=arguments.length<1?0:v(j(n)),t=this;return u(x,t)&&m((function(){b(t)}))?c(Object(e),t,I):e},T=r?f(v):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),z=0;T.length>z;z++)l(v,A=T[z])&&!l(I,A)&&g(I,A,h(v,A));I.prototype=x,x.constructor=I,s(o,"Number",I)}},function(n,e,t){var r=t(3),o=t(0).RegExp;n.exports=r((function(){var n=o(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){"use strict";var r=t(163).IteratorPrototype,o=t(34),a=t(48),i=t(59),s=t(65),l=function(){return this};n.exports=function(n,e,t,c){var u=e+" Iterator";return n.prototype=o(r,{next:a(+!c,t)}),i(n,u,!1,!0),s[u]=l,n}},function(n,e,t){var r=t(14);n.exports=function(n,e,t){for(var o in e)r(n,o,e[o],t);return n}},function(n,e,t){"use strict";var r=t(16),o=t(13),a=t(6),i=t(7),s=a("species");n.exports=function(n){var e=r(n),t=o.f;i&&e&&!e[s]&&t(e,s,{configurable:!0,get:function(){return this}})}},function(n,e,t){var r=t(0),o=t(35),a=r.TypeError;n.exports=function(n,e){if(o(e,n))return n;throw a("Incorrect invocation")}},function(n,e,t){var r=t(3),o=t(0).RegExp;n.exports=r((function(){var n=o("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e,t){"use strict";var r=t(1),o=t(115).includes,a=t(141);r({target:"Array",proto:!0},{includes:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}}),a("includes")},function(n,e,t){"use strict";var r=t(1),o=t(2),a=t(180),i=t(18),s=t(12),l=t(181),c=o("".indexOf);r({target:"String",proto:!0,forced:!l("includes")},{includes:function(n){return!!~c(s(i(this)),s(a(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var r=t(1),o=t(153).trim;r({target:"String",proto:!0,forced:t(366)("trim")},{trim:function(){return o(this)}})},function(n,e,t){var r=t(125),o=Math.floor,a=function(n,e){var t=n.length,l=o(t/2);return t<8?i(n,e):s(n,a(r(n,0,l),e),a(r(n,l),e),e)},i=function(n,e){for(var t,r,o=n.length,a=1;a<o;){for(r=a,t=n[a];r&&e(n[r-1],t)>0;)n[r]=n[--r];r!==a++&&(n[r]=t)}return n},s=function(n,e,t,r){for(var o=e.length,a=t.length,i=0,s=0;i<o||s<a;)n[i+s]=i<o&&s<a?r(e[i],t[s])<=0?e[i++]:t[s++]:i<o?e[i++]:t[s++];return n};n.exports=a},function(n,e,t){var r=t(0),o=t(7),a=t(107).MISSED_STICKY,i=t(25),s=t(13).f,l=t(39).get,c=RegExp.prototype,u=r.TypeError;o&&a&&s(c,"sticky",{configurable:!0,get:function(){if(this!==c){if("RegExp"===i(this))return!!l(this).sticky;throw u("Incompatible receiver, RegExp required")}}})},function(n,e,t){n.exports=t(389)},function(n,e,t){var r=t(0),o=t(11),a=t(5),i=t(9),s=r.TypeError;n.exports=function(n,e){var t,r;if("string"===e&&a(t=n.toString)&&!i(r=o(t,n)))return r;if(a(t=n.valueOf)&&!i(r=o(t,n)))return r;if("string"!==e&&a(t=n.toString)&&!i(r=o(t,n)))return r;throw s("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),o=t(5),a=t(87),i=r.WeakMap;n.exports=o(i)&&/native code/.test(a(i))},function(n,e,t){var r=t(0),o=t(5),a=r.String,i=r.TypeError;n.exports=function(n){if("object"==typeof n||o(n))return n;throw i("Can't set "+a(n)+" as a prototype")}},function(n,e,t){"use strict";var r,o,a,i,s=t(1),l=t(26),c=t(0),u=t(16),d=t(11),p=t(165),m=t(14),f=t(227),h=t(67),g=t(59),b=t(228),y=t(37),v=t(5),x=t(9),w=t(229),k=t(87),S=t(242),j=t(168),E=t(124),A=t(170).set,I=t(243),T=t(172),z=t(246),_=t(173),C=t(247),P=t(248),O=t(39),M=t(105),D=t(6),R=t(249),B=t(89),L=t(51),N=D("species"),F="Promise",q=O.getterFor(F),$=O.set,G=O.getterFor(F),U=p&&p.prototype,H=p,J=U,W=c.TypeError,V=c.document,K=c.process,Z=_.f,Y=Z,X=!!(V&&V.createEvent&&c.dispatchEvent),Q=v(c.PromiseRejectionEvent),nn=!1,en=M(F,(function(){var n=k(H),e=n!==String(H);if(!e&&66===L)return!0;if(l&&!J.finally)return!0;if(L>=51&&/native code/.test(n))return!1;var t=new H((function(n){n(1)})),r=function(n){n((function(){}),(function(){}))};return(t.constructor={})[N]=r,!(nn=t.then((function(){}))instanceof r)||!e&&R&&!Q})),tn=en||!j((function(n){H.all(n).catch((function(){}))})),rn=function(n){var e;return!(!x(n)||!v(e=n.then))&&e},on=function(n,e){var t,r,o,a=e.value,i=1==e.state,s=i?n.ok:n.fail,l=n.resolve,c=n.reject,u=n.domain;try{s?(i||(2===e.rejection&&un(e),e.rejection=1),!0===s?t=a:(u&&u.enter(),t=s(a),u&&(u.exit(),o=!0)),t===n.promise?c(W("Promise-chain cycle")):(r=rn(t))?d(r,t,l,c):l(t)):c(a)}catch(n){u&&!o&&u.exit(),c(n)}},an=function(n,e){n.notified||(n.notified=!0,I((function(){for(var t,r=n.reactions;t=r.get();)on(t,n);n.notified=!1,e&&!n.rejection&&ln(n)})))},sn=function(n,e,t){var r,o;X?((r=V.createEvent("Event")).promise=e,r.reason=t,r.initEvent(n,!1,!0),c.dispatchEvent(r)):r={promise:e,reason:t},!Q&&(o=c["on"+n])?o(r):"unhandledrejection"===n&&z("Unhandled promise rejection",t)},ln=function(n){d(A,c,(function(){var e,t=n.facade,r=n.value;if(cn(n)&&(e=C((function(){B?K.emit("unhandledRejection",r,t):sn("unhandledrejection",t,r)})),n.rejection=B||cn(n)?2:1,e.error))throw e.value}))},cn=function(n){return 1!==n.rejection&&!n.parent},un=function(n){d(A,c,(function(){var e=n.facade;B?K.emit("rejectionHandled",e):sn("rejectionhandled",e,n.value)}))},dn=function(n,e,t){return function(r){n(e,r,t)}},pn=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,an(n,!0))},mn=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw W("Promise can't be resolved itself");var r=rn(e);r?I((function(){var t={done:!1};try{d(r,e,dn(mn,t,n),dn(pn,t,n))}catch(e){pn(t,e,n)}})):(n.value=e,n.state=1,an(n,!1))}catch(e){pn({done:!1},e,n)}}};if(en&&(J=(H=function(n){w(this,J),y(n),d(r,this);var e=q(this);try{n(dn(mn,e),dn(pn,e))}catch(n){pn(e,n)}}).prototype,(r=function(n){$(this,{type:F,done:!1,notified:!1,parent:!1,reactions:new P,rejection:!1,state:0,value:void 0})}).prototype=f(J,{then:function(n,e){var t=G(this),r=Z(E(this,H));return t.parent=!0,r.ok=!v(n)||n,r.fail=v(e)&&e,r.domain=B?K.domain:void 0,0==t.state?t.reactions.add(r):I((function(){on(r,t)})),r.promise},catch:function(n){return this.then(void 0,n)}}),o=function(){var n=new r,e=q(n);this.promise=n,this.resolve=dn(mn,e),this.reject=dn(pn,e)},_.f=Z=function(n){return n===H||n===a?new o(n):Y(n)},!l&&v(p)&&U!==Object.prototype)){i=U.then,nn||(m(U,"then",(function(n,e){var t=this;return new H((function(n,e){d(i,t,n,e)})).then(n,e)}),{unsafe:!0}),m(U,"catch",J.catch,{unsafe:!0}));try{delete U.constructor}catch(n){}h&&h(U,J)}s({global:!0,wrap:!0,forced:en},{Promise:H}),g(H,F,!1,!0),b(F),a=u(F),s({target:F,stat:!0,forced:en},{reject:function(n){var e=Z(this);return d(e.reject,void 0,n),e.promise}}),s({target:F,stat:!0,forced:l||en},{resolve:function(n){return T(l&&this===a?H:this,n)}}),s({target:F,stat:!0,forced:tn},{all:function(n){var e=this,t=Z(e),r=t.resolve,o=t.reject,a=C((function(){var t=y(e.resolve),a=[],i=0,s=1;S(n,(function(n){var l=i++,c=!1;s++,d(t,e,n).then((function(n){c||(c=!0,a[l]=n,--s||r(a))}),o)})),--s||r(a)}));return a.error&&o(a.value),t.promise},race:function(n){var e=this,t=Z(e),r=t.reject,o=C((function(){var o=y(e.resolve);S(n,(function(n){d(o,e,n).then(t.resolve,r)}))}));return o.error&&r(o.value),t.promise}})},function(n,e,t){var r=t(0),o=t(56),a=t(11),i=t(8),s=t(84),l=t(166),c=t(22),u=t(35),d=t(145),p=t(106),m=t(167),f=r.TypeError,h=function(n,e){this.stopped=n,this.result=e},g=h.prototype;n.exports=function(n,e,t){var r,b,y,v,x,w,k,S=t&&t.that,j=!(!t||!t.AS_ENTRIES),E=!(!t||!t.IS_ITERATOR),A=!(!t||!t.INTERRUPTED),I=o(e,S),T=function(n){return r&&m(r,"normal",n),new h(!0,n)},z=function(n){return j?(i(n),A?I(n[0],n[1],T):I(n[0],n[1])):A?I(n,T):I(n)};if(E)r=n;else{if(!(b=p(n)))throw f(s(n)+" is not iterable");if(l(b)){for(y=0,v=c(n);v>y;y++)if((x=z(n[y]))&&u(g,x))return x;return new h(!1)}r=d(n,b)}for(w=r.next;!(k=a(w,r)).done;){try{x=z(k.value)}catch(n){m(r,"throw",n)}if("object"==typeof x&&x&&u(g,x))return x}return new h(!1)}},function(n,e,t){var r,o,a,i,s,l,c,u,d=t(0),p=t(56),m=t(38).f,f=t(170).set,h=t(171),g=t(244),b=t(245),y=t(89),v=d.MutationObserver||d.WebKitMutationObserver,x=d.document,w=d.process,k=d.Promise,S=m(d,"queueMicrotask"),j=S&&S.value;j||(r=function(){var n,e;for(y&&(n=w.domain)&&n.exit();o;){e=o.fn,o=o.next;try{e()}catch(n){throw o?i():a=void 0,n}}a=void 0,n&&n.enter()},h||y||b||!v||!x?!g&&k&&k.resolve?((c=k.resolve(void 0)).constructor=k,u=p(c.then,c),i=function(){u(r)}):y?i=function(){w.nextTick(r)}:(f=p(f,d),i=function(){f(r)}):(s=!0,l=x.createTextNode(""),new v(r).observe(l,{characterData:!0}),i=function(){l.data=s=!s})),n.exports=j||function(n){var e={fn:n,next:void 0};a&&(a.next=e),o||(o=e,i()),a=e}},function(n,e,t){var r=t(32),o=t(0);n.exports=/ipad|iphone|ipod/i.test(r)&&void 0!==o.Pebble},function(n,e,t){var r=t(32);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,e,t){var r=t(0);n.exports=function(n,e){var t=r.console;t&&t.error&&(1==arguments.length?t.error(n):t.error(n,e))}},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e){var t=function(){this.head=null,this.tail=null};t.prototype={add:function(n){var e={item:n,next:null};this.head?this.tail.next=e:this.head=e,this.tail=e},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=t},function(n,e){n.exports="object"==typeof window},function(n,e,t){var r=t(1),o=t(251);r({target:"Object",stat:!0,forced:Object.assign!==o},{assign:o})},function(n,e,t){"use strict";var r=t(7),o=t(2),a=t(11),i=t(3),s=t(85),l=t(121),c=t(118),u=t(15),d=t(62),p=Object.assign,m=Object.defineProperty,f=o([].concat);n.exports=!p||i((function(){if(r&&1!==p({b:1},p(m({},"a",{enumerable:!0,get:function(){m(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=p({},n)[t]||"abcdefghijklmnopqrst"!=s(p({},e)).join("")}))?function(n,e){for(var t=u(n),o=arguments.length,i=1,p=l.f,m=c.f;o>i;)for(var h,g=d(arguments[i++]),b=p?f(s(g),p(g)):s(g),y=b.length,v=0;y>v;)h=b[v++],r&&!a(m,g,h)||(t[h]=g[h]);return t}:p},function(n,e,t){"use strict";var r=t(1),o=t(26),a=t(165),i=t(3),s=t(16),l=t(5),c=t(124),u=t(172),d=t(14);if(r({target:"Promise",proto:!0,real:!0,forced:!!a&&i((function(){a.prototype.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=c(this,s("Promise")),t=l(n);return this.then(t?function(t){return u(e,n()).then((function(){return t}))}:n,t?function(t){return u(e,n()).then((function(){throw t}))}:n)}}),!o&&l(a)){var p=s("Promise").prototype.finally;a.prototype.finally!==p&&d(a.prototype,"finally",p,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(123),o=t(76);n.exports=r?{}.toString:function(){return"[object "+o(this)+"]"}},function(n,e,t){var r=t(0),o=t(60),a=t(88),i=t(9),s=t(6)("species"),l=r.Array;n.exports=function(n){var e;return o(n)&&(e=n.constructor,(a(e)&&(e===l||o(e.prototype))||i(e)&&null===(e=e[s]))&&(e=void 0)),void 0===e?l:e}},function(n,e,t){"use strict";var r=t(1),o=t(256).left,a=t(46),i=t(51),s=t(89);r({target:"Array",proto:!0,forced:!a("reduce")||!s&&i>79&&i<83},{reduce:function(n){var e=arguments.length;return o(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(0),o=t(37),a=t(15),i=t(62),s=t(22),l=r.TypeError,c=function(n){return function(e,t,r,c){o(t);var u=a(e),d=i(u),p=s(u),m=n?p-1:0,f=n?-1:1;if(r<2)for(;;){if(m in d){c=d[m],m+=f;break}if(m+=f,n?m<0:p<=m)throw l("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=f)m in d&&(c=t(c,d[m],m,u));return c}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){var r=t(1),o=t(183),a=t(3),i=t(9),s=t(258).onFreeze,l=Object.freeze;r({target:"Object",stat:!0,forced:a((function(){l(1)})),sham:!o},{freeze:function(n){return l&&i(n)?l(s(n)):n}})},function(n,e,t){var r=t(1),o=t(2),a=t(64),i=t(9),s=t(10),l=t(13).f,c=t(58),u=t(184),d=t(259),p=t(80),m=t(183),f=!1,h=p("meta"),g=0,b=function(n){l(n,h,{value:{objectID:"O"+g++,weakData:{}}})},y=n.exports={enable:function(){y.enable=function(){},f=!0;var n=c.f,e=o([].splice),t={};t[h]=1,n(t).length&&(c.f=function(t){for(var r=n(t),o=0,a=r.length;o<a;o++)if(r[o]===h){e(r,o,1);break}return r},r({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:u.f}))},fastKey:function(n,e){if(!i(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!s(n,h)){if(!d(n))return"F";if(!e)return"E";b(n)}return n[h].objectID},getWeakData:function(n,e){if(!s(n,h)){if(!d(n))return!0;if(!e)return!1;b(n)}return n[h].weakData},onFreeze:function(n){return m&&f&&d(n)&&!s(n,h)&&b(n),n}};a[h]=!0},function(n,e,t){var r=t(3),o=t(9),a=t(25),i=t(260),s=Object.isExtensible,l=r((function(){s(1)}));n.exports=l||i?function(n){return!!o(n)&&((!i||"ArrayBuffer"!=a(n))&&(!s||s(n)))}:s},function(n,e,t){var r=t(3);n.exports=r((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,e,t){var r=t(0);n.exports=r},function(n,e,t){"use strict";var r=t(0),o=t(56),a=t(11),i=t(15),s=t(263),l=t(166),c=t(88),u=t(22),d=t(69),p=t(145),m=t(106),f=r.Array;n.exports=function(n){var e=i(n),t=c(this),r=arguments.length,h=r>1?arguments[1]:void 0,g=void 0!==h;g&&(h=o(h,r>2?arguments[2]:void 0));var b,y,v,x,w,k,S=m(e),j=0;if(!S||this==f&&l(S))for(b=u(e),y=t?new this(b):f(b);b>j;j++)k=g?h(e[j],j):e[j],d(y,j,k);else for(w=(x=p(e,S)).next,y=t?new this:[];!(v=a(w,x)).done;j++)k=g?s(x,h,[v.value,j],!0):v.value,d(y,j,k);return y.length=j,y}},function(n,e,t){var r=t(8),o=t(167);n.exports=function(n,e,t,a){try{return a?e(r(t)[0],t[1]):e(t)}catch(e){o(n,"throw",e)}}},function(n,e,t){"use strict";var r=t(16),o=t(10),a=t(27),i=t(35),s=t(67),l=t(119),c=t(150),u=t(188),d=t(265),p=t(266),m=t(267),f=t(26);n.exports=function(n,e,t,h){var g=h?2:1,b=n.split("."),y=b[b.length-1],v=r.apply(null,b);if(v){var x=v.prototype;if(!f&&o(x,"cause")&&delete x.cause,!t)return v;var w=r("Error"),k=e((function(n,e){var t=u(h?e:n,void 0),r=h?new v(n):new v;return void 0!==t&&a(r,"message",t),m&&a(r,"stack",p(r.stack,2)),this&&i(x,this)&&c(r,this,k),arguments.length>g&&d(r,arguments[g]),r}));if(k.prototype=x,"Error"!==y&&(s?s(k,w):l(k,w,{name:!0})),l(k,v),!f)try{x.name!==y&&a(x,"name",y),x.constructor=k}catch(n){}return k}}},function(n,e,t){var r=t(9),o=t(27);n.exports=function(n,e){r(e)&&"cause"in e&&o(n,"cause",e.cause)}},function(n,e,t){var r=t(2)("".replace),o=String(Error("zxcasd").stack),a=/\n\s*at [^:]*:[^\n]*/,i=a.test(o);n.exports=function(n,e){if(i&&"string"==typeof n)for(;e--;)n=r(n,a,"");return n}},function(n,e,t){var r=t(3),o=t(48);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",o(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(7),o=t(3),a=t(8),i=t(34),s=t(188),l=Error.prototype.toString,c=o((function(){if(r){var n=i(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==l.call(n))return!0}return"2: 1"!==l.call({message:1,name:2})||"Error"!==l.call({})}));n.exports=c?function(){var n=a(this),e=s(n.name,"Error"),t=s(n.message);return e?t?e+": "+t:e:t}:l},function(n,e,t){var r=t(2),o=t(15),a=Math.floor,i=r("".charAt),s=r("".replace),l=r("".slice),c=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,u=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,r,d,p){var m=t+n.length,f=r.length,h=u;return void 0!==d&&(d=o(d),h=c),s(p,h,(function(o,s){var c;switch(i(s,0)){case"$":return"$";case"&":return n;case"`":return l(e,0,t);case"'":return l(e,m);case"<":c=d[l(s,1,-1)];break;default:var u=+s;if(0===u)return o;if(u>f){var p=a(u/10);return 0===p?o:p<=f?void 0===r[p-1]?i(s,1):r[p-1]+i(s,1):o}c=r[u-1]}return void 0===c?"":c}))}},function(n,e,t){var r=t(191),o=t(271);n.exports=function n(e,t,a,i,s){var l=-1,c=e.length;for(a||(a=o),s||(s=[]);++l<c;){var u=e[l];t>0&&a(u)?t>1?n(u,t-1,a,i,s):r(s,u):i||(s[s.length]=u)}return s}},function(n,e,t){var r=t(71),o=t(128),a=t(31),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||o(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(61),o=t(49);n.exports=function(n){return o(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(71),o=Object.prototype,a=o.hasOwnProperty,i=o.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var o=i.call(n);return r&&(e?n[s]=t:delete n[s]),o}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(276),o=t(332),a=t(136),i=t(31),s=t(343);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?i(n)?o(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(277),o=t(331),a=t(208);n.exports=function(n){var e=o(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(193),o=t(197);n.exports=function(n,e,t,a){var i=t.length,s=i,l=!a;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var u=(c=t[i])[0],d=n[u],p=c[1];if(l&&c[2]){if(void 0===d&&!(u in n))return!1}else{var m=new r;if(a)var f=a(d,p,u,n,e,m);if(!(void 0===f?o(p,d,3,a,m):f))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(95),o=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():o.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(95);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(95);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(95);n.exports=function(n,e){var t=this.__data__,o=r(t,n);return o<0?(++this.size,t.push([n,e])):t[o][1]=e,this}},function(n,e,t){var r=t(94);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(94),o=t(129),a=t(131);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!o||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(195),o=t(289),a=t(130),i=t(196),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,d=c.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||o(n))&&(r(n)?p:s).test(i(n))}},function(n,e,t){var r,o=t(290),a=(r=/[^.]+$/.exec(o&&o.keys&&o.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(33)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(293),o=t(94),a=t(129);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||o),string:new r}}},function(n,e,t){var r=t(294),o=t(295),a=t(296),i=t(297),s=t(298);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(96);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(96),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return o.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(96),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:o.call(e,n)}},function(n,e,t){var r=t(96);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(97);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(97);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(97);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(97);n.exports=function(n,e){var t=r(this,n),o=t.size;return t.set(n,e),this.size+=t.size==o?0:1,this}},function(n,e,t){var r=t(193),o=t(198),a=t(308),i=t(311),s=t(327),l=t(31),c=t(202),u=t(204),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,f,h){var g=l(n),b=l(e),y=g?"[object Array]":s(n),v=b?"[object Array]":s(e),x=(y="[object Arguments]"==y?d:y)==d,w=(v="[object Arguments]"==v?d:v)==d,k=y==v;if(k&&c(n)){if(!c(e))return!1;g=!0,x=!1}if(k&&!x)return h||(h=new r),g||u(n)?o(n,e,t,m,f,h):a(n,e,y,t,m,f,h);if(!(1&t)){var S=x&&p.call(n,"__wrapped__"),j=w&&p.call(e,"__wrapped__");if(S||j){var E=S?n.value():n,A=j?e.value():e;return h||(h=new r),f(E,A,t,m,h)}}return!!k&&(h||(h=new r),i(n,e,t,m,f,h))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(71),o=t(309),a=t(194),i=t(198),s=t(310),l=t(132),c=r?r.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new o(n),new o(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var f=1&r;if(m||(m=l),n.size!=e.size&&!f)return!1;var h=p.get(n);if(h)return h==e;r|=2,p.set(n,e);var g=i(m(n),m(e),r,c,d,p);return p.delete(n),g;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var r=t(33).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(312),o=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,i,s){var l=1&t,c=r(n),u=c.length;if(u!=r(e).length&&!l)return!1;for(var d=u;d--;){var p=c[d];if(!(l?p in e:o.call(e,p)))return!1}var m=s.get(n),f=s.get(e);if(m&&f)return m==e&&f==n;var h=!0;s.set(n,e),s.set(e,n);for(var g=l;++d<u;){var b=n[p=c[d]],y=e[p];if(a)var v=l?a(y,b,p,e,n,s):a(b,y,p,n,e,s);if(!(void 0===v?b===y||i(b,y,t,a,s):v)){h=!1;break}g||(g="constructor"==p)}if(h&&!g){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(h=!1)}return s.delete(n),s.delete(e),h}},function(n,e,t){var r=t(313),o=t(314),a=t(201);n.exports=function(n){return r(n,a,o)}},function(n,e,t){var r=t(191),o=t(31);n.exports=function(n,e,t){var a=e(n);return o(n)?a:r(a,t(n))}},function(n,e,t){var r=t(315),o=t(316),a=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return a.call(n,e)})))}:o;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=0,a=[];++t<r;){var i=n[t];e(i,t,n)&&(a[o++]=i)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(318),o=t(128),a=t(31),i=t(202),s=t(203),l=t(204),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),u=!t&&o(n),d=!t&&!u&&i(n),p=!t&&!u&&!d&&l(n),m=t||u||d||p,f=m?r(n.length,String):[],h=f.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||d&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,h))||f.push(g);return f}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(61),o=t(133),a=t(49),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&o(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(192),o=e&&!e.nodeType&&e,a=o&&"object"==typeof n&&n&&!n.nodeType&&n,i=a&&a.exports===o&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(151)(n))},function(n,e,t){var r=t(324),o=t(325),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return o(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(326)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(328),o=t(129),a=t(329),i=t(206),s=t(330),l=t(61),c=t(196),u=c(r),d=c(o),p=c(a),m=c(i),f=c(s),h=l;(r&&"[object DataView]"!=h(new r(new ArrayBuffer(1)))||o&&"[object Map]"!=h(new o)||a&&"[object Promise]"!=h(a.resolve())||i&&"[object Set]"!=h(new i)||s&&"[object WeakMap]"!=h(new s))&&(h=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case f:return"[object WeakMap]"}return e}),n.exports=h},function(n,e,t){var r=t(41)(t(33),"DataView");n.exports=r},function(n,e,t){var r=t(41)(t(33),"Promise");n.exports=r},function(n,e,t){var r=t(41)(t(33),"WeakMap");n.exports=r},function(n,e,t){var r=t(207),o=t(201);n.exports=function(n){for(var e=o(n),t=e.length;t--;){var a=e[t],i=n[a];e[t]=[a,i,r(i)]}return e}},function(n,e,t){var r=t(197),o=t(333),a=t(340),i=t(134),s=t(207),l=t(208),c=t(98);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=o(t,n);return void 0===i&&i===e?a(t,n):r(e,i,3)}}},function(n,e,t){var r=t(209);n.exports=function(n,e,t){var o=null==n?void 0:r(n,e);return void 0===o?t:o}},function(n,e,t){var r=t(335),o=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(o,(function(n,t,r,o){e.push(r?o.replace(a,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(336);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(131);function o(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,o=e?e.apply(this,r):r[0],a=t.cache;if(a.has(o))return a.get(o);var i=n.apply(this,r);return t.cache=a.set(o,i)||a,i};return t.cache=new(o.Cache||r),t}o.Cache=r,n.exports=o},function(n,e,t){var r=t(338);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(71),o=t(339),a=t(31),i=t(135),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return o(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=Array(r);++t<r;)o[t]=e(n[t],t,n);return o}},function(n,e,t){var r=t(341),o=t(342);n.exports=function(n,e){return null!=n&&o(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(210),o=t(128),a=t(31),i=t(203),s=t(133),l=t(98);n.exports=function(n,e,t){for(var c=-1,u=(e=r(e,n)).length,d=!1;++c<u;){var p=l(e[c]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++c!=u?d:!!(u=null==n?0:n.length)&&s(u)&&i(p,u)&&(a(n)||o(n))}},function(n,e,t){var r=t(344),o=t(345),a=t(134),i=t(98);n.exports=function(n){return a(n)?r(i(n)):o(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(209);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(136),o=t(347),a=t(349);n.exports=function(n,e){return a(o(n,e,r),n+"")}},function(n,e,t){var r=t(348),o=Math.max;n.exports=function(n,e,t){return e=o(void 0===e?n.length-1:e,0),function(){for(var a=arguments,i=-1,s=o(a.length-e,0),l=Array(s);++i<s;)l[i]=a[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=a[i];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(350),o=t(353)(r);n.exports=o},function(n,e,t){var r=t(351),o=t(352),a=t(136),i=o?function(n,e){return o(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(41),o=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=o},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var o=t(),a=16-(o-r);if(r=o,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(199),o=t(355),a=t(360),i=t(200),s=t(361),l=t(132);n.exports=function(n,e,t){var c=-1,u=o,d=n.length,p=!0,m=[],f=m;if(t)p=!1,u=a;else if(d>=200){var h=e?null:s(n);if(h)return l(h);p=!1,u=i,f=new r}else f=e?[]:m;n:for(;++c<d;){var g=n[c],b=e?e(g):g;if(g=t||0!==g?g:0,p&&b==b){for(var y=f.length;y--;)if(f[y]===b)continue n;e&&f.push(b),m.push(g)}else u(f,b,t)||(f!==m&&f.push(b),m.push(g))}return m}},function(n,e,t){var r=t(356);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(357),o=t(358),a=t(359);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,o,t)}},function(n,e){n.exports=function(n,e,t,r){for(var o=n.length,a=t+(r?1:-1);r?a--:++a<o;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,o=n.length;++r<o;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,o=null==n?0:n.length;++r<o;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(206),o=t(362),a=t(132),i=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:o;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(205),o=t(49);n.exports=function(n){return o(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(66).PROPER,o=t(3),a=t(154);n.exports=function(n){return o((function(){return!!a[n]()||"​᠎"!=="​᠎"[n]()||r&&a[n].name!==n}))}},function(n,e,t){var r=t(1),o=t(211);r({target:"Function",proto:!0,forced:Function.bind!==o},{bind:o})},function(n,e,t){var r=t(2);n.exports=r(1..valueOf)},function(n,e,t){var r=t(2),o=t(52),a=t(12),i=t(370),s=t(18),l=r(i),c=r("".slice),u=Math.ceil,d=function(n){return function(e,t,r){var i,d,p=a(s(e)),m=o(t),f=p.length,h=void 0===r?" ":a(r);return m<=f||""==h?p:((d=l(h,u((i=m-f)/h.length))).length>i&&(d=c(d,0,i)),n?p+d:d+p)}};n.exports={start:d(!1),end:d(!0)}},function(n,e,t){"use strict";var r=t(0),o=t(55),a=t(12),i=t(18),s=r.RangeError;n.exports=function(n){var e=a(i(this)),t="",r=o(n);if(r<0||r==1/0)throw s("Wrong number of repetitions");for(;r>0;(r>>>=1)&&(e+=e))1&r&&(t+=e);return t}},function(n,e,t){var r=t(32);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(r)},function(n,e,t){"use strict";t(213)},function(n,e,t){"use strict";t(214)},function(n,e,t){"use strict";var r=t(1),o=t(2),a=t(37),i=t(15),s=t(22),l=t(12),c=t(3),u=t(235),d=t(46),p=t(375),m=t(376),f=t(51),h=t(377),g=[],b=o(g.sort),y=o(g.push),v=c((function(){g.sort(void 0)})),x=c((function(){g.sort(null)})),w=d("sort"),k=!c((function(){if(f)return f<70;if(!(p&&p>3)){if(m)return!0;if(h)return h<603;var n,e,t,r,o="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(r=0;r<47;r++)g.push({k:e+r,v:t})}for(g.sort((function(n,e){return e.v-n.v})),r=0;r<g.length;r++)e=g[r].k.charAt(0),o.charAt(o.length-1)!==e&&(o+=e);return"DGBEFHACIJK"!==o}}));r({target:"Array",proto:!0,forced:v||!x||!w||!k},{sort:function(n){void 0!==n&&a(n);var e=i(this);if(k)return void 0===n?b(e):b(e,n);var t,r,o=[],c=s(e);for(r=0;r<c;r++)r in e&&y(o,e[r]);for(u(o,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:l(e)>l(t)?1:-1}}(n)),t=o.length,r=0;r<t;)e[r]=o[r++];for(;r<c;)delete e[r++];return e}})},function(n,e,t){var r=t(32).match(/firefox\/(\d+)/i);n.exports=!!r&&+r[1]},function(n,e,t){var r=t(32);n.exports=/MSIE|Trident/.test(r)},function(n,e,t){var r=t(32).match(/AppleWebKit\/(\d+)\./);n.exports=!!r&&+r[1]},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(1),o=t(3),a=t(19),i=t(38).f,s=t(7),l=o((function(){i(1)}));r({target:"Object",stat:!0,forced:!s||l,sham:!s},{getOwnPropertyDescriptor:function(n,e){return i(a(n),e)}})},function(n,e,t){var r=t(1),o=t(7),a=t(114).f;r({target:"Object",stat:!0,forced:Object.defineProperties!==a,sham:!o},{defineProperties:a})},function(n,e,t){t(1)({target:"Reflect",stat:!0},{ownKeys:t(120)})},function(n,e){},function(n,e){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var o=n[r];"."===o?n.splice(r,1):".."===o?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var n="",e=!1,o=arguments.length-1;o>=-1&&!e;o--){var a=o>=0?arguments[o]:process.cwd();if("string"!=typeof a)throw new TypeError("Arguments to path.resolve must be strings");a&&(n=a+"/"+n,e="/"===a.charAt(0))}return(e?"/":"")+(n=t(r(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var a=e.isAbsolute(n),i="/"===o(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!a).join("/"))||a||(n="."),n&&i&&(n+="/"),(a?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var o=r(n.split("/")),a=r(t.split("/")),i=Math.min(o.length,a.length),s=i,l=0;l<i;l++)if(o[l]!==a[l]){s=l;break}var c=[];for(l=s;l<o.length;l++)c.push("..");return(c=c.concat(a.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,o=!0,a=n.length-1;a>=1;--a)if(47===(e=n.charCodeAt(a))){if(!o){r=a;break}}else o=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,o=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!o){t=e+1;break}}else-1===r&&(o=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,o=!0,a=0,i=n.length-1;i>=0;--i){var s=n.charCodeAt(i);if(47!==s)-1===r&&(o=!1,r=i+1),46===s?-1===e?e=i:1!==a&&(a=1):-1!==e&&(a=-1);else if(!o){t=i+1;break}}return-1===e||-1===r||0===a||1===a&&e===r-1&&e===t+1?"":n.slice(e,r)};var o="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var o={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},a=/[&<>'"]/g;function i(n){return o[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(a,i)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var o=t[r];void 0!==e[o]&&(n[o]=e[o])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){"use strict";t(217)},function(n,e,t){"use strict";t(218)},function(n,e,t){"use strict";t.r(e);t(144),t(241),t(250),t(252);var r=t(90),o=(t(142),t(42),t(4),t(21),t(24),t(44),t(23),Object.freeze({}));function a(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function d(n){return"[object Object]"===u.call(n)}function p(n){return"[object RegExp]"===u.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function h(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function g(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),o=0;o<r.length;o++)t[r[o]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function v(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var x=Object.prototype.hasOwnProperty;function w(n,e){return x.call(n,e)}function k(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var S=/-(\w)/g,j=k((function(n){return n.replace(S,(function(n,e){return e?e.toUpperCase():""}))})),E=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),A=/\B([A-Z])/g,I=k((function(n){return n.replace(A,"-$1").toLowerCase()}));var T=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function z(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function _(n,e){for(var t in e)n[t]=e[t];return n}function C(n){for(var e={},t=0;t<n.length;t++)n[t]&&_(e,n[t]);return e}function P(n,e,t){}var O=function(n,e,t){return!1},M=function(n){return n};function D(n,e){if(n===e)return!0;var t=c(n),r=c(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var o=Array.isArray(n),a=Array.isArray(e);if(o&&a)return n.length===e.length&&n.every((function(n,t){return D(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(o||a)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return D(n[t],e[t])}))}catch(n){return!1}}function R(n,e){for(var t=0;t<n.length;t++)if(D(n[t],e))return t;return-1}function B(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var L=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:O,isReservedAttr:O,isUnknownElement:O,getTagNamespace:P,parsePlatformTagName:M,mustUseProp:O,async:!0,_lifecycleHooks:N},q=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function $(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var G=new RegExp("[^"+q.source+".$_\\d]");var U,H="__proto__"in{},J="undefined"!=typeof window,W="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,V=W&&WXEnvironment.platform.toLowerCase(),K=J&&window.navigator.userAgent.toLowerCase(),Z=K&&/msie|trident/.test(K),Y=K&&K.indexOf("msie 9.0")>0,X=K&&K.indexOf("edge/")>0,Q=(K&&K.indexOf("android"),K&&/iphone|ipad|ipod|ios/.test(K)||"ios"===V),nn=(K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K),K&&K.match(/firefox\/(\d+)/)),en={}.watch,tn=!1;if(J)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){tn=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var on=function(){return void 0===U&&(U=!J&&!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),U},an=J&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function sn(n){return"function"==typeof n&&/native code/.test(n.toString())}var ln,cn="undefined"!=typeof Symbol&&sn(Symbol)&&"undefined"!=typeof Reflect&&sn(Reflect.ownKeys);ln="undefined"!=typeof Set&&sn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=P,dn=0,pn=function(){this.id=dn++,this.subs=[]};pn.prototype.addSub=function(n){this.subs.push(n)},pn.prototype.removeSub=function(n){v(this.subs,n)},pn.prototype.depend=function(){pn.target&&pn.target.addDep(this)},pn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},pn.target=null;var mn=[];function fn(n){mn.push(n),pn.target=n}function hn(){mn.pop(),pn.target=mn[mn.length-1]}var gn=function(n,e,t,r,o,a,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=o,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},bn={child:{configurable:!0}};bn.child.get=function(){return this.componentInstance},Object.defineProperties(gn.prototype,bn);var yn=function(n){void 0===n&&(n="");var e=new gn;return e.text=n,e.isComment=!0,e};function vn(n){return new gn(void 0,void 0,void 0,String(n))}function xn(n){var e=new gn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var wn=Array.prototype,kn=Object.create(wn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];$(kn,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var o,a=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":o=t;break;case"splice":o=t.slice(2)}return o&&i.observeArray(o),i.dep.notify(),a}))}));var Sn=Object.getOwnPropertyNames(kn),jn=!0;function En(n){jn=n}var An=function(n){this.value=n,this.dep=new pn,this.vmCount=0,$(n,"__ob__",this),Array.isArray(n)?(H?function(n,e){n.__proto__=e}(n,kn):function(n,e,t){for(var r=0,o=t.length;r<o;r++){var a=t[r];$(n,a,e[a])}}(n,kn,Sn),this.observeArray(n)):this.walk(n)};function In(n,e){var t;if(c(n)&&!(n instanceof gn))return w(n,"__ob__")&&n.__ob__ instanceof An?t=n.__ob__:jn&&!on()&&(Array.isArray(n)||d(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new An(n)),e&&t&&t.vmCount++,t}function Tn(n,e,t,r,o){var a=new pn,i=Object.getOwnPropertyDescriptor(n,e);if(!i||!1!==i.configurable){var s=i&&i.get,l=i&&i.set;s&&!l||2!==arguments.length||(t=n[e]);var c=!o&&In(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(n):t;return pn.target&&(a.depend(),c&&(c.dep.depend(),Array.isArray(e)&&Cn(e))),e},set:function(e){var r=s?s.call(n):t;e===r||e!=e&&r!=r||s&&!l||(l?l.call(n,e):t=e,c=!o&&In(e),a.notify())}})}}function zn(n,e,t){if(Array.isArray(n)&&m(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(Tn(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function _n(n,e){if(Array.isArray(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function Cn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&Cn(e)}An.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)Tn(n,e[t])},An.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)In(n[e])};var Pn=F.optionMergeStrategies;function On(n,e){if(!e)return n;for(var t,r,o,a=cn?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++)"__ob__"!==(t=a[i])&&(r=n[t],o=e[t],w(n,t)?r!==o&&d(r)&&d(o)&&On(r,o):zn(n,t,o));return n}function Mn(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,o="function"==typeof n?n.call(t,t):n;return r?On(r,o):o}:e?n?function(){return On("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function Dn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Rn(n,e,t,r){var o=Object.create(n||null);return e?_(o,e):o}Pn.data=function(n,e,t){return t?Mn(n,e,t):e&&"function"!=typeof e?n:Mn(n,e)},N.forEach((function(n){Pn[n]=Dn})),L.forEach((function(n){Pn[n+"s"]=Rn})),Pn.watch=function(n,e,t,r){if(n===en&&(n=void 0),e===en&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var a in _(o,n),e){var i=o[a],s=e[a];i&&!Array.isArray(i)&&(i=[i]),o[a]=i?i.concat(s):Array.isArray(s)?s:[s]}return o},Pn.props=Pn.methods=Pn.inject=Pn.computed=function(n,e,t,r){if(!n)return e;var o=Object.create(null);return _(o,n),e&&_(o,e),o},Pn.provide=Mn;var Bn=function(n,e){return void 0===e?n:e};function Ln(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,o,a={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(o=t[r])&&(a[j(o)]={type:null});else if(d(t))for(var i in t)o=t[i],a[j(i)]=d(o)?o:{type:o};else 0;n.props=a}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var o=0;o<t.length;o++)r[t[o]]={from:t[o]};else if(d(t))for(var a in t){var i=t[a];r[a]=d(i)?_({from:a},i):{from:i}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Ln(n,e.extends,t)),e.mixins))for(var r=0,o=e.mixins.length;r<o;r++)n=Ln(n,e.mixins[r],t);var a,i={};for(a in n)s(a);for(a in e)w(n,a)||s(a);function s(r){var o=Pn[r]||Bn;i[r]=o(n[r],e[r],t,r)}return i}function Nn(n,e,t,r){if("string"==typeof t){var o=n[e];if(w(o,t))return o[t];var a=j(t);if(w(o,a))return o[a];var i=E(a);return w(o,i)?o[i]:o[t]||o[a]||o[i]}}function Fn(n,e,t,r){var o=e[n],a=!w(t,n),i=t[n],s=Un(Boolean,o.type);if(s>-1)if(a&&!w(o,"default"))i=!1;else if(""===i||i===I(n)){var l=Un(String,o.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!w(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==$n(e.type)?r.call(n):r}(r,o,n);var c=jn;En(!0),In(i),En(c)}return i}var qn=/^\s*function (\w+)/;function $n(n){var e=n&&n.toString().match(qn);return e?e[1]:""}function Gn(n,e){return $n(n)===$n(e)}function Un(n,e){if(!Array.isArray(e))return Gn(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Gn(e[t],n))return t;return-1}function Hn(n,e,t){fn();try{if(e)for(var r=e;r=r.$parent;){var o=r.$options.errorCaptured;if(o)for(var a=0;a<o.length;a++)try{if(!1===o[a].call(r,n,e,t))return}catch(n){Wn(n,r,"errorCaptured hook")}}Wn(n,e,t)}finally{hn()}}function Jn(n,e,t,r,o){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&f(a)&&!a._handled&&(a.catch((function(n){return Hn(n,r,o+" (Promise/async)")})),a._handled=!0)}catch(n){Hn(n,r,o)}return a}function Wn(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Vn(e,null,"config.errorHandler")}Vn(n,e,t)}function Vn(n,e,t){if(!J&&!W||"undefined"==typeof console)throw n;console.error(n)}var Kn,Zn=!1,Yn=[],Xn=!1;function Qn(){Xn=!1;var n=Yn.slice(0);Yn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&sn(Promise)){var ne=Promise.resolve();Kn=function(){ne.then(Qn),Q&&setTimeout(P)},Zn=!0}else if(Z||"undefined"==typeof MutationObserver||!sn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Kn="undefined"!=typeof setImmediate&&sn(setImmediate)?function(){setImmediate(Qn)}:function(){setTimeout(Qn,0)};else{var ee=1,te=new MutationObserver(Qn),re=document.createTextNode(String(ee));te.observe(re,{characterData:!0}),Kn=function(){ee=(ee+1)%2,re.data=String(ee)},Zn=!0}function oe(n,e){var t;if(Yn.push((function(){if(n)try{n.call(e)}catch(n){Hn(n,e,"nextTick")}else t&&t(e)})),Xn||(Xn=!0,Kn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var ae=new ln;function ie(n){!function n(e,t){var r,o,a=Array.isArray(e);if(!a&&!c(e)||Object.isFrozen(e)||e instanceof gn)return;if(e.__ob__){var i=e.__ob__.dep.id;if(t.has(i))return;t.add(i)}if(a)for(r=e.length;r--;)n(e[r],t);else for(o=Object.keys(e),r=o.length;r--;)n(e[o[r]],t)}(n,ae),ae.clear()}var se=k((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function le(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return Jn(r,null,arguments,e,"v-on handler");for(var o=r.slice(),a=0;a<o.length;a++)Jn(o[a],null,n,e,"v-on handler")}return t.fns=n,t}function ce(n,e,t,r,o,i){var l,c,u,d;for(l in n)c=n[l],u=e[l],d=se(l),a(c)||(a(u)?(a(c.fns)&&(c=n[l]=le(c,i)),s(d.once)&&(c=n[l]=o(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)a(n[l])&&r((d=se(l)).name,e[l],d.capture)}function ue(n,e,t){var r;n instanceof gn&&(n=n.data.hook||(n.data.hook={}));var o=n[e];function l(){t.apply(this,arguments),v(r.fns,l)}a(o)?r=le([l]):i(o.fns)&&s(o.merged)?(r=o).fns.push(l):r=le([o,l]),r.merged=!0,n[e]=r}function de(n,e,t,r,o){if(i(e)){if(w(e,t))return n[t]=e[t],o||delete e[t],!0;if(w(e,r))return n[t]=e[r],o||delete e[r],!0}return!1}function pe(n){return l(n)?[vn(n)]:Array.isArray(n)?function n(e,t){var r,o,c,u,d=[];for(r=0;r<e.length;r++)a(o=e[r])||"boolean"==typeof o||(c=d.length-1,u=d[c],Array.isArray(o)?o.length>0&&(me((o=n(o,(t||"")+"_"+r))[0])&&me(u)&&(d[c]=vn(u.text+o[0].text),o.shift()),d.push.apply(d,o)):l(o)?me(u)?d[c]=vn(u.text+o):""!==o&&d.push(vn(o)):me(o)&&me(u)?d[c]=vn(u.text+o.text):(s(e._isVList)&&i(o.tag)&&a(o.key)&&i(t)&&(o.key="__vlist"+t+"_"+r+"__"),d.push(o)));return d}(n):void 0}function me(n){return i(n)&&i(n.text)&&!1===n.isComment}function fe(n,e){if(n){for(var t=Object.create(null),r=cn?Reflect.ownKeys(n):Object.keys(n),o=0;o<r.length;o++){var a=r[o];if("__ob__"!==a){for(var i=n[a].from,s=e;s;){if(s._provided&&w(s._provided,i)){t[a]=s._provided[i];break}s=s.$parent}if(!s)if("default"in n[a]){var l=n[a].default;t[a]="function"==typeof l?l.call(e):l}else 0}}return t}}function he(n,e){if(!n||!n.length)return{};for(var t={},r=0,o=n.length;r<o;r++){var a=n[r],i=a.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,a.context!==e&&a.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(a);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(ge)&&delete t[c];return t}function ge(n){return n.isComment&&!n.asyncFactory||" "===n.text}function be(n){return n.isComment&&n.asyncFactory}function ye(n,e,t){var r,a=Object.keys(e).length>0,i=n?!!n.$stable:!a,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(i&&t&&t!==o&&s===t.$key&&!a&&!t.$hasNormal)return t;for(var l in r={},n)n[l]&&"$"!==l[0]&&(r[l]=ve(e,l,n[l]))}else r={};for(var c in e)c in r||(r[c]=xe(e,c));return n&&Object.isExtensible(n)&&(n._normalized=r),$(r,"$stable",i),$(r,"$key",s),$(r,"$hasNormal",a),r}function ve(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:pe(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!be(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function xe(n,e){return function(){return n[e]}}function we(n,e){var t,r,o,a,s;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,o=n.length;r<o;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(c(n))if(cn&&n[Symbol.iterator]){t=[];for(var l=n[Symbol.iterator](),u=l.next();!u.done;)t.push(e(u.value,t.length)),u=l.next()}else for(a=Object.keys(n),t=new Array(a.length),r=0,o=a.length;r<o;r++)s=a[r],t[r]=e(n[s],s,r);return i(t)||(t=[]),t._isVList=!0,t}function ke(n,e,t,r){var o,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=_(_({},r),t)),o=a(t)||("function"==typeof e?e():e)):o=this.$slots[n]||("function"==typeof e?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},o):o}function Se(n){return Nn(this.$options,"filters",n)||M}function je(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Ee(n,e,t,r,o){var a=F.keyCodes[e]||t;return o&&r&&!F.keyCodes[e]?je(o,r):a?je(a,n):r?I(r)!==e:void 0===n}function Ae(n,e,t,r,o){if(t)if(c(t)){var a;Array.isArray(t)&&(t=C(t));var i=function(i){if("class"===i||"style"===i||y(i))a=n;else{var s=n.attrs&&n.attrs.type;a=r||F.mustUseProp(e,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=j(i),c=I(i);l in a||c in a||(a[i]=t[i],o&&((n.on||(n.on={}))["update:"+i]=function(n){t[i]=n}))};for(var s in t)i(s)}else;return n}function Ie(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||ze(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function Te(n,e,t){return ze(n,"__once__"+e+(t?"_"+t:""),!0),n}function ze(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&_e(n[r],e+"_"+r,t);else _e(n,e,t)}function _e(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Ce(n,e){if(e)if(d(e)){var t=n.on=n.on?_({},n.on):{};for(var r in e){var o=t[r],a=e[r];t[r]=o?[].concat(o,a):a}}else;return n}function Pe(n,e,t,r){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var a=n[o];Array.isArray(a)?Pe(a,e,t):a&&(a.proxy&&(a.fn.proxy=!0),e[a.key]=a.fn)}return r&&(e.$key=r),e}function Oe(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function Me(n,e){return"string"==typeof n?e+n:n}function De(n){n._o=Te,n._n=g,n._s=h,n._l=we,n._t=ke,n._q=D,n._i=R,n._m=Ie,n._f=Se,n._k=Ee,n._b=Ae,n._v=vn,n._e=yn,n._u=Pe,n._g=Ce,n._d=Oe,n._p=Me}function Re(n,e,t,r,a){var i,l=this,c=a.options;w(r,"_uid")?(i=Object.create(r))._original=r:(i=r,r=r._original);var u=s(c._compiled),d=!u;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||o,this.injections=fe(c.inject,r),this.slots=function(){return l.$slots||ye(n.scopedSlots,l.$slots=he(t,r)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ye(n.scopedSlots,this.slots())}}),u&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=ye(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,o){var a=Ge(i,n,e,t,o,d);return a&&!Array.isArray(a)&&(a.fnScopeId=c._scopeId,a.fnContext=r),a}:this._c=function(n,e,t,r){return Ge(i,n,e,t,r,d)}}function Be(n,e,t,r,o){var a=xn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function Le(n,e){for(var t in e)n[j(t)]=e[t]}De(Re.prototype);var Ne={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Ne.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Xe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,a){0;var i=r.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==o&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||l);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=a,n.$attrs=r.data.attrs||o,n.$listeners=t||o,e&&n.$options.props){En(!1);for(var u=n._props,d=n.$options._propKeys||[],p=0;p<d.length;p++){var m=d[p],f=n.$options.props;u[m]=Fn(m,f,e,n)}En(!0),n.$options.propsData=e}t=t||o;var h=n.$options._parentListeners;n.$options._parentListeners=t,Ye(n,t,h),c&&(n.$slots=he(a,r.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,tt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,ot.push(e)):et(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,nt(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);tt(e,"deactivated")}}(e,!0):e.$destroy())}},Fe=Object.keys(Ne);function qe(n,e,t,r,l){if(!a(n)){var u=t.$options._base;if(c(n)&&(n=u.extend(n)),"function"==typeof n){var d;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=He;t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],o=!0,l=null,u=null;t.$on("hook:destroyed",(function(){return v(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==u&&(clearTimeout(u),u=null))},p=B((function(t){n.resolved=Je(t,e),o?r.length=0:d(!0)})),m=B((function(e){i(n.errorComp)&&(n.error=!0,d(!0))})),h=n(p,m);return c(h)&&(f(h)?a(n.resolved)&&h.then(p,m):f(h.component)&&(h.component.then(p,m),i(h.error)&&(n.errorComp=Je(h.error,e)),i(h.loading)&&(n.loadingComp=Je(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,d(!1))}),h.delay||200)),i(h.timeout)&&(u=setTimeout((function(){u=null,a(n.resolved)&&m(null)}),h.timeout)))),o=!1,n.loading?n.loadingComp:n.resolved}}(d=n,u)))return function(n,e,t,r,o){var a=yn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:o},a}(d,e,t,r,l);e=e||{},jt(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),a=o[r],s=e.model.callback;i(a)?(Array.isArray(a)?-1===a.indexOf(s):a!==s)&&(o[r]=[s].concat(a)):o[r]=s}(n.options,e);var p=function(n,e,t){var r=e.options.props;if(!a(r)){var o={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in r){var u=I(c);de(o,l,c,u,!0)||de(o,s,c,u,!1)}return o}}(e,n);if(s(n.options.functional))return function(n,e,t,r,a){var s=n.options,l={},c=s.props;if(i(c))for(var u in c)l[u]=Fn(u,c,e||o);else i(t.attrs)&&Le(l,t.attrs),i(t.props)&&Le(l,t.props);var d=new Re(t,l,a,r,n),p=s.render.call(null,d._c,d);if(p instanceof gn)return Be(p,t,d.parent,s,d);if(Array.isArray(p)){for(var m=pe(p)||[],f=new Array(m.length),h=0;h<m.length;h++)f[h]=Be(m[h],t,d.parent,s,d);return f}}(n,p,e,t,r);var m=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var h=e.slot;e={},h&&(e.slot=h)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Fe.length;t++){var r=Fe[t],o=e[r],a=Ne[r];o===a||o&&o._merged||(e[r]=o?$e(a,o):a)}}(e);var g=n.options.name||l;return new gn("vue-component-"+n.cid+(g?"-"+g:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:m,tag:l,children:r},d)}}}function $e(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function Ge(n,e,t,r,o,u){return(Array.isArray(t)||l(t))&&(o=r,r=t,t=void 0),s(u)&&(o=2),function(n,e,t,r,o){if(i(t)&&i(t.__ob__))return yn();i(t)&&i(t.is)&&(e=t.is);if(!e)return yn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===o?r=pe(r):1===o&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var l,u;if("string"==typeof e){var d;u=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),l=F.isReservedTag(e)?new gn(F.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(d=Nn(n.$options,"components",e))?new gn(e,t,r,void 0,void 0,n):qe(d,t,n,r,e)}else l=qe(e,t,n,r);return Array.isArray(l)?l:i(l)?(i(u)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var o=0,l=e.children.length;o<l;o++){var c=e.children[o];i(c.tag)&&(a(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(l,u),i(t)&&function(n){c(n.style)&&ie(n.style);c(n.class)&&ie(n.class)}(t),l):yn()}(n,e,t,r,o)}var Ue,He=null;function Je(n,e){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function We(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||be(t)))return t}}function Ve(n,e){Ue.$on(n,e)}function Ke(n,e){Ue.$off(n,e)}function Ze(n,e){var t=Ue;return function r(){var o=e.apply(null,arguments);null!==o&&t.$off(n,r)}}function Ye(n,e,t){Ue=n,ce(e,t||{},Ve,Ke,Ze,n),Ue=void 0}var Xe=null;function Qe(n){var e=Xe;return Xe=n,function(){Xe=e}}function nt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function et(n,e){if(e){if(n._directInactive=!1,nt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)et(n.$children[t]);tt(n,"activated")}}function tt(n,e){fn();var t=n.$options[e],r=e+" hook";if(t)for(var o=0,a=t.length;o<a;o++)Jn(t[o],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),hn()}var rt=[],ot=[],at={},it=!1,st=!1,lt=0;var ct=0,ut=Date.now;if(J&&!Z){var dt=window.performance;dt&&"function"==typeof dt.now&&ut()>document.createEvent("Event").timeStamp&&(ut=function(){return dt.now()})}function pt(){var n,e;for(ct=ut(),st=!0,rt.sort((function(n,e){return n.id-e.id})),lt=0;lt<rt.length;lt++)(n=rt[lt]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=ot.slice(),r=rt.slice();lt=rt.length=ot.length=0,at={},it=st=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,et(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&tt(r,"updated")}}(r),an&&F.devtools&&an.emit("flush")}var mt=0,ft=function(n,e,t,r,o){this.vm=n,o&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++mt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ln,this.newDepIds=new ln,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!G.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=P)),this.value=this.lazy?void 0:this.get()};ft.prototype.get=function(){var n;fn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Hn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&ie(n),hn(),this.cleanupDeps()}return n},ft.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},ft.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},ft.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==at[e]){if(at[e]=!0,st){for(var t=rt.length-1;t>lt&&rt[t].id>n.id;)t--;rt.splice(t+1,0,n)}else rt.push(n);it||(it=!0,oe(pt))}}(this)},ft.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Jn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},ft.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},ft.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},ft.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||v(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ht={enumerable:!0,configurable:!0,get:P,set:P};function gt(n,e,t){ht.get=function(){return this[e][t]},ht.set=function(n){this[e][t]=n},Object.defineProperty(n,t,ht)}function bt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},o=n.$options._propKeys=[];n.$parent&&En(!1);var a=function(a){o.push(a);var i=Fn(a,e,t,n);Tn(r,a,i),a in n||gt(n,"_props",a)};for(var i in e)a(i);En(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?P:T(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;d(e=n._data="function"==typeof e?function(n,e){fn();try{return n.call(e,e)}catch(n){return Hn(n,e,"data()"),{}}finally{hn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,o=(n.$options.methods,t.length);for(;o--;){var a=t[o];0,r&&w(r,a)||(i=void 0,36!==(i=(a+"").charCodeAt(0))&&95!==i&&gt(n,"_data",a))}var i;In(e,!0)}(n):In(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var o in e){var a=e[o],i="function"==typeof a?a:a.get;0,r||(t[o]=new ft(n,i||P,P,yt)),o in n||vt(n,o,a)}}(n,e.computed),e.watch&&e.watch!==en&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var o=0;o<r.length;o++)kt(n,t,r[o]);else kt(n,t,r)}}(n,e.watch)}var yt={lazy:!0};function vt(n,e,t){var r=!on();"function"==typeof t?(ht.get=r?xt(e):wt(t),ht.set=P):(ht.get=t.get?r&&!1!==t.cache?xt(e):wt(t.get):P,ht.set=t.set||P),Object.defineProperty(n,e,ht)}function xt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),pn.target&&e.depend(),e.value}}function wt(n){return function(){return n.call(this,this)}}function kt(n,e,t,r){return d(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var St=0;function jt(n){var e=n.options;if(n.super){var t=jt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var o in t)t[o]!==r[o]&&(e||(e={}),e[o]=t[o]);return e}(n);r&&_(n.extendOptions,r),(e=n.options=Ln(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Et(n){this._init(n)}function At(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,o=n._Ctor||(n._Ctor={});if(o[r])return o[r];var a=n.name||t.options.name;var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=Ln(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)gt(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)vt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,L.forEach((function(n){i[n]=t[n]})),a&&(i.options.components[a]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=_({},i.options),o[r]=i,i}}function It(n){return n&&(n.Ctor.options.name||n.tag)}function Tt(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function zt(n,e){var t=n.cache,r=n.keys,o=n._vnode;for(var a in t){var i=t[a];if(i){var s=i.name;s&&!e(s)&&_t(t,a,r,o)}}}function _t(n,e,t,r){var o=n[e];!o||r&&o.tag===r.tag||o.componentInstance.$destroy(),n[e]=null,v(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=St++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var o=r.componentOptions;t.propsData=o.propsData,t._parentListeners=o.listeners,t._renderChildren=o.children,t._componentTag=o.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Ln(jt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ye(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=he(e._renderChildren,r),n.$scopedSlots=o,n._c=function(e,t,r,o){return Ge(n,e,t,r,o,!1)},n.$createElement=function(e,t,r,o){return Ge(n,e,t,r,o,!0)};var a=t&&t.data;Tn(n,"$attrs",a&&a.attrs||o,null,!0),Tn(n,"$listeners",e._parentListeners||o,null,!0)}(e),tt(e,"beforeCreate"),function(n){var e=fe(n.$options.inject,n);e&&(En(!1),Object.keys(e).forEach((function(t){Tn(n,t,e[t])})),En(!0))}(e),bt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),tt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Et),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=zn,n.prototype.$delete=_n,n.prototype.$watch=function(n,e,t){if(d(e))return kt(this,n,e,t);(t=t||{}).user=!0;var r=new ft(this,n,e,t);if(t.immediate){var o='callback for immediate watcher "'+r.expression+'"';fn(),Jn(e,this,[r.value],this,o),hn()}return function(){r.teardown()}}}(Et),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var o=0,a=n.length;o<a;o++)r.$on(n[o],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,o=n.length;r<o;r++)t.$off(n[r],e);return t}var a,i=t._events[n];if(!i)return t;if(!e)return t._events[n]=null,t;for(var s=i.length;s--;)if((a=i[s])===e||a.fn===e){i.splice(s,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?z(t):t;for(var r=z(arguments,1),o='event handler for "'+n+'"',a=0,i=t.length;a<i;a++)Jn(t[a],e,r,e,o)}return e}}(Et),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,o=t._vnode,a=Qe(t);t._vnode=n,t.$el=o?t.__patch__(o,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){tt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||v(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),tt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Et),function(n){De(n.prototype),n.prototype.$nextTick=function(n){return oe(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,o=t._parentVnode;o&&(e.$scopedSlots=ye(o.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=o;try{He=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Hn(t,e,"render"),n=e._vnode}finally{He=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof gn||(n=yn()),n.parent=o,n}}(Et);var Ct=[String,RegExp,Array],Pt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Ct,exclude:Ct,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var o=t.tag,a=t.componentInstance,i=t.componentOptions;n[r]={name:It(i),tag:o,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&_t(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)_t(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){zt(n,(function(n){return Tt(e,n)}))})),this.$watch("exclude",(function(e){zt(n,(function(n){return!Tt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=We(n),t=e&&e.componentOptions;if(t){var r=It(t),o=this.include,a=this.exclude;if(o&&(!r||!Tt(o,r))||a&&r&&Tt(a,r))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,v(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:un,extend:_,mergeOptions:Ln,defineReactive:Tn},n.set=zn,n.delete=_n,n.nextTick=oe,n.observable=function(n){return In(n),n},n.options=Object.create(null),L.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,_(n.options.components,Pt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=z(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Ln(this.options,n),this}}(n),At(n),function(n){L.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Et),Object.defineProperty(Et.prototype,"$isServer",{get:on}),Object.defineProperty(Et.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Et,"FunctionalRenderContext",{value:Re}),Et.version="2.6.14";var Ot=b("style,class"),Mt=b("input,textarea,option,select,progress"),Dt=b("contenteditable,draggable,spellcheck"),Rt=b("events,caret,typing,plaintext-only"),Bt=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Lt="http://www.w3.org/1999/xlink",Nt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Ft=function(n){return Nt(n)?n.slice(6,n.length):""},qt=function(n){return null==n||!1===n};function $t(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=Gt(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=Gt(e,t.data));return function(n,e){if(i(n)||i(e))return Ut(n,Ht(e));return""}(e.staticClass,e.class)}function Gt(n,e){return{staticClass:Ut(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function Ut(n,e){return n?e?n+" "+e:n:e||""}function Ht(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,o=n.length;r<o;r++)i(e=Ht(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Jt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Wt=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Vt=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Kt=function(n){return Wt(n)||Vt(n)};var Zt=Object.create(null);var Yt=b("text,number,password,search,email,tel,url");var Xt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Jt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Qt={create:function(n,e){nr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(nr(n,!0),nr(e))},destroy:function(n){nr(n,!0)}};function nr(n,e){var t=n.data.ref;if(i(t)){var r=n.context,o=n.componentInstance||n.elm,a=r.$refs;e?Array.isArray(a[t])?v(a[t],o):a[t]===o&&(a[t]=void 0):n.data.refInFor?Array.isArray(a[t])?a[t].indexOf(o)<0&&a[t].push(o):a[t]=[o]:a[t]=o}}var er=new gn("",{},[]),tr=["create","activate","update","remove","destroy"];function rr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,o=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===o||Yt(r)&&Yt(o)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function or(n,e,t){var r,o,a={};for(r=e;r<=t;++r)i(o=n[r].key)&&(a[o]=r);return a}var ar={create:ir,update:ir,destroy:function(n){ir(n,er)}};function ir(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,o,a=n===er,i=e===er,s=lr(n.data.directives,n.context),l=lr(e.data.directives,e.context),c=[],u=[];for(t in l)r=s[t],o=l[t],r?(o.oldValue=r.value,o.oldArg=r.arg,ur(o,"update",e,n),o.def&&o.def.componentUpdated&&u.push(o)):(ur(o,"bind",e,n),o.def&&o.def.inserted&&c.push(o));if(c.length){var d=function(){for(var t=0;t<c.length;t++)ur(c[t],"inserted",e,n)};a?ue(e,"insert",d):d()}u.length&&ue(e,"postpatch",(function(){for(var t=0;t<u.length;t++)ur(u[t],"componentUpdated",e,n)}));if(!a)for(t in s)l[t]||ur(s[t],"unbind",n,n,i)}(n,e)}var sr=Object.create(null);function lr(n,e){var t,r,o=Object.create(null);if(!n)return o;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=sr),o[cr(r)]=r,r.def=Nn(e.$options,"directives",r.name);return o}function cr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function ur(n,e,t,r,o){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,o)}catch(r){Hn(r,t.context,"directive "+n.name+" "+e+" hook")}}var dr=[Qt,ar];function pr(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,o,s=e.elm,l=n.data.attrs||{},c=e.data.attrs||{};for(r in i(c.__ob__)&&(c=e.data.attrs=_({},c)),c)o=c[r],l[r]!==o&&mr(s,r,o,e.data.pre);for(r in(Z||X)&&c.value!==l.value&&mr(s,"value",c.value),l)a(c[r])&&(Nt(r)?s.removeAttributeNS(Lt,Ft(r)):Dt(r)||s.removeAttribute(r))}}function mr(n,e,t,r){r||n.tagName.indexOf("-")>-1?fr(n,e,t):Bt(e)?qt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Dt(e)?n.setAttribute(e,function(n,e){return qt(e)||"false"===e?"false":"contenteditable"===n&&Rt(e)?e:"true"}(e,t)):Nt(e)?qt(t)?n.removeAttributeNS(Lt,Ft(e)):n.setAttributeNS(Lt,e,t):fr(n,e,t)}function fr(n,e,t){if(qt(t))n.removeAttribute(e);else{if(Z&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var hr={create:pr,update:pr};function gr(n,e){var t=e.elm,r=e.data,o=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(o)||a(o.staticClass)&&a(o.class)))){var s=$t(e),l=t._transitionClasses;i(l)&&(s=Ut(s,Ht(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var br,yr={create:gr,update:gr};function vr(n,e,t){var r=br;return function o(){var a=e.apply(null,arguments);null!==a&&kr(n,o,t,r)}}var xr=Zn&&!(nn&&Number(nn[1])<=53);function wr(n,e,t,r){if(xr){var o=ct,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=o||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}br.addEventListener(n,e,tn?{capture:t,passive:r}:t)}function kr(n,e,t,r){(r||br).removeEventListener(n,e._wrapper||e,t)}function Sr(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};br=e.elm,function(n){if(i(n.__r)){var e=Z?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),ce(t,r,wr,kr,vr,e.context),br=void 0}}var jr,Er={create:Sr,update:Sr};function Ar(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,o=e.elm,s=n.data.domProps||{},l=e.data.domProps||{};for(t in i(l.__ob__)&&(l=e.data.domProps=_({},l)),s)t in l||(o[t]="");for(t in l){if(r=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===s[t])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===t&&"PROGRESS"!==o.tagName){o._value=r;var c=a(r)?"":String(r);Ir(o,c)&&(o.value=c)}else if("innerHTML"===t&&Vt(o.tagName)&&a(o.innerHTML)){(jr=jr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var u=jr.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;u.firstChild;)o.appendChild(u.firstChild)}else if(r!==s[t])try{o[t]=r}catch(n){}}}}function Ir(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return g(t)!==g(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Tr={create:Ar,update:Ar},zr=k((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function _r(n){var e=Cr(n.style);return n.staticStyle?_(n.staticStyle,e):e}function Cr(n){return Array.isArray(n)?C(n):"string"==typeof n?zr(n):n}var Pr,Or=/^--/,Mr=/\s*!important$/,Dr=function(n,e,t){if(Or.test(e))n.style.setProperty(e,t);else if(Mr.test(t))n.style.setProperty(I(e),t.replace(Mr,""),"important");else{var r=Br(e);if(Array.isArray(t))for(var o=0,a=t.length;o<a;o++)n.style[r]=t[o];else n.style[r]=t}},Rr=["Webkit","Moz","ms"],Br=k((function(n){if(Pr=Pr||document.createElement("div").style,"filter"!==(n=j(n))&&n in Pr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Rr.length;t++){var r=Rr[t]+e;if(r in Pr)return r}}));function Lr(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var o,s,l=e.elm,c=r.staticStyle,u=r.normalizedStyle||r.style||{},d=c||u,p=Cr(e.data.style)||{};e.data.normalizedStyle=i(p.__ob__)?_({},p):p;var m=function(n,e){var t,r={};if(e)for(var o=n;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(t=_r(o.data))&&_(r,t);(t=_r(n.data))&&_(r,t);for(var a=n;a=a.parent;)a.data&&(t=_r(a.data))&&_(r,t);return r}(e,!0);for(s in d)a(m[s])&&Dr(l,s,"");for(s in m)(o=m[s])!==d[s]&&Dr(l,s,null==o?"":o)}}var Nr={create:Lr,update:Lr},Fr=/\s+/;function qr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Fr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function $r(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Fr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Gr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&_(e,Ur(n.name||"v")),_(e,n),e}return"string"==typeof n?Ur(n):void 0}}var Ur=k((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Hr=J&&!Y,Jr="transition",Wr="transitionend",Vr="animation",Kr="animationend";Hr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Jr="WebkitTransition",Wr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Vr="WebkitAnimation",Kr="webkitAnimationEnd"));var Zr=J?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Yr(n){Zr((function(){Zr(n)}))}function Xr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),qr(n,e))}function Qr(n,e){n._transitionClasses&&v(n._transitionClasses,e),$r(n,e)}function no(n,e,t){var r=to(n,e),o=r.type,a=r.timeout,i=r.propCount;if(!o)return t();var s="transition"===o?Wr:Kr,l=0,c=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),a+1),n.addEventListener(s,u)}var eo=/\b(transform|all)(,|$)/;function to(n,e){var t,r=window.getComputedStyle(n),o=(r[Jr+"Delay"]||"").split(", "),a=(r[Jr+"Duration"]||"").split(", "),i=ro(o,a),s=(r[Vr+"Delay"]||"").split(", "),l=(r[Vr+"Duration"]||"").split(", "),c=ro(s,l),u=0,d=0;return"transition"===e?i>0&&(t="transition",u=i,d=a.length):"animation"===e?c>0&&(t="animation",u=c,d=l.length):d=(t=(u=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&eo.test(r[Jr+"Property"])}}function ro(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return oo(e)+oo(n[t])})))}function oo(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ao(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=Gr(n.data.transition);if(!a(r)&&!i(t._enterCb)&&1===t.nodeType){for(var o=r.css,s=r.type,l=r.enterClass,u=r.enterToClass,d=r.enterActiveClass,p=r.appearClass,m=r.appearToClass,f=r.appearActiveClass,h=r.beforeEnter,b=r.enter,y=r.afterEnter,v=r.enterCancelled,x=r.beforeAppear,w=r.appear,k=r.afterAppear,S=r.appearCancelled,j=r.duration,E=Xe,A=Xe.$vnode;A&&A.parent;)E=A.context,A=A.parent;var I=!E._isMounted||!n.isRootInsert;if(!I||w||""===w){var T=I&&p?p:l,z=I&&f?f:d,_=I&&m?m:u,C=I&&x||h,P=I&&"function"==typeof w?w:b,O=I&&k||y,M=I&&S||v,D=g(c(j)?j.enter:j);0;var R=!1!==o&&!Y,L=lo(P),N=t._enterCb=B((function(){R&&(Qr(t,_),Qr(t,z)),N.cancelled?(R&&Qr(t,T),M&&M(t)):O&&O(t),t._enterCb=null}));n.data.show||ue(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),P&&P(t,N)})),C&&C(t),R&&(Xr(t,T),Xr(t,z),Yr((function(){Qr(t,T),N.cancelled||(Xr(t,_),L||(so(D)?setTimeout(N,D):no(t,s,N)))}))),n.data.show&&(e&&e(),P&&P(t,N)),R||L||N()}}}function io(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=Gr(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var o=r.css,s=r.type,l=r.leaveClass,u=r.leaveToClass,d=r.leaveActiveClass,p=r.beforeLeave,m=r.leave,f=r.afterLeave,h=r.leaveCancelled,b=r.delayLeave,y=r.duration,v=!1!==o&&!Y,x=lo(m),w=g(c(y)?y.leave:y);0;var k=t._leaveCb=B((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),v&&(Qr(t,u),Qr(t,d)),k.cancelled?(v&&Qr(t,l),h&&h(t)):(e(),f&&f(t)),t._leaveCb=null}));b?b(S):S()}function S(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),v&&(Xr(t,l),Xr(t,d),Yr((function(){Qr(t,l),k.cancelled||(Xr(t,u),x||(so(w)?setTimeout(k,w):no(t,s,k)))}))),m&&m(t,k),v||x||k())}}function so(n){return"number"==typeof n&&!isNaN(n)}function lo(n){if(a(n))return!1;var e=n.fns;return i(e)?lo(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function co(n,e){!0!==e.data.show&&ao(e)}var uo=function(n){var e,t,r={},o=n.modules,c=n.nodeOps;for(e=0;e<tr.length;++e)for(r[tr[e]]=[],t=0;t<o.length;++t)i(o[t][tr[e]])&&r[tr[e]].push(o[t][tr[e]]);function u(n){var e=c.parentNode(n);i(e)&&c.removeChild(e,n)}function d(n,e,t,o,a,l,u){if(i(n.elm)&&i(l)&&(n=l[u]=xn(n)),n.isRootInsert=!a,!function(n,e,t,o){var a=n.data;if(i(a)){var l=i(n.componentInstance)&&a.keepAlive;if(i(a=a.hook)&&i(a=a.init)&&a(n,!1),i(n.componentInstance))return p(n,e),m(t,n.elm,o),s(l)&&function(n,e,t,o){var a,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(a=s.data)&&i(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](er,s);e.push(s);break}m(t,n.elm,o)}(n,e,t,o),!0}}(n,e,t,o)){var d=n.data,h=n.children,b=n.tag;i(b)?(n.elm=n.ns?c.createElementNS(n.ns,b):c.createElement(b,n),y(n),f(n,h,e),i(d)&&g(n,e),m(t,n.elm,o)):s(n.isComment)?(n.elm=c.createComment(n.text),m(t,n.elm,o)):(n.elm=c.createTextNode(n.text),m(t,n.elm,o))}}function p(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,h(n)?(g(n,e),y(n)):(nr(n),e.push(n))}function m(n,e,t){i(n)&&(i(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function f(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function h(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function g(n,t){for(var o=0;o<r.create.length;++o)r.create[o](er,n);i(e=n.data.hook)&&(i(e.create)&&e.create(er,n),i(e.insert)&&t.push(n))}function y(n){var e;if(i(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;i(e=Xe)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function v(n,e,t,r,o,a){for(;r<=o;++r)d(t[r],a,n,e,!1,t,r)}function x(n){var e,t,o=n.data;if(i(o))for(i(e=o.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(k(r),x(r)):u(r.elm))}}function k(n,e){if(i(e)||i(n.data)){var t,o=r.remove.length+1;for(i(e)?e.listeners+=o:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,o),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&k(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else u(n.elm)}function S(n,e,t,r){for(var o=t;o<r;o++){var a=e[o];if(i(a)&&rr(n,a))return o}}function j(n,e,t,o,l,u){if(n!==e){i(e.elm)&&i(o)&&(e=o[l]=xn(e));var p=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?I(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,f=e.data;i(f)&&i(m=f.hook)&&i(m=m.prepatch)&&m(n,e);var g=n.children,b=e.children;if(i(f)&&h(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);i(m=f.hook)&&i(m=m.update)&&m(n,e)}a(e.text)?i(g)&&i(b)?g!==b&&function(n,e,t,r,o){var s,l,u,p=0,m=0,f=e.length-1,h=e[0],g=e[f],b=t.length-1,y=t[0],x=t[b],k=!o;for(0;p<=f&&m<=b;)a(h)?h=e[++p]:a(g)?g=e[--f]:rr(h,y)?(j(h,y,r,t,m),h=e[++p],y=t[++m]):rr(g,x)?(j(g,x,r,t,b),g=e[--f],x=t[--b]):rr(h,x)?(j(h,x,r,t,b),k&&c.insertBefore(n,h.elm,c.nextSibling(g.elm)),h=e[++p],x=t[--b]):rr(g,y)?(j(g,y,r,t,m),k&&c.insertBefore(n,g.elm,h.elm),g=e[--f],y=t[++m]):(a(s)&&(s=or(e,p,f)),a(l=i(y.key)?s[y.key]:S(y,e,p,f))?d(y,r,n,h.elm,!1,t,m):rr(u=e[l],y)?(j(u,y,r,t,m),e[l]=void 0,k&&c.insertBefore(n,u.elm,h.elm)):d(y,r,n,h.elm,!1,t,m),y=t[++m]);p>f?v(n,a(t[b+1])?null:t[b+1].elm,t,m,b,r):m>b&&w(e,p,f)}(p,g,b,t,u):i(b)?(i(n.text)&&c.setTextContent(p,""),v(p,null,b,0,b.length-1,t)):i(g)?w(g,0,g.length-1):i(n.text)&&c.setTextContent(p,""):n.text!==e.text&&c.setTextContent(p,e.text),i(f)&&i(m=f.hook)&&i(m=m.postpatch)&&m(n,e)}}}function E(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var A=b("attrs,class,staticClass,staticStyle,key");function I(n,e,t,r){var o,a=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(o=l.hook)&&i(o=o.init)&&o(e,!0),i(o=e.componentInstance)))return p(e,t),!0;if(i(a)){if(i(c))if(n.hasChildNodes())if(i(o=l)&&i(o=o.domProps)&&i(o=o.innerHTML)){if(o!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,m=0;m<c.length;m++){if(!d||!I(d,c[m],t,r)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else f(e,c,t);if(i(l)){var h=!1;for(var b in l)if(!A(b)){h=!0,g(e,t);break}!h&&l.class&&ie(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,o){if(!a(e)){var l,u=!1,p=[];if(a(n))u=!0,d(e,p);else{var m=i(n.nodeType);if(!m&&rr(n,e))j(n,e,p,null,null,o);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&I(n,e,p))return E(e,p,!0),n;l=n,n=new gn(c.tagName(l).toLowerCase(),{},[],void 0,l)}var f=n.elm,g=c.parentNode(f);if(d(e,p,f._leaveCb?null:g,c.nextSibling(f)),i(e.parent))for(var b=e.parent,y=h(e);b;){for(var v=0;v<r.destroy.length;++v)r.destroy[v](b);if(b.elm=e.elm,y){for(var k=0;k<r.create.length;++k)r.create[k](er,b);var S=b.data.hook.insert;if(S.merged)for(var A=1;A<S.fns.length;A++)S.fns[A]()}else nr(b);b=b.parent}i(g)?w([n],0,0):i(n.tag)&&x(n)}}return E(e,p,u),e.elm}i(n)&&x(n)}}({nodeOps:Xt,modules:[hr,yr,Er,Tr,Nr,J?{create:co,activate:co,remove:function(n,e){!0!==n.data.show?io(n,e):e()}}:{}].concat(dr)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&vo(n,"input")}));var po={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?ue(t,"postpatch",(function(){po.componentUpdated(n,e,t)})):mo(n,e,t.context),n._vOptions=[].map.call(n.options,go)):("textarea"===t.tag||Yt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",bo),n.addEventListener("compositionend",yo),n.addEventListener("change",yo),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){mo(n,e,t.context);var r=n._vOptions,o=n._vOptions=[].map.call(n.options,go);if(o.some((function(n,e){return!D(n,r[e])})))(n.multiple?e.value.some((function(n){return ho(n,o)})):e.value!==e.oldValue&&ho(e.value,o))&&vo(n,"change")}}};function mo(n,e,t){fo(n,e,t),(Z||X)&&setTimeout((function(){fo(n,e,t)}),0)}function fo(n,e,t){var r=e.value,o=n.multiple;if(!o||Array.isArray(r)){for(var a,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],o)a=R(r,go(i))>-1,i.selected!==a&&(i.selected=a);else if(D(go(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));o||(n.selectedIndex=-1)}}function ho(n,e){return e.every((function(e){return!D(e,n)}))}function go(n){return"_value"in n?n._value:n.value}function bo(n){n.target.composing=!0}function yo(n){n.target.composing&&(n.target.composing=!1,vo(n.target,"input"))}function vo(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function xo(n){return!n.componentInstance||n.data&&n.data.transition?n:xo(n.componentInstance._vnode)}var wo={model:po,show:{bind:function(n,e,t){var r=e.value,o=(t=xo(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&o?(t.data.show=!0,ao(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=xo(t)).data&&t.data.transition?(t.data.show=!0,r?ao(t,(function(){n.style.display=n.__vOriginalDisplay})):io(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,o){o||(n.style.display=n.__vOriginalDisplay)}}},ko={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function So(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?So(We(e.children)):n}function jo(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var o=t._parentListeners;for(var a in o)e[j(a)]=o[a];return e}function Eo(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Ao=function(n){return n.tag||be(n)},Io=function(n){return"show"===n.name},To={name:"transition",props:ko,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Ao)).length){0;var r=this.mode;0;var o=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return o;var a=So(o);if(!a)return o;if(this._leaving)return Eo(n,o);var i="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?i+"comment":i+a.tag:l(a.key)?0===String(a.key).indexOf(i)?a.key:i+a.key:a.key;var s=(a.data||(a.data={})).transition=jo(this),c=this._vnode,u=So(c);if(a.data.directives&&a.data.directives.some(Io)&&(a.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,u)&&!be(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=_({},s);if("out-in"===r)return this._leaving=!0,ue(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Eo(n,o);if("in-out"===r){if(be(a))return c;var p,m=function(){p()};ue(s,"afterEnter",m),ue(s,"enterCancelled",m),ue(d,"delayLeave",(function(n){p=n}))}}return o}}},zo=_({tag:String,moveClass:String},ko);function _o(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Co(n){n.data.newPos=n.elm.getBoundingClientRect()}function Po(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,o=e.top-t.top;if(r||o){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate("+r+"px,"+o+"px)",a.transitionDuration="0s"}}delete zo.mode;var Oo={Transition:To,TransitionGroup:{props:zo,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var o=Qe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,o(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,o=this.$slots.default||[],a=this.children=[],i=jo(this),s=0;s<o.length;s++){var l=o[s];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))a.push(l),t[l.key]=l,(l.data||(l.data={})).transition=i;else;}if(r){for(var c=[],u=[],d=0;d<r.length;d++){var p=r[d];p.data.transition=i,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?c.push(p):u.push(p)}this.kept=n(e,null,c),this.removed=u}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(_o),n.forEach(Co),n.forEach(Po),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Xr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Wr,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Wr,n),t._moveCb=null,Qr(t,e))})}})))},methods:{hasMove:function(n,e){if(!Hr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){$r(t,n)})),qr(t,e),t.style.display="none",this.$el.appendChild(t);var r=to(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};Et.config.mustUseProp=function(n,e,t){return"value"===t&&Mt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Et.config.isReservedTag=Kt,Et.config.isReservedAttr=Ot,Et.config.getTagNamespace=function(n){return Vt(n)?"svg":"math"===n?"math":void 0},Et.config.isUnknownElement=function(n){if(!J)return!0;if(Kt(n))return!1;if(n=n.toLowerCase(),null!=Zt[n])return Zt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Zt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Zt[n]=/HTMLUnknownElement/.test(e.toString())},_(Et.options.directives,wo),_(Et.options.components,Oo),Et.prototype.__patch__=J?uo:P,Et.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=yn),tt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new ft(n,r,P,{before:function(){n._isMounted&&!n._isDestroyed&&tt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,tt(n,"mounted")),n}(this,n=n&&J?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},J&&setTimeout((function(){F.devtools&&an&&an.emit("init",Et)}),0);var Mo=Et;
/*!
  * vue-router v3.5.3
  * (c) 2021 Evan You
  * @license MIT
  */function Do(n,e){for(var t in e)n[t]=e[t];return n}var Ro=/[!'()*]/g,Bo=function(n){return"%"+n.charCodeAt(0).toString(16)},Lo=/%2C/g,No=function(n){return encodeURIComponent(n).replace(Ro,Bo).replace(Lo,",")};function Fo(n){try{return decodeURIComponent(n)}catch(n){0}return n}var qo=function(n){return null==n||"object"==typeof n?n:String(n)};function $o(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=Fo(t.shift()),o=t.length>0?Fo(t.join("=")):null;void 0===e[r]?e[r]=o:Array.isArray(e[r])?e[r].push(o):e[r]=[e[r],o]})),e):e}function Go(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return No(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(No(e)):r.push(No(e)+"="+No(n)))})),r.join("&")}return No(e)+"="+No(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Uo=/\/?$/;function Ho(n,e,t,r){var o=r&&r.options.stringifyQuery,a=e.query||{};try{a=Jo(a)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:Ko(e,o),matched:n?Vo(n):[]};return t&&(i.redirectedFrom=Ko(t,o)),Object.freeze(i)}function Jo(n){if(Array.isArray(n))return n.map(Jo);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=Jo(n[t]);return e}return n}var Wo=Ho(null,{path:"/"});function Vo(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Ko(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var o=n.hash;return void 0===o&&(o=""),(t||"/")+(e||Go)(r)+o}function Zo(n,e,t){return e===Wo?n===e:!!e&&(n.path&&e.path?n.path.replace(Uo,"")===e.path.replace(Uo,"")&&(t||n.hash===e.hash&&Yo(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Yo(n.query,e.query)&&Yo(n.params,e.params))))}function Yo(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,o){var a=n[t];if(r[o]!==t)return!1;var i=e[t];return null==a||null==i?a===i:"object"==typeof a&&"object"==typeof i?Yo(a,i):String(a)===String(i)}))}function Xo(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var o=t.instances[r],a=t.enteredCbs[r];if(o&&a){delete t.enteredCbs[r];for(var i=0;i<a.length;i++)o._isBeingDestroyed||a[i](o)}}}}var Qo={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,o=e.parent,a=e.data;a.routerView=!0;for(var i=o.$createElement,s=t.name,l=o.$route,c=o._routerViewCache||(o._routerViewCache={}),u=0,d=!1;o&&o._routerRoot!==o;){var p=o.$vnode?o.$vnode.data:{};p.routerView&&u++,p.keepAlive&&o._directInactive&&o._inactive&&(d=!0),o=o.$parent}if(a.routerViewDepth=u,d){var m=c[s],f=m&&m.component;return f?(m.configProps&&na(f,a,m.route,m.configProps),i(f,a,r)):i()}var h=l.matched[u],g=h&&h.components[s];if(!h||!g)return c[s]=null,i();c[s]={component:g},a.registerRouteInstance=function(n,e){var t=h.instances[s];(e&&t!==n||!e&&t===n)&&(h.instances[s]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){h.instances[s]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[s]&&(h.instances[s]=n.componentInstance),Xo(l)};var b=h.props&&h.props[s];return b&&(Do(c[s],{route:l,configProps:b}),na(g,a,l,b)),i(g,a,r)}};function na(n,e,t,r){var o=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(o){o=e.props=Do({},o);var a=e.attrs=e.attrs||{};for(var i in o)n.props&&i in n.props||(a[i]=o[i],delete o[i])}}function ea(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var o=e.split("/");t&&o[o.length-1]||o.pop();for(var a=n.replace(/^\//,"").split("/"),i=0;i<a.length;i++){var s=a[i];".."===s?o.pop():"."!==s&&o.push(s)}return""!==o[0]&&o.unshift(""),o.join("/")}function ta(n){return n.replace(/\/+/g,"/")}var ra=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},oa=ya,aa=ua,ia=function(n,e){return pa(ua(n,e),e)},sa=pa,la=ba,ca=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function ua(n,e){for(var t,r=[],o=0,a=0,i="",s=e&&e.delimiter||"/";null!=(t=ca.exec(n));){var l=t[0],c=t[1],u=t.index;if(i+=n.slice(a,u),a=u+l.length,c)i+=c[1];else{var d=n[a],p=t[2],m=t[3],f=t[4],h=t[5],g=t[6],b=t[7];i&&(r.push(i),i="");var y=null!=p&&null!=d&&d!==p,v="+"===g||"*"===g,x="?"===g||"*"===g,w=t[2]||s,k=f||h;r.push({name:m||o++,prefix:p||"",delimiter:w,optional:x,repeat:v,partial:y,asterisk:!!b,pattern:k?fa(k):b?".*":"[^"+ma(w)+"]+?"})}}return a<n.length&&(i+=n.substr(a)),i&&r.push(i),r}function da(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function pa(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",ga(e)));return function(e,r){for(var o="",a=e||{},i=(r||{}).pretty?da:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,u=a[l.name];if(null==u){if(l.optional){l.partial&&(o+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ra(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(c=i(u[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");o+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(u),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');o+=l.prefix+c}}else o+=l}return o}}function ma(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function fa(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function ha(n,e){return n.keys=e,n}function ga(n){return n&&n.sensitive?"":"i"}function ba(n,e,t){ra(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,o=!1!==t.end,a="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)a+=ma(s);else{var l=ma(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),a+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=ma(t.delimiter||"/"),d=a.slice(-u.length)===u;return r||(a=(d?a.slice(0,-u.length):a)+"(?:"+u+"(?=$))?"),a+=o?"$":r&&d?"":"(?="+u+"|$)",ha(new RegExp("^"+a,ga(t)),e)}function ya(n,e,t){return ra(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return ha(n,e)}(n,e):ra(n)?function(n,e,t){for(var r=[],o=0;o<n.length;o++)r.push(ya(n[o],e,t).source);return ha(new RegExp("(?:"+r.join("|")+")",ga(t)),e)}(n,e,t):function(n,e,t){return ba(ua(n,t),e,t)}(n,e,t)}oa.parse=aa,oa.compile=ia,oa.tokensToFunction=sa,oa.tokensToRegExp=la;var va=Object.create(null);function xa(n,e,t){e=e||{};try{var r=va[n]||(va[n]=oa.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function wa(n,e,t,r){var o="string"==typeof n?{path:n}:n;if(o._normalized)return o;if(o.name){var a=(o=Do({},n)).params;return a&&"object"==typeof a&&(o.params=Do({},a)),o}if(!o.path&&o.params&&e){(o=Do({},o))._normalized=!0;var i=Do(Do({},e.params),o.params);if(e.name)o.name=e.name,o.params=i;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;o.path=xa(s,i,e.path)}else 0;return o}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var o=n.indexOf("?");return o>=0&&(t=n.slice(o+1),n=n.slice(0,o)),{path:n,query:t,hash:e}}(o.path||""),c=e&&e.path||"/",u=l.path?ea(l.path,c,t||o.append):c,d=function(n,e,t){void 0===e&&(e={});var r,o=t||$o;try{r=o(n||"")}catch(n){r={}}for(var a in e){var i=e[a];r[a]=Array.isArray(i)?i.map(qo):qo(i)}return r}(l.query,o.query,r&&r.options.parseQuery),p=o.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:u,query:d,hash:p}}var ka,Sa=function(){},ja={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,o=t.resolve(this.to,r,this.append),a=o.location,i=o.route,s=o.href,l={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,p=null==u?"router-link-exact-active":u,m=null==this.activeClass?d:this.activeClass,f=null==this.exactActiveClass?p:this.exactActiveClass,h=i.redirectedFrom?Ho(null,wa(i.redirectedFrom),null,t):i;l[f]=Zo(r,h,this.exactPath),l[m]=this.exact||this.exactPath?l[f]:function(n,e){return 0===n.path.replace(Uo,"/").indexOf(e.path.replace(Uo,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,h);var g=l[f]?this.ariaCurrentValue:null,b=function(n){Ea(n)&&(e.replace?t.replace(a,Sa):t.push(a,Sa))},y={click:Ea};Array.isArray(this.event)?this.event.forEach((function(n){y[n]=b})):y[this.event]=b;var v={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:i,navigate:b,isActive:l[m],isExactActive:l[f]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)v.on=y,v.attrs={href:s,"aria-current":g};else{var w=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var k=w.data=Do({},w.data);for(var S in k.on=k.on||{},k.on){var j=k.on[S];S in y&&(k.on[S]=Array.isArray(j)?j:[j])}for(var E in y)E in k.on?k.on[E].push(y[E]):k.on[E]=b;var A=w.data.attrs=Do({},w.data.attrs);A.href=s,A["aria-current"]=g}else v.on=y}return n(this.tag,v,this.$slots.default)}};function Ea(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Aa="undefined"!=typeof window;function Ia(n,e,t,r,o){var a=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,o,a,i){var s=o.path,l=o.name;0;var c=o.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ta(e.path+"/"+n)}(s,a,c.strict);"boolean"==typeof o.caseSensitive&&(c.sensitive=o.caseSensitive);var d={path:u,regex:Ta(u,c),components:o.components||{default:o.component},alias:o.alias?"string"==typeof o.alias?[o.alias]:o.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:i,redirect:o.redirect,beforeEnter:o.beforeEnter,meta:o.meta||{},props:null==o.props?{}:o.components?o.props:{default:o.props}};o.children&&o.children.forEach((function(o){var a=i?ta(i+"/"+o.path):void 0;n(e,t,r,o,d,a)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==o.alias)for(var p=Array.isArray(o.alias)?o.alias:[o.alias],m=0;m<p.length;++m){0;var f={path:p[m],children:o.children};n(e,t,r,f,a,d.path||"/")}l&&(r[l]||(r[l]=d))}(a,i,s,n,o)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:i,nameMap:s}}function Ta(n,e){return oa(n,[],e)}function za(n,e){var t=Ia(n),r=t.pathList,o=t.pathMap,a=t.nameMap;function i(n,t,i){var s=wa(n,t,!1,e),c=s.name;if(c){var u=a[c];if(!u)return l(null,s);var d=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&d.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=xa(u.path,s.params),l(u,s,i)}if(s.path){s.params={};for(var m=0;m<r.length;m++){var f=r[m],h=o[f];if(_a(h.regex,s.path,s.params))return l(h,s,i)}}return l(null,s)}function s(n,t){var r=n.redirect,o="function"==typeof r?r(Ho(n,t,null,e)):r;if("string"==typeof o&&(o={path:o}),!o||"object"!=typeof o)return l(null,t);var s=o,c=s.name,u=s.path,d=t.query,p=t.hash,m=t.params;if(d=s.hasOwnProperty("query")?s.query:d,p=s.hasOwnProperty("hash")?s.hash:p,m=s.hasOwnProperty("params")?s.params:m,c){a[c];return i({_normalized:!0,name:c,query:d,hash:p,params:m},void 0,t)}if(u){var f=function(n,e){return ea(n,e.parent?e.parent.path:"/",!0)}(u,n);return i({_normalized:!0,path:xa(f,m),query:d,hash:p},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:xa(t,e.params)});if(r){var o=r.matched,a=o[o.length-1];return e.params=r.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):Ho(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Ia([e||n],r,o,a,t),t&&t.alias.length&&Ia(t.alias.map((function(n){return{path:n,children:[e]}})),r,o,a,t)},getRoutes:function(){return r.map((function(n){return o[n]}))},addRoutes:function(n){Ia(n,r,o,a)}}}function _a(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var o=1,a=r.length;o<a;++o){var i=n.keys[o-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[o]?Fo(r[o]):r[o])}return!0}var Ca=Aa&&window.performance&&window.performance.now?window.performance:Date;function Pa(){return Ca.now().toFixed(3)}var Oa=Pa();function Ma(){return Oa}function Da(n){return Oa=n}var Ra=Object.create(null);function Ba(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Do({},window.history.state);return t.key=Ma(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Fa),function(){window.removeEventListener("popstate",Fa)}}function La(n,e,t,r){if(n.app){var o=n.options.scrollBehavior;o&&n.app.$nextTick((function(){var a=function(){var n=Ma();if(n)return Ra[n]}(),i=o.call(n,e,t,r?a:null);i&&("function"==typeof i.then?i.then((function(n){Ha(n,a)})).catch((function(n){0})):Ha(i,a))}))}}function Na(){var n=Ma();n&&(Ra[n]={x:window.pageXOffset,y:window.pageYOffset})}function Fa(n){Na(),n.state&&n.state.key&&Da(n.state.key)}function qa(n){return Ga(n.x)||Ga(n.y)}function $a(n){return{x:Ga(n.x)?n.x:window.pageXOffset,y:Ga(n.y)?n.y:window.pageYOffset}}function Ga(n){return"number"==typeof n}var Ua=/^#\d/;function Ha(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var o=Ua.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(o){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(o,a={x:Ga((t=a).x)?t.x:0,y:Ga(t.y)?t.y:0})}else qa(n)&&(e=$a(n))}else r&&qa(n)&&(e=$a(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var Ja,Wa=Aa&&((-1===(Ja=window.navigator.userAgent).indexOf("Android 2.")&&-1===Ja.indexOf("Android 4.0")||-1===Ja.indexOf("Mobile Safari")||-1!==Ja.indexOf("Chrome")||-1!==Ja.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Va(n,e){Na();var t=window.history;try{if(e){var r=Do({},t.state);r.key=Ma(),t.replaceState(r,"",n)}else t.pushState({key:Da(Pa())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Ka(n){Va(n,!0)}function Za(n,e,t){var r=function(o){o>=n.length?t():n[o]?e(n[o],(function(){r(o+1)})):r(o+1)};r(0)}var Ya={redirected:2,aborted:4,cancelled:8,duplicated:16};function Xa(n,e){return ni(n,e,Ya.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ei.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Qa(n,e){return ni(n,e,Ya.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ni(n,e,t,r){var o=new Error(r);return o._isRouter=!0,o.from=n,o.to=e,o.type=t,o}var ei=["params","query","hash"];function ti(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ri(n,e){return ti(n)&&n._isRouter&&(null==e||n.type===e)}function oi(n){return function(e,t,r){var o=!1,a=0,i=null;ai(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){o=!0,a++;var l,c=li((function(e){var o;((o=e).__esModule||si&&"Module"===o[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:ka.extend(e),t.components[s]=e,--a<=0&&r()})),u=li((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=ti(n)?n:new Error(e),r(i))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,u)}}})),o||r()}}function ai(n,e){return ii(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function ii(n){return Array.prototype.concat.apply([],n)}var si="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function li(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var ci=function(n,e){this.router=n,this.base=function(n){if(!n)if(Aa){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Wo,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function ui(n,e,t,r){var o=ai(n,(function(n,r,o,a){var i=function(n,e){"function"!=typeof n&&(n=ka.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,o,a)})):t(i,r,o,a)}));return ii(r?o.reverse():o)}function di(n,e){if(e)return function(){return n.apply(e,arguments)}}ci.prototype.listen=function(n){this.cb=n},ci.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},ci.prototype.onError=function(n){this.errorCbs.push(n)},ci.prototype.transitionTo=function(n,e,t){var r,o=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){o.updateRoute(r),e&&e(r),o.ensureURL(),o.router.afterHooks.forEach((function(n){n&&n(r,a)})),o.ready||(o.ready=!0,o.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!o.ready&&(ri(n,Ya.redirected)&&a===Wo||(o.ready=!0,o.readyErrorCbs.forEach((function(e){e(n)}))))}))},ci.prototype.confirmTransition=function(n,e,t){var r=this,o=this.current;this.pending=n;var a,i,s=function(n){!ri(n)&&ti(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=o.matched.length-1;if(Zo(n,o)&&l===c&&n.matched[l]===o.matched[c])return this.ensureURL(),n.hash&&La(this.router,o,n,!1),s(((i=ni(a=o,n,Ya.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",i));var u=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=u.updated,p=u.deactivated,m=u.activated,f=[].concat(function(n){return ui(n,"beforeRouteLeave",di,!0)}(p),this.router.beforeHooks,function(n){return ui(n,"beforeRouteUpdate",di)}(d),m.map((function(n){return n.beforeEnter})),oi(m)),h=function(e,t){if(r.pending!==n)return s(Qa(o,n));try{e(n,o,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return ni(n,e,Ya.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(o,n))):ti(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(Xa(o,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};Za(f,h,(function(){Za(function(n){return ui(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,o,a){return n(r,o,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),h,(function(){if(r.pending!==n)return s(Qa(o,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){Xo(n)}))}))}))},ci.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},ci.prototype.setupListeners=function(){},ci.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Wo,this.pending=null};var pi=function(n){function e(e,t){n.call(this,e,t),this._startLocation=mi(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=Wa&&t;r&&this.listeners.push(Ba());var o=function(){var t=n.current,o=mi(n.base);n.current===Wo&&o===n._startLocation||n.transitionTo(o,(function(n){r&&La(e,n,t,!0)}))};window.addEventListener("popstate",o),this.listeners.push((function(){window.removeEventListener("popstate",o)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Va(ta(r.base+n.fullPath)),La(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Ka(ta(r.base+n.fullPath)),La(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(mi(this.base)!==this.current.fullPath){var e=ta(this.base+this.current.fullPath);n?Va(e):Ka(e)}},e.prototype.getCurrentLocation=function(){return mi(this.base)},e}(ci);function mi(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(ta(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var fi=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=mi(n);if(!/^\/#/.test(e))return window.location.replace(ta(n+"/#"+e)),!0}(this.base)||hi()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Wa&&e;t&&this.listeners.push(Ba());var r=function(){var e=n.current;hi()&&n.transitionTo(gi(),(function(r){t&&La(n.router,r,e,!0),Wa||vi(r.fullPath)}))},o=Wa?"popstate":"hashchange";window.addEventListener(o,r),this.listeners.push((function(){window.removeEventListener(o,r)}))}},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){yi(n.fullPath),La(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){vi(n.fullPath),La(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;gi()!==e&&(n?yi(e):vi(e))},e.prototype.getCurrentLocation=function(){return gi()},e}(ci);function hi(){var n=gi();return"/"===n.charAt(0)||(vi("/"+n),!1)}function gi(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function bi(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function yi(n){Wa?Va(bi(n)):window.location.hash=n}function vi(n){Wa?Ka(bi(n)):window.location.replace(bi(n))}var xi=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){ri(n,Ya.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(ci),wi=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=za(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Wa&&!1!==n.fallback,this.fallback&&(e="hash"),Aa||(e="abstract"),this.mode=e,e){case"history":this.history=new pi(this,n.base);break;case"hash":this.history=new fi(this,n.base,this.fallback);break;case"abstract":this.history=new xi(this,n.base);break;default:0}},ki={currentRoute:{configurable:!0}};function Si(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}wi.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},ki.currentRoute.get=function(){return this.history&&this.history.current},wi.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof pi||t instanceof fi){var r=function(n){t.setupListeners(),function(n){var r=t.current,o=e.options.scrollBehavior;Wa&&o&&"fullPath"in n&&La(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},wi.prototype.beforeEach=function(n){return Si(this.beforeHooks,n)},wi.prototype.beforeResolve=function(n){return Si(this.resolveHooks,n)},wi.prototype.afterEach=function(n){return Si(this.afterHooks,n)},wi.prototype.onReady=function(n,e){this.history.onReady(n,e)},wi.prototype.onError=function(n){this.history.onError(n)},wi.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},wi.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},wi.prototype.go=function(n){this.history.go(n)},wi.prototype.back=function(){this.go(-1)},wi.prototype.forward=function(){this.go(1)},wi.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},wi.prototype.resolve=function(n,e,t){var r=wa(n,e=e||this.history.current,t,this),o=this.match(r,e),a=o.redirectedFrom||o.fullPath;return{location:r,route:o,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?ta(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:o}},wi.prototype.getRoutes=function(){return this.matcher.getRoutes()},wi.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Wo&&this.history.transitionTo(this.history.getCurrentLocation())},wi.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Wo&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(wi.prototype,ki),wi.install=function n(e){if(!n.installed||ka!==e){n.installed=!0,ka=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Qo),e.component("RouterLink",ja);var o=e.config.optionMergeStrategies;o.beforeRouteEnter=o.beforeRouteLeave=o.beforeRouteUpdate=o.created}},wi.version="3.5.3",wi.isNavigationFailure=ri,wi.NavigationFailureType=Ya,wi.START_LOCATION=Wo,Aa&&window.Vue&&window.Vue.use(wi);var ji=wi;t(177),t(178),t(255),t(75),t(179),t(28),t(29),t(257);function Ei(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(70),t(92),t(126);function Ai(n){return(Ai="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}var Ii=t(72),Ti=(t(189),t(17),t(45),t(231),t(232),t(40),t(30),{NotFound:function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,484))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,483))}}),zi={"v-1df4d616":function(){return t.e(6).then(t.bind(null,485))},"v-10284f70":function(){return t.e(7).then(t.bind(null,486))},"v-27875be3":function(){return t.e(9).then(t.bind(null,487))},"v-326b4e84":function(){return t.e(10).then(t.bind(null,488))},"v-223d701a":function(){return t.e(11).then(t.bind(null,489))},"v-7d49cd87":function(){return t.e(12).then(t.bind(null,490))},"v-130f5d29":function(){return t.e(13).then(t.bind(null,491))},"v-17af0f12":function(){return t.e(14).then(t.bind(null,492))},"v-5621ad6f":function(){return t.e(15).then(t.bind(null,493))},"v-120fd95f":function(){return t.e(16).then(t.bind(null,494))},"v-3ef46c3e":function(){return t.e(8).then(t.bind(null,495))},"v-20167b32":function(){return t.e(17).then(t.bind(null,496))},"v-061159fa":function(){return t.e(18).then(t.bind(null,497))},"v-2b0b1b3e":function(){return t.e(19).then(t.bind(null,498))},"v-2b72ba50":function(){return t.e(20).then(t.bind(null,499))},"v-d22b1d0e":function(){return t.e(21).then(t.bind(null,500))},"v-30695d13":function(){return t.e(22).then(t.bind(null,501))},"v-27133cbb":function(){return t.e(23).then(t.bind(null,502))},"v-2203d9c2":function(){return t.e(24).then(t.bind(null,503))},"v-2bdfec00":function(){return t.e(25).then(t.bind(null,504))},"v-f7677c3c":function(){return t.e(26).then(t.bind(null,505))},"v-83400752":function(){return t.e(28).then(t.bind(null,506))},"v-6c08538d":function(){return t.e(27).then(t.bind(null,507))},"v-4c61c5bc":function(){return t.e(29).then(t.bind(null,508))},"v-3f5b59cf":function(){return t.e(30).then(t.bind(null,509))},"v-a5a12a48":function(){return t.e(31).then(t.bind(null,510))},"v-58f14e65":function(){return t.e(33).then(t.bind(null,511))},"v-35bfa9e0":function(){return t.e(34).then(t.bind(null,512))},"v-363cf0bc":function(){return t.e(35).then(t.bind(null,513))},"v-6756bb32":function(){return t.e(36).then(t.bind(null,514))},"v-6e63d81a":function(){return t.e(37).then(t.bind(null,515))},"v-2fe45ff3":function(){return t.e(38).then(t.bind(null,516))},"v-350792bc":function(){return t.e(39).then(t.bind(null,517))},"v-3913f24b":function(){return t.e(40).then(t.bind(null,518))},"v-fa3822fc":function(){return t.e(32).then(t.bind(null,519))},"v-614b0a72":function(){return t.e(41).then(t.bind(null,520))},"v-36fb0f35":function(){return t.e(42).then(t.bind(null,521))},"v-47148396":function(){return t.e(43).then(t.bind(null,522))},"v-38b5a542":function(){return t.e(44).then(t.bind(null,523))},"v-a5b0f788":function(){return t.e(45).then(t.bind(null,524))},"v-5746bea6":function(){return t.e(46).then(t.bind(null,525))},"v-0e65177a":function(){return t.e(47).then(t.bind(null,526))},"v-936eed32":function(){return t.e(48).then(t.bind(null,527))},"v-0944f7ee":function(){return t.e(49).then(t.bind(null,528))},"v-638f70fb":function(){return t.e(50).then(t.bind(null,529))},"v-6d7302f2":function(){return t.e(51).then(t.bind(null,530))},"v-1de1c18a":function(){return t.e(53).then(t.bind(null,531))},"v-f465e8f0":function(){return t.e(54).then(t.bind(null,532))},"v-1a36efce":function(){return t.e(55).then(t.bind(null,533))},"v-1426c78e":function(){return Promise.all([t.e(0),t.e(5)]).then(t.bind(null,534))},"v-8b61ee12":function(){return t.e(56).then(t.bind(null,535))},"v-01eb52f2":function(){return t.e(57).then(t.bind(null,536))},"v-0832524d":function(){return t.e(58).then(t.bind(null,537))},"v-3e241928":function(){return t.e(52).then(t.bind(null,538))},"v-85694126":function(){return t.e(59).then(t.bind(null,539))},"v-7db0be6d":function(){return t.e(61).then(t.bind(null,540))},"v-0033648a":function(){return t.e(60).then(t.bind(null,541))},"v-315c4010":function(){return t.e(62).then(t.bind(null,542))},"v-50864176":function(){return t.e(64).then(t.bind(null,543))},"v-520c0bed":function(){return t.e(63).then(t.bind(null,544))},"v-7284126c":function(){return t.e(66).then(t.bind(null,545))},"v-462b4ed7":function(){return t.e(65).then(t.bind(null,546))},"v-64279124":function(){return t.e(67).then(t.bind(null,547))},"v-10cc5422":function(){return t.e(68).then(t.bind(null,548))},"v-61d376a8":function(){return t.e(69).then(t.bind(null,549))},"v-529de428":function(){return t.e(70).then(t.bind(null,550))},"v-69bafd4e":function(){return t.e(72).then(t.bind(null,551))},"v-485c8077":function(){return t.e(71).then(t.bind(null,552))},"v-25458d2a":function(){return t.e(73).then(t.bind(null,553))},"v-dc7c1222":function(){return t.e(74).then(t.bind(null,554))},"v-69d48d6a":function(){return t.e(75).then(t.bind(null,555))},"v-252683df":function(){return t.e(76).then(t.bind(null,556))},"v-e8a298c2":function(){return t.e(77).then(t.bind(null,557))},"v-dbcc7c0e":function(){return t.e(79).then(t.bind(null,558))},"v-2dd7091f":function(){return t.e(80).then(t.bind(null,559))},"v-67e77451":function(){return t.e(81).then(t.bind(null,560))},"v-18cea7e8":function(){return t.e(82).then(t.bind(null,561))},"v-fdf3da36":function(){return t.e(83).then(t.bind(null,562))},"v-52f3ee7a":function(){return t.e(84).then(t.bind(null,563))},"v-6e96fc20":function(){return t.e(85).then(t.bind(null,564))},"v-3cfa8772":function(){return t.e(86).then(t.bind(null,565))},"v-2a641a1f":function(){return t.e(78).then(t.bind(null,566))},"v-abf399c4":function(){return t.e(87).then(t.bind(null,567))},"v-dc40f1c0":function(){return t.e(88).then(t.bind(null,568))},"v-10ef9d52":function(){return t.e(89).then(t.bind(null,569))},"v-3b86a05e":function(){return t.e(90).then(t.bind(null,570))},"v-5176e105":function(){return t.e(91).then(t.bind(null,571))},"v-75e41c65":function(){return t.e(92).then(t.bind(null,572))},"v-3249c685":function(){return t.e(93).then(t.bind(null,573))},"v-ec84fed2":function(){return t.e(94).then(t.bind(null,574))},"v-2100b3d2":function(){return t.e(95).then(t.bind(null,575))},"v-2b7111c4":function(){return t.e(96).then(t.bind(null,576))},"v-7b48c50c":function(){return t.e(97).then(t.bind(null,577))},"v-399fd293":function(){return t.e(98).then(t.bind(null,578))},"v-346f208f":function(){return t.e(99).then(t.bind(null,579))},"v-4d3a6db4":function(){return t.e(101).then(t.bind(null,580))},"v-05ba6584":function(){return t.e(102).then(t.bind(null,581))},"v-e165eb18":function(){return t.e(103).then(t.bind(null,582))},"v-d6f05d32":function(){return t.e(104).then(t.bind(null,583))},"v-1f0d05a1":function(){return t.e(105).then(t.bind(null,584))},"v-c1496618":function(){return t.e(106).then(t.bind(null,585))},"v-2b833066":function(){return t.e(107).then(t.bind(null,586))},"v-0a300e27":function(){return t.e(100).then(t.bind(null,587))},"v-1f5f8d8a":function(){return t.e(108).then(t.bind(null,588))},"v-2ec63a50":function(){return t.e(109).then(t.bind(null,589))},"v-7055771a":function(){return t.e(110).then(t.bind(null,590))},"v-20b8f620":function(){return t.e(114).then(t.bind(null,591))},"v-1bbe4ea2":function(){return t.e(115).then(t.bind(null,592))},"v-f6e3cecc":function(){return t.e(111).then(t.bind(null,593))},"v-4685ff34":function(){return t.e(116).then(t.bind(null,594))},"v-44d2c0fc":function(){return t.e(118).then(t.bind(null,595))},"v-73e6fcbe":function(){return t.e(117).then(t.bind(null,596))},"v-ad45f6fa":function(){return t.e(119).then(t.bind(null,597))},"v-25827231":function(){return t.e(120).then(t.bind(null,598))},"v-092c0610":function(){return t.e(121).then(t.bind(null,599))},"v-31cb3fe6":function(){return t.e(123).then(t.bind(null,600))},"v-6145bf5a":function(){return t.e(124).then(t.bind(null,601))},"v-733dba34":function(){return t.e(125).then(t.bind(null,602))},"v-3b44ff9b":function(){return t.e(126).then(t.bind(null,603))},"v-4248c6f3":function(){return t.e(122).then(t.bind(null,604))},"v-0bfabf3c":function(){return t.e(127).then(t.bind(null,605))},"v-8b56fb8c":function(){return t.e(128).then(t.bind(null,606))},"v-07dc7dde":function(){return t.e(129).then(t.bind(null,607))},"v-21627c86":function(){return t.e(130).then(t.bind(null,608))},"v-16bacf9d":function(){return t.e(131).then(t.bind(null,609))},"v-720d8224":function(){return t.e(133).then(t.bind(null,610))},"v-52f1734b":function(){return t.e(132).then(t.bind(null,611))},"v-449301a8":function(){return t.e(134).then(t.bind(null,612))},"v-364e812a":function(){return t.e(135).then(t.bind(null,613))},"v-0dd61c07":function(){return t.e(136).then(t.bind(null,614))},"v-59177494":function(){return t.e(138).then(t.bind(null,615))},"v-7c3437ac":function(){return t.e(139).then(t.bind(null,616))},"v-60ad1438":function(){return t.e(140).then(t.bind(null,617))},"v-42d161dc":function(){return t.e(141).then(t.bind(null,618))},"v-92c363a2":function(){return t.e(137).then(t.bind(null,619))},"v-1d730a99":function(){return t.e(142).then(t.bind(null,620))},"v-34d42a50":function(){return t.e(144).then(t.bind(null,621))},"v-546fd54a":function(){return t.e(143).then(t.bind(null,622))},"v-03537083":function(){return t.e(145).then(t.bind(null,623))},"v-51ad7edb":function(){return t.e(112).then(t.bind(null,624))},"v-584aa1ec":function(){return t.e(113).then(t.bind(null,625))}};function _i(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var Ci=/-(\w)/g,Pi=_i((function(n){return n.replace(Ci,(function(n,e){return e?e.toUpperCase():""}))})),Oi=/\B([A-Z])/g,Mi=_i((function(n){return n.replace(Oi,"-$1").toLowerCase()})),Di=_i((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function Ri(n,e){if(e)return n(e)?n(e):e.includes("-")?n(Di(Pi(e))):n(Di(e))||n(Mi(e))}var Bi=Object.assign({},Ti,zi),Li=function(n){return Bi[n]},Ni=function(n){return zi[n]},Fi=function(n){return Ti[n]},qi=function(n){return Mo.component(n)};function $i(n){return Ri(Ni,n)}function Gi(n){return Ri(Fi,n)}function Ui(n){return Ri(Li,n)}function Hi(n){return Ri(qi,n)}function Ji(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(r.a)(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(Hi(e)||!Ui(e)){n.next=5;break}return n.next=3,Ui(e)();case 3:t=n.sent,Mo.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function Wi(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var Vi=t(138),Ki=(t(190),t(110),t(53),t(219)),Zi=t.n(Ki),Yi=t(220),Xi=t.n(Yi),Qi={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(Vi.a)(n,1)[0]})).map((function(n){var e=Object(Vi.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(Xi()(n[t]),'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=es(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(Ii.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=ts(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Zi()([{name:"description",content:this.$description}],n,this.siteMeta,rs)},updateCanonicalLink:function(){ns(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",es(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){ts(null,this.currentMetaTags),ns()}};function ns(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function es(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function ts(n,e){if(e&&Object(Ii.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function rs(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var r=t[e];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}t(139);var os=t(152),as={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(os)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),o=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+r,i=0;i<t.length;i++){var s=t[i],l=t[i+1],c=0===i&&0===r||r>=s.parentElement.offsetTop+10&&(!l||r<l.parentElement.offsetTop-10),u=decodeURIComponent(this.$route.hash);if(c&&u!==decodeURIComponent(s.hash)){var d=s;if(a===o)for(var p=i+1;p<t.length;p++)if(u===decodeURIComponent(t[p].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(d.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},is=(t(78),t(101)),ss=t.n(is),ls={mounted:function(){var n=this;ss.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||Mo.component(n.name)||ss.a.start(),t()})),this.$router.afterEach((function(){ss.a.done(),n.isSidebarOpen=!1}))}};t(74),t(54),t(77),t(364);function cs(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(99);function us(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function ds(n,e,t){return e&&us(n.prototype,e),t&&us(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}t(365);var ps=function(){function n(){cs(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return ds(n,[{key:"show",value:function(n){var e=this,t=n.text,r=void 0===t?"":t,o=n.duration,a=void 0===o?3e3:o,i=document.createElement("div");i.className="message move-in",i.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(r,"</div>\n    "),this.containerEl.appendChild(i),a>0&&setTimeout((function(){e.close(i)}),a)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),ms={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(e){document.querySelectorAll(e).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var e=this;if(!n.classList.contains("codecopy-enabled")){var t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Copy to clipboard",t.addEventListener("click",(function(){e.copyToClipboard(n.innerText)})),n.appendChild(t),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),(new ps).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};t(234),t(104),t(103),t(140),t(367);!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],o=document.createElement("style");o.type="text/css","top"===t&&r.firstChild?r.insertBefore(o,r.firstChild):r.appendChild(o),o.styleSheet?o.styleSheet.cssText=n:o.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var fs={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},hs={},gs=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},bs=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:fs[n]},ys=function n(e,t,r){var o=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))o[n]=t[n];else{var e=n.replace("data","");o.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,a=e.children;o.appendChild(n(t,r,a))})),o},vs=function(n,e,t){var r,o=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==o.length||t?o:o[0]},xs=function(n,e){var t,r,o=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),i=n.match(/<script>([\s\S]+)<\/script>/),s={css:o&&o[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=gs(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),o=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,a=[eval][0](o);return a.template=e,a}(s.js,s.html);var l=bs("vue");return s.jsLib.unshift(l),s},ws=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),i={css:r&&r[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return i.htmlTpl=i.html,i.jsTpl=i.js,i.script=(t=i.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),i},ks=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Ss(){var n=vs(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=vs(n,"vuepress-plugin-demo-block__code"),t=vs(n,"vuepress-plugin-demo-block__display"),r=vs(n,"vuepress-plugin-demo-block__footer"),o=vs(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),i=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);i=i?JSON.parse(i):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),o=new Function("return ".concat(r))(),a={js:o,css:o.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:ks(n),htmlTpl:gs("")},i=bs("react"),s=bs("reactDOM");return a.jsLib.unshift(i,s),a}(a,i):"vanilla"===s?ws(a,i):xs(a,i),u=ys("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(u),u.addEventListener("click",js.bind(null,u,l,e,r)),bs("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,o=n.jsLib,a=n.cssLib,i=o.concat(a).concat(bs("cssLib")).concat(bs("jsLib")).join(",");return ys("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:i}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),bs("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,o=n.jsLib,a=n.cssLib,i=JSON.stringify({css:e,html:t,js:r,js_external:o.concat(bs("jsLib")).join(";"),css_external:a.concat(bs("cssLib")).join(";"),layout:bs("codepenLayout"),js_pre_processor:bs("codepenJsProcessor"),editors:bs("codepenEditors")});return ys("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:i}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==i.horizontal?i.horizontal:bs("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var d=e.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(c.css&&function(n){if(!hs[n]){var e=ys("style",{innerHTML:n});document.body.appendChild(e),hs[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),o);else if("vue"===s){var p=(new(Vue.extend(c.script))).$mount();o.appendChild(p.$el)}else"vanilla"===s&&(o.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Ss()}),300)}function js(n,e,t,r){var o="1"!==n.dataset.isExpand;t.style.height=o?"".concat(e,"px"):0,o?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=o?"1":"0"}var Es={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Ss()},updated:function(){Ss()}},As=(t(224),"auto"),Is="zoom-in",Ts="zoom-out",zs="grab",_s="move";function Cs(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o={passive:!1};r?n.addEventListener(e,t,o):n.removeEventListener(e,t,o)}function Ps(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Os(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ms(n,e,t){!function(n){var e=Ds,t=Rs;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var o=n.transform;delete n.transform,n[t]=o}}(e);var r=n.style,o={};for(var a in e)t&&(o[a]=r[a]||""),r[a]=e[a];return o}var Ds="transition",Rs="transform",Bs="transform",Ls="transitionend";var Ns=function(){},Fs={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Ns,onClose:Ns,onGrab:Ns,onMove:Ns,onRelease:Ns,onBeforeOpen:Ns,onBeforeClose:Ns,onBeforeGrab:Ns,onBeforeRelease:Ns,onImageLoading:Ns,onImageLoaded:Ns},qs={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Gs(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,o=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(o)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if($s(n)&&!Gs(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){$s(n)&&!Gs(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function $s(n){return 0===n.button}function Gs(n){return n.metaKey||n.ctrlKey}var Us={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ms(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Cs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ms(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Hs="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Js=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),Ws=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},Vs={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Os(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,o=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?zs:Ts,transition:Bs+"\n        "+r+"s\n        "+o,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ms(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ms(this.el,{transform:"none"})},grab:function(n,e,t){var r=Ks(),o=r.x-n,a=r.y-e;Ms(this.el,{cursor:_s,transform:"translate3d(\n        "+(this.translate.x+o)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=Ks(),o=r.x-n,a=r.y-e;Ms(this.el,{transition:Bs,transform:"translate3d(\n        "+(this.translate.x+o)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ms(this.el,this.styleClose)},restoreOpenStyle:function(){Ms(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Ks(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,o=r.customSize,a=r.scaleBase;if(!o&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(o&&"object"===(void 0===o?"undefined":Hs(o)))return{x:o.width/this.rect.width,y:o.height/this.rect.height};var i=this.rect.width/2,s=this.rect.height/2,l=Ks(),c={x:l.x-i,y:l.y-s},u=c.x/i,d=c.y/s,p=a+Math.min(u,d);if(o&&"string"==typeof o){var m=t||this.el.naturalWidth,f=e||this.el.naturalHeight,h=parseFloat(o)*m/(100*this.rect.width),g=parseFloat(o)*f/(100*this.rect.height);if(p>h||p>g)return{x:h,y:g}}return{x:p,y:p}}};function Ks(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Zs(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Cs(n,r,e[r],t)}))}var Ys=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Vs),this.overlay=Object.create(Us),this.handler=Object.create(qs),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Ws({},Fs,e),this.overlay.init(this),this.handler.init(this)}return Js(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Is,Cs(n,"click",this.handler.click),this.options.preloadImage&&Ps(Os(n)));return this}},{key:"config",value:function(n){return n?(Ws(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var o=this.target.srcOriginal;null!=o&&(this.options.onImageLoading(r),Ps(o,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Cs(document,"scroll",this.handler.scroll),Cs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Cs(window,"resize",this.handler.resizeWindow);var a=function n(){Cs(r,Ls,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Zs(document,e.handler,!0),t(r)};return Cs(r,Ls,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=As,this.overlay.fadeOut(),this.target.zoomOut(),Cs(document,"scroll",this.handler.scroll,!1),Cs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Cs(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Cs(t,Ls,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Zs(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Cs(t,Ls,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var o=this.target.el;this.options.onBeforeGrab(o),this.released=!1,this.target.grab(n,e,t);var a=function n(){Cs(o,Ls,n,!1),r(o)};return Cs(o,Ls,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=_s,this.target.move(n,e,t);var o=this.target.el,a=function n(){Cs(o,Ls,n,!1),r(o)};return Cs(o,Ls,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=As,this.target.restoreOpenStyle();var r=function r(){Cs(t,Ls,r,!1),n.lock=!1,n.released=!0,e(t)};return Cs(t,Ls,r),this}}}]),n}(),Xs=".theme-vdoing-content img:not(.no-zoom)",Qs=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),nl=Number("500"),el=function(){function n(){cs(this,n),this.instance=new Ys(Qs)}return ds(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Xs;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Xs,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:nl;setTimeout((function(){return n.update(e)}),t)}}]),n}(),tl=[Qi,as,ls,ms,Es,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new el,this.$vuepress.zooming.updateDelay()}}],rl={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Wi("layout",n),Mo.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},ol=t(20),al=Object(ol.a)(rl,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var r;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(r=n[e]).push.apply(r,Object(Ii.a)(t));break;default:throw new Error("Unknown option name.")}}(al,"mixins",tl);var il=[{name:"v-1df4d616",path:"/interview/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-1df4d616").then(t)}},{path:"/interview/index.html",redirect:"/interview/"},{path:"/00.目录页/50.面试.html",redirect:"/interview/"},{name:"v-10284f70",path:"/pages/8a3d2e/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-10284f70").then(t)}},{path:"/pages/8a3d2e/index.html",redirect:"/pages/8a3d2e/"},{path:"/05.Java/05.Java基础/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/8a3d2e/"},{name:"v-27875be3",path:"/pages/14d613/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-27875be3").then(t)}},{path:"/pages/14d613/index.html",redirect:"/pages/14d613/"},{path:"/05.Java/15.Java虚拟机/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/14d613/"},{name:"v-326b4e84",path:"/pages/101235/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-326b4e84").then(t)}},{path:"/pages/101235/index.html",redirect:"/pages/101235/"},{path:"/05.Java/20.JDK新特性/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/101235/"},{name:"v-223d701a",path:"/pages/b9843d/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-223d701a").then(t)}},{path:"/pages/b9843d/index.html",redirect:"/pages/b9843d/"},{path:"/05.Java/25.Java Web/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/b9843d/"},{name:"v-7d49cd87",path:"/pages/48f257/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-7d49cd87").then(t)}},{path:"/pages/48f257/index.html",redirect:"/pages/48f257/"},{path:"/05.Java/30.数据结构和算法/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/48f257/"},{name:"v-130f5d29",path:"/pages/f9d65e/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-130f5d29").then(t)}},{path:"/pages/f9d65e/index.html",redirect:"/pages/f9d65e/"},{path:"/05.Java/35.计算机网络/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/f9d65e/"},{name:"v-17af0f12",path:"/pages/d4d364/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-17af0f12").then(t)}},{path:"/pages/d4d364/index.html",redirect:"/pages/d4d364/"},{path:"/10.框架/05.Spring/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/d4d364/"},{name:"v-5621ad6f",path:"/pages/72f279/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-5621ad6f").then(t)}},{path:"/pages/72f279/index.html",redirect:"/pages/72f279/"},{path:"/10.框架/10.Spring MVC/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/72f279/"},{name:"v-120fd95f",path:"/pages/815499/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-120fd95f").then(t)}},{path:"/pages/815499/index.html",redirect:"/pages/815499/"},{path:"/10.框架/15.Spring Boot/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/815499/"},{name:"v-3ef46c3e",path:"/pages/616956/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-3ef46c3e").then(t)}},{path:"/pages/616956/index.html",redirect:"/pages/616956/"},{path:"/05.Java/10.Java并发/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/616956/"},{name:"v-20167b32",path:"/pages/82b6d4/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-20167b32").then(t)}},{path:"/pages/82b6d4/index.html",redirect:"/pages/82b6d4/"},{path:"/10.框架/20.Spring Cloud/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/82b6d4/"},{name:"v-061159fa",path:"/pages/075df8/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-061159fa").then(t)}},{path:"/pages/075df8/index.html",redirect:"/pages/075df8/"},{path:"/10.框架/21.Spring Cloud Alibaba/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/075df8/"},{name:"v-2b0b1b3e",path:"/pages/c55839/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-2b0b1b3e").then(t)}},{path:"/pages/c55839/index.html",redirect:"/pages/c55839/"},{path:"/10.框架/25.Spring Security/01.【老徐】Spring Security(一) —— Architecture Overview.html",redirect:"/pages/c55839/"},{name:"v-2b72ba50",path:"/pages/188a19/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-2b72ba50").then(t)}},{path:"/pages/188a19/index.html",redirect:"/pages/188a19/"},{path:"/10.框架/25.Spring Security/02.【老徐】Spring Security(二) —— Guides.html",redirect:"/pages/188a19/"},{name:"v-d22b1d0e",path:"/pages/9327fd/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-d22b1d0e").then(t)}},{path:"/pages/9327fd/index.html",redirect:"/pages/9327fd/"},{path:"/10.框架/25.Spring Security/03.【老徐】Spring Security(三) —— 核心配置解读.html",redirect:"/pages/9327fd/"},{name:"v-30695d13",path:"/pages/bb2ce5/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-30695d13").then(t)}},{path:"/pages/bb2ce5/index.html",redirect:"/pages/bb2ce5/"},{path:"/10.框架/25.Spring Security/04.【老徐】Spring Security(四) —— 核心过滤器源码分析.html",redirect:"/pages/bb2ce5/"},{name:"v-27133cbb",path:"/pages/754b42/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-27133cbb").then(t)}},{path:"/pages/754b42/index.html",redirect:"/pages/754b42/"},{path:"/10.框架/25.Spring Security/05.【老徐】Spring Security(五) —— 动手实现一个 IP_Login.html",redirect:"/pages/754b42/"},{name:"v-2203d9c2",path:"/pages/79202c/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-2203d9c2").then(t)}},{path:"/pages/79202c/index.html",redirect:"/pages/79202c/"},{path:"/10.框架/25.Spring Security/06.【老徐】从零开始的 Spring Security OAuth2（一）.html",redirect:"/pages/79202c/"},{name:"v-2bdfec00",path:"/pages/3e6453/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-2bdfec00").then(t)}},{path:"/pages/3e6453/index.html",redirect:"/pages/3e6453/"},{path:"/10.框架/25.Spring Security/07.【老徐】从零开始的 Spring Security OAuth2（二）.html",redirect:"/pages/3e6453/"},{name:"v-f7677c3c",path:"/pages/202614/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-f7677c3c").then(t)}},{path:"/pages/202614/index.html",redirect:"/pages/202614/"},{path:"/10.框架/25.Spring Security/08.【老徐】从零开始的 Spring Security OAuth2（三）.html",redirect:"/pages/202614/"},{name:"v-83400752",path:"/pages/605664/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-83400752").then(t)}},{path:"/pages/605664/index.html",redirect:"/pages/605664/"},{path:"/10.框架/25.Spring Security/10.Spring Security 入门篇.html",redirect:"/pages/605664/"},{name:"v-6c08538d",path:"/pages/9be0a1/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-6c08538d").then(t)}},{path:"/pages/9be0a1/index.html",redirect:"/pages/9be0a1/"},{path:"/10.框架/25.Spring Security/09.【老徐】该如何设计你的 PasswordEncoder.html",redirect:"/pages/9be0a1/"},{name:"v-4c61c5bc",path:"/pages/d07b16/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-4c61c5bc").then(t)}},{path:"/pages/d07b16/index.html",redirect:"/pages/d07b16/"},{path:"/10.框架/30.Mybatis/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/d07b16/"},{name:"v-3f5b59cf",path:"/pages/d35a9e/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-3f5b59cf").then(t)}},{path:"/pages/d35a9e/index.html",redirect:"/pages/d35a9e/"},{path:"/10.框架/35.Mybatis Plus/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/d35a9e/"},{name:"v-a5a12a48",path:"/pages/b8166d/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-a5a12a48").then(t)}},{path:"/pages/b8166d/index.html",redirect:"/pages/b8166d/"},{path:"/10.框架/40.Redis/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/b8166d/"},{name:"v-58f14e65",path:"/pages/ee8f7b/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-58f14e65").then(t)}},{path:"/pages/ee8f7b/index.html",redirect:"/pages/ee8f7b/"},{path:"/10.框架/45.Mysql/05.SQL/05.EXISTS（NOT EXISTS ） 语句.html",redirect:"/pages/ee8f7b/"},{name:"v-35bfa9e0",path:"/pages/bc1a45/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-35bfa9e0").then(t)}},{path:"/pages/bc1a45/index.html",redirect:"/pages/bc1a45/"},{path:"/10.框架/50.Zookeeper/10.实例详解ZooKeeper ZAB协议、分布式锁与领导选举.html",redirect:"/pages/bc1a45/"},{name:"v-363cf0bc",path:"/pages/017da3/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-363cf0bc").then(t)}},{path:"/pages/017da3/index.html",redirect:"/pages/017da3/"},{path:"/10.框架/55.Dubbo/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/017da3/"},{name:"v-6756bb32",path:"/pages/e5e3af/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-6756bb32").then(t)}},{path:"/pages/e5e3af/index.html",redirect:"/pages/e5e3af/"},{path:"/10.框架/60.Kafka/01.Kafka单机版安装.html",redirect:"/pages/e5e3af/"},{name:"v-6e63d81a",path:"/pages/bc987c/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-6e63d81a").then(t)}},{path:"/pages/bc987c/index.html",redirect:"/pages/bc987c/"},{path:"/10.框架/60.Kafka/10.kafka命令整理.html",redirect:"/pages/bc987c/"},{name:"v-2fe45ff3",path:"/pages/4975ea/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-2fe45ff3").then(t)}},{path:"/pages/4975ea/index.html",redirect:"/pages/4975ea/"},{path:"/10.框架/60.Kafka/20.kafka客户端示例代码.html",redirect:"/pages/4975ea/"},{name:"v-350792bc",path:"/pages/fb3719/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-350792bc").then(t)}},{path:"/pages/fb3719/index.html",redirect:"/pages/fb3719/"},{path:"/10.框架/65.Apollo/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/fb3719/"},{name:"v-3913f24b",path:"/pages/7f0c55/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-3913f24b").then(t)}},{path:"/pages/7f0c55/index.html",redirect:"/pages/7f0c55/"},{path:"/10.框架/70.大数据/05.Hbase/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/7f0c55/"},{name:"v-fa3822fc",path:"/pages/d09904/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-fa3822fc").then(t)}},{path:"/pages/d09904/index.html",redirect:"/pages/d09904/"},{path:"/10.框架/40.Redis/20.布隆过滤器.html",redirect:"/pages/d09904/"},{name:"v-614b0a72",path:"/pages/466af9/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-614b0a72").then(t)}},{path:"/pages/466af9/index.html",redirect:"/pages/466af9/"},{path:"/10.框架/70.大数据/10.Spark/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/466af9/"},{name:"v-36fb0f35",path:"/pages/d96f04/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-36fb0f35").then(t)}},{path:"/pages/d96f04/index.html",redirect:"/pages/d96f04/"},{path:"/10.框架/70.大数据/15.ClickHouse/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/d96f04/"},{name:"v-47148396",path:"/pages/9a7ee40fc232253e/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-47148396").then(t)}},{path:"/pages/9a7ee40fc232253e/index.html",redirect:"/pages/9a7ee40fc232253e/"},{path:"/100.其他/01.技术文档/01.Git使用手册.html",redirect:"/pages/9a7ee40fc232253e/"},{name:"v-38b5a542",path:"/pages/ad247c4332211551/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-38b5a542").then(t)}},{path:"/pages/ad247c4332211551/index.html",redirect:"/pages/ad247c4332211551/"},{path:"/100.其他/01.技术文档/02.Markdown使用教程.html",redirect:"/pages/ad247c4332211551/"},{name:"v-a5b0f788",path:"/pages/61f2f95fd7da14fd/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-a5b0f788").then(t)}},{path:"/pages/61f2f95fd7da14fd/index.html",redirect:"/pages/61f2f95fd7da14fd/"},{path:"/100.其他/01.技术文档/03.npm常用命令.html",redirect:"/pages/61f2f95fd7da14fd/"},{name:"v-5746bea6",path:"/pages/dec4f3f00e71a312/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-5746bea6").then(t)}},{path:"/pages/dec4f3f00e71a312/index.html",redirect:"/pages/dec4f3f00e71a312/"},{path:"/100.其他/01.技术文档/10.npm packageJson属性详解.html",redirect:"/pages/dec4f3f00e71a312/"},{name:"v-0e65177a",path:"/pages/4e8444e2d534d14f/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-0e65177a").then(t)}},{path:"/pages/4e8444e2d534d14f/index.html",redirect:"/pages/4e8444e2d534d14f/"},{path:"/100.其他/01.技术文档/15.yaml语言教程.html",redirect:"/pages/4e8444e2d534d14f/"},{name:"v-936eed32",path:"/pages/4c778760be26d8b3/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-936eed32").then(t)}},{path:"/pages/4c778760be26d8b3/index.html",redirect:"/pages/4c778760be26d8b3/"},{path:"/100.其他/02.GitHub技巧/01.GitHub高级搜索技巧.html",redirect:"/pages/4c778760be26d8b3/"},{name:"v-0944f7ee",path:"/pages/6b9d359ec5aa5019/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-0944f7ee").then(t)}},{path:"/pages/6b9d359ec5aa5019/index.html",redirect:"/pages/6b9d359ec5aa5019/"},{path:"/100.其他/02.GitHub技巧/02.GitHub Actions 实现自动部署静态博客.html",redirect:"/pages/6b9d359ec5aa5019/"},{name:"v-638f70fb",path:"/pages/f44d2f9ad04ab8d3/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-638f70fb").then(t)}},{path:"/pages/f44d2f9ad04ab8d3/index.html",redirect:"/pages/f44d2f9ad04ab8d3/"},{path:"/100.其他/02.GitHub技巧/03.GitHub Actions 定时运行代码：每天定时百度链接推送.html",redirect:"/pages/f44d2f9ad04ab8d3/"},{name:"v-6d7302f2",path:"/pages/95331c6a9613faf8/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-6d7302f2").then(t)}},{path:"/pages/95331c6a9613faf8/index.html",redirect:"/pages/95331c6a9613faf8/"},{path:"/100.其他/02.GitHub技巧/10.GitHub加速下载项目的方法.html",redirect:"/pages/95331c6a9613faf8/"},{name:"v-1de1c18a",path:"/pages/41f87d890d0a02af/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-1de1c18a").then(t)}},{path:"/pages/41f87d890d0a02af/index.html",redirect:"/pages/41f87d890d0a02af/"},{path:"/100.其他/04.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html",redirect:"/pages/41f87d890d0a02af/"},{name:"v-f465e8f0",path:"/pages/1da0bf9a988eafe5/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-f465e8f0").then(t)}},{path:"/pages/1da0bf9a988eafe5/index.html",redirect:"/pages/1da0bf9a988eafe5/"},{path:"/100.其他/04.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html",redirect:"/pages/1da0bf9a988eafe5/"},{name:"v-1a36efce",path:"/pages/a5f73af5185fdf0a/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-1a36efce").then(t)}},{path:"/pages/a5f73af5185fdf0a/index.html",redirect:"/pages/a5f73af5185fdf0a/"},{path:"/100.其他/04.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html",redirect:"/pages/a5f73af5185fdf0a/"},{name:"v-1426c78e",path:"/pages/d557b9a89a215d2e/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-1426c78e").then(t)}},{path:"/pages/d557b9a89a215d2e/index.html",redirect:"/pages/d557b9a89a215d2e/"},{path:"/100.其他/04.博客搭建/10.vdoing主题效果图.html",redirect:"/pages/d557b9a89a215d2e/"},{name:"v-8b61ee12",path:"/pages/f1cf70/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-8b61ee12").then(t)}},{path:"/pages/f1cf70/index.html",redirect:"/pages/f1cf70/"},{path:"/15.前端/05.HTML/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/f1cf70/"},{name:"v-01eb52f2",path:"/pages/b0cbfe/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-01eb52f2").then(t)}},{path:"/pages/b0cbfe/index.html",redirect:"/pages/b0cbfe/"},{path:"/15.前端/10.JavaScript/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/b0cbfe/"},{name:"v-0832524d",path:"/pages/1b9d03/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-0832524d").then(t)}},{path:"/pages/1b9d03/index.html",redirect:"/pages/1b9d03/"},{path:"/15.前端/15.CSS/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/1b9d03/"},{name:"v-3e241928",path:"/pages/117708e0af7f0bd9/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-3e241928").then(t)}},{path:"/pages/117708e0af7f0bd9/index.html",redirect:"/pages/117708e0af7f0bd9/"},{path:"/100.其他/03.Nodejs/01.nodejs递归读取所有文件.html",redirect:"/pages/117708e0af7f0bd9/"},{name:"v-85694126",path:"/pages/f94942/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-85694126").then(t)}},{path:"/pages/f94942/index.html",redirect:"/pages/f94942/"},{path:"/15.前端/20.ES6/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/f94942/"},{name:"v-7db0be6d",path:"/pages/3a3093/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-7db0be6d").then(t)}},{path:"/pages/3a3093/index.html",redirect:"/pages/3a3093/"},{path:"/15.前端/30.Webpack/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/3a3093/"},{name:"v-0033648a",path:"/pages/6397c2/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-0033648a").then(t)}},{path:"/pages/6397c2/index.html",redirect:"/pages/6397c2/"},{path:"/15.前端/25.Nodejs/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/6397c2/"},{name:"v-315c4010",path:"/pages/45f613/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-315c4010").then(t)}},{path:"/pages/45f613/index.html",redirect:"/pages/45f613/"},{path:"/15.前端/35.Vue/05.Vue Router/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/45f613/"},{name:"v-50864176",path:"/note/es6/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-50864176").then(t)}},{path:"/note/es6/index.html",redirect:"/note/es6/"},{path:"/15.前端/40.学习笔记/10.《ES6 教程》笔记.html",redirect:"/note/es6/"},{name:"v-520c0bed",path:"/pages/8b11e8/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-520c0bed").then(t)}},{path:"/pages/8b11e8/index.html",redirect:"/pages/8b11e8/"},{path:"/15.前端/35.Vue/10.Vuex/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/8b11e8/"},{name:"v-7284126c",path:"/pages/be47c5/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-7284126c").then(t)}},{path:"/pages/be47c5/index.html",redirect:"/pages/be47c5/"},{path:"/25.运维/05.Linux/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/be47c5/"},{name:"v-462b4ed7",path:"/pages/1cbc1f/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-462b4ed7").then(t)}},{path:"/pages/1cbc1f/index.html",redirect:"/pages/1cbc1f/"},{path:"/20.架构/05.设计模式/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/1cbc1f/"},{name:"v-64279124",path:"/pages/48ee28/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-64279124").then(t)}},{path:"/pages/48ee28/index.html",redirect:"/pages/48ee28/"},{path:"/25.运维/10.Shell脚本/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/48ee28/"},{name:"v-10cc5422",path:"/pages/c0a158/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-10cc5422").then(t)}},{path:"/pages/c0a158/index.html",redirect:"/pages/c0a158/"},{path:"/25.运维/40.Tomcat/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/c0a158/"},{name:"v-61d376a8",path:"/pages/22279f/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-61d376a8").then(t)}},{path:"/pages/22279f/index.html",redirect:"/pages/22279f/"},{path:"/25.运维/45.Nginx/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/22279f/"},{name:"v-529de428",path:"/pages/261b24/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-529de428").then(t)}},{path:"/pages/261b24/index.html",redirect:"/pages/261b24/"},{path:"/25.运维/50.Docker/01.Docker 初级篇.html",redirect:"/pages/261b24/"},{name:"v-69bafd4e",path:"/pages/a24e91/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-69bafd4e").then(t)}},{path:"/pages/a24e91/index.html",redirect:"/pages/a24e91/"},{path:"/25.运维/50.Docker/03.Docker 高级实践篇.html",redirect:"/pages/a24e91/"},{name:"v-485c8077",path:"/pages/5ca863/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-485c8077").then(t)}},{path:"/pages/5ca863/index.html",redirect:"/pages/5ca863/"},{path:"/25.运维/50.Docker/02.Docker 中级篇.html",redirect:"/pages/5ca863/"},{name:"v-25458d2a",path:"/pages/8a7664/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-25458d2a").then(t)}},{path:"/pages/8a7664/index.html",redirect:"/pages/8a7664/"},{path:"/25.运维/50.Docker/04.Docker 网络模式和容器间通信.html",redirect:"/pages/8a7664/"},{name:"v-dc7c1222",path:"/pages/457953/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-dc7c1222").then(t)}},{path:"/pages/457953/index.html",redirect:"/pages/457953/"},{path:"/25.运维/50.Docker/05.Docker 搭建 Redis Cluster 集群.html",redirect:"/pages/457953/"},{name:"v-69d48d6a",path:"/pages/1b1528/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-69d48d6a").then(t)}},{path:"/pages/1b1528/index.html",redirect:"/pages/1b1528/"},{path:"/25.运维/60.kubernetes/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/1b1528/"},{name:"v-252683df",path:"/pages/2c13c2/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-252683df").then(t)}},{path:"/pages/2c13c2/index.html",redirect:"/pages/2c13c2/"},{path:"/30.工具/05.maven/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/2c13c2/"},{name:"v-e8a298c2",path:"/pages/2ec465/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-e8a298c2").then(t)}},{path:"/pages/2ec465/index.html",redirect:"/pages/2ec465/"},{path:"/30.工具/10.svn/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/2ec465/"},{name:"v-dbcc7c0e",path:"/pages/891624/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-dbcc7c0e").then(t)}},{path:"/pages/891624/index.html",redirect:"/pages/891624/"},{path:"/30.工具/20.idea/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/891624/"},{name:"v-2dd7091f",path:"/pages/df2d8d/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-2dd7091f").then(t)}},{path:"/pages/df2d8d/index.html",redirect:"/pages/df2d8d/"},{path:"/30.工具/25.windows/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/df2d8d/"},{name:"v-67e77451",path:"/pages/bbda94/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-67e77451").then(t)}},{path:"/pages/bbda94/index.html",redirect:"/pages/bbda94/"},{path:"/35.面试/05.Java/05.Java基础/05.Java 基础.html",redirect:"/pages/bbda94/"},{name:"v-18cea7e8",path:"/pages/17acab/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-18cea7e8").then(t)}},{path:"/pages/17acab/index.html",redirect:"/pages/17acab/"},{path:"/35.面试/05.Java/05.Java基础/10.Java 容器.html",redirect:"/pages/17acab/"},{name:"v-fdf3da36",path:"/pages/5859c4/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-fdf3da36").then(t)}},{path:"/pages/5859c4/index.html",redirect:"/pages/5859c4/"},{path:"/35.面试/05.Java/05.Java基础/15.Java IO.html",redirect:"/pages/5859c4/"},{name:"v-52f3ee7a",path:"/pages/e5ea78/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-52f3ee7a").then(t)}},{path:"/pages/e5ea78/index.html",redirect:"/pages/e5ea78/"},{path:"/35.面试/05.Java/05.Java基础/30.JDK 动态代理.html",redirect:"/pages/e5ea78/"},{name:"v-6e96fc20",path:"/pages/14fc4f/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-6e96fc20").then(t)}},{path:"/pages/14fc4f/index.html",redirect:"/pages/14fc4f/"},{path:"/35.面试/10.Java Web/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/14fc4f/"},{name:"v-3cfa8772",path:"/pages/1ca50c/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-3cfa8772").then(t)}},{path:"/pages/1ca50c/index.html",redirect:"/pages/1ca50c/"},{path:"/35.面试/15.框架原理/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/1ca50c/"},{name:"v-2a641a1f",path:"/pages/657a34/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-2a641a1f").then(t)}},{path:"/pages/657a34/index.html",redirect:"/pages/657a34/"},{path:"/30.工具/15.git/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/657a34/"},{name:"v-abf399c4",path:"/pages/6678f4/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-abf399c4").then(t)}},{path:"/pages/6678f4/index.html",redirect:"/pages/6678f4/"},{path:"/35.面试/20.数据库/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/6678f4/"},{name:"v-dc40f1c0",path:"/pages/ddeaf7/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-dc40f1c0").then(t)}},{path:"/pages/ddeaf7/index.html",redirect:"/pages/ddeaf7/"},{path:"/35.面试/25.设计模式/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/ddeaf7/"},{name:"v-10ef9d52",path:"/pages/bc7c50/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-10ef9d52").then(t)}},{path:"/pages/bc7c50/index.html",redirect:"/pages/bc7c50/"},{path:"/35.面试/30.计算机基础/10.IO 模型.html",redirect:"/pages/bc7c50/"},{name:"v-3b86a05e",path:"/pages/bdd0da/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-3b86a05e").then(t)}},{path:"/pages/bdd0da/index.html",redirect:"/pages/bdd0da/"},{path:"/40.更多/10.Redis高级客户端Lettuce详解.html",redirect:"/pages/bdd0da/"},{name:"v-5176e105",path:"/archives/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-5176e105").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-75e41c65",path:"/categories/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-75e41c65").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-3249c685",path:"/tags/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-3249c685").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-ec84fed2",path:"/pages/f2e63f/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-ec84fed2").then(t)}},{path:"/pages/f2e63f/index.html",redirect:"/pages/f2e63f/"},{path:"/_posts/随笔/你知道的越多，不知道的也就越多.html",redirect:"/pages/f2e63f/"},{name:"v-2100b3d2",path:"/pages/cd8bde/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-2100b3d2").then(t)}},{path:"/pages/cd8bde/index.html",redirect:"/pages/cd8bde/"},{path:"/_posts/随笔/拥抱生活，拥抱快乐.html",redirect:"/pages/cd8bde/"},{name:"v-2b7111c4",path:"/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-2b7111c4").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-7b48c50c",path:"/pages/f344d070a1031ef7/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-7b48c50c").then(t)}},{path:"/pages/f344d070a1031ef7/index.html",redirect:"/pages/f344d070a1031ef7/"},{path:"/《ES6 教程》笔记/01.ECMAScript 6 简介.html",redirect:"/pages/f344d070a1031ef7/"},{name:"v-399fd293",path:"/pages/c1edd70a6b7c7872/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-399fd293").then(t)}},{path:"/pages/c1edd70a6b7c7872/index.html",redirect:"/pages/c1edd70a6b7c7872/"},{path:"/《ES6 教程》笔记/02.let 和 const 命令.html",redirect:"/pages/c1edd70a6b7c7872/"},{name:"v-346f208f",path:"/pages/b1ab10a62f7564da/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-346f208f").then(t)}},{path:"/pages/b1ab10a62f7564da/index.html",redirect:"/pages/b1ab10a62f7564da/"},{path:"/《ES6 教程》笔记/03.变量的解构赋值.html",redirect:"/pages/b1ab10a62f7564da/"},{name:"v-4d3a6db4",path:"/pages/a650b4a0ebfc9350/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-4d3a6db4").then(t)}},{path:"/pages/a650b4a0ebfc9350/index.html",redirect:"/pages/a650b4a0ebfc9350/"},{path:"/《ES6 教程》笔记/05.字符串的新增方法.html",redirect:"/pages/a650b4a0ebfc9350/"},{name:"v-05ba6584",path:"/pages/0473261a6ab0ee8c/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-05ba6584").then(t)}},{path:"/pages/0473261a6ab0ee8c/index.html",redirect:"/pages/0473261a6ab0ee8c/"},{path:"/《ES6 教程》笔记/06.正则的扩展.html",redirect:"/pages/0473261a6ab0ee8c/"},{name:"v-e165eb18",path:"/pages/5dfea9a0f2d1a392/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-e165eb18").then(t)}},{path:"/pages/5dfea9a0f2d1a392/index.html",redirect:"/pages/5dfea9a0f2d1a392/"},{path:"/《ES6 教程》笔记/07.数值的扩展.html",redirect:"/pages/5dfea9a0f2d1a392/"},{name:"v-d6f05d32",path:"/pages/8ed309d668b20264/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-d6f05d32").then(t)}},{path:"/pages/8ed309d668b20264/index.html",redirect:"/pages/8ed309d668b20264/"},{path:"/《ES6 教程》笔记/08.函数的扩展.html",redirect:"/pages/8ed309d668b20264/"},{name:"v-1f0d05a1",path:"/pages/e34009d60d8bc4b2/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-1f0d05a1").then(t)}},{path:"/pages/e34009d60d8bc4b2/index.html",redirect:"/pages/e34009d60d8bc4b2/"},{path:"/《ES6 教程》笔记/09.数组的扩展.html",redirect:"/pages/e34009d60d8bc4b2/"},{name:"v-c1496618",path:"/pages/b5e3e0a0ff6e9c25/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-c1496618").then(t)}},{path:"/pages/b5e3e0a0ff6e9c25/index.html",redirect:"/pages/b5e3e0a0ff6e9c25/"},{path:"/《ES6 教程》笔记/10.对象的扩展.html",redirect:"/pages/b5e3e0a0ff6e9c25/"},{name:"v-2b833066",path:"/pages/e85e68947502cf90/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-2b833066").then(t)}},{path:"/pages/e85e68947502cf90/index.html",redirect:"/pages/e85e68947502cf90/"},{path:"/《ES6 教程》笔记/11.对象的新增方法.html",redirect:"/pages/e85e68947502cf90/"},{name:"v-0a300e27",path:"/pages/ca89eca8adeba5f4/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-0a300e27").then(t)}},{path:"/pages/ca89eca8adeba5f4/index.html",redirect:"/pages/ca89eca8adeba5f4/"},{path:"/《ES6 教程》笔记/04.字符串的扩展.html",redirect:"/pages/ca89eca8adeba5f4/"},{name:"v-1f5f8d8a",path:"/pages/02c86eb2792f3262/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-1f5f8d8a").then(t)}},{path:"/pages/02c86eb2792f3262/index.html",redirect:"/pages/02c86eb2792f3262/"},{path:"/《ES6 教程》笔记/12.Symbol.html",redirect:"/pages/02c86eb2792f3262/"},{name:"v-2ec63a50",path:"/pages/0c21dae358fca16b/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-2ec63a50").then(t)}},{path:"/pages/0c21dae358fca16b/index.html",redirect:"/pages/0c21dae358fca16b/"},{path:"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html",redirect:"/pages/0c21dae358fca16b/"},{name:"v-7055771a",path:"/pages/f56ec2ab97d60483/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-7055771a").then(t)}},{path:"/pages/f56ec2ab97d60483/index.html",redirect:"/pages/f56ec2ab97d60483/"},{path:"/《ES6 教程》笔记/14.Proxy.html",redirect:"/pages/f56ec2ab97d60483/"},{name:"v-20b8f620",path:"/pages/718b48ed9ce0adce/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-20b8f620").then(t)}},{path:"/pages/718b48ed9ce0adce/index.html",redirect:"/pages/718b48ed9ce0adce/"},{path:"/《ES6 教程》笔记/18.Generator 函数的语法.html",redirect:"/pages/718b48ed9ce0adce/"},{name:"v-1bbe4ea2",path:"/pages/75af7031eb66847b/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-1bbe4ea2").then(t)}},{path:"/pages/75af7031eb66847b/index.html",redirect:"/pages/75af7031eb66847b/"},{path:"/《ES6 教程》笔记/19.Generator 函数的异步应用.html",redirect:"/pages/75af7031eb66847b/"},{name:"v-f6e3cecc",path:"/pages/74de3e45e4491e95/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-f6e3cecc").then(t)}},{path:"/pages/74de3e45e4491e95/index.html",redirect:"/pages/74de3e45e4491e95/"},{path:"/《ES6 教程》笔记/15.Reflect.html",redirect:"/pages/74de3e45e4491e95/"},{name:"v-4685ff34",path:"/pages/3777253e65bac487/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-4685ff34").then(t)}},{path:"/pages/3777253e65bac487/index.html",redirect:"/pages/3777253e65bac487/"},{path:"/《ES6 教程》笔记/20.async 函数.html",redirect:"/pages/3777253e65bac487/"},{name:"v-44d2c0fc",path:"/pages/83f8c3a0cd87dd83/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-44d2c0fc").then(t)}},{path:"/pages/83f8c3a0cd87dd83/index.html",redirect:"/pages/83f8c3a0cd87dd83/"},{path:"/《ES6 教程》笔记/22.Class 的继承.html",redirect:"/pages/83f8c3a0cd87dd83/"},{name:"v-73e6fcbe",path:"/pages/e831e1593c82bbe0/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-73e6fcbe").then(t)}},{path:"/pages/e831e1593c82bbe0/index.html",redirect:"/pages/e831e1593c82bbe0/"},{path:"/《ES6 教程》笔记/21.Class 的基本语法.html",redirect:"/pages/e831e1593c82bbe0/"},{name:"v-ad45f6fa",path:"/pages/efe2fb04eb8ac5fb/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-ad45f6fa").then(t)}},{path:"/pages/efe2fb04eb8ac5fb/index.html",redirect:"/pages/efe2fb04eb8ac5fb/"},{path:"/《ES6 教程》笔记/23.Module 的语法.html",redirect:"/pages/efe2fb04eb8ac5fb/"},{name:"v-25827231",path:"/pages/a79ca2e64ceae213/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-25827231").then(t)}},{path:"/pages/a79ca2e64ceae213/index.html",redirect:"/pages/a79ca2e64ceae213/"},{path:"/《ES6 教程》笔记/24.Module 的加载实现.html",redirect:"/pages/a79ca2e64ceae213/"},{name:"v-092c0610",path:"/pages/984bf549204bb266/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-092c0610").then(t)}},{path:"/pages/984bf549204bb266/index.html",redirect:"/pages/984bf549204bb266/"},{path:"/《ES6 教程》笔记/25.编程风格.html",redirect:"/pages/984bf549204bb266/"},{name:"v-31cb3fe6",path:"/pages/16121351be68691b/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-31cb3fe6").then(t)}},{path:"/pages/16121351be68691b/index.html",redirect:"/pages/16121351be68691b/"},{path:"/《ES6 教程》笔记/27.异步遍历器.html",redirect:"/pages/16121351be68691b/"},{name:"v-6145bf5a",path:"/pages/a2ba314746bfdbdd/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-6145bf5a").then(t)}},{path:"/pages/a2ba314746bfdbdd/index.html",redirect:"/pages/a2ba314746bfdbdd/"},{path:"/《ES6 教程》笔记/28.ArrayBuffer.html",redirect:"/pages/a2ba314746bfdbdd/"},{name:"v-733dba34",path:"/pages/7188882b8d65af1b/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-733dba34").then(t)}},{path:"/pages/7188882b8d65af1b/index.html",redirect:"/pages/7188882b8d65af1b/"},{path:"/《ES6 教程》笔记/29.最新提案.html",redirect:"/pages/7188882b8d65af1b/"},{name:"v-3b44ff9b",path:"/pages/e97bc1e5626b082c/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-3b44ff9b").then(t)}},{path:"/pages/e97bc1e5626b082c/index.html",redirect:"/pages/e97bc1e5626b082c/"},{path:"/《ES6 教程》笔记/30.装饰器.html",redirect:"/pages/e97bc1e5626b082c/"},{name:"v-4248c6f3",path:"/pages/32c35f7651d6e58e/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-4248c6f3").then(t)}},{path:"/pages/32c35f7651d6e58e/index.html",redirect:"/pages/32c35f7651d6e58e/"},{path:"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html",redirect:"/pages/32c35f7651d6e58e/"},{name:"v-0bfabf3c",path:"/pages/1cf50330655efc69/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-0bfabf3c").then(t)}},{path:"/pages/1cf50330655efc69/index.html",redirect:"/pages/1cf50330655efc69/"},{path:"/《ES6 教程》笔记/31.函数式编程.html",redirect:"/pages/1cf50330655efc69/"},{name:"v-8b56fb8c",path:"/pages/6a8e2dc558da1b39/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-8b56fb8c").then(t)}},{path:"/pages/6a8e2dc558da1b39/index.html",redirect:"/pages/6a8e2dc558da1b39/"},{path:"/《ES6 教程》笔记/32.Mixin.html",redirect:"/pages/6a8e2dc558da1b39/"},{name:"v-07dc7dde",path:"/pages/8e8f80f69b775a56/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-07dc7dde").then(t)}},{path:"/pages/8e8f80f69b775a56/index.html",redirect:"/pages/8e8f80f69b775a56/"},{path:"/《ES6 教程》笔记/33.SIMD.html",redirect:"/pages/8e8f80f69b775a56/"},{name:"v-21627c86",path:"/pages/ea6f3b870f6dab69/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-21627c86").then(t)}},{path:"/pages/ea6f3b870f6dab69/index.html",redirect:"/pages/ea6f3b870f6dab69/"},{path:"/《ES6 教程》笔记/34.参考链接.html",redirect:"/pages/ea6f3b870f6dab69/"},{name:"v-16bacf9d",path:"/pages/8292d8/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-16bacf9d").then(t)}},{path:"/pages/8292d8/index.html",redirect:"/pages/8292d8/"},{path:"/《Git》学习笔记/10.手册/00.常用Git命令清单.html",redirect:"/pages/8292d8/"},{name:"v-720d8224",path:"/pages/4cbc21/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-720d8224").then(t)}},{path:"/pages/4cbc21/index.html",redirect:"/pages/4cbc21/"},{path:"/《Git》学习笔记/10.手册/06.Git命令思维导图.html",redirect:"/pages/4cbc21/"},{name:"v-52f1734b",path:"/pages/c10281/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-52f1734b").then(t)}},{path:"/pages/c10281/index.html",redirect:"/pages/c10281/"},{path:"/《Git》学习笔记/10.手册/03.Git变基合并.html",redirect:"/pages/c10281/"},{name:"v-449301a8",path:"/pages/4bdb82/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-449301a8").then(t)}},{path:"/pages/4bdb82/index.html",redirect:"/pages/4bdb82/"},{path:"/《Git》学习笔记/10.手册/07.湖南科大计算机网络.html",redirect:"/pages/4bdb82/"},{name:"v-364e812a",path:"/pages/635088/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-364e812a").then(t)}},{path:"/pages/635088/index.html",redirect:"/pages/635088/"},{path:"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html",redirect:"/pages/635088/"},{name:"v-0dd61c07",path:"/pages/1832fe/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-0dd61c07").then(t)}},{path:"/pages/1832fe/index.html",redirect:"/pages/1832fe/"},{path:"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html",redirect:"/pages/1832fe/"},{name:"v-59177494",path:"/pages/4bef1a/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-59177494").then(t)}},{path:"/pages/4bef1a/index.html",redirect:"/pages/4bef1a/"},{path:"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html",redirect:"/pages/4bef1a/"},{name:"v-7c3437ac",path:"/pages/ea5a8c/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-7c3437ac").then(t)}},{path:"/pages/ea5a8c/index.html",redirect:"/pages/ea5a8c/"},{path:"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html",redirect:"/pages/ea5a8c/"},{name:"v-60ad1438",path:"/pages/a399b3/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-60ad1438").then(t)}},{path:"/pages/a399b3/index.html",redirect:"/pages/a399b3/"},{path:"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html",redirect:"/pages/a399b3/"},{name:"v-42d161dc",path:"/pages/49ee30/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-42d161dc").then(t)}},{path:"/pages/49ee30/index.html",redirect:"/pages/49ee30/"},{path:"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html",redirect:"/pages/49ee30/"},{name:"v-92c363a2",path:"/pages/d9e9c6/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-92c363a2").then(t)}},{path:"/pages/d9e9c6/index.html",redirect:"/pages/d9e9c6/"},{path:"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html",redirect:"/pages/d9e9c6/"},{name:"v-1d730a99",path:"/pages/574d62/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-1d730a99").then(t)}},{path:"/pages/574d62/index.html",redirect:"/pages/574d62/"},{path:"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html",redirect:"/pages/574d62/"},{name:"v-34d42a50",path:"/pages/c984d1/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-34d42a50").then(t)}},{path:"/pages/c984d1/index.html",redirect:"/pages/c984d1/"},{path:"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html",redirect:"/pages/c984d1/"},{name:"v-546fd54a",path:"/pages/3a3247/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-546fd54a").then(t)}},{path:"/pages/3a3247/index.html",redirect:"/pages/3a3247/"},{path:"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html",redirect:"/pages/3a3247/"},{name:"v-03537083",path:"/pages/76d859/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-03537083").then(t)}},{path:"/pages/76d859/index.html",redirect:"/pages/76d859/"},{path:"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html",redirect:"/pages/76d859/"},{name:"v-51ad7edb",path:"/pages/2810ae8985e9bd52/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-51ad7edb").then(t)}},{path:"/pages/2810ae8985e9bd52/index.html",redirect:"/pages/2810ae8985e9bd52/"},{path:"/《ES6 教程》笔记/16.Promise 对象.html",redirect:"/pages/2810ae8985e9bd52/"},{name:"v-584aa1ec",path:"/pages/48df907ad3570f3d/",component:al,beforeEnter:function(n,e,t){Ji("Layout","v-584aa1ec").then(t)}},{path:"/pages/48df907ad3570f3d/index.html",redirect:"/pages/48df907ad3570f3d/"},{path:"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html",redirect:"/pages/48df907ad3570f3d/"},{path:"*",component:al}],sl={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"面试",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"35.面试",imgUrl:"/img/web.png",description:"面试指南"}},title:"面试",date:"2020-03-11T21:50:53.000Z",permalink:"/interview",sidebar:!1,article:!0,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/50.%E9%9D%A2%E8%AF%95.html",relativePath:"00.目录页/50.面试.md",key:"v-1df4d616",path:"/interview/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/8a3d2e/"},regularPath:"/05.Java/05.Java%E5%9F%BA%E7%A1%80/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"05.Java/05.Java基础/10.Redis高级客户端Lettuce详解.md",key:"v-10284f70",path:"/pages/8a3d2e/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/14d613/"},regularPath:"/05.Java/15.Java%E8%99%9A%E6%8B%9F%E6%9C%BA/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"05.Java/15.Java虚拟机/10.Redis高级客户端Lettuce详解.md",key:"v-27875be3",path:"/pages/14d613/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/101235/"},regularPath:"/05.Java/20.JDK%E6%96%B0%E7%89%B9%E6%80%A7/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"05.Java/20.JDK新特性/10.Redis高级客户端Lettuce详解.md",key:"v-326b4e84",path:"/pages/101235/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/b9843d/"},regularPath:"/05.Java/25.Java%20Web/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"05.Java/25.Java Web/10.Redis高级客户端Lettuce详解.md",key:"v-223d701a",path:"/pages/b9843d/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/48f257/"},regularPath:"/05.Java/30.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"05.Java/30.数据结构和算法/10.Redis高级客户端Lettuce详解.md",key:"v-7d49cd87",path:"/pages/48f257/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/f9d65e/"},regularPath:"/05.Java/35.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"05.Java/35.计算机网络/10.Redis高级客户端Lettuce详解.md",key:"v-130f5d29",path:"/pages/f9d65e/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/d4d364/"},regularPath:"/10.%E6%A1%86%E6%9E%B6/05.Spring/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"10.框架/05.Spring/10.Redis高级客户端Lettuce详解.md",key:"v-17af0f12",path:"/pages/d4d364/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/72f279/"},regularPath:"/10.%E6%A1%86%E6%9E%B6/10.Spring%20MVC/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"10.框架/10.Spring MVC/10.Redis高级客户端Lettuce详解.md",key:"v-5621ad6f",path:"/pages/72f279/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/815499/"},regularPath:"/10.%E6%A1%86%E6%9E%B6/15.Spring%20Boot/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"10.框架/15.Spring Boot/10.Redis高级客户端Lettuce详解.md",key:"v-120fd95f",path:"/pages/815499/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/616956/"},regularPath:"/05.Java/10.Java%E5%B9%B6%E5%8F%91/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"05.Java/10.Java并发/10.Redis高级客户端Lettuce详解.md",key:"v-3ef46c3e",path:"/pages/616956/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/82b6d4/"},regularPath:"/10.%E6%A1%86%E6%9E%B6/20.Spring%20Cloud/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"10.框架/20.Spring Cloud/10.Redis高级客户端Lettuce详解.md",key:"v-20167b32",path:"/pages/82b6d4/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-04T10:02:50.000Z",permalink:"/pages/075df8/",categories:["框架","Spring Cloud Alibaba"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/21.Spring%20Cloud%20Alibaba/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"10.框架/21.Spring Cloud Alibaba/10.Redis高级客户端Lettuce详解.md",key:"v-061159fa",path:"/pages/075df8/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"【老徐】Spring Security(一) —— Architecture Overview",frontmatter:{title:"【老徐】Spring Security(一) —— Architecture Overview",date:"2022-02-03T00:03:27.000Z",permalink:"/pages/c55839/",categories:["后端","Spring Security"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/25.Spring%20Security/01.%E3%80%90%E8%80%81%E5%BE%90%E3%80%91Spring%20Security(%E4%B8%80)%20%E2%80%94%E2%80%94%20Architecture%20Overview.html",relativePath:"10.框架/25.Spring Security/01.【老徐】Spring Security(一) —— Architecture Overview.md",key:"v-2b0b1b3e",path:"/pages/c55839/",headers:[{level:3,title:"1.1 SecurityContextHolder",slug:"_1-1-securitycontextholder",normalizedTitle:"1.1 securitycontextholder",charIndex:743},{level:3,title:"1.2 Authentication",slug:"_1-2-authentication",normalizedTitle:"1.2 authentication",charIndex:1676},{level:3,title:"1.3 AuthenticationManager",slug:"_1-3-authenticationmanager",normalizedTitle:"1.3 authenticationmanager",charIndex:5220},{level:3,title:"1.4 DaoAuthenticationProvider",slug:"_1-4-daoauthenticationprovider",normalizedTitle:"1.4 daoauthenticationprovider",charIndex:8209},{level:3,title:"1.5 UserDetails与UserDetailsService",slug:"_1-5-userdetails与userdetailsservice",normalizedTitle:"1.5 userdetails与userdetailsservice",charIndex:9001},{level:3,title:"1.6 架构概览图",slug:"_1-6-架构概览图",normalizedTitle:"1.6 架构概览图",charIndex:10207}],headersStr:"1.1 SecurityContextHolder 1.2 Authentication 1.3 AuthenticationManager 1.4 DaoAuthenticationProvider 1.5 UserDetails与UserDetailsService 1.6 架构概览图",content:' * 1 核心组件\n\n----------------------------------------\n\n----------------------------------------\n\n一直以来我都想写一写Spring Security系列的文章，但是整个Spring Security体系强大却又繁杂。陆陆续续从最开始的guides接触它，到项目中看了一些源码，到最近这个月为了写一写这个系列的文章，阅读了好几遍文档，最终打算尝试一下，写一个较为完整的系列文章。\n\n较为简单或者体量较小的技术，完全可以参考着demo直接上手，但系统的学习一门技术则不然。以我的认知，一般的文档大致有两种风格：Architecture First和Code First。前者致力于让读者先了解整体的架构，方便我们对自己的认知有一个宏观的把控，而后者以特定的demo配合讲解，可以让读者在解决问题的过程中顺便掌握一门技术。关注过我博客或者公众号的朋友会发现，我之前介绍技术的文章，大多数是Code First，提出一个需求，介绍一个思路，解决一个问题，分析一下源码，大多如此。而学习一个体系的技术，我推荐Architecture First，正如本文标题所言，这篇文章是我Spring Security系列的第一篇，主要是根据Spring Security文档选择性翻译整理而成的一个架构概览，配合自己的一些注释方便大家理解。写作本系列文章时，参考版本为Spring Security 4.2.3.RELEASE。\n\n\n# 1 核心组件\n\n这一节主要介绍一些在Spring Security中常见且核心的Java类，它们之间的依赖，构建起了整个框架。想要理解整个架构，最起码得对这些类眼熟。\n\n\n# 1.1 SecurityContextHolder\n\nSecurityContextHolder用于存储安全上下文（security context）的信息。当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权限…这些都被保存在SecurityContextHolder中。SecurityContextHolder默认使用ThreadLocal 策略来存储认证信息。看到ThreadLocal 也就意味着，这是一种与线程绑定的策略。Spring Security在用户登录时自动绑定认证信息到当前线程，在用户退出时，自动清除当前线程的认证信息。但这一切的前提，是你在web场景下使用Spring Security，而如果是Swing界面，Spring也提供了支持，SecurityContextHolder的策略则需要被替换，鉴于我的初衷是基于web来介绍Spring Security，所以这里以及后续，非web的相关的内容都一笔带过。\n\n# 获取当前用户的信息\n\n因为身份信息是与线程绑定的，所以可以在程序的任何地方使用静态方法获取用户信息。一个典型的获取当前登录用户的姓名的例子如下所示：\n\nObject principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n\nif (principal instanceof UserDetails) {\n    String username = ((UserDetails)principal).getUsername();\n} else {\n    String username = principal.toString();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ngetAuthentication()返回了认证信息，再次getPrincipal()返回了身份信息，UserDetails便是Spring对身份信息封装的一个接口。Authentication和UserDetails的介绍在下面的小节具体讲解，本节重要的内容是介绍SecurityContextHolder这个容器。\n\n\n# 1.2 Authentication\n\n先看看这个接口的源码长什么样：\n\npackage org.springframework.security.core;// <1>\n\npublic interface Authentication extends Principal, Serializable { // <1>\n    \n    Collection<? extends GrantedAuthority> getAuthorities(); // <2>\n\n    Object getCredentials();// <2>\n\n    Object getDetails();// <2>\n\n    Object getPrincipal();// <2>\n\n    boolean isAuthenticated();// <2>\n\n    void setAuthenticated(boolean var1) throws IllegalArgumentException;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n<1> Authentication是spring security包中的接口，直接继承自Principal类，而Principal是位于java.security包中的。可以见得，Authentication在spring security中是最高级别的身份/认证的抽象。\n\n<2> 由这个顶级接口，我们可以得到用户拥有的权限信息列表，密码，用户细节信息，用户身份信息，认证信息。\n\n还记得1.1节中，authentication.getPrincipal()返回了一个Object，我们将Principal强转成了Spring Security中最常用的UserDetails，这在Spring Security中非常常见，接口返回Object，使用instanceof判断类型，强转成对应的具体实现类。接口详细解读如下：\n\n * getAuthorities()，权限信息列表，默认是GrantedAuthority接口的一些实现类，通常是代表权限信息的一系列字符串。\n * getCredentials()，密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。\n * getDetails()，细节信息，web应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的ip地址和sessionId的值。\n * getPrincipal()，敲黑板！！！最重要的身份信息，大部分情况下返回的是UserDetails接口的实现类，也是框架中的常用接口之一。UserDetails接口将会在下面的小节重点介绍。\n\n# Spring Security是如何完成身份认证的？\n\n1 用户名和密码被过滤器获取到，封装成Authentication,通常情况下是UsernamePasswordAuthenticationToken这个实现类。\n\n2 AuthenticationManager 身份管理器负责验证这个Authentication\n\n3 认证成功后，AuthenticationManager身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）Authentication实例。\n\n4 SecurityContextHolder安全上下文容器将第3步填充了信息的Authentication，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。\n\n这是一个抽象的认证流程，而整个过程中，如果不纠结于细节，其实只剩下一个AuthenticationManager 是我们没有接触过的了，这个身份管理器我们在后面的小节介绍。将上述的流程转换成代码，便是如下的流程：\n\npublic class AuthenticationExample {\nprivate static AuthenticationManager am = new SampleAuthenticationManager();\n\npublic static void main(String[] args) throws Exception {\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\twhile(true) {\n        System.out.println("Please enter your username:");\n        String name = in.readLine();\n        System.out.println("Please enter your password:");\n        String password = in.readLine();\n        try {\n                Authentication request = new UsernamePasswordAuthenticationToken(name, password);\n                Authentication result = am.authenticate(request);\n                SecurityContextHolder.getContext().setAuthentication(result);\n                break;\n            } catch(AuthenticationException e) {\n                System.out.println("Authentication failed: " + e.getMessage());\n            }\n        }\n        System.out.println("Successfully authenticated. Security context contains: " +\n                SecurityContextHolder.getContext().getAuthentication());\n    }\n}\n\nclass SampleAuthenticationManager implements AuthenticationManager {\n    static final List<GrantedAuthority> AUTHORITIES = new ArrayList<GrantedAuthority>();\n\n    static {\n        AUTHORITIES.add(new SimpleGrantedAuthority("ROLE_USER"));\n    }\n\n    public Authentication authenticate(Authentication auth) throws AuthenticationException {\n        if (auth.getName().equals(auth.getCredentials())) {\n            return new UsernamePasswordAuthenticationToken(auth.getName(),\n                   auth.getCredentials(), AUTHORITIES);\n        }\n        throw new BadCredentialsException("Bad Credentials");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n注意：上述这段代码只是为了让大家了解Spring Security的工作流程而写的，不是什么源码。在实际使用中，整个流程会变得更加的复杂，但是基本思想，和上述代码如出一辙。\n\n\n# 1.3 AuthenticationManager\n\n初次接触Spring Security的朋友相信会被AuthenticationManager，ProviderManager ，AuthenticationProvider …这么多相似的Spring认证类搞得晕头转向，但只要稍微梳理一下就可以理解清楚它们的联系和设计者的用意。AuthenticationManager（接口）是认证相关的核心接口，也是发起认证的出发点，因为在实际需求中，我们可能会允许用户使用用户名+密码登录，同时允许用户使用邮箱+密码，手机号码+密码登录，甚至，可能允许用户使用指纹登录（还有这样的操作？没想到吧），所以说AuthenticationManager一般不直接认证，AuthenticationManager接口的常用实现类ProviderManager 内部会维护一个List<AuthenticationProvider>列表，存放多种认证方式，实际上这是委托者模式的应用（Delegate）。也就是说，核心的认证入口始终只有一个：AuthenticationManager，不同的认证方式：用户名+密码（UsernamePasswordAuthenticationToken），邮箱+密码，手机号码+密码登录则对应了三个AuthenticationProvider。这样一来四不四就好理解多了？熟悉shiro的朋友可以把AuthenticationProvider理解成Realm。在默认策略下，只需要通过一个AuthenticationProvider的认证，即可被认为是登录成功。\n\n只保留了关键认证部分的ProviderManager源码：\n\npublic class ProviderManager implements AuthenticationManager, MessageSourceAware,\n\t\tInitializingBean {\n\n    // 维护一个AuthenticationProvider列表\n    private List<AuthenticationProvider> providers = Collections.emptyList();\n\n    public Authentication authenticate(Authentication authentication)\n          throws AuthenticationException {\n       Class<? extends Authentication> toTest = authentication.getClass();\n       AuthenticationException lastException = null;\n       Authentication result = null;\n\n       // 依次认证\n       for (AuthenticationProvider provider : getProviders()) {\n          if (!provider.supports(toTest)) {\n             continue;\n          }\n          try {\n             result = provider.authenticate(authentication);\n\n             if (result != null) {\n                copyDetails(authentication, result);\n                break;\n             }\n          }\n          ...\n          catch (AuthenticationException e) {\n             lastException = e;\n          }\n       }\n       // 如果有Authentication信息，则直接返回\n       if (result != null) {\n\t\t\tif (eraseCredentialsAfterAuthentication\n\t\t\t\t\t&& (result instanceof CredentialsContainer)) {\n              \t //移除密码\n\t\t\t\t((CredentialsContainer) result).eraseCredentials();\n\t\t\t}\n             //发布登录成功事件\n\t\t\teventPublisher.publishAuthenticationSuccess(result);\n\t\t\treturn result;\n\t   }\n\t   ...\n       //执行到此，说明没有认证成功，包装异常信息\n       if (lastException == null) {\n          lastException = new ProviderNotFoundException(messages.getMessage(\n                "ProviderManager.providerNotFound",\n                new Object[] { toTest.getName() },\n                "No AuthenticationProvider found for {0}"));\n       }\n       prepareException(lastException, authentication);\n       throw lastException;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\nProviderManager 中的List，会依照次序去认证，认证成功则立即返回，若认证失败则返回null，下一个AuthenticationProvider会继续尝试认证，如果所有认证器都无法认证成功，则ProviderManager 会抛出一个ProviderNotFoundException异常。\n\n到这里，如果不纠结于AuthenticationProvider的实现细节以及安全相关的过滤器，认证相关的核心类其实都已经介绍完毕了：身份信息的存放容器SecurityContextHolder，身份信息的抽象Authentication，身份认证器AuthenticationManager及其认证流程。姑且在这里做一个分隔线。下面来介绍下AuthenticationProvider接口的具体实现。\n\n\n# 1.4 DaoAuthenticationProvider\n\nAuthenticationProvider最最最常用的一个实现便是DaoAuthenticationProvider。顾名思义，Dao正是数据访问层的缩写，也暗示了这个身份认证器的实现思路。由于本文是一个Overview，姑且只给出其UML类图：\n\nDaoAuthenticationProvider UML\n\n按照我们最直观的思路，怎么去认证一个用户呢？用户前台提交了用户名和密码，而数据库中保存了用户名和密码，认证便是负责比对同一个用户名，提交的密码和保存的密码是否相同便是了。在Spring Security中。提交的用户名和密码，被封装成了UsernamePasswordAuthenticationToken，而根据用户名加载用户的任务则是交给了UserDetailsService，在DaoAuthenticationProvider中，对应的方法便是retrieveUser，虽然有两个参数，但是retrieveUser只有第一个参数起主要作用，返回一个UserDetails。还需要完成UsernamePasswordAuthenticationToken和UserDetails密码的比对，这便是交给additionalAuthenticationChecks方法完成的，如果这个void方法没有抛异常，则认为比对成功。比对密码的过程，用到了PasswordEncoder和SaltSource，密码加密和盐的概念相信不用我赘述了，它们为保障安全而设计，都是比较基础的概念。\n\n如果你已经被这些概念搞得晕头转向了，不妨这么理解DaoAuthenticationProvider：它获取用户提交的用户名和密码，比对其正确性，如果正确，返回一个数据库中的用户信息（假设用户信息被保存在数据库中）。\n\n\n# 1.5 UserDetails与UserDetailsService\n\n上面不断提到了UserDetails这个接口，它代表了最详细的用户信息，这个接口涵盖了一些必要的用户信息字段，具体的实现类对它进行了扩展。\n\npublic interface UserDetails extends Serializable {\n\n   Collection<? extends GrantedAuthority> getAuthorities();\n\n   String getPassword();\n\n   String getUsername();\n\n   boolean isAccountNonExpired();\n\n   boolean isAccountNonLocked();\n\n   boolean isCredentialsNonExpired();\n\n   boolean isEnabled();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n它和Authentication接口很类似，比如它们都拥有username，authorities，区分他们也是本文的重点内容之一。Authentication的getCredentials()与UserDetails中的getPassword()需要被区分对待，前者是用户提交的密码凭证，后者是用户正确的密码，认证器其实就是对这两者的比对。Authentication中的getAuthorities()实际是由UserDetails的getAuthorities()传递而形成的。还记得Authentication接口中的getUserDetails()方法吗？其中的UserDetails用户详细信息便是经过了AuthenticationProvider之后被填充的。\n\npublic interface UserDetailsService {\n   UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;\n}\n\n\n1\n2\n3\n\n\nUserDetailsService和AuthenticationProvider两者的职责常常被人们搞混，关于他们的问题在文档的FAQ和issues中屡见不鲜。记住一点即可，敲黑板！！！UserDetailsService只负责从特定的地方（通常是数据库）加载用户信息，仅此而已，记住这一点，可以避免走很多弯路。UserDetailsService常见的实现类有JdbcDaoImpl，InMemoryUserDetailsManager，前者从数据库加载用户，后者从内存中加载用户，也可以自己实现UserDetailsService，通常这更加灵活。\n\n\n# 1.6 架构概览图\n\n为了更加形象的理解上述我介绍的这些核心类，附上一张按照我的理解，所画出Spring Security的一张非典型的UML图\n\n[](http://kirito.iocoder.cn/spring security architecture.png)架构概览图\n\n如果对Spring Security的这些概念感到理解不能，不用担心，因为这是Architecture First导致的必然结果，先过个眼熟。后续的文章会秉持Code First的理念，陆续详细地讲解这些实现类的使用场景，源码分析，以及最基本的：如何配置Spring Security，在后面的文章中可以不时翻看这篇文章，找到具体的类在整个架构中所处的位置，这也是本篇文章的定位。另外，一些Spring Security的过滤器还未囊括在架构概览中，如将表单信息包装成UsernamePasswordAuthenticationToken的过滤器，考虑到这些虽然也是架构的一部分，但是真正重写他们的可能性较小，所以打算放到后面的章节讲解。',normalizedContent:' * 1 核心组件\n\n----------------------------------------\n\n----------------------------------------\n\n一直以来我都想写一写spring security系列的文章，但是整个spring security体系强大却又繁杂。陆陆续续从最开始的guides接触它，到项目中看了一些源码，到最近这个月为了写一写这个系列的文章，阅读了好几遍文档，最终打算尝试一下，写一个较为完整的系列文章。\n\n较为简单或者体量较小的技术，完全可以参考着demo直接上手，但系统的学习一门技术则不然。以我的认知，一般的文档大致有两种风格：architecture first和code first。前者致力于让读者先了解整体的架构，方便我们对自己的认知有一个宏观的把控，而后者以特定的demo配合讲解，可以让读者在解决问题的过程中顺便掌握一门技术。关注过我博客或者公众号的朋友会发现，我之前介绍技术的文章，大多数是code first，提出一个需求，介绍一个思路，解决一个问题，分析一下源码，大多如此。而学习一个体系的技术，我推荐architecture first，正如本文标题所言，这篇文章是我spring security系列的第一篇，主要是根据spring security文档选择性翻译整理而成的一个架构概览，配合自己的一些注释方便大家理解。写作本系列文章时，参考版本为spring security 4.2.3.release。\n\n\n# 1 核心组件\n\n这一节主要介绍一些在spring security中常见且核心的java类，它们之间的依赖，构建起了整个框架。想要理解整个架构，最起码得对这些类眼熟。\n\n\n# 1.1 securitycontextholder\n\nsecuritycontextholder用于存储安全上下文（security context）的信息。当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权限…这些都被保存在securitycontextholder中。securitycontextholder默认使用threadlocal 策略来存储认证信息。看到threadlocal 也就意味着，这是一种与线程绑定的策略。spring security在用户登录时自动绑定认证信息到当前线程，在用户退出时，自动清除当前线程的认证信息。但这一切的前提，是你在web场景下使用spring security，而如果是swing界面，spring也提供了支持，securitycontextholder的策略则需要被替换，鉴于我的初衷是基于web来介绍spring security，所以这里以及后续，非web的相关的内容都一笔带过。\n\n# 获取当前用户的信息\n\n因为身份信息是与线程绑定的，所以可以在程序的任何地方使用静态方法获取用户信息。一个典型的获取当前登录用户的姓名的例子如下所示：\n\nobject principal = securitycontextholder.getcontext().getauthentication().getprincipal();\n\nif (principal instanceof userdetails) {\n    string username = ((userdetails)principal).getusername();\n} else {\n    string username = principal.tostring();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ngetauthentication()返回了认证信息，再次getprincipal()返回了身份信息，userdetails便是spring对身份信息封装的一个接口。authentication和userdetails的介绍在下面的小节具体讲解，本节重要的内容是介绍securitycontextholder这个容器。\n\n\n# 1.2 authentication\n\n先看看这个接口的源码长什么样：\n\npackage org.springframework.security.core;// <1>\n\npublic interface authentication extends principal, serializable { // <1>\n    \n    collection<? extends grantedauthority> getauthorities(); // <2>\n\n    object getcredentials();// <2>\n\n    object getdetails();// <2>\n\n    object getprincipal();// <2>\n\n    boolean isauthenticated();// <2>\n\n    void setauthenticated(boolean var1) throws illegalargumentexception;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n<1> authentication是spring security包中的接口，直接继承自principal类，而principal是位于java.security包中的。可以见得，authentication在spring security中是最高级别的身份/认证的抽象。\n\n<2> 由这个顶级接口，我们可以得到用户拥有的权限信息列表，密码，用户细节信息，用户身份信息，认证信息。\n\n还记得1.1节中，authentication.getprincipal()返回了一个object，我们将principal强转成了spring security中最常用的userdetails，这在spring security中非常常见，接口返回object，使用instanceof判断类型，强转成对应的具体实现类。接口详细解读如下：\n\n * getauthorities()，权限信息列表，默认是grantedauthority接口的一些实现类，通常是代表权限信息的一系列字符串。\n * getcredentials()，密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。\n * getdetails()，细节信息，web应用中的实现接口通常为 webauthenticationdetails，它记录了访问者的ip地址和sessionid的值。\n * getprincipal()，敲黑板！！！最重要的身份信息，大部分情况下返回的是userdetails接口的实现类，也是框架中的常用接口之一。userdetails接口将会在下面的小节重点介绍。\n\n# spring security是如何完成身份认证的？\n\n1 用户名和密码被过滤器获取到，封装成authentication,通常情况下是usernamepasswordauthenticationtoken这个实现类。\n\n2 authenticationmanager 身份管理器负责验证这个authentication\n\n3 认证成功后，authenticationmanager身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）authentication实例。\n\n4 securitycontextholder安全上下文容器将第3步填充了信息的authentication，通过securitycontextholder.getcontext().setauthentication(…)方法，设置到其中。\n\n这是一个抽象的认证流程，而整个过程中，如果不纠结于细节，其实只剩下一个authenticationmanager 是我们没有接触过的了，这个身份管理器我们在后面的小节介绍。将上述的流程转换成代码，便是如下的流程：\n\npublic class authenticationexample {\nprivate static authenticationmanager am = new sampleauthenticationmanager();\n\npublic static void main(string[] args) throws exception {\n\tbufferedreader in = new bufferedreader(new inputstreamreader(system.in));\n\n\twhile(true) {\n        system.out.println("please enter your username:");\n        string name = in.readline();\n        system.out.println("please enter your password:");\n        string password = in.readline();\n        try {\n                authentication request = new usernamepasswordauthenticationtoken(name, password);\n                authentication result = am.authenticate(request);\n                securitycontextholder.getcontext().setauthentication(result);\n                break;\n            } catch(authenticationexception e) {\n                system.out.println("authentication failed: " + e.getmessage());\n            }\n        }\n        system.out.println("successfully authenticated. security context contains: " +\n                securitycontextholder.getcontext().getauthentication());\n    }\n}\n\nclass sampleauthenticationmanager implements authenticationmanager {\n    static final list<grantedauthority> authorities = new arraylist<grantedauthority>();\n\n    static {\n        authorities.add(new simplegrantedauthority("role_user"));\n    }\n\n    public authentication authenticate(authentication auth) throws authenticationexception {\n        if (auth.getname().equals(auth.getcredentials())) {\n            return new usernamepasswordauthenticationtoken(auth.getname(),\n                   auth.getcredentials(), authorities);\n        }\n        throw new badcredentialsexception("bad credentials");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n注意：上述这段代码只是为了让大家了解spring security的工作流程而写的，不是什么源码。在实际使用中，整个流程会变得更加的复杂，但是基本思想，和上述代码如出一辙。\n\n\n# 1.3 authenticationmanager\n\n初次接触spring security的朋友相信会被authenticationmanager，providermanager ，authenticationprovider …这么多相似的spring认证类搞得晕头转向，但只要稍微梳理一下就可以理解清楚它们的联系和设计者的用意。authenticationmanager（接口）是认证相关的核心接口，也是发起认证的出发点，因为在实际需求中，我们可能会允许用户使用用户名+密码登录，同时允许用户使用邮箱+密码，手机号码+密码登录，甚至，可能允许用户使用指纹登录（还有这样的操作？没想到吧），所以说authenticationmanager一般不直接认证，authenticationmanager接口的常用实现类providermanager 内部会维护一个list<authenticationprovider>列表，存放多种认证方式，实际上这是委托者模式的应用（delegate）。也就是说，核心的认证入口始终只有一个：authenticationmanager，不同的认证方式：用户名+密码（usernamepasswordauthenticationtoken），邮箱+密码，手机号码+密码登录则对应了三个authenticationprovider。这样一来四不四就好理解多了？熟悉shiro的朋友可以把authenticationprovider理解成realm。在默认策略下，只需要通过一个authenticationprovider的认证，即可被认为是登录成功。\n\n只保留了关键认证部分的providermanager源码：\n\npublic class providermanager implements authenticationmanager, messagesourceaware,\n\t\tinitializingbean {\n\n    // 维护一个authenticationprovider列表\n    private list<authenticationprovider> providers = collections.emptylist();\n\n    public authentication authenticate(authentication authentication)\n          throws authenticationexception {\n       class<? extends authentication> totest = authentication.getclass();\n       authenticationexception lastexception = null;\n       authentication result = null;\n\n       // 依次认证\n       for (authenticationprovider provider : getproviders()) {\n          if (!provider.supports(totest)) {\n             continue;\n          }\n          try {\n             result = provider.authenticate(authentication);\n\n             if (result != null) {\n                copydetails(authentication, result);\n                break;\n             }\n          }\n          ...\n          catch (authenticationexception e) {\n             lastexception = e;\n          }\n       }\n       // 如果有authentication信息，则直接返回\n       if (result != null) {\n\t\t\tif (erasecredentialsafterauthentication\n\t\t\t\t\t&& (result instanceof credentialscontainer)) {\n              \t //移除密码\n\t\t\t\t((credentialscontainer) result).erasecredentials();\n\t\t\t}\n             //发布登录成功事件\n\t\t\teventpublisher.publishauthenticationsuccess(result);\n\t\t\treturn result;\n\t   }\n\t   ...\n       //执行到此，说明没有认证成功，包装异常信息\n       if (lastexception == null) {\n          lastexception = new providernotfoundexception(messages.getmessage(\n                "providermanager.providernotfound",\n                new object[] { totest.getname() },\n                "no authenticationprovider found for {0}"));\n       }\n       prepareexception(lastexception, authentication);\n       throw lastexception;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\nprovidermanager 中的list，会依照次序去认证，认证成功则立即返回，若认证失败则返回null，下一个authenticationprovider会继续尝试认证，如果所有认证器都无法认证成功，则providermanager 会抛出一个providernotfoundexception异常。\n\n到这里，如果不纠结于authenticationprovider的实现细节以及安全相关的过滤器，认证相关的核心类其实都已经介绍完毕了：身份信息的存放容器securitycontextholder，身份信息的抽象authentication，身份认证器authenticationmanager及其认证流程。姑且在这里做一个分隔线。下面来介绍下authenticationprovider接口的具体实现。\n\n\n# 1.4 daoauthenticationprovider\n\nauthenticationprovider最最最常用的一个实现便是daoauthenticationprovider。顾名思义，dao正是数据访问层的缩写，也暗示了这个身份认证器的实现思路。由于本文是一个overview，姑且只给出其uml类图：\n\ndaoauthenticationprovider uml\n\n按照我们最直观的思路，怎么去认证一个用户呢？用户前台提交了用户名和密码，而数据库中保存了用户名和密码，认证便是负责比对同一个用户名，提交的密码和保存的密码是否相同便是了。在spring security中。提交的用户名和密码，被封装成了usernamepasswordauthenticationtoken，而根据用户名加载用户的任务则是交给了userdetailsservice，在daoauthenticationprovider中，对应的方法便是retrieveuser，虽然有两个参数，但是retrieveuser只有第一个参数起主要作用，返回一个userdetails。还需要完成usernamepasswordauthenticationtoken和userdetails密码的比对，这便是交给additionalauthenticationchecks方法完成的，如果这个void方法没有抛异常，则认为比对成功。比对密码的过程，用到了passwordencoder和saltsource，密码加密和盐的概念相信不用我赘述了，它们为保障安全而设计，都是比较基础的概念。\n\n如果你已经被这些概念搞得晕头转向了，不妨这么理解daoauthenticationprovider：它获取用户提交的用户名和密码，比对其正确性，如果正确，返回一个数据库中的用户信息（假设用户信息被保存在数据库中）。\n\n\n# 1.5 userdetails与userdetailsservice\n\n上面不断提到了userdetails这个接口，它代表了最详细的用户信息，这个接口涵盖了一些必要的用户信息字段，具体的实现类对它进行了扩展。\n\npublic interface userdetails extends serializable {\n\n   collection<? extends grantedauthority> getauthorities();\n\n   string getpassword();\n\n   string getusername();\n\n   boolean isaccountnonexpired();\n\n   boolean isaccountnonlocked();\n\n   boolean iscredentialsnonexpired();\n\n   boolean isenabled();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n它和authentication接口很类似，比如它们都拥有username，authorities，区分他们也是本文的重点内容之一。authentication的getcredentials()与userdetails中的getpassword()需要被区分对待，前者是用户提交的密码凭证，后者是用户正确的密码，认证器其实就是对这两者的比对。authentication中的getauthorities()实际是由userdetails的getauthorities()传递而形成的。还记得authentication接口中的getuserdetails()方法吗？其中的userdetails用户详细信息便是经过了authenticationprovider之后被填充的。\n\npublic interface userdetailsservice {\n   userdetails loaduserbyusername(string username) throws usernamenotfoundexception;\n}\n\n\n1\n2\n3\n\n\nuserdetailsservice和authenticationprovider两者的职责常常被人们搞混，关于他们的问题在文档的faq和issues中屡见不鲜。记住一点即可，敲黑板！！！userdetailsservice只负责从特定的地方（通常是数据库）加载用户信息，仅此而已，记住这一点，可以避免走很多弯路。userdetailsservice常见的实现类有jdbcdaoimpl，inmemoryuserdetailsmanager，前者从数据库加载用户，后者从内存中加载用户，也可以自己实现userdetailsservice，通常这更加灵活。\n\n\n# 1.6 架构概览图\n\n为了更加形象的理解上述我介绍的这些核心类，附上一张按照我的理解，所画出spring security的一张非典型的uml图\n\n[](http://kirito.iocoder.cn/spring security architecture.png)架构概览图\n\n如果对spring security的这些概念感到理解不能，不用担心，因为这是architecture first导致的必然结果，先过个眼熟。后续的文章会秉持code first的理念，陆续详细地讲解这些实现类的使用场景，源码分析，以及最基本的：如何配置spring security，在后面的文章中可以不时翻看这篇文章，找到具体的类在整个架构中所处的位置，这也是本篇文章的定位。另外，一些spring security的过滤器还未囊括在架构概览中，如将表单信息包装成usernamepasswordauthenticationtoken的过滤器，考虑到这些虽然也是架构的一部分，但是真正重写他们的可能性较小，所以打算放到后面的章节讲解。',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"【老徐】Spring Security(二) —— Guides",frontmatter:{title:"【老徐】Spring Security(二) —— Guides",date:"2022-02-03T00:03:27.000Z",permalink:"/pages/188a19/",categories:["后端","Spring Security"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/25.Spring%20Security/02.%E3%80%90%E8%80%81%E5%BE%90%E3%80%91Spring%20Security(%E4%BA%8C)%20%E2%80%94%E2%80%94%20Guides.html",relativePath:"10.框架/25.Spring Security/02.【老徐】Spring Security(二) —— Guides.md",key:"v-2b72ba50",path:"/pages/188a19/",headers:[{level:2,title:"2 Spring Security Guides",slug:"_2-spring-security-guides",normalizedTitle:"2 spring security guides",charIndex:75},{level:3,title:"2.1 引入依赖",slug:"_2-1-引入依赖",normalizedTitle:"2.1 引入依赖",charIndex:363},{level:3,title:"2.2 创建一个不受安全限制的web应用",slug:"_2-2-创建一个不受安全限制的web应用",normalizedTitle:"2.2 创建一个不受安全限制的web应用",charIndex:987},{level:3,title:"2.3 配置Spring Security",slug:"_2-3-配置spring-security",normalizedTitle:"2.3 配置spring security",charIndex:2343},{level:3,title:"2.4 添加启动类",slug:"_2-4-添加启动类",normalizedTitle:"2.4 添加启动类",charIndex:5360},{level:3,title:"2.5 测试",slug:"_2-5-测试",normalizedTitle:"2.5 测试",charIndex:5572},{level:3,title:"2.6 总结",slug:"_2-6-总结",normalizedTitle:"2.6 总结",charIndex:5778}],headersStr:"2 Spring Security Guides 2.1 引入依赖 2.2 创建一个不受安全限制的web应用 2.3 配置Spring Security 2.4 添加启动类 2.5 测试 2.6 总结",content:'摘要: 原创出处 https://www.cnkirito.moe/spring-security-2/ 「老徐」欢迎转载，保留摘要，谢谢！\n\n * 2 Spring Security Guides\n\n----------------------------------------\n\n----------------------------------------\n\n上一篇文章《Spring Security(一)–Architecture Overview》，我们介绍了Spring Security的基础架构，这一节我们通过Spring官方给出的一个guides例子，来了解Spring Security是如何保护我们的应用的，之后会对进行一个解读。\n\n\n# 2 Spring Security Guides\n\n\n# 2.1 引入依赖\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-thymeleaf</artifactId>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n由于我们集成了springboot，所以不需要显示的引入Spring Security文档中描述core，config依赖，只需要引入spring-boot-starter-security即可。\n\n\n# 2.2 创建一个不受安全限制的web应用\n\n这是一个首页，不受安全限制\n\nsrc/main/resources/templates/home.html\n<!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity3">\n    <head>\n        <title>Spring Security Example</title>\n    </head>\n    <body>\n        <h1>Welcome!</h1>\n        <p>Click <a th:href="@{/hello}">here</a> to see a greeting.</p>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这个简单的页面上包含了一个链接，跳转到”/hello”。对应如下的页面\n\nsrc/main/resources/templates/hello.html\n<!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"\n      xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity3">\n    <head>\n        <title>Hello World!</title>\n    </head>\n    <body>\n        <h1>Hello world!</h1>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n接下来配置Spring MVC，使得我们能够访问到页面。\n\n@Configuration\npublic class MvcConfig extends WebMvcConfigurerAdapter {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController("/home").setViewName("home");\n        registry.addViewController("/").setViewName("home");\n        registry.addViewController("/hello").setViewName("hello");\n        registry.addViewController("/login").setViewName("login");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.3 配置Spring Security\n\n一个典型的安全配置如下所示：\n\n@Configuration\n@EnableWebSecurity <1>\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter { <1>\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http <2>\n            .authorizeRequests()\n                .antMatchers("/", "/home").permitAll()\n                .anyRequest().authenticated()\n                .and()\n            .formLogin()\n                .loginPage("/login")\n                .permitAll()\n                .and()\n            .logout()\n                .permitAll();\n    }\n\n    @Autowired\n    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n        auth <3>\n            .inMemoryAuthentication()\n                .withUser("admin").password("admin").roles("USER");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n<1> @EnableWebSecurity注解使得SpringMVC集成了Spring Security的web安全支持。另外，WebSecurityConfig配置类同时集成了WebSecurityConfigurerAdapter，重写了其中的特定方法，用于自定义Spring Security配置。整个Spring Security的工作量，其实都是集中在该配置类，不仅仅是这个guides，实际项目中也是如此。\n\n<2> configure(HttpSecurity)定义了哪些URL路径应该被拦截，如字面意思所描述：”/“, “/home”允许所有人访问，”/login”作为登录入口，也被允许访问，而剩下的”/hello”则需要登录后才可以访问。\n\n<3> configureGlobal(AuthenticationManagerBuilder)在内存中配置一个用户，admin/admin分别是用户名和密码，这个用户拥有USER角色。\n\n我们目前还没有登录页面，下面创建登录页面：\n\n<!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"\n      xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity3">\n    <head>\n        <title>Spring Security Example </title>\n    </head>\n    <body>\n        <div th:if="${param.error}">\n            Invalid username and password.\n        </div>\n        <div th:if="${param.logout}">\n            You have been logged out.\n        </div>\n        <form th:action="@{/login}" method="post">\n            <div><label> User Name : <input type="text" name="username"/> </label></div>\n            <div><label> Password: <input type="password" name="password"/> </label></div>\n            <div><input type="submit" value="Sign In"/></div>\n        </form>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这个Thymeleaf模板提供了一个用于提交用户名和密码的表单,其中name=”username”，name=”password”是默认的表单值，并发送到“/ login”。 在默认配置中，Spring Security提供了一个拦截该请求并验证用户的过滤器。 如果验证失败，该页面将重定向到“/ login?error”，并显示相应的错误消息。 当用户选择注销，请求会被发送到“/ login?logout”。\n\n最后，我们为hello.html添加一些内容，用于展示用户信息。\n\n<!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"\n      xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity3">\n    <head>\n        <title>Hello World!</title>\n    </head>\n    <body>\n        <h1 th:inline="text">Hello [[${#httpServletRequest.remoteUser}]]!</h1>\n        <form th:action="@{/logout}" method="post">\n            <input type="submit" value="Sign Out"/>\n        </form>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们使用Spring Security之后，HttpServletRequest#getRemoteUser()可以用来获取用户名。 登出请求将被发送到“/ logout”。 成功注销后，会将用户重定向到“/ login?logout”。\n\n\n# 2.4 添加启动类\n\n@SpringBootApplication\npublic class Application {\n\n    public static void main(String[] args) throws Throwable {\n        SpringApplication.run(Application.class, args);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2.5 测试\n\n访问首页http://localhost:8080/:\n\nhome.html\n\n点击here，尝试访问受限的页面：/hello,由于未登录，结果被强制跳转到登录也/login：\n\nlogin.html\n\n输入正确的用户名和密码之后，跳转到之前想要访问的/hello:\n\nhello.html\n\n点击Sign out退出按钮，访问:/logout,回到登录页面:\n\nlogout.html\n\n\n# 2.6 总结\n\n本篇文章没有什么干货，基本算是翻译了Spring Security Guides的内容，稍微了解Spring Security的朋友都不会对这个翻译感到陌生。考虑到受众的问题，一个入门的例子是必须得有的，方便后续对Spring Security的自定义配置进行讲解。下一节，以此guides为例，讲解这些最简化的配置背后，Spring Security都帮我们做了什么工作。\n\n本节所有的代码，可以直接在Spring的官方仓库下载得到，git clone https://github.com/spring-guides/gs-securing-web.git。不过，建议初学者根据文章先一步步配置，出了问题，再与demo进行对比。',normalizedContent:'摘要: 原创出处 https://www.cnkirito.moe/spring-security-2/ 「老徐」欢迎转载，保留摘要，谢谢！\n\n * 2 spring security guides\n\n----------------------------------------\n\n----------------------------------------\n\n上一篇文章《spring security(一)–architecture overview》，我们介绍了spring security的基础架构，这一节我们通过spring官方给出的一个guides例子，来了解spring security是如何保护我们的应用的，之后会对进行一个解读。\n\n\n# 2 spring security guides\n\n\n# 2.1 引入依赖\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-web</artifactid>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-security</artifactid>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-thymeleaf</artifactid>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n由于我们集成了springboot，所以不需要显示的引入spring security文档中描述core，config依赖，只需要引入spring-boot-starter-security即可。\n\n\n# 2.2 创建一个不受安全限制的web应用\n\n这是一个首页，不受安全限制\n\nsrc/main/resources/templates/home.html\n<!doctype html>\n<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity3">\n    <head>\n        <title>spring security example</title>\n    </head>\n    <body>\n        <h1>welcome!</h1>\n        <p>click <a th:href="@{/hello}">here</a> to see a greeting.</p>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这个简单的页面上包含了一个链接，跳转到”/hello”。对应如下的页面\n\nsrc/main/resources/templates/hello.html\n<!doctype html>\n<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"\n      xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity3">\n    <head>\n        <title>hello world!</title>\n    </head>\n    <body>\n        <h1>hello world!</h1>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n接下来配置spring mvc，使得我们能够访问到页面。\n\n@configuration\npublic class mvcconfig extends webmvcconfigureradapter {\n\n    @override\n    public void addviewcontrollers(viewcontrollerregistry registry) {\n        registry.addviewcontroller("/home").setviewname("home");\n        registry.addviewcontroller("/").setviewname("home");\n        registry.addviewcontroller("/hello").setviewname("hello");\n        registry.addviewcontroller("/login").setviewname("login");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.3 配置spring security\n\n一个典型的安全配置如下所示：\n\n@configuration\n@enablewebsecurity <1>\npublic class websecurityconfig extends websecurityconfigureradapter { <1>\n    @override\n    protected void configure(httpsecurity http) throws exception {\n        http <2>\n            .authorizerequests()\n                .antmatchers("/", "/home").permitall()\n                .anyrequest().authenticated()\n                .and()\n            .formlogin()\n                .loginpage("/login")\n                .permitall()\n                .and()\n            .logout()\n                .permitall();\n    }\n\n    @autowired\n    public void configureglobal(authenticationmanagerbuilder auth) throws exception {\n        auth <3>\n            .inmemoryauthentication()\n                .withuser("admin").password("admin").roles("user");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n<1> @enablewebsecurity注解使得springmvc集成了spring security的web安全支持。另外，websecurityconfig配置类同时集成了websecurityconfigureradapter，重写了其中的特定方法，用于自定义spring security配置。整个spring security的工作量，其实都是集中在该配置类，不仅仅是这个guides，实际项目中也是如此。\n\n<2> configure(httpsecurity)定义了哪些url路径应该被拦截，如字面意思所描述：”/“, “/home”允许所有人访问，”/login”作为登录入口，也被允许访问，而剩下的”/hello”则需要登录后才可以访问。\n\n<3> configureglobal(authenticationmanagerbuilder)在内存中配置一个用户，admin/admin分别是用户名和密码，这个用户拥有user角色。\n\n我们目前还没有登录页面，下面创建登录页面：\n\n<!doctype html>\n<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"\n      xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity3">\n    <head>\n        <title>spring security example </title>\n    </head>\n    <body>\n        <div th:if="${param.error}">\n            invalid username and password.\n        </div>\n        <div th:if="${param.logout}">\n            you have been logged out.\n        </div>\n        <form th:action="@{/login}" method="post">\n            <div><label> user name : <input type="text" name="username"/> </label></div>\n            <div><label> password: <input type="password" name="password"/> </label></div>\n            <div><input type="submit" value="sign in"/></div>\n        </form>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这个thymeleaf模板提供了一个用于提交用户名和密码的表单,其中name=”username”，name=”password”是默认的表单值，并发送到“/ login”。 在默认配置中，spring security提供了一个拦截该请求并验证用户的过滤器。 如果验证失败，该页面将重定向到“/ login?error”，并显示相应的错误消息。 当用户选择注销，请求会被发送到“/ login?logout”。\n\n最后，我们为hello.html添加一些内容，用于展示用户信息。\n\n<!doctype html>\n<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"\n      xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity3">\n    <head>\n        <title>hello world!</title>\n    </head>\n    <body>\n        <h1 th:inline="text">hello [[${#httpservletrequest.remoteuser}]]!</h1>\n        <form th:action="@{/logout}" method="post">\n            <input type="submit" value="sign out"/>\n        </form>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们使用spring security之后，httpservletrequest#getremoteuser()可以用来获取用户名。 登出请求将被发送到“/ logout”。 成功注销后，会将用户重定向到“/ login?logout”。\n\n\n# 2.4 添加启动类\n\n@springbootapplication\npublic class application {\n\n    public static void main(string[] args) throws throwable {\n        springapplication.run(application.class, args);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2.5 测试\n\n访问首页http://localhost:8080/:\n\nhome.html\n\n点击here，尝试访问受限的页面：/hello,由于未登录，结果被强制跳转到登录也/login：\n\nlogin.html\n\n输入正确的用户名和密码之后，跳转到之前想要访问的/hello:\n\nhello.html\n\n点击sign out退出按钮，访问:/logout,回到登录页面:\n\nlogout.html\n\n\n# 2.6 总结\n\n本篇文章没有什么干货，基本算是翻译了spring security guides的内容，稍微了解spring security的朋友都不会对这个翻译感到陌生。考虑到受众的问题，一个入门的例子是必须得有的，方便后续对spring security的自定义配置进行讲解。下一节，以此guides为例，讲解这些最简化的配置背后，spring security都帮我们做了什么工作。\n\n本节所有的代码，可以直接在spring的官方仓库下载得到，git clone https://github.com/spring-guides/gs-securing-web.git。不过，建议初学者根据文章先一步步配置，出了问题，再与demo进行对比。',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"【老徐】Spring Security(三) —— 核心配置解读",frontmatter:{title:"【老徐】Spring Security(三) —— 核心配置解读",date:"2022-02-03T00:03:27.000Z",permalink:"/pages/9327fd/",categories:["后端","Spring Security"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/25.Spring%20Security/03.%E3%80%90%E8%80%81%E5%BE%90%E3%80%91Spring%20Security(%E4%B8%89)%20%E2%80%94%E2%80%94%20%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E8%A7%A3%E8%AF%BB.html",relativePath:"10.框架/25.Spring Security/03.【老徐】Spring Security(三) —— 核心配置解读.md",key:"v-d22b1d0e",path:"/pages/9327fd/",headers:[{level:2,title:"3 核心配置解读",slug:"_3-核心配置解读",normalizedTitle:"3 核心配置解读",charIndex:75},{level:3,title:"3.1 功能介绍",slug:"_3-1-功能介绍",normalizedTitle:"3.1 功能介绍",charIndex:288},{level:3,title:"3.2 @EnableWebSecurity",slug:"_3-2-enablewebsecurity",normalizedTitle:"3.2 @enablewebsecurity",charIndex:2093},{level:3,title:"3.3 WebSecurityConfigurerAdapter",slug:"_3-3-websecurityconfigureradapter",normalizedTitle:"3.3 websecurityconfigureradapter",charIndex:4850}],headersStr:"3 核心配置解读 3.1 功能介绍 3.2 @EnableWebSecurity 3.3 WebSecurityConfigurerAdapter",content:'摘要: 原创出处 https://www.cnkirito.moe/spring-security-3/ 「老徐」欢迎转载，保留摘要，谢谢！\n\n * 3 核心配置解读\n\n----------------------------------------\n\n----------------------------------------\n\n上一篇文章《Spring Security(二)–Guides》，通过Spring Security的配置项了解了Spring Security是如何保护我们的应用的，本篇文章对上一次的配置做一个分析。\n\n\n# 3 核心配置解读\n\n\n# 3.1 功能介绍\n\n这是Spring Security入门指南中的配置项：\n\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n      http\n          .authorizeRequests()\n              .antMatchers("/", "/home").permitAll()\n              .anyRequest().authenticated()\n              .and()\n          .formLogin()\n              .loginPage("/login")\n              .permitAll()\n              .and()\n          .logout()\n              .permitAll();\n  }\n\n  @Autowired\n  public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n      auth\n          .inMemoryAuthentication()\n              .withUser("admin").password("admin").roles("USER");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n当配置了上述的javaconfig之后，我们的应用便具备了如下的功能：\n\n * 除了“/”,”/home”(首页),”/login”(登录),”/logout”(注销),之外，其他路径都需要认证。\n\n * 指定“/login”该路径为登录页面，当未认证的用户尝试访问任何受保护的资源时，都会跳转到“/login”。\n\n * 默认指定“/logout”为注销页面\n\n * 配置一个内存中的用户认证器，使用admin/admin作为用户名和密码，具有USER角色\n\n * 防止CSRF攻击\n\n * Session Fixation protection(可以参考我之前讲解Spring Session的文章，防止别人篡改sessionId)\n\n * Security Header(添加一系列和Header相关的控制)\n   \n   * HTTP Strict Transport Security for secure requests\n   * 集成X-Content-Type-Options\n   * 缓存控制\n   * 集成X-XSS-Protection\n   * X-Frame-Options integration to help prevent Clickjacking(iframe被默认禁止使用)\n\n * 为Servlet API集成了如下的几个方法\n   \n   * HttpServletRequest#getRemoteUser()\n   * HttpServletRequest.html#getUserPrincipal()\n   * HttpServletRequest.html#isUserInRole(java.lang.String)\n   * [HttpServletRequest.html#login(java.lang.String, java.lang.String)](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String, java.lang.String))\n   * HttpServletRequest.html#logout()\n\n\n# 3.2 @EnableWebSecurity\n\n我们自己定义的配置类WebSecurityConfig加上了@EnableWebSecurity注解，同时继承了WebSecurityConfigurerAdapter。你可能会在想谁的作用大一点，毫无疑问@EnableWebSecurity起到决定性的配置作用，它其实是个组合注解。\n\n@Import({ WebSecurityConfiguration.class, // <2>\n      SpringWebMvcImportSelector.class }) // <1>\n@EnableGlobalAuthentication // <3>\n@Configuration\npublic @interface EnableWebSecurity {\n   boolean debug() default false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n@Import是springboot提供的用于引入外部的配置的注解，可以理解为：@EnableWebSecurity注解激活了@Import注解中包含的配置类。\n\n<1> SpringWebMvcImportSelector的作用是判断当前的环境是否包含springmvc，因为spring security可以在非spring环境下使用，为了避免DispatcherServlet的重复配置，所以使用了这个注解来区分。\n\n<2> WebSecurityConfiguration顾名思义，是用来配置web安全的，下面的小节会详细介绍。\n\n<3> @EnableGlobalAuthentication注解的源码如下：\n\n@Import(AuthenticationConfiguration.class)\n@Configuration\npublic @interface EnableGlobalAuthentication {\n}\n\n\n1\n2\n3\n4\n\n\n注意点同样在@Import之中，它实际上激活了AuthenticationConfiguration这样的一个配置类，用来配置认证相关的核心类。\n\n也就是说：@EnableWebSecurity完成的工作便是加载了WebSecurityConfiguration，AuthenticationConfiguration这两个核心配置类，也就此将spring security的职责划分为了配置安全信息，配置认证信息两部分。\n\n# WebSecurityConfiguration\n\n在这个配置类中，有一个非常重要的Bean被注册了。\n\n@Configuration\npublic class WebSecurityConfiguration {\n\n\t//DEFAULT_FILTER_NAME = "springSecurityFilterChain"\n\t@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)\n    public Filter springSecurityFilterChain() throws Exception {\n    \t...\n    }\n\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在未使用springboot之前，大多数人都应该对“springSecurityFilterChain”这个名词不会陌生，他是spring security的核心过滤器，是整个认证的入口。在曾经的XML配置中，想要启用spring security，需要在web.xml中进行如下配置：\n\n\x3c!-- Spring Security --\x3e\n<filter>\n    <filter-name>springSecurityFilterChain</filter-name>\n    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n</filter>\n\n<filter-mapping>\n    <filter-name>springSecurityFilterChain</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n而在springboot集成之后，这样的XML被java配置取代。WebSecurityConfiguration中完成了声明springSecurityFilterChain的作用，并且最终交给DelegatingFilterProxy这个代理类，负责拦截请求（注意DelegatingFilterProxy这个类不是spring security包中的，而是存在于web包中，spring使用了代理模式来实现安全过滤的解耦）。\n\n# AuthenticationConfiguration\n\n@Configuration\n@Import(ObjectPostProcessorConfiguration.class)\npublic class AuthenticationConfiguration {\n\n  \t@Bean\n\tpublic AuthenticationManagerBuilder authenticationManagerBuilder(\n\t\t\tObjectPostProcessor<Object> objectPostProcessor) {\n\t\treturn new AuthenticationManagerBuilder(objectPostProcessor);\n\t}\n\n  \tpublic AuthenticationManager getAuthenticationManager() throws Exception {\n    \t...\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nAuthenticationConfiguration的主要任务，便是负责生成全局的身份认证管理者AuthenticationManager。还记得在《Spring Security(一)–Architecture Overview》中，介绍了Spring Security的认证体系，AuthenticationManager便是最核心的身份认证管理器。\n\n\n# 3.3 WebSecurityConfigurerAdapter\n\n适配器模式在spring中被广泛的使用，在配置中使用Adapter的好处便是，我们可以选择性的配置想要修改的那一部分配置，而不用覆盖其他不相关的配置。WebSecurityConfigurerAdapter中我们可以选择自己想要修改的内容，来进行重写，而其提供了三个configure重载方法，是我们主要关心的：\n\n\n\nWebSecurityConfigurerAdapter中的configure\n\n由参数就可以知道，分别是对AuthenticationManagerBuilder，WebSecurity，HttpSecurity进行个性化的配置。\n\n# HttpSecurity常用配置\n\n@Configuration\n@EnableWebSecurity\npublic class CustomWebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeRequests()\n                .antMatchers("/resources/**", "/signup", "/about").permitAll()\n                .antMatchers("/admin/**").hasRole("ADMIN")\n                .antMatchers("/db/**").access("hasRole(\'ADMIN\') and hasRole(\'DBA\')")\n                .anyRequest().authenticated()\n                .and()\n            .formLogin()\n                .usernameParameter("username")\n                .passwordParameter("password")\n                .failureForwardUrl("/login?error")\n                .loginPage("/login")\n                .permitAll()\n                .and()\n            .logout()\n                .logoutUrl("/logout")\n                .logoutSuccessUrl("/index")\n                .permitAll()\n                .and()\n            .httpBasic()\n                .disable();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上述是一个使用Java Configuration配置HttpSecurity的典型配置，其中http作为根开始配置，每一个and()对应了一个模块的配置（等同于xml配置中的结束标签），并且and()返回了HttpSecurity本身，于是可以连续进行配置。他们配置的含义也非常容易通过变量本身来推测，\n\n * authorizeRequests()配置路径拦截，表明路径访问所对应的权限，角色，认证信息。\n * formLogin()对应表单认证相关的配置\n * logout()对应了注销相关的配置\n * httpBasic()可以配置basic登录\n * etc\n\n他们分别代表了http请求相关的安全配置，这些配置项无一例外的返回了Configurer类，而所有的http相关配置可以通过查看HttpSecurity的主要方法得知：\n\nhttp://kirito.iocoder.cn/QQ%E5%9B%BE%E7%89%8720170924223252.png\n\n需要对http协议有一定的了解才能完全掌握所有的配置，不过，springboot和spring security的自动配置已经足够使用了。其中每一项Configurer（e.g.FormLoginConfigurer,CsrfConfigurer）都是HttpConfigurer的细化配置项。\n\n# WebSecurityBuilder\n\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    public void configure(WebSecurity web) throws Exception {\n        web\n            .ignoring()\n            .antMatchers("/resources/**");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n以笔者的经验，这个配置中并不会出现太多的配置信息。\n\n# AuthenticationManagerBuilder\n\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth\n            .inMemoryAuthentication()\n            .withUser("admin").password("admin").roles("USER");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n想要在WebSecurityConfigurerAdapter中进行认证相关的配置，可以使用configure(AuthenticationManagerBuilder auth)暴露一个AuthenticationManager的建造器：AuthenticationManagerBuilder 。如上所示，我们便完成了内存中用户的配置。\n\n细心的朋友会发现，在前面的文章中我们配置内存中的用户时，似乎不是这么配置的，而是：\n\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n        auth\n            .inMemoryAuthentication()\n                .withUser("admin").password("admin").roles("USER");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果你的应用只有唯一一个WebSecurityConfigurerAdapter，那么他们之间的差距可以被忽略，从方法名可以看出两者的区别：使用@Autowired注入的AuthenticationManagerBuilder是全局的身份认证器，作用域可以跨越多个WebSecurityConfigurerAdapter，以及影响到基于Method的安全控制；而 protected configure()的方式则类似于一个匿名内部类，它的作用域局限于一个WebSecurityConfigurerAdapter内部。关于这一点的区别，可以参考我曾经提出的issuespring-security#issues4571。官方文档中，也给出了配置多个WebSecurityConfigurerAdapter的场景以及demo，将在该系列的后续文章中解读。',normalizedContent:'摘要: 原创出处 https://www.cnkirito.moe/spring-security-3/ 「老徐」欢迎转载，保留摘要，谢谢！\n\n * 3 核心配置解读\n\n----------------------------------------\n\n----------------------------------------\n\n上一篇文章《spring security(二)–guides》，通过spring security的配置项了解了spring security是如何保护我们的应用的，本篇文章对上一次的配置做一个分析。\n\n\n# 3 核心配置解读\n\n\n# 3.1 功能介绍\n\n这是spring security入门指南中的配置项：\n\n@configuration\n@enablewebsecurity\npublic class websecurityconfig extends websecurityconfigureradapter {\n\n  @override\n  protected void configure(httpsecurity http) throws exception {\n      http\n          .authorizerequests()\n              .antmatchers("/", "/home").permitall()\n              .anyrequest().authenticated()\n              .and()\n          .formlogin()\n              .loginpage("/login")\n              .permitall()\n              .and()\n          .logout()\n              .permitall();\n  }\n\n  @autowired\n  public void configureglobal(authenticationmanagerbuilder auth) throws exception {\n      auth\n          .inmemoryauthentication()\n              .withuser("admin").password("admin").roles("user");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n当配置了上述的javaconfig之后，我们的应用便具备了如下的功能：\n\n * 除了“/”,”/home”(首页),”/login”(登录),”/logout”(注销),之外，其他路径都需要认证。\n\n * 指定“/login”该路径为登录页面，当未认证的用户尝试访问任何受保护的资源时，都会跳转到“/login”。\n\n * 默认指定“/logout”为注销页面\n\n * 配置一个内存中的用户认证器，使用admin/admin作为用户名和密码，具有user角色\n\n * 防止csrf攻击\n\n * session fixation protection(可以参考我之前讲解spring session的文章，防止别人篡改sessionid)\n\n * security header(添加一系列和header相关的控制)\n   \n   * http strict transport security for secure requests\n   * 集成x-content-type-options\n   * 缓存控制\n   * 集成x-xss-protection\n   * x-frame-options integration to help prevent clickjacking(iframe被默认禁止使用)\n\n * 为servlet api集成了如下的几个方法\n   \n   * httpservletrequest#getremoteuser()\n   * httpservletrequest.html#getuserprincipal()\n   * httpservletrequest.html#isuserinrole(java.lang.string)\n   * [httpservletrequest.html#login(java.lang.string, java.lang.string)](https://docs.oracle.com/javaee/6/api/javax/servlet/http/httpservletrequest.html#login(java.lang.string, java.lang.string))\n   * httpservletrequest.html#logout()\n\n\n# 3.2 @enablewebsecurity\n\n我们自己定义的配置类websecurityconfig加上了@enablewebsecurity注解，同时继承了websecurityconfigureradapter。你可能会在想谁的作用大一点，毫无疑问@enablewebsecurity起到决定性的配置作用，它其实是个组合注解。\n\n@import({ websecurityconfiguration.class, // <2>\n      springwebmvcimportselector.class }) // <1>\n@enableglobalauthentication // <3>\n@configuration\npublic @interface enablewebsecurity {\n   boolean debug() default false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n@import是springboot提供的用于引入外部的配置的注解，可以理解为：@enablewebsecurity注解激活了@import注解中包含的配置类。\n\n<1> springwebmvcimportselector的作用是判断当前的环境是否包含springmvc，因为spring security可以在非spring环境下使用，为了避免dispatcherservlet的重复配置，所以使用了这个注解来区分。\n\n<2> websecurityconfiguration顾名思义，是用来配置web安全的，下面的小节会详细介绍。\n\n<3> @enableglobalauthentication注解的源码如下：\n\n@import(authenticationconfiguration.class)\n@configuration\npublic @interface enableglobalauthentication {\n}\n\n\n1\n2\n3\n4\n\n\n注意点同样在@import之中，它实际上激活了authenticationconfiguration这样的一个配置类，用来配置认证相关的核心类。\n\n也就是说：@enablewebsecurity完成的工作便是加载了websecurityconfiguration，authenticationconfiguration这两个核心配置类，也就此将spring security的职责划分为了配置安全信息，配置认证信息两部分。\n\n# websecurityconfiguration\n\n在这个配置类中，有一个非常重要的bean被注册了。\n\n@configuration\npublic class websecurityconfiguration {\n\n\t//default_filter_name = "springsecurityfilterchain"\n\t@bean(name = abstractsecuritywebapplicationinitializer.default_filter_name)\n    public filter springsecurityfilterchain() throws exception {\n    \t...\n    }\n\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在未使用springboot之前，大多数人都应该对“springsecurityfilterchain”这个名词不会陌生，他是spring security的核心过滤器，是整个认证的入口。在曾经的xml配置中，想要启用spring security，需要在web.xml中进行如下配置：\n\n\x3c!-- spring security --\x3e\n<filter>\n    <filter-name>springsecurityfilterchain</filter-name>\n    <filter-class>org.springframework.web.filter.delegatingfilterproxy</filter-class>\n</filter>\n\n<filter-mapping>\n    <filter-name>springsecurityfilterchain</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n而在springboot集成之后，这样的xml被java配置取代。websecurityconfiguration中完成了声明springsecurityfilterchain的作用，并且最终交给delegatingfilterproxy这个代理类，负责拦截请求（注意delegatingfilterproxy这个类不是spring security包中的，而是存在于web包中，spring使用了代理模式来实现安全过滤的解耦）。\n\n# authenticationconfiguration\n\n@configuration\n@import(objectpostprocessorconfiguration.class)\npublic class authenticationconfiguration {\n\n  \t@bean\n\tpublic authenticationmanagerbuilder authenticationmanagerbuilder(\n\t\t\tobjectpostprocessor<object> objectpostprocessor) {\n\t\treturn new authenticationmanagerbuilder(objectpostprocessor);\n\t}\n\n  \tpublic authenticationmanager getauthenticationmanager() throws exception {\n    \t...\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nauthenticationconfiguration的主要任务，便是负责生成全局的身份认证管理者authenticationmanager。还记得在《spring security(一)–architecture overview》中，介绍了spring security的认证体系，authenticationmanager便是最核心的身份认证管理器。\n\n\n# 3.3 websecurityconfigureradapter\n\n适配器模式在spring中被广泛的使用，在配置中使用adapter的好处便是，我们可以选择性的配置想要修改的那一部分配置，而不用覆盖其他不相关的配置。websecurityconfigureradapter中我们可以选择自己想要修改的内容，来进行重写，而其提供了三个configure重载方法，是我们主要关心的：\n\n\n\nwebsecurityconfigureradapter中的configure\n\n由参数就可以知道，分别是对authenticationmanagerbuilder，websecurity，httpsecurity进行个性化的配置。\n\n# httpsecurity常用配置\n\n@configuration\n@enablewebsecurity\npublic class customwebsecurityconfig extends websecurityconfigureradapter {\n\n    @override\n    protected void configure(httpsecurity http) throws exception {\n        http\n            .authorizerequests()\n                .antmatchers("/resources/**", "/signup", "/about").permitall()\n                .antmatchers("/admin/**").hasrole("admin")\n                .antmatchers("/db/**").access("hasrole(\'admin\') and hasrole(\'dba\')")\n                .anyrequest().authenticated()\n                .and()\n            .formlogin()\n                .usernameparameter("username")\n                .passwordparameter("password")\n                .failureforwardurl("/login?error")\n                .loginpage("/login")\n                .permitall()\n                .and()\n            .logout()\n                .logouturl("/logout")\n                .logoutsuccessurl("/index")\n                .permitall()\n                .and()\n            .httpbasic()\n                .disable();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上述是一个使用java configuration配置httpsecurity的典型配置，其中http作为根开始配置，每一个and()对应了一个模块的配置（等同于xml配置中的结束标签），并且and()返回了httpsecurity本身，于是可以连续进行配置。他们配置的含义也非常容易通过变量本身来推测，\n\n * authorizerequests()配置路径拦截，表明路径访问所对应的权限，角色，认证信息。\n * formlogin()对应表单认证相关的配置\n * logout()对应了注销相关的配置\n * httpbasic()可以配置basic登录\n * etc\n\n他们分别代表了http请求相关的安全配置，这些配置项无一例外的返回了configurer类，而所有的http相关配置可以通过查看httpsecurity的主要方法得知：\n\nhttp://kirito.iocoder.cn/qq%e5%9b%be%e7%89%8720170924223252.png\n\n需要对http协议有一定的了解才能完全掌握所有的配置，不过，springboot和spring security的自动配置已经足够使用了。其中每一项configurer（e.g.formloginconfigurer,csrfconfigurer）都是httpconfigurer的细化配置项。\n\n# websecuritybuilder\n\n@configuration\n@enablewebsecurity\npublic class websecurityconfig extends websecurityconfigureradapter {\n    @override\n    public void configure(websecurity web) throws exception {\n        web\n            .ignoring()\n            .antmatchers("/resources/**");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n以笔者的经验，这个配置中并不会出现太多的配置信息。\n\n# authenticationmanagerbuilder\n\n@configuration\n@enablewebsecurity\npublic class websecurityconfig extends websecurityconfigureradapter {\n\n    @override\n    protected void configure(authenticationmanagerbuilder auth) throws exception {\n        auth\n            .inmemoryauthentication()\n            .withuser("admin").password("admin").roles("user");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n想要在websecurityconfigureradapter中进行认证相关的配置，可以使用configure(authenticationmanagerbuilder auth)暴露一个authenticationmanager的建造器：authenticationmanagerbuilder 。如上所示，我们便完成了内存中用户的配置。\n\n细心的朋友会发现，在前面的文章中我们配置内存中的用户时，似乎不是这么配置的，而是：\n\n@configuration\n@enablewebsecurity\npublic class websecurityconfig extends websecurityconfigureradapter {\n\n    @autowired\n    public void configureglobal(authenticationmanagerbuilder auth) throws exception {\n        auth\n            .inmemoryauthentication()\n                .withuser("admin").password("admin").roles("user");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果你的应用只有唯一一个websecurityconfigureradapter，那么他们之间的差距可以被忽略，从方法名可以看出两者的区别：使用@autowired注入的authenticationmanagerbuilder是全局的身份认证器，作用域可以跨越多个websecurityconfigureradapter，以及影响到基于method的安全控制；而 protected configure()的方式则类似于一个匿名内部类，它的作用域局限于一个websecurityconfigureradapter内部。关于这一点的区别，可以参考我曾经提出的issuespring-security#issues4571。官方文档中，也给出了配置多个websecurityconfigureradapter的场景以及demo，将在该系列的后续文章中解读。',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"【老徐】Spring Security(四) —— 核心过滤器源码分析",frontmatter:{title:"【老徐】Spring Security(四) —— 核心过滤器源码分析",date:"2022-02-03T00:03:27.000Z",permalink:"/pages/bb2ce5/",categories:["后端","Spring Security"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/25.Spring%20Security/04.%E3%80%90%E8%80%81%E5%BE%90%E3%80%91Spring%20Security(%E5%9B%9B)%20%E2%80%94%E2%80%94%20%E6%A0%B8%E5%BF%83%E8%BF%87%E6%BB%A4%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html",relativePath:"10.框架/25.Spring Security/04.【老徐】Spring Security(四) —— 核心过滤器源码分析.md",key:"v-30695d13",path:"/pages/bb2ce5/",headers:[{level:2,title:"4 过滤器详解",slug:"_4-过滤器详解",normalizedTitle:"4 过滤器详解",charIndex:75},{level:3,title:"4.1 核心过滤器概述",slug:"_4-1-核心过滤器概述",normalizedTitle:"4.1 核心过滤器概述",charIndex:345},{level:3,title:"4.2 SecurityContextPersistenceFilter",slug:"_4-2-securitycontextpersistencefilter",normalizedTitle:"4.2 securitycontextpersistencefilter",charIndex:2831},{level:3,title:"4.3 UsernamePasswordAuthenticationFilter",slug:"_4-3-usernamepasswordauthenticationfilter",normalizedTitle:"4.3 usernamepasswordauthenticationfilter",charIndex:8105},{level:3,title:"4.4 AnonymousAuthenticationFilter",slug:"_4-4-anonymousauthenticationfilter",normalizedTitle:"4.4 anonymousauthenticationfilter",charIndex:11442},{level:3,title:"4.5 ExceptionTranslationFilter",slug:"_4-5-exceptiontranslationfilter",normalizedTitle:"4.5 exceptiontranslationfilter",charIndex:14196},{level:3,title:"4.6 FilterSecurityInterceptor",slug:"_4-6-filtersecurityinterceptor",normalizedTitle:"4.6 filtersecurityinterceptor",charIndex:18631},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:19866}],headersStr:"4 过滤器详解 4.1 核心过滤器概述 4.2 SecurityContextPersistenceFilter 4.3 UsernamePasswordAuthenticationFilter 4.4 AnonymousAuthenticationFilter 4.5 ExceptionTranslationFilter 4.6 FilterSecurityInterceptor 总结",content:'摘要: 原创出处 https://www.cnkirito.moe/spring-security-4/ 「老徐」欢迎转载，保留摘要，谢谢！\n\n * 4 过滤器详解\n\n----------------------------------------\n\n----------------------------------------\n\n前面的部分，我们关注了Spring Security是如何完成认证工作的，但是另外一部分核心的内容：过滤器，一直没有提到，我们已经知道Spring Security使用了springSecurityFilterChain作为了安全过滤的入口，这一节主要分析一下这个过滤器链都包含了哪些关键的过滤器，并且各自的使命是什么。\n\n\n# 4 过滤器详解\n\n\n# 4.1 核心过滤器概述\n\n由于过滤器链路中的过滤较多，即使是Spring Security的官方文档中也并未对所有的过滤器进行介绍，在之前，《Spring Security(二)–Guides》入门指南中我们配置了一个表单登录的demo，以此为例，来看看这过程中Spring Security都帮我们自动配置了哪些过滤器。\n\nCreating filter chain: o.s.s.web.util.matcher.AnyRequestMatcher@1,\n[o.s.s.web.context.SecurityContextPersistenceFilter@8851ce1,\no.s.s.web.header.HeaderWriterFilter@6a472566, o.s.s.web.csrf.CsrfFilter@61cd1c71,\no.s.s.web.authentication.logout.LogoutFilter@5e1d03d7,\no.s.s.web.authentication.UsernamePasswordAuthenticationFilter@122d6c22,\no.s.s.web.savedrequest.RequestCacheAwareFilter@5ef6fd7f,\no.s.s.web.servletapi.SecurityContextHolderAwareRequestFilter@4beaf6bd,\no.s.s.web.authentication.AnonymousAuthenticationFilter@6edcad64,\no.s.s.web.session.SessionManagementFilter@5e65afb6,\no.s.s.web.access.ExceptionTranslationFilter@5b9396d3,\no.s.s.web.access.intercept.FilterSecurityInterceptor@3c5dbdf8\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上述的log信息是我从springboot启动的日志中CV所得，spring security的过滤器日志有一个特点：log打印顺序与实际配置顺序符合，也就意味着SecurityContextPersistenceFilter是整个过滤器链的第一个过滤器，而FilterSecurityInterceptor则是末置的过滤器。另外通过观察过滤器的名称，和所在的包名，可以大致地分析出他们各自的作用，如UsernamePasswordAuthenticationFilter明显便是与使用用户名和密码登录相关的过滤器，而FilterSecurityInterceptor我们似乎看不出它的作用，但是其位于web.access包下，大致可以分析出他与访问限制相关。第四篇文章主要就是介绍这些常用的过滤器，对其中关键的过滤器进行一些源码分析。先大致介绍下每个过滤器的作用：\n\n * SecurityContextPersistenceFilter 两个主要职责：请求来临时，创建SecurityContext安全上下文信息，请求结束时清空SecurityContextHolder。\n * HeaderWriterFilter (文档中并未介绍，非核心过滤器) 用来给http响应添加一些Header,比如X-Frame-Options, X-XSS-Protection*，X-Content-Type-Options.\n * CsrfFilter 在spring4这个版本中被默认开启的一个过滤器，用于防止csrf攻击，了解前后端分离的人一定不会对这个攻击方式感到陌生，前后端使用json交互需要注意的一个问题。\n * LogoutFilter 顾名思义，处理注销的过滤器\n * UsernamePasswordAuthenticationFilter 这个会重点分析，表单提交了username和password，被封装成token进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。\n * RequestCacheAwareFilter (文档中并未介绍，非核心过滤器) 内部维护了一个RequestCache，用于缓存request请求\n * SecurityContextHolderAwareRequestFilter 此过滤器对ServletRequest进行了一次包装，使得request具有更加丰富的API\n * AnonymousAuthenticationFilter 匿名身份过滤器，这个过滤器个人认为很重要，需要将它与UsernamePasswordAuthenticationFilter 放在一起比较理解，spring security为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。\n * SessionManagementFilter 和session相关的过滤器，内部维护了一个SessionAuthenticationStrategy，两者组合使用，常用来防止session-fixation protection attack，以及限制同一用户开启多个会话的数量\n * ExceptionTranslationFilter 直译成异常翻译过滤器，还是比较形象的，这个过滤器本身不处理异常，而是将认证过程中出现的异常交给内部维护的一些类去处理，具体是那些类下面详细介绍\n * FilterSecurityInterceptor 这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的。\n\n其中加粗的过滤器可以被认为是Spring Security的核心过滤器，将在下面，一个过滤器对应一个小节来讲解。\n\n\n# 4.2 SecurityContextPersistenceFilter\n\n试想一下，如果我们不使用Spring Security，如果保存用户信息呢，大多数情况下会考虑使用Session对吧？在Spring Security中也是如此，用户在登录过一次之后，后续的访问便是通过sessionId来识别，从而认为用户已经被认证。具体在何处存放用户信息，便是第一篇文章中提到的SecurityContextHolder；认证相关的信息是如何被存放到其中的，便是通过SecurityContextPersistenceFilter。在4.1概述中也提到了，SecurityContextPersistenceFilter的两个主要作用便是请求来临时，创建SecurityContext安全上下文信息和请求结束时清空SecurityContextHolder。顺带提一下：微服务的一个设计理念需要实现服务通信的无状态，而http协议中的无状态意味着不允许存在session，这可以通过setAllowSessionCreation(false) 实现，这并不意味着SecurityContextPersistenceFilter变得无用，因为它还需要负责清除用户信息。在Spring Security中，虽然安全上下文信息被存储于Session中，但我们在实际使用中不应该直接操作Session，而应当使用SecurityContextHolder。\n\n# 源码分析\n\norg.springframework.security.web.context.SecurityContextPersistenceFilter\npublic class SecurityContextPersistenceFilter extends GenericFilterBean {\n\n   static final String FILTER_APPLIED = "__spring_security_scpf_applied";\n   //安全上下文存储的仓库\n   private SecurityContextRepository repo;\n\n   public SecurityContextPersistenceFilter() {\n      //HttpSessionSecurityContextRepository是SecurityContextRepository接口的一个实现类\n      //使用HttpSession来存储SecurityContext\n      this(new HttpSessionSecurityContextRepository());\n   }\n\n   public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)\n         throws IOException, ServletException {\n      HttpServletRequest request = (HttpServletRequest) req;\n      HttpServletResponse response = (HttpServletResponse) res;\n\n      if (request.getAttribute(FILTER_APPLIED) != null) {\n         // ensure that filter is only applied once per request\n         chain.doFilter(request, response);\n         return;\n      }\n      request.setAttribute(FILTER_APPLIED, Boolean.TRUE);\n      //包装request，response\n      HttpRequestResponseHolder holder = new HttpRequestResponseHolder(request,\n            response);\n      //从Session中获取安全上下文信息\n      SecurityContext contextBeforeChainExecution = repo.loadContext(holder);\n      try {\n         //请求开始时，设置安全上下文信息，这样就避免了用户直接从Session中获取安全上下文信息\n         SecurityContextHolder.setContext(contextBeforeChainExecution);\n         chain.doFilter(holder.getRequest(), holder.getResponse());\n      }\n      finally {\n         //请求结束后，清空安全上下文信息\n         SecurityContext contextAfterChainExecution = SecurityContextHolder\n               .getContext();\n         SecurityContextHolder.clearContext();\n         repo.saveContext(contextAfterChainExecution, holder.getRequest(),\n               holder.getResponse());\n         request.removeAttribute(FILTER_APPLIED);\n         if (debug) {\n            logger.debug("SecurityContextHolder now cleared, as request processing completed");\n         }\n      }\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n过滤器一般负责核心的处理流程，而具体的业务实现，通常交给其中聚合的其他实体类，这在Filter的设计中很常见，同时也符合职责分离模式。例如存储安全上下文和读取安全上下文的工作完全委托给了HttpSessionSecurityContextRepository去处理，而这个类中也有几个方法可以稍微解读下，方便我们理解内部的工作流程\n\norg.springframework.security.web.context.HttpSessionSecurityContextRepository\npublic class HttpSessionSecurityContextRepository implements SecurityContextRepository {\n   // \'SPRING_SECURITY_CONTEXT\'是安全上下文默认存储在Session中的键值\n   public static final String SPRING_SECURITY_CONTEXT_KEY = "SPRING_SECURITY_CONTEXT";\n   ...\n   private final Object contextObject = SecurityContextHolder.createEmptyContext();\n   private boolean allowSessionCreation = true;\n   private boolean disableUrlRewriting = false;\n   private String springSecurityContextKey = SPRING_SECURITY_CONTEXT_KEY;\n\n   private AuthenticationTrustResolver trustResolver = new AuthenticationTrustResolverImpl();\n\n   //从当前request中取出安全上下文，如果session为空，则会返回一个新的安全上下文\n   public SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder) {\n      HttpServletRequest request = requestResponseHolder.getRequest();\n      HttpServletResponse response = requestResponseHolder.getResponse();\n      HttpSession httpSession = request.getSession(false);\n      SecurityContext context = readSecurityContextFromSession(httpSession);\n      if (context == null) {\n         context = generateNewContext();\n      }\n      ...\n      return context;\n   }\n\n   ...\n\n   public boolean containsContext(HttpServletRequest request) {\n      HttpSession session = request.getSession(false);\n      if (session == null) {\n         return false;\n      }\n      return session.getAttribute(springSecurityContextKey) != null;\n   }\n\n   private SecurityContext readSecurityContextFromSession(HttpSession httpSession) {\n      if (httpSession == null) {\n         return null;\n      }\n      ...\n      // Session存在的情况下，尝试获取其中的SecurityContext\n      Object contextFromSession = httpSession.getAttribute(springSecurityContextKey);\n      if (contextFromSession == null) {\n         return null;\n      }\n      ...\n      return (SecurityContext) contextFromSession;\n   }\n\n   //初次请求时创建一个新的SecurityContext实例\n   protected SecurityContext generateNewContext() {\n      return SecurityContextHolder.createEmptyContext();\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\nSecurityContextPersistenceFilter和HttpSessionSecurityContextRepository配合使用，构成了Spring Security整个调用链路的入口，为什么将它放在最开始的地方也是显而易见的，后续的过滤器中大概率会依赖Session信息和安全上下文信息。\n\n\n# 4.3 UsernamePasswordAuthenticationFilter\n\n表单认证是最常用的一个认证方式，一个最直观的业务场景便是允许用户在表单中输入用户名和密码进行登录，而这背后的UsernamePasswordAuthenticationFilter，在整个Spring Security的认证体系中则扮演着至关重要的角色。\n\nhttp://kirito.iocoder.cn/2011121410543010.jpg\n\n上述的时序图，可以看出UsernamePasswordAuthenticationFilter主要肩负起了调用身份认证器，校验身份的作用，至于认证的细节，在前面几章花了很大篇幅进行了介绍，到这里，其实Spring Security的基本流程就已经走通了。\n\n# 源码分析\n\norg.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter#attemptAuthentication\npublic Authentication attemptAuthentication(HttpServletRequest request,\n      HttpServletResponse response) throws AuthenticationException {\n   //获取表单中的用户名和密码\n   String username = obtainUsername(request);\n   String password = obtainPassword(request);\n   ...\n   username = username.trim();\n   //组装成username+password形式的token\n   UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(\n         username, password);\n   // Allow subclasses to set the "details" property\n   setDetails(request, authRequest);\n   //交给内部的AuthenticationManager去认证，并返回认证信息\n   return this.getAuthenticationManager().authenticate(authRequest);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nUsernamePasswordAuthenticationFilter本身的代码只包含了上述这么一个方法，非常简略，而在其父类AbstractAuthenticationProcessingFilter中包含了大量的细节，值得我们分析：\n\npublic abstract class AbstractAuthenticationProcessingFilter extends GenericFilterBean\n      implements ApplicationEventPublisherAware, MessageSourceAware {\n\t//包含了一个身份认证器\n\tprivate AuthenticationManager authenticationManager;\n\t//用于实现remeberMe\n\tprivate RememberMeServices rememberMeServices = new NullRememberMeServices();\n\tprivate RequestMatcher requiresAuthenticationRequestMatcher;\n\t//这两个Handler很关键，分别代表了认证成功和失败相应的处理器\n\tprivate AuthenticationSuccessHandler successHandler = new SavedRequestAwareAuthenticationSuccessHandler();\n\tprivate AuthenticationFailureHandler failureHandler = new SimpleUrlAuthenticationFailureHandler();\n\n\tpublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n\n\t\tHttpServletRequest request = (HttpServletRequest) req;\n\t\tHttpServletResponse response = (HttpServletResponse) res;\n\t\t...\n\t\tAuthentication authResult;\n\t\ttry {\n\t\t\t//此处实际上就是调用UsernamePasswordAuthenticationFilter的attemptAuthentication方法\n\t\t\tauthResult = attemptAuthentication(request, response);\n\t\t\tif (authResult == null) {\n\t\t\t\t//子类未完成认证，立刻返回\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsessionStrategy.onAuthentication(authResult, request, response);\n\t\t}\n\t\t//在认证过程中可以直接抛出异常，在过滤器中，就像此处一样，进行捕获\n\t\tcatch (InternalAuthenticationServiceException failed) {\n\t\t\t//内部服务异常\n\t\t\tunsuccessfulAuthentication(request, response, failed);\n\t\t\treturn;\n\t\t}\n\t\tcatch (AuthenticationException failed) {\n\t\t\t//认证失败\n\t\t\tunsuccessfulAuthentication(request, response, failed);\n\t\t\treturn;\n\t\t}\n\t\t//认证成功\n\t\tif (continueChainBeforeSuccessfulAuthentication) {\n\t\t\tchain.doFilter(request, response);\n\t\t}\n\t\t//注意，认证成功后过滤器把authResult结果也传递给了成功处理器\n\t\tsuccessfulAuthentication(request, response, chain, authResult);\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n整个流程理解起来也并不难，主要就是内部调用了authenticationManager完成认证，根据认证结果执行successfulAuthentication或者unsuccessfulAuthentication，无论成功失败，一般的实现都是转发或者重定向等处理，不再细究AuthenticationSuccessHandler和AuthenticationFailureHandler，有兴趣的朋友，可以去看看两者的实现类。\n\n\n# 4.4 AnonymousAuthenticationFilter\n\n匿名认证过滤器，可能有人会想：匿名了还有身份？我自己对于Anonymous匿名身份的理解是Spirng Security为了整体逻辑的统一性，即使是未通过认证的用户，也给予了一个匿名身份。而AnonymousAuthenticationFilter该过滤器的位置也是非常的科学的，它位于常用的身份认证过滤器（如UsernamePasswordAuthenticationFilter、BasicAuthenticationFilter、RememberMeAuthenticationFilter）之后，意味着只有在上述身份过滤器执行完毕后，SecurityContext依旧没有用户信息，AnonymousAuthenticationFilter该过滤器才会有意义—-基于用户一个匿名身份。\n\n# 源码分析\n\norg.springframework.security.web.authentication.AnonymousAuthenticationFilter\npublic class AnonymousAuthenticationFilter extends GenericFilterBean implements\n      InitializingBean {\n\n   private AuthenticationDetailsSource<HttpServletRequest, ?> authenticationDetailsSource = new WebAuthenticationDetailsSource();\n   private String key;\n   private Object principal;\n   private List<GrantedAuthority> authorities;\n\n\n   //自动创建一个"anonymousUser"的匿名用户,其具有ANONYMOUS角色\n   public AnonymousAuthenticationFilter(String key) {\n      this(key, "anonymousUser", AuthorityUtils.createAuthorityList("ROLE_ANONYMOUS"));\n   }\n\n   /**\n    *\n    * @param key key用来识别该过滤器创建的身份\n    * @param principal principal代表匿名用户的身份\n    * @param authorities authorities代表匿名用户的权限集合\n    */\n   public AnonymousAuthenticationFilter(String key, Object principal,\n         List<GrantedAuthority> authorities) {\n      Assert.hasLength(key, "key cannot be null or empty");\n      Assert.notNull(principal, "Anonymous authentication principal must be set");\n      Assert.notNull(authorities, "Anonymous authorities must be set");\n      this.key = key;\n      this.principal = principal;\n      this.authorities = authorities;\n   }\n\n   ...\n\n   public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)\n         throws IOException, ServletException {\n      //过滤器链都执行到匿名认证过滤器这儿了还没有身份信息，塞一个匿名身份进去\n      if (SecurityContextHolder.getContext().getAuthentication() == null) {\n         SecurityContextHolder.getContext().setAuthentication(\n               createAuthentication((HttpServletRequest) req));\n      }\n      chain.doFilter(req, res);\n   }\n\n   protected Authentication createAuthentication(HttpServletRequest request) {\n     //创建一个AnonymousAuthenticationToken\n      AnonymousAuthenticationToken auth = new AnonymousAuthenticationToken(key,\n            principal, authorities);\n      auth.setDetails(authenticationDetailsSource.buildDetails(request));\n\n      return auth;\n   }\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n其实对比AnonymousAuthenticationFilter和UsernamePasswordAuthenticationFilter就可以发现一些门道了，UsernamePasswordAuthenticationToken对应AnonymousAuthenticationToken，他们都是Authentication的实现类，而Authentication则是被SecurityContextHolder(SecurityContext)持有的，一切都被串联在了一起。\n\n\n# 4.5 ExceptionTranslationFilter\n\nExceptionTranslationFilter异常转换过滤器位于整个springSecurityFilterChain的后方，用来转换整个链路中出现的异常，将其转化，顾名思义，转化以意味本身并不处理。一般其只处理两大类异常：AccessDeniedException访问异常和AuthenticationException认证异常。\n\n这个过滤器非常重要，因为它将Java中的异常和HTTP的响应连接在了一起，这样在处理异常时，我们不用考虑密码错误该跳到什么页面，账号锁定该如何，只需要关注自己的业务逻辑，抛出相应的异常便可。如果该过滤器检测到AuthenticationException，则将会交给内部的AuthenticationEntryPoint去处理，如果检测到AccessDeniedException，需要先判断当前用户是不是匿名用户，如果是匿名访问，则和前面一样运行AuthenticationEntryPoint，否则会委托给AccessDeniedHandler去处理，而AccessDeniedHandler的默认实现，是AccessDeniedHandlerImpl。所以ExceptionTranslationFilter内部的AuthenticationEntryPoint是至关重要的，顾名思义：认证的入口点。\n\n# 源码分析\n\npublic class ExceptionTranslationFilter extends GenericFilterBean {\n  //处理异常转换的核心方法\n  private void handleSpringSecurityException(HttpServletRequest request,\n        HttpServletResponse response, FilterChain chain, RuntimeException exception)\n        throws IOException, ServletException {\n     if (exception instanceof AuthenticationException) {\n       \t//重定向到登录端点\n        sendStartAuthentication(request, response, chain,\n              (AuthenticationException) exception);\n     }\n     else if (exception instanceof AccessDeniedException) {\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        if (authenticationTrustResolver.isAnonymous(authentication) || authenticationTrustResolver.isRememberMe(authentication)) {\n\t\t  //重定向到登录端点\n           sendStartAuthentication(\n                 request,\n                 response,\n                 chain,\n                 new InsufficientAuthenticationException(\n                       "Full authentication is required to access this resource"));\n        }\n        else {\n           //交给accessDeniedHandler处理\n           accessDeniedHandler.handle(request, response,\n                 (AccessDeniedException) exception);\n        }\n     }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n剩下的便是要搞懂AuthenticationEntryPoint和AccessDeniedHandler就可以了。\n\nAuthenticationEntryPoint\n\n选择了几个常用的登录端点，以其中第一个为例来介绍，看名字就能猜到是认证失败之后，让用户跳转到登录页面。还记得我们一开始怎么配置表单登录页面的吗？\n\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeRequests()\n                .antMatchers("/", "/home").permitAll()\n                .anyRequest().authenticated()\n                .and()\n            .formLogin()//FormLoginConfigurer\n                .loginPage("/login")\n                .permitAll()\n                .and()\n            .logout()\n                .permitAll();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n我们顺着formLogin返回的FormLoginConfigurer往下找，看看能发现什么，最终在FormLoginConfigurer的父类AbstractAuthenticationFilterConfigurer中有了不小的收获：\n\npublic abstract class AbstractAuthenticationFilterConfigurer extends ...{\n   ...\n   //formLogin不出所料配置了AuthenticationEntryPoint\n   private LoginUrlAuthenticationEntryPoint authenticationEntryPoint;\n   //认证失败的处理器\n   private AuthenticationFailureHandler failureHandler;\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n具体如何配置的就不看了，我们得出了结论，formLogin()配置了之后最起码做了两件事，其一，为UsernamePasswordAuthenticationFilter设置了相关的配置，其二配置了AuthenticationEntryPoint。\n\n登录端点还有Http401AuthenticationEntryPoint，Http403ForbiddenEntryPoint这些都是很简单的实现，有时候我们访问受限页面，又没有配置登录，就看到了一个空荡荡的默认错误页面，上面显示着401,403，就是这两个入口起了作用。\n\n还剩下一个AccessDeniedHandler访问决策器未被讲解，简单提一下：AccessDeniedHandlerImpl这个默认实现类会根据errorPage和状态码来判断，最终决定跳转的页面\n\norg.springframework.security.web.access.AccessDeniedHandlerImpl#handle\npublic void handle(HttpServletRequest request, HttpServletResponse response,\n      AccessDeniedException accessDeniedException) throws IOException,\n      ServletException {\n   if (!response.isCommitted()) {\n      if (errorPage != null) {\n         // Put exception into request scope (perhaps of use to a view)\n         request.setAttribute(WebAttributes.ACCESS_DENIED_403,\n               accessDeniedException);\n         // Set the 403 status code.\n         response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n         // forward to error page.\n         RequestDispatcher dispatcher = request.getRequestDispatcher(errorPage);\n         dispatcher.forward(request, response);\n      }\n      else {\n         response.sendError(HttpServletResponse.SC_FORBIDDEN,\n               accessDeniedException.getMessage());\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4.6 FilterSecurityInterceptor\n\n想想整个认证安全控制流程还缺了什么？我们已经有了认证，有了请求的封装，有了Session的关联…还缺一个：由什么控制哪些资源是受限的，这些受限的资源需要什么权限，需要什么角色…这一切和访问控制相关的操作，都是由FilterSecurityInterceptor完成的。\n\nFilterSecurityInterceptor的工作流程用笔者的理解可以理解如下：FilterSecurityInterceptor从SecurityContextHolder中获取Authentication对象，然后比对用户拥有的权限和资源所需的权限。前者可以通过Authentication对象直接获得，而后者则需要引入我们之前一直未提到过的两个类：SecurityMetadataSource，AccessDecisionManager。理解清楚决策管理器的整个创建流程和SecurityMetadataSource的作用需要花很大一笔功夫，这里，暂时只介绍其大概的作用。\n\n在JavaConfig的配置中，我们通常如下配置路径的访问控制：\n\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n\thttp\n\t\t.authorizeRequests()\n\t\t\t.antMatchers("/resources/**", "/signup", "/about").permitAll()\n             .antMatchers("/admin/**").hasRole("ADMIN")\n             .antMatchers("/db/**").access("hasRole(\'ADMIN\') and hasRole(\'DBA\')")\n             .anyRequest().authenticated()\n\t\t\t.withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\n\t\t\t\tpublic <O extends FilterSecurityInterceptor> O postProcess(\n\t\t\t\t\t\tO fsi) {\n\t\t\t\t\tfsi.setPublishAuthorizationSuccess(true);\n\t\t\t\t\treturn fsi;\n\t\t\t\t}\n\t\t\t});\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n在ObjectPostProcessor的泛型中看到了FilterSecurityInterceptor，以笔者的经验，目前并没有太多机会需要修改FilterSecurityInterceptor的配置。\n\n\n# 总结\n\n本篇文章在介绍过滤器时，顺便进行了一些源码的分析，目的是方便理解整个Spring Security的工作流。伴随着整个过滤器链的介绍，安全框架的轮廓应该已经浮出水面了，下面的章节，主要打算通过自定义一些需求，再次分析其他组件的源码，学习应该如何改造Spring Security，为我们所用。',normalizedContent:'摘要: 原创出处 https://www.cnkirito.moe/spring-security-4/ 「老徐」欢迎转载，保留摘要，谢谢！\n\n * 4 过滤器详解\n\n----------------------------------------\n\n----------------------------------------\n\n前面的部分，我们关注了spring security是如何完成认证工作的，但是另外一部分核心的内容：过滤器，一直没有提到，我们已经知道spring security使用了springsecurityfilterchain作为了安全过滤的入口，这一节主要分析一下这个过滤器链都包含了哪些关键的过滤器，并且各自的使命是什么。\n\n\n# 4 过滤器详解\n\n\n# 4.1 核心过滤器概述\n\n由于过滤器链路中的过滤较多，即使是spring security的官方文档中也并未对所有的过滤器进行介绍，在之前，《spring security(二)–guides》入门指南中我们配置了一个表单登录的demo，以此为例，来看看这过程中spring security都帮我们自动配置了哪些过滤器。\n\ncreating filter chain: o.s.s.web.util.matcher.anyrequestmatcher@1,\n[o.s.s.web.context.securitycontextpersistencefilter@8851ce1,\no.s.s.web.header.headerwriterfilter@6a472566, o.s.s.web.csrf.csrffilter@61cd1c71,\no.s.s.web.authentication.logout.logoutfilter@5e1d03d7,\no.s.s.web.authentication.usernamepasswordauthenticationfilter@122d6c22,\no.s.s.web.savedrequest.requestcacheawarefilter@5ef6fd7f,\no.s.s.web.servletapi.securitycontextholderawarerequestfilter@4beaf6bd,\no.s.s.web.authentication.anonymousauthenticationfilter@6edcad64,\no.s.s.web.session.sessionmanagementfilter@5e65afb6,\no.s.s.web.access.exceptiontranslationfilter@5b9396d3,\no.s.s.web.access.intercept.filtersecurityinterceptor@3c5dbdf8\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上述的log信息是我从springboot启动的日志中cv所得，spring security的过滤器日志有一个特点：log打印顺序与实际配置顺序符合，也就意味着securitycontextpersistencefilter是整个过滤器链的第一个过滤器，而filtersecurityinterceptor则是末置的过滤器。另外通过观察过滤器的名称，和所在的包名，可以大致地分析出他们各自的作用，如usernamepasswordauthenticationfilter明显便是与使用用户名和密码登录相关的过滤器，而filtersecurityinterceptor我们似乎看不出它的作用，但是其位于web.access包下，大致可以分析出他与访问限制相关。第四篇文章主要就是介绍这些常用的过滤器，对其中关键的过滤器进行一些源码分析。先大致介绍下每个过滤器的作用：\n\n * securitycontextpersistencefilter 两个主要职责：请求来临时，创建securitycontext安全上下文信息，请求结束时清空securitycontextholder。\n * headerwriterfilter (文档中并未介绍，非核心过滤器) 用来给http响应添加一些header,比如x-frame-options, x-xss-protection*，x-content-type-options.\n * csrffilter 在spring4这个版本中被默认开启的一个过滤器，用于防止csrf攻击，了解前后端分离的人一定不会对这个攻击方式感到陌生，前后端使用json交互需要注意的一个问题。\n * logoutfilter 顾名思义，处理注销的过滤器\n * usernamepasswordauthenticationfilter 这个会重点分析，表单提交了username和password，被封装成token进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。\n * requestcacheawarefilter (文档中并未介绍，非核心过滤器) 内部维护了一个requestcache，用于缓存request请求\n * securitycontextholderawarerequestfilter 此过滤器对servletrequest进行了一次包装，使得request具有更加丰富的api\n * anonymousauthenticationfilter 匿名身份过滤器，这个过滤器个人认为很重要，需要将它与usernamepasswordauthenticationfilter 放在一起比较理解，spring security为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。\n * sessionmanagementfilter 和session相关的过滤器，内部维护了一个sessionauthenticationstrategy，两者组合使用，常用来防止session-fixation protection attack，以及限制同一用户开启多个会话的数量\n * exceptiontranslationfilter 直译成异常翻译过滤器，还是比较形象的，这个过滤器本身不处理异常，而是将认证过程中出现的异常交给内部维护的一些类去处理，具体是那些类下面详细介绍\n * filtersecurityinterceptor 这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的。\n\n其中加粗的过滤器可以被认为是spring security的核心过滤器，将在下面，一个过滤器对应一个小节来讲解。\n\n\n# 4.2 securitycontextpersistencefilter\n\n试想一下，如果我们不使用spring security，如果保存用户信息呢，大多数情况下会考虑使用session对吧？在spring security中也是如此，用户在登录过一次之后，后续的访问便是通过sessionid来识别，从而认为用户已经被认证。具体在何处存放用户信息，便是第一篇文章中提到的securitycontextholder；认证相关的信息是如何被存放到其中的，便是通过securitycontextpersistencefilter。在4.1概述中也提到了，securitycontextpersistencefilter的两个主要作用便是请求来临时，创建securitycontext安全上下文信息和请求结束时清空securitycontextholder。顺带提一下：微服务的一个设计理念需要实现服务通信的无状态，而http协议中的无状态意味着不允许存在session，这可以通过setallowsessioncreation(false) 实现，这并不意味着securitycontextpersistencefilter变得无用，因为它还需要负责清除用户信息。在spring security中，虽然安全上下文信息被存储于session中，但我们在实际使用中不应该直接操作session，而应当使用securitycontextholder。\n\n# 源码分析\n\norg.springframework.security.web.context.securitycontextpersistencefilter\npublic class securitycontextpersistencefilter extends genericfilterbean {\n\n   static final string filter_applied = "__spring_security_scpf_applied";\n   //安全上下文存储的仓库\n   private securitycontextrepository repo;\n\n   public securitycontextpersistencefilter() {\n      //httpsessionsecuritycontextrepository是securitycontextrepository接口的一个实现类\n      //使用httpsession来存储securitycontext\n      this(new httpsessionsecuritycontextrepository());\n   }\n\n   public void dofilter(servletrequest req, servletresponse res, filterchain chain)\n         throws ioexception, servletexception {\n      httpservletrequest request = (httpservletrequest) req;\n      httpservletresponse response = (httpservletresponse) res;\n\n      if (request.getattribute(filter_applied) != null) {\n         // ensure that filter is only applied once per request\n         chain.dofilter(request, response);\n         return;\n      }\n      request.setattribute(filter_applied, boolean.true);\n      //包装request，response\n      httprequestresponseholder holder = new httprequestresponseholder(request,\n            response);\n      //从session中获取安全上下文信息\n      securitycontext contextbeforechainexecution = repo.loadcontext(holder);\n      try {\n         //请求开始时，设置安全上下文信息，这样就避免了用户直接从session中获取安全上下文信息\n         securitycontextholder.setcontext(contextbeforechainexecution);\n         chain.dofilter(holder.getrequest(), holder.getresponse());\n      }\n      finally {\n         //请求结束后，清空安全上下文信息\n         securitycontext contextafterchainexecution = securitycontextholder\n               .getcontext();\n         securitycontextholder.clearcontext();\n         repo.savecontext(contextafterchainexecution, holder.getrequest(),\n               holder.getresponse());\n         request.removeattribute(filter_applied);\n         if (debug) {\n            logger.debug("securitycontextholder now cleared, as request processing completed");\n         }\n      }\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n过滤器一般负责核心的处理流程，而具体的业务实现，通常交给其中聚合的其他实体类，这在filter的设计中很常见，同时也符合职责分离模式。例如存储安全上下文和读取安全上下文的工作完全委托给了httpsessionsecuritycontextrepository去处理，而这个类中也有几个方法可以稍微解读下，方便我们理解内部的工作流程\n\norg.springframework.security.web.context.httpsessionsecuritycontextrepository\npublic class httpsessionsecuritycontextrepository implements securitycontextrepository {\n   // \'spring_security_context\'是安全上下文默认存储在session中的键值\n   public static final string spring_security_context_key = "spring_security_context";\n   ...\n   private final object contextobject = securitycontextholder.createemptycontext();\n   private boolean allowsessioncreation = true;\n   private boolean disableurlrewriting = false;\n   private string springsecuritycontextkey = spring_security_context_key;\n\n   private authenticationtrustresolver trustresolver = new authenticationtrustresolverimpl();\n\n   //从当前request中取出安全上下文，如果session为空，则会返回一个新的安全上下文\n   public securitycontext loadcontext(httprequestresponseholder requestresponseholder) {\n      httpservletrequest request = requestresponseholder.getrequest();\n      httpservletresponse response = requestresponseholder.getresponse();\n      httpsession httpsession = request.getsession(false);\n      securitycontext context = readsecuritycontextfromsession(httpsession);\n      if (context == null) {\n         context = generatenewcontext();\n      }\n      ...\n      return context;\n   }\n\n   ...\n\n   public boolean containscontext(httpservletrequest request) {\n      httpsession session = request.getsession(false);\n      if (session == null) {\n         return false;\n      }\n      return session.getattribute(springsecuritycontextkey) != null;\n   }\n\n   private securitycontext readsecuritycontextfromsession(httpsession httpsession) {\n      if (httpsession == null) {\n         return null;\n      }\n      ...\n      // session存在的情况下，尝试获取其中的securitycontext\n      object contextfromsession = httpsession.getattribute(springsecuritycontextkey);\n      if (contextfromsession == null) {\n         return null;\n      }\n      ...\n      return (securitycontext) contextfromsession;\n   }\n\n   //初次请求时创建一个新的securitycontext实例\n   protected securitycontext generatenewcontext() {\n      return securitycontextholder.createemptycontext();\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\nsecuritycontextpersistencefilter和httpsessionsecuritycontextrepository配合使用，构成了spring security整个调用链路的入口，为什么将它放在最开始的地方也是显而易见的，后续的过滤器中大概率会依赖session信息和安全上下文信息。\n\n\n# 4.3 usernamepasswordauthenticationfilter\n\n表单认证是最常用的一个认证方式，一个最直观的业务场景便是允许用户在表单中输入用户名和密码进行登录，而这背后的usernamepasswordauthenticationfilter，在整个spring security的认证体系中则扮演着至关重要的角色。\n\nhttp://kirito.iocoder.cn/2011121410543010.jpg\n\n上述的时序图，可以看出usernamepasswordauthenticationfilter主要肩负起了调用身份认证器，校验身份的作用，至于认证的细节，在前面几章花了很大篇幅进行了介绍，到这里，其实spring security的基本流程就已经走通了。\n\n# 源码分析\n\norg.springframework.security.web.authentication.usernamepasswordauthenticationfilter#attemptauthentication\npublic authentication attemptauthentication(httpservletrequest request,\n      httpservletresponse response) throws authenticationexception {\n   //获取表单中的用户名和密码\n   string username = obtainusername(request);\n   string password = obtainpassword(request);\n   ...\n   username = username.trim();\n   //组装成username+password形式的token\n   usernamepasswordauthenticationtoken authrequest = new usernamepasswordauthenticationtoken(\n         username, password);\n   // allow subclasses to set the "details" property\n   setdetails(request, authrequest);\n   //交给内部的authenticationmanager去认证，并返回认证信息\n   return this.getauthenticationmanager().authenticate(authrequest);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nusernamepasswordauthenticationfilter本身的代码只包含了上述这么一个方法，非常简略，而在其父类abstractauthenticationprocessingfilter中包含了大量的细节，值得我们分析：\n\npublic abstract class abstractauthenticationprocessingfilter extends genericfilterbean\n      implements applicationeventpublisheraware, messagesourceaware {\n\t//包含了一个身份认证器\n\tprivate authenticationmanager authenticationmanager;\n\t//用于实现remeberme\n\tprivate remembermeservices remembermeservices = new nullremembermeservices();\n\tprivate requestmatcher requiresauthenticationrequestmatcher;\n\t//这两个handler很关键，分别代表了认证成功和失败相应的处理器\n\tprivate authenticationsuccesshandler successhandler = new savedrequestawareauthenticationsuccesshandler();\n\tprivate authenticationfailurehandler failurehandler = new simpleurlauthenticationfailurehandler();\n\n\tpublic void dofilter(servletrequest req, servletresponse res, filterchain chain)\n\t\t\tthrows ioexception, servletexception {\n\n\t\thttpservletrequest request = (httpservletrequest) req;\n\t\thttpservletresponse response = (httpservletresponse) res;\n\t\t...\n\t\tauthentication authresult;\n\t\ttry {\n\t\t\t//此处实际上就是调用usernamepasswordauthenticationfilter的attemptauthentication方法\n\t\t\tauthresult = attemptauthentication(request, response);\n\t\t\tif (authresult == null) {\n\t\t\t\t//子类未完成认证，立刻返回\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsessionstrategy.onauthentication(authresult, request, response);\n\t\t}\n\t\t//在认证过程中可以直接抛出异常，在过滤器中，就像此处一样，进行捕获\n\t\tcatch (internalauthenticationserviceexception failed) {\n\t\t\t//内部服务异常\n\t\t\tunsuccessfulauthentication(request, response, failed);\n\t\t\treturn;\n\t\t}\n\t\tcatch (authenticationexception failed) {\n\t\t\t//认证失败\n\t\t\tunsuccessfulauthentication(request, response, failed);\n\t\t\treturn;\n\t\t}\n\t\t//认证成功\n\t\tif (continuechainbeforesuccessfulauthentication) {\n\t\t\tchain.dofilter(request, response);\n\t\t}\n\t\t//注意，认证成功后过滤器把authresult结果也传递给了成功处理器\n\t\tsuccessfulauthentication(request, response, chain, authresult);\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n整个流程理解起来也并不难，主要就是内部调用了authenticationmanager完成认证，根据认证结果执行successfulauthentication或者unsuccessfulauthentication，无论成功失败，一般的实现都是转发或者重定向等处理，不再细究authenticationsuccesshandler和authenticationfailurehandler，有兴趣的朋友，可以去看看两者的实现类。\n\n\n# 4.4 anonymousauthenticationfilter\n\n匿名认证过滤器，可能有人会想：匿名了还有身份？我自己对于anonymous匿名身份的理解是spirng security为了整体逻辑的统一性，即使是未通过认证的用户，也给予了一个匿名身份。而anonymousauthenticationfilter该过滤器的位置也是非常的科学的，它位于常用的身份认证过滤器（如usernamepasswordauthenticationfilter、basicauthenticationfilter、remembermeauthenticationfilter）之后，意味着只有在上述身份过滤器执行完毕后，securitycontext依旧没有用户信息，anonymousauthenticationfilter该过滤器才会有意义—-基于用户一个匿名身份。\n\n# 源码分析\n\norg.springframework.security.web.authentication.anonymousauthenticationfilter\npublic class anonymousauthenticationfilter extends genericfilterbean implements\n      initializingbean {\n\n   private authenticationdetailssource<httpservletrequest, ?> authenticationdetailssource = new webauthenticationdetailssource();\n   private string key;\n   private object principal;\n   private list<grantedauthority> authorities;\n\n\n   //自动创建一个"anonymoususer"的匿名用户,其具有anonymous角色\n   public anonymousauthenticationfilter(string key) {\n      this(key, "anonymoususer", authorityutils.createauthoritylist("role_anonymous"));\n   }\n\n   /**\n    *\n    * @param key key用来识别该过滤器创建的身份\n    * @param principal principal代表匿名用户的身份\n    * @param authorities authorities代表匿名用户的权限集合\n    */\n   public anonymousauthenticationfilter(string key, object principal,\n         list<grantedauthority> authorities) {\n      assert.haslength(key, "key cannot be null or empty");\n      assert.notnull(principal, "anonymous authentication principal must be set");\n      assert.notnull(authorities, "anonymous authorities must be set");\n      this.key = key;\n      this.principal = principal;\n      this.authorities = authorities;\n   }\n\n   ...\n\n   public void dofilter(servletrequest req, servletresponse res, filterchain chain)\n         throws ioexception, servletexception {\n      //过滤器链都执行到匿名认证过滤器这儿了还没有身份信息，塞一个匿名身份进去\n      if (securitycontextholder.getcontext().getauthentication() == null) {\n         securitycontextholder.getcontext().setauthentication(\n               createauthentication((httpservletrequest) req));\n      }\n      chain.dofilter(req, res);\n   }\n\n   protected authentication createauthentication(httpservletrequest request) {\n     //创建一个anonymousauthenticationtoken\n      anonymousauthenticationtoken auth = new anonymousauthenticationtoken(key,\n            principal, authorities);\n      auth.setdetails(authenticationdetailssource.builddetails(request));\n\n      return auth;\n   }\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n其实对比anonymousauthenticationfilter和usernamepasswordauthenticationfilter就可以发现一些门道了，usernamepasswordauthenticationtoken对应anonymousauthenticationtoken，他们都是authentication的实现类，而authentication则是被securitycontextholder(securitycontext)持有的，一切都被串联在了一起。\n\n\n# 4.5 exceptiontranslationfilter\n\nexceptiontranslationfilter异常转换过滤器位于整个springsecurityfilterchain的后方，用来转换整个链路中出现的异常，将其转化，顾名思义，转化以意味本身并不处理。一般其只处理两大类异常：accessdeniedexception访问异常和authenticationexception认证异常。\n\n这个过滤器非常重要，因为它将java中的异常和http的响应连接在了一起，这样在处理异常时，我们不用考虑密码错误该跳到什么页面，账号锁定该如何，只需要关注自己的业务逻辑，抛出相应的异常便可。如果该过滤器检测到authenticationexception，则将会交给内部的authenticationentrypoint去处理，如果检测到accessdeniedexception，需要先判断当前用户是不是匿名用户，如果是匿名访问，则和前面一样运行authenticationentrypoint，否则会委托给accessdeniedhandler去处理，而accessdeniedhandler的默认实现，是accessdeniedhandlerimpl。所以exceptiontranslationfilter内部的authenticationentrypoint是至关重要的，顾名思义：认证的入口点。\n\n# 源码分析\n\npublic class exceptiontranslationfilter extends genericfilterbean {\n  //处理异常转换的核心方法\n  private void handlespringsecurityexception(httpservletrequest request,\n        httpservletresponse response, filterchain chain, runtimeexception exception)\n        throws ioexception, servletexception {\n     if (exception instanceof authenticationexception) {\n       \t//重定向到登录端点\n        sendstartauthentication(request, response, chain,\n              (authenticationexception) exception);\n     }\n     else if (exception instanceof accessdeniedexception) {\n        authentication authentication = securitycontextholder.getcontext().getauthentication();\n        if (authenticationtrustresolver.isanonymous(authentication) || authenticationtrustresolver.isrememberme(authentication)) {\n\t\t  //重定向到登录端点\n           sendstartauthentication(\n                 request,\n                 response,\n                 chain,\n                 new insufficientauthenticationexception(\n                       "full authentication is required to access this resource"));\n        }\n        else {\n           //交给accessdeniedhandler处理\n           accessdeniedhandler.handle(request, response,\n                 (accessdeniedexception) exception);\n        }\n     }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n剩下的便是要搞懂authenticationentrypoint和accessdeniedhandler就可以了。\n\nauthenticationentrypoint\n\n选择了几个常用的登录端点，以其中第一个为例来介绍，看名字就能猜到是认证失败之后，让用户跳转到登录页面。还记得我们一开始怎么配置表单登录页面的吗？\n\n@configuration\n@enablewebsecurity\npublic class websecurityconfig extends websecurityconfigureradapter {\n\n    @override\n    protected void configure(httpsecurity http) throws exception {\n        http\n            .authorizerequests()\n                .antmatchers("/", "/home").permitall()\n                .anyrequest().authenticated()\n                .and()\n            .formlogin()//formloginconfigurer\n                .loginpage("/login")\n                .permitall()\n                .and()\n            .logout()\n                .permitall();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n我们顺着formlogin返回的formloginconfigurer往下找，看看能发现什么，最终在formloginconfigurer的父类abstractauthenticationfilterconfigurer中有了不小的收获：\n\npublic abstract class abstractauthenticationfilterconfigurer extends ...{\n   ...\n   //formlogin不出所料配置了authenticationentrypoint\n   private loginurlauthenticationentrypoint authenticationentrypoint;\n   //认证失败的处理器\n   private authenticationfailurehandler failurehandler;\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n具体如何配置的就不看了，我们得出了结论，formlogin()配置了之后最起码做了两件事，其一，为usernamepasswordauthenticationfilter设置了相关的配置，其二配置了authenticationentrypoint。\n\n登录端点还有http401authenticationentrypoint，http403forbiddenentrypoint这些都是很简单的实现，有时候我们访问受限页面，又没有配置登录，就看到了一个空荡荡的默认错误页面，上面显示着401,403，就是这两个入口起了作用。\n\n还剩下一个accessdeniedhandler访问决策器未被讲解，简单提一下：accessdeniedhandlerimpl这个默认实现类会根据errorpage和状态码来判断，最终决定跳转的页面\n\norg.springframework.security.web.access.accessdeniedhandlerimpl#handle\npublic void handle(httpservletrequest request, httpservletresponse response,\n      accessdeniedexception accessdeniedexception) throws ioexception,\n      servletexception {\n   if (!response.iscommitted()) {\n      if (errorpage != null) {\n         // put exception into request scope (perhaps of use to a view)\n         request.setattribute(webattributes.access_denied_403,\n               accessdeniedexception);\n         // set the 403 status code.\n         response.setstatus(httpservletresponse.sc_forbidden);\n         // forward to error page.\n         requestdispatcher dispatcher = request.getrequestdispatcher(errorpage);\n         dispatcher.forward(request, response);\n      }\n      else {\n         response.senderror(httpservletresponse.sc_forbidden,\n               accessdeniedexception.getmessage());\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4.6 filtersecurityinterceptor\n\n想想整个认证安全控制流程还缺了什么？我们已经有了认证，有了请求的封装，有了session的关联…还缺一个：由什么控制哪些资源是受限的，这些受限的资源需要什么权限，需要什么角色…这一切和访问控制相关的操作，都是由filtersecurityinterceptor完成的。\n\nfiltersecurityinterceptor的工作流程用笔者的理解可以理解如下：filtersecurityinterceptor从securitycontextholder中获取authentication对象，然后比对用户拥有的权限和资源所需的权限。前者可以通过authentication对象直接获得，而后者则需要引入我们之前一直未提到过的两个类：securitymetadatasource，accessdecisionmanager。理解清楚决策管理器的整个创建流程和securitymetadatasource的作用需要花很大一笔功夫，这里，暂时只介绍其大概的作用。\n\n在javaconfig的配置中，我们通常如下配置路径的访问控制：\n\n@override\nprotected void configure(httpsecurity http) throws exception {\n\thttp\n\t\t.authorizerequests()\n\t\t\t.antmatchers("/resources/**", "/signup", "/about").permitall()\n             .antmatchers("/admin/**").hasrole("admin")\n             .antmatchers("/db/**").access("hasrole(\'admin\') and hasrole(\'dba\')")\n             .anyrequest().authenticated()\n\t\t\t.withobjectpostprocessor(new objectpostprocessor<filtersecurityinterceptor>() {\n\t\t\t\tpublic <o extends filtersecurityinterceptor> o postprocess(\n\t\t\t\t\t\to fsi) {\n\t\t\t\t\tfsi.setpublishauthorizationsuccess(true);\n\t\t\t\t\treturn fsi;\n\t\t\t\t}\n\t\t\t});\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n在objectpostprocessor的泛型中看到了filtersecurityinterceptor，以笔者的经验，目前并没有太多机会需要修改filtersecurityinterceptor的配置。\n\n\n# 总结\n\n本篇文章在介绍过滤器时，顺便进行了一些源码的分析，目的是方便理解整个spring security的工作流。伴随着整个过滤器链的介绍，安全框架的轮廓应该已经浮出水面了，下面的章节，主要打算通过自定义一些需求，再次分析其他组件的源码，学习应该如何改造spring security，为我们所用。',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"【老徐】Spring Security(五) —— 动手实现一个 IP_Login",frontmatter:{title:"【老徐】Spring Security(五) —— 动手实现一个 IP_Login",date:"2022-02-03T00:03:27.000Z",permalink:"/pages/754b42/",categories:["后端","Spring Security"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/25.Spring%20Security/05.%E3%80%90%E8%80%81%E5%BE%90%E3%80%91Spring%20Security(%E4%BA%94)%20%E2%80%94%E2%80%94%20%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20IP_Login.html",relativePath:"10.框架/25.Spring Security/05.【老徐】Spring Security(五) —— 动手实现一个 IP_Login.md",key:"v-27133cbb",path:"/pages/754b42/",headers:[{level:2,title:"5 动手实现一个IP_Login",slug:"_5-动手实现一个ip-login",normalizedTitle:"5 动手实现一个ip_login",charIndex:75},{level:3,title:"5.1 定义需求",slug:"_5-1-定义需求",normalizedTitle:"5.1 定义需求",charIndex:943},{level:3,title:"5.2 设计概述",slug:"_5-2-设计概述",normalizedTitle:"5.2 设计概述",charIndex:1330},{level:3,title:"5.3 IpAuthenticationToken",slug:"_5-3-ipauthenticationtoken",normalizedTitle:"5.3 ipauthenticationtoken",charIndex:1944},{level:3,title:"5.4 IpAuthenticationProcessingFilter",slug:"_5-4-ipauthenticationprocessingfilter",normalizedTitle:"5.4 ipauthenticationprocessingfilter",charIndex:3010},{level:3,title:"5.5 IpAuthenticationProvider",slug:"_5-5-ipauthenticationprovider",normalizedTitle:"5.5 ipauthenticationprovider",charIndex:3945},{level:3,title:"5.6 配置WebSecurityConfigAdapter",slug:"_5-6-配置websecurityconfigadapter",normalizedTitle:"5.6 配置websecurityconfigadapter",charIndex:5460},{level:3,title:"5.7 配置SpringMVC",slug:"_5-7-配置springmvc",normalizedTitle:"5.7 配置springmvc",charIndex:7922},{level:3,title:"5.8 运行效果",slug:"_5-8-运行效果",normalizedTitle:"5.8 运行效果",charIndex:8507},{level:3,title:"成功的流程",slug:"成功的流程",normalizedTitle:"成功的流程",charIndex:8520},{level:3,title:"失败的流程",slug:"失败的流程",normalizedTitle:"失败的流程",charIndex:8760},{level:3,title:"5.9 总结",slug:"_5-9-总结",normalizedTitle:"5.9 总结",charIndex:8961}],headersStr:"5 动手实现一个IP_Login 5.1 定义需求 5.2 设计概述 5.3 IpAuthenticationToken 5.4 IpAuthenticationProcessingFilter 5.5 IpAuthenticationProvider 5.6 配置WebSecurityConfigAdapter 5.7 配置SpringMVC 5.8 运行效果 成功的流程 失败的流程 5.9 总结",content:'摘要: 原创出处 https://www.cnkirito.moe/spring-security-5/ 「老徐」欢迎转载，保留摘要，谢谢！\n\n * 5 动手实现一个IP_Login\n\n----------------------------------------\n\n----------------------------------------\n\n在开始这篇文章之前，我们似乎应该思考下为什么需要搞清楚Spring Security的内部工作原理？按照第二篇文章中的配置，一个简单的表单认证不就达成了吗？更有甚者，为什么我们不自己写一个表单认证，用过滤器即可完成，大费周章引入Spring Security，看起来也并没有方便多少。对的，在引入Spring Security之前，我们得首先想到，是什么需求让我们引入了Spring Security，以及为什么是Spring Security，而不是shiro等等其他安全框架。我的理解是有如下几点：\n\n1 在前文的介绍中，Spring Security支持防止csrf攻击，session-fixation protection，支持表单认证，basic认证，rememberMe…等等一些特性，有很多是开箱即用的功能，而大多特性都可以通过配置灵活的变更，这是它的强大之处。\n\n2 Spring Security的兄弟的项目Spring Security SSO，OAuth2等支持了多种协议，而这些都是基于Spring Security的，方便了项目的扩展。\n\n3 SpringBoot的支持，更加保证了Spring Security的开箱即用。\n\n4 为什么需要理解其内部工作原理?一个有自我追求的程序员都不会满足于浅尝辄止，如果一个开源技术在我们的日常工作中十分常用，那么我偏向于阅读其源码，这样可以让我们即使排查不期而至的问题，也方便日后需求扩展。\n\n5 Spring及其子项目的官方文档是我见过的最良心的文档！相比较于Apache的部分文档\n\n这一节，为了对之前分析的Spring Security源码和组件有一个清晰的认识，介绍一个使用IP完成登录的简单demo。\n\n\n# 5 动手实现一个IP_Login\n\n\n# 5.1 定义需求\n\n在表单登录中，一般使用数据库中配置的用户表，权限表，角色表，权限组表…这取决于你的权限粒度，但本质都是借助了一个持久化存储，维护了用户的角色权限，而后给出一个/login作为登录端点，使用表单提交用户名和密码，而后完成登录后可自由访问受限页面。\n\n在我们的IP登录demo中，也是类似的，使用IP地址作为身份，内存中的一个ConcurrentHashMap维护IP地址和权限的映射，如果在认证时找不到相应的权限，则认为认证失败。\n\n实际上，在表单登录中，用户的IP地址已经被存放在Authentication.getDetails()中了，完全可以只重写一个AuthenticationProvider认证这个IP地址即可，但是，本demo是为了厘清Spring Security内部工作原理而设置，为了设计到更多的类，我完全重写了IP过滤器。\n\n\n# 5.2 设计概述\n\n我们的参考完全是表单认证，在之前章节中，已经了解了表单认证相关的核心流程，将此图再贴一遍：\n\nhttp://kirito.iocoder.cn/2011121410543010.jpg\n\n在IP登录的demo中，使用IpAuthenticationProcessingFilter拦截IP登录请求，同样使用ProviderManager作为全局AuthenticationManager接口的实现类，将ProviderManager内部的DaoAuthenticationProvider替换为IpAuthenticationProvider，而UserDetailsService则使用一个ConcurrentHashMap代替。更详细一点的设计：\n\n 1. IpAuthenticationProcessingFilter–>UsernamePasswordAuthenticationFilter\n 2. IpAuthenticationToken–>UsernamePasswordAuthenticationToken\n 3. ProviderManager–>ProviderManager\n 4. IpAuthenticationProvider–>DaoAuthenticationProvider\n 5. ConcurrentHashMap–>UserDetailsService\n\n\n# 5.3 IpAuthenticationToken\n\npublic class IpAuthenticationToken extends AbstractAuthenticationToken {\n\n    private String ip;\n\n    public String getIp() {\n        return ip;\n    }\n\n    public void setIp(String ip) {\n        this.ip = ip;\n    }\n\n    public IpAuthenticationToken(String ip) {\n        super(null);\n        this.ip = ip;\n        super.setAuthenticated(false);//注意这个构造方法是认证时使用的\n    }\n\n    public IpAuthenticationToken(String ip, Collection<? extends GrantedAuthority> authorities) {\n        super(authorities);\n        this.ip = ip;\n        super.setAuthenticated(true);//注意这个构造方法是认证成功后使用的\n\n    }\n\n    @Override\n    public Object getCredentials() {\n        return null;\n    }\n\n    @Override\n    public Object getPrincipal() {\n        return this.ip;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n两个构造方法需要引起我们的注意，这里设计的用意是模仿的UsernamePasswordAuthenticationToken，第一个构造器是用于认证之前，传递给认证器使用的，所以只有IP地址，自然是未认证；第二个构造器用于认证成功之后，封装认证用户的信息，此时需要将权限也设置到其中，并且setAuthenticated(true)。这样的设计在诸多的Token类设计中很常见。\n\n\n# 5.4 IpAuthenticationProcessingFilter\n\npublic class IpAuthenticationProcessingFilter extends AbstractAuthenticationProcessingFilter {\n    //使用/ipVerify该端点进行ip认证\n    IpAuthenticationProcessingFilter() {\n        super(new AntPathRequestMatcher("/ipVerify"));\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException {\n        //获取host信息\n        String host = request.getRemoteHost();\n        //交给内部的AuthenticationManager去认证，实现解耦\n        return getAuthenticationManager().authenticate(new IpAuthenticationToken(host));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 1. AbstractAuthenticationProcessingFilter这个过滤器在前面一节介绍过，是UsernamePasswordAuthenticationFilter的父类，我们的IpAuthenticationProcessingFilter也继承了它\n 2. 构造器中传入了/ipVerify作为IP登录的端点\n 3. attemptAuthentication()方法中加载请求的IP地址，之后交给内部的AuthenticationManager去认证\n\n\n# 5.5 IpAuthenticationProvider\n\npublic class IpAuthenticationProvider implements AuthenticationProvider {\n\tfinal static Map<String, SimpleGrantedAuthority> ipAuthorityMap = new ConcurrenHashMap();\n    //维护一个ip白名单列表，每个ip对应一定的权限\n    static {\n        ipAuthorityMap.put("127.0.0.1", new SimpleGrantedAuthority("ADMIN"));\n        ipAuthorityMap.put("10.236.69.103", new SimpleGrantedAuthority("ADMIN"));\n        ipAuthorityMap.put("10.236.69.104", new SimpleGrantedAuthority("FRIEND"));\n    }\n\n    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n        IpAuthenticationToken ipAuthenticationToken = (IpAuthenticationToken) authentication;\n        String ip = ipAuthenticationToken.getIp();\n        SimpleGrantedAuthority simpleGrantedAuthority = ipAuthorityMap.get(ip);\n        //不在白名单列表中\n        if (simpleGrantedAuthority == null) {\n            return null;\n        } else {\n            //封装权限信息，并且此时身份已经被认证\n            return new IpAuthenticationToken(ip, Arrays.asList(simpleGrantedAuthority));\n        }\n    }\n\n    //只支持IpAuthenticationToken该身份\n    @Override\n    public boolean supports(Class<?> authentication) {\n        return (IpAuthenticationToken.class\n                .isAssignableFrom(authentication));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nreturn new IpAuthenticationToken(ip, Arrays.asList(simpleGrantedAuthority));使用了IpAuthenticationToken的第二个构造器，返回了一个已经经过认证的IpAuthenticationToken。\n\n\n# 5.6 配置WebSecurityConfigAdapter\n\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    //ip认证者配置\n    @Bean\n    IpAuthenticationProvider ipAuthenticationProvider() {\n        return new IpAuthenticationProvider();\n    }\n\n    //配置封装ipAuthenticationToken的过滤器\n    IpAuthenticationProcessingFilter ipAuthenticationProcessingFilter(AuthenticationManager authenticationManager) {\n        IpAuthenticationProcessingFilter ipAuthenticationProcessingFilter = new IpAuthenticationProcessingFilter();\n        //为过滤器添加认证器\n        ipAuthenticationProcessingFilter.setAuthenticationManager(authenticationManager);\n        //重写认证失败时的跳转页面\n        ipAuthenticationProcessingFilter.setAuthenticationFailureHandler(new SimpleUrlAuthenticationFailureHandler("/ipLogin?error"));\n        return ipAuthenticationProcessingFilter;\n    }\n\n    //配置登录端点\n    @Bean\n    LoginUrlAuthenticationEntryPoint loginUrlAuthenticationEntryPoint(){\n        LoginUrlAuthenticationEntryPoint loginUrlAuthenticationEntryPoint = new LoginUrlAuthenticationEntryPoint\n                ("/ipLogin");\n        return loginUrlAuthenticationEntryPoint;\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeRequests()\n                .antMatchers("/", "/home").permitAll()\n                .antMatchers("/ipLogin").permitAll()\n                .anyRequest().authenticated()\n                .and()\n            .logout()\n                .logoutSuccessUrl("/")\n                .permitAll()\n                .and()\n            .exceptionHandling()\n                .accessDeniedPage("/ipLogin")\n                .authenticationEntryPoint(loginUrlAuthenticationEntryPoint())\n        ;\n\n        //注册IpAuthenticationProcessingFilter  注意放置的顺序 这很关键\n        http.addFilterBefore(ipAuthenticationProcessingFilter(authenticationManager()), UsernamePasswordAuthenticationFilter.class);\n\n    }\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.authenticationProvider(ipAuthenticationProvider());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\nWebSecurityConfigAdapter提供了我们很大的便利，不需要关注AuthenticationManager什么时候被创建，只需要使用其暴露的configure(AuthenticationManagerBuilder auth)便可以添加我们自定义的ipAuthenticationProvider。剩下的一些细节，注释中基本都写了出来。\n\n\n# 5.7 配置SpringMVC\n\n@Configuration\npublic class MvcConfig extends WebMvcConfigurerAdapter {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController("/home").setViewName("home");\n        registry.addViewController("/").setViewName("home");\n        registry.addViewController("/hello").setViewName("hello");\n        registry.addViewController("/ip").setViewName("ipHello");\n        registry.addViewController("/ipLogin").setViewName("ipLogin");\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n页面的具体内容和表单登录基本一致，可以在文末的源码中查看。\n\n\n# 5.8 运行效果\n\n\n# 成功的流程\n\n * http://127.0.0.1:8080/访问首页，其中here链接到的地址为：http://127.0.0.1:8080/hello\n\n首页\n\n * 点击here，由于http://127.0.0.1:8080/hello是受保护资源，所以跳转到了校验IP的页面。此时若点击Sign In by IP按钮，将会提交到/ipVerify端点，进行IP的认证。\n\n登录\n\n * 登录校验成功之后，页面被成功重定向到了原先访问的\n\n受保护的hello页\n\n\n# 失败的流程\n\n * 注意此时已经注销了上次的登录，并且，使用了localhost(localhost和127.0.0.1是两个不同的IP地址，我们的内存中只有127.0.0.1的用户,没有localhost的用户)\n\n首页\n\n * 点击here后，由于没有认证过，依旧跳转到登录页面\n   \n   登录\n\n * 此时，我们发现使用localhost，并没有认证成功，符合我们的预期\n\n认证失败\n\n\n# 5.9 总结\n\n一个简单的使用Spring Security来进行验证IP地址的登录demo就已经完成了，这个demo主要是为了更加清晰地阐释Spring Security内部工作的原理设置的，其本身没有实际的项目意义，认证IP其实也不应该通过Spring Security的过滤器去做，退一步也应该交给Filter去做（这个Filter不存在于Spring Security的过滤器链中），而真正项目中，如果真正要做黑白名单这样的功能，一般选择在网关层或者nginx的扩展模块中做。再次特地强调下，怕大家误解。\n\n最后祝大家国庆玩的开心~\n\n本节的代码可以在github中下载源码：https://github.com/lexburner/spring-security-ipLogin',normalizedContent:'摘要: 原创出处 https://www.cnkirito.moe/spring-security-5/ 「老徐」欢迎转载，保留摘要，谢谢！\n\n * 5 动手实现一个ip_login\n\n----------------------------------------\n\n----------------------------------------\n\n在开始这篇文章之前，我们似乎应该思考下为什么需要搞清楚spring security的内部工作原理？按照第二篇文章中的配置，一个简单的表单认证不就达成了吗？更有甚者，为什么我们不自己写一个表单认证，用过滤器即可完成，大费周章引入spring security，看起来也并没有方便多少。对的，在引入spring security之前，我们得首先想到，是什么需求让我们引入了spring security，以及为什么是spring security，而不是shiro等等其他安全框架。我的理解是有如下几点：\n\n1 在前文的介绍中，spring security支持防止csrf攻击，session-fixation protection，支持表单认证，basic认证，rememberme…等等一些特性，有很多是开箱即用的功能，而大多特性都可以通过配置灵活的变更，这是它的强大之处。\n\n2 spring security的兄弟的项目spring security sso，oauth2等支持了多种协议，而这些都是基于spring security的，方便了项目的扩展。\n\n3 springboot的支持，更加保证了spring security的开箱即用。\n\n4 为什么需要理解其内部工作原理?一个有自我追求的程序员都不会满足于浅尝辄止，如果一个开源技术在我们的日常工作中十分常用，那么我偏向于阅读其源码，这样可以让我们即使排查不期而至的问题，也方便日后需求扩展。\n\n5 spring及其子项目的官方文档是我见过的最良心的文档！相比较于apache的部分文档\n\n这一节，为了对之前分析的spring security源码和组件有一个清晰的认识，介绍一个使用ip完成登录的简单demo。\n\n\n# 5 动手实现一个ip_login\n\n\n# 5.1 定义需求\n\n在表单登录中，一般使用数据库中配置的用户表，权限表，角色表，权限组表…这取决于你的权限粒度，但本质都是借助了一个持久化存储，维护了用户的角色权限，而后给出一个/login作为登录端点，使用表单提交用户名和密码，而后完成登录后可自由访问受限页面。\n\n在我们的ip登录demo中，也是类似的，使用ip地址作为身份，内存中的一个concurrenthashmap维护ip地址和权限的映射，如果在认证时找不到相应的权限，则认为认证失败。\n\n实际上，在表单登录中，用户的ip地址已经被存放在authentication.getdetails()中了，完全可以只重写一个authenticationprovider认证这个ip地址即可，但是，本demo是为了厘清spring security内部工作原理而设置，为了设计到更多的类，我完全重写了ip过滤器。\n\n\n# 5.2 设计概述\n\n我们的参考完全是表单认证，在之前章节中，已经了解了表单认证相关的核心流程，将此图再贴一遍：\n\nhttp://kirito.iocoder.cn/2011121410543010.jpg\n\n在ip登录的demo中，使用ipauthenticationprocessingfilter拦截ip登录请求，同样使用providermanager作为全局authenticationmanager接口的实现类，将providermanager内部的daoauthenticationprovider替换为ipauthenticationprovider，而userdetailsservice则使用一个concurrenthashmap代替。更详细一点的设计：\n\n 1. ipauthenticationprocessingfilter–>usernamepasswordauthenticationfilter\n 2. ipauthenticationtoken–>usernamepasswordauthenticationtoken\n 3. providermanager–>providermanager\n 4. ipauthenticationprovider–>daoauthenticationprovider\n 5. concurrenthashmap–>userdetailsservice\n\n\n# 5.3 ipauthenticationtoken\n\npublic class ipauthenticationtoken extends abstractauthenticationtoken {\n\n    private string ip;\n\n    public string getip() {\n        return ip;\n    }\n\n    public void setip(string ip) {\n        this.ip = ip;\n    }\n\n    public ipauthenticationtoken(string ip) {\n        super(null);\n        this.ip = ip;\n        super.setauthenticated(false);//注意这个构造方法是认证时使用的\n    }\n\n    public ipauthenticationtoken(string ip, collection<? extends grantedauthority> authorities) {\n        super(authorities);\n        this.ip = ip;\n        super.setauthenticated(true);//注意这个构造方法是认证成功后使用的\n\n    }\n\n    @override\n    public object getcredentials() {\n        return null;\n    }\n\n    @override\n    public object getprincipal() {\n        return this.ip;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n两个构造方法需要引起我们的注意，这里设计的用意是模仿的usernamepasswordauthenticationtoken，第一个构造器是用于认证之前，传递给认证器使用的，所以只有ip地址，自然是未认证；第二个构造器用于认证成功之后，封装认证用户的信息，此时需要将权限也设置到其中，并且setauthenticated(true)。这样的设计在诸多的token类设计中很常见。\n\n\n# 5.4 ipauthenticationprocessingfilter\n\npublic class ipauthenticationprocessingfilter extends abstractauthenticationprocessingfilter {\n    //使用/ipverify该端点进行ip认证\n    ipauthenticationprocessingfilter() {\n        super(new antpathrequestmatcher("/ipverify"));\n    }\n\n    @override\n    public authentication attemptauthentication(httpservletrequest request, httpservletresponse response) throws authenticationexception, ioexception, servletexception {\n        //获取host信息\n        string host = request.getremotehost();\n        //交给内部的authenticationmanager去认证，实现解耦\n        return getauthenticationmanager().authenticate(new ipauthenticationtoken(host));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 1. abstractauthenticationprocessingfilter这个过滤器在前面一节介绍过，是usernamepasswordauthenticationfilter的父类，我们的ipauthenticationprocessingfilter也继承了它\n 2. 构造器中传入了/ipverify作为ip登录的端点\n 3. attemptauthentication()方法中加载请求的ip地址，之后交给内部的authenticationmanager去认证\n\n\n# 5.5 ipauthenticationprovider\n\npublic class ipauthenticationprovider implements authenticationprovider {\n\tfinal static map<string, simplegrantedauthority> ipauthoritymap = new concurrenhashmap();\n    //维护一个ip白名单列表，每个ip对应一定的权限\n    static {\n        ipauthoritymap.put("127.0.0.1", new simplegrantedauthority("admin"));\n        ipauthoritymap.put("10.236.69.103", new simplegrantedauthority("admin"));\n        ipauthoritymap.put("10.236.69.104", new simplegrantedauthority("friend"));\n    }\n\n    @override\n    public authentication authenticate(authentication authentication) throws authenticationexception {\n        ipauthenticationtoken ipauthenticationtoken = (ipauthenticationtoken) authentication;\n        string ip = ipauthenticationtoken.getip();\n        simplegrantedauthority simplegrantedauthority = ipauthoritymap.get(ip);\n        //不在白名单列表中\n        if (simplegrantedauthority == null) {\n            return null;\n        } else {\n            //封装权限信息，并且此时身份已经被认证\n            return new ipauthenticationtoken(ip, arrays.aslist(simplegrantedauthority));\n        }\n    }\n\n    //只支持ipauthenticationtoken该身份\n    @override\n    public boolean supports(class<?> authentication) {\n        return (ipauthenticationtoken.class\n                .isassignablefrom(authentication));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nreturn new ipauthenticationtoken(ip, arrays.aslist(simplegrantedauthority));使用了ipauthenticationtoken的第二个构造器，返回了一个已经经过认证的ipauthenticationtoken。\n\n\n# 5.6 配置websecurityconfigadapter\n\n@configuration\n@enablewebsecurity\npublic class websecurityconfig extends websecurityconfigureradapter {\n\n    //ip认证者配置\n    @bean\n    ipauthenticationprovider ipauthenticationprovider() {\n        return new ipauthenticationprovider();\n    }\n\n    //配置封装ipauthenticationtoken的过滤器\n    ipauthenticationprocessingfilter ipauthenticationprocessingfilter(authenticationmanager authenticationmanager) {\n        ipauthenticationprocessingfilter ipauthenticationprocessingfilter = new ipauthenticationprocessingfilter();\n        //为过滤器添加认证器\n        ipauthenticationprocessingfilter.setauthenticationmanager(authenticationmanager);\n        //重写认证失败时的跳转页面\n        ipauthenticationprocessingfilter.setauthenticationfailurehandler(new simpleurlauthenticationfailurehandler("/iplogin?error"));\n        return ipauthenticationprocessingfilter;\n    }\n\n    //配置登录端点\n    @bean\n    loginurlauthenticationentrypoint loginurlauthenticationentrypoint(){\n        loginurlauthenticationentrypoint loginurlauthenticationentrypoint = new loginurlauthenticationentrypoint\n                ("/iplogin");\n        return loginurlauthenticationentrypoint;\n    }\n\n    @override\n    protected void configure(httpsecurity http) throws exception {\n        http\n            .authorizerequests()\n                .antmatchers("/", "/home").permitall()\n                .antmatchers("/iplogin").permitall()\n                .anyrequest().authenticated()\n                .and()\n            .logout()\n                .logoutsuccessurl("/")\n                .permitall()\n                .and()\n            .exceptionhandling()\n                .accessdeniedpage("/iplogin")\n                .authenticationentrypoint(loginurlauthenticationentrypoint())\n        ;\n\n        //注册ipauthenticationprocessingfilter  注意放置的顺序 这很关键\n        http.addfilterbefore(ipauthenticationprocessingfilter(authenticationmanager()), usernamepasswordauthenticationfilter.class);\n\n    }\n\n    @override\n    protected void configure(authenticationmanagerbuilder auth) throws exception {\n        auth.authenticationprovider(ipauthenticationprovider());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\nwebsecurityconfigadapter提供了我们很大的便利，不需要关注authenticationmanager什么时候被创建，只需要使用其暴露的configure(authenticationmanagerbuilder auth)便可以添加我们自定义的ipauthenticationprovider。剩下的一些细节，注释中基本都写了出来。\n\n\n# 5.7 配置springmvc\n\n@configuration\npublic class mvcconfig extends webmvcconfigureradapter {\n\n    @override\n    public void addviewcontrollers(viewcontrollerregistry registry) {\n        registry.addviewcontroller("/home").setviewname("home");\n        registry.addviewcontroller("/").setviewname("home");\n        registry.addviewcontroller("/hello").setviewname("hello");\n        registry.addviewcontroller("/ip").setviewname("iphello");\n        registry.addviewcontroller("/iplogin").setviewname("iplogin");\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n页面的具体内容和表单登录基本一致，可以在文末的源码中查看。\n\n\n# 5.8 运行效果\n\n\n# 成功的流程\n\n * http://127.0.0.1:8080/访问首页，其中here链接到的地址为：http://127.0.0.1:8080/hello\n\n首页\n\n * 点击here，由于http://127.0.0.1:8080/hello是受保护资源，所以跳转到了校验ip的页面。此时若点击sign in by ip按钮，将会提交到/ipverify端点，进行ip的认证。\n\n登录\n\n * 登录校验成功之后，页面被成功重定向到了原先访问的\n\n受保护的hello页\n\n\n# 失败的流程\n\n * 注意此时已经注销了上次的登录，并且，使用了localhost(localhost和127.0.0.1是两个不同的ip地址，我们的内存中只有127.0.0.1的用户,没有localhost的用户)\n\n首页\n\n * 点击here后，由于没有认证过，依旧跳转到登录页面\n   \n   登录\n\n * 此时，我们发现使用localhost，并没有认证成功，符合我们的预期\n\n认证失败\n\n\n# 5.9 总结\n\n一个简单的使用spring security来进行验证ip地址的登录demo就已经完成了，这个demo主要是为了更加清晰地阐释spring security内部工作的原理设置的，其本身没有实际的项目意义，认证ip其实也不应该通过spring security的过滤器去做，退一步也应该交给filter去做（这个filter不存在于spring security的过滤器链中），而真正项目中，如果真正要做黑白名单这样的功能，一般选择在网关层或者nginx的扩展模块中做。再次特地强调下，怕大家误解。\n\n最后祝大家国庆玩的开心~\n\n本节的代码可以在github中下载源码：https://github.com/lexburner/spring-security-iplogin',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"【老徐】从零开始的 Spring Security OAuth2（一）",frontmatter:{title:"【老徐】从零开始的 Spring Security OAuth2（一）",date:"2022-02-03T00:03:27.000Z",permalink:"/pages/79202c/",categories:["后端","Spring Security"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/25.Spring%20Security/06.%E3%80%90%E8%80%81%E5%BE%90%E3%80%91%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%20Spring%20Security%20OAuth2%EF%BC%88%E4%B8%80%EF%BC%89.html",relativePath:"10.框架/25.Spring Security/06.【老徐】从零开始的 Spring Security OAuth2（一）.md",key:"v-2203d9c2",path:"/pages/79202c/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:230},{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:236},{level:2,title:"项目准备",slug:"项目准备",normalizedTitle:"项目准备",charIndex:242},{level:2,title:"配置资源服务器和授权服务器",slug:"配置资源服务器和授权服务器",normalizedTitle:"配置资源服务器和授权服务器",charIndex:250},{level:2,title:"配置spring security",slug:"配置spring-security",normalizedTitle:"配置spring security",charIndex:267},{level:2,title:"获取token",slug:"获取token",normalizedTitle:"获取token",charIndex:288},{level:2,title:"示例代码下载",slug:"示例代码下载",normalizedTitle:"示例代码下载",charIndex:299}],headersStr:"前言 概述 项目准备 配置资源服务器和授权服务器 配置spring security 获取token 示例代码下载",content:'摘要: 原创出处 [https://www.cnkirito.moe/Re%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Spring%20Security%20OAuth2%EF%BC%88%E4%B8%80%EF%BC%89/](https://www.cnkirito.moe/Re：从零开始的Spring Security OAuth2（一）/) 「老徐」欢迎转载，保留摘要，谢谢！\n\n * 前言\n * 概述\n * 项目准备\n * 配置资源服务器和授权服务器\n * 配置spring security\n * 获取token\n * 示例代码下载\n\n----------------------------------------\n\n----------------------------------------\n\n\n# 前言\n\n今天来聊聊一个接口对接的场景，A厂家有一套HTTP接口需要提供给B厂家使用，由于是外网环境，所以需要有一套安全机制保障，这个时候oauth2就可以作为一个方案。\n\n关于oauth2，其实是一个规范，本文重点讲解spring对他进行的实现，如果你还不清楚授权服务器，资源服务器，认证授权等基础概念，可以移步理解OAuth 2.0 - 阮一峰，这是一篇对于oauth2很好的科普文章。\n\n需要对spring security有一定的配置使用经验，用户认证这一块，spring security oauth2建立在spring security的基础之上。第一篇文章主要是讲解使用springboot搭建一个简易的授权，资源服务器，在文末会给出具体代码的github地址。后续文章会进行spring security oauth2的相关源码分析。java中的安全框架如shrio，已经有跟我学shiro - 开涛，非常成体系地，深入浅出地讲解了apache的这个开源安全框架，但是spring security包括oauth2一直没有成体系的文章，学习它们大多依赖于较少的官方文档，理解一下基本的使用配置；通过零散的博客，了解一下他人的使用经验；打断点，分析内部的工作流程；看源码中的接口设计，以及注释，了解设计者的用意。spring的各个框架都运用了很多的设计模式，在学习源码的过程中，也大概了解了一些套路。spring也在必要的地方添加了适当的注释，避免了源码阅读者对于一些细节设计的理解产生偏差，让我更加感叹，spring不仅仅是一个工具框架，更像是一个艺术品。\n\n\n# 概述\n\n使用oauth2保护你的应用，可以分为简易的分为三个步骤\n\n * 配置资源服务器\n * 配置认证服务器\n * 配置spring security\n\n前两点是oauth2的主体内容，但前面我已经描述过了，spring security oauth2是建立在spring security基础之上的，所以有一些体系是公用的。\n\noauth2根据使用场景不同，分成了4种模式\n\n * 授权码模式（authorization code）\n * 简化模式（implicit）\n * 密码模式（resource owner password credentials）\n * 客户端模式（client credentials）\n\n本文重点讲解接口对接中常使用的密码模式（以下简称password模式）和客户端模式（以下简称client模式）。授权码模式使用到了回调地址，是最为复杂的方式，通常网站中经常出现的微博，qq第三方登录，都会采用这个形式。简化模式不常用。\n\n\n# 项目准备\n\n主要的maven依赖如下\n\n\x3c!-- 注意是starter,自动配置 --\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n\x3c!-- 不是starter,手动配置 --\x3e\n<dependency>\n    <groupId>org.springframework.security.oauth</groupId>\n    <artifactId>spring-security-oauth2</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\x3c!-- 将token存储在redis中 --\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n我们给自己先定个目标，要干什么事？既然说到保护应用，那必须得先有一些资源，我们创建一个endpoint作为提供给外部的接口：\n\n@RestController\npublic class TestEndpoints {\n\n    @GetMapping("/product/{id}")\n    public String getProduct(@PathVariable String id) {\n        //for debug\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        return "product id : " + id;\n    }\n\n    @GetMapping("/order/{id}")\n    public String getOrder(@PathVariable String id) {\n\t    //for debug\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        return "order id : " + id;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n暴露一个商品查询接口，后续不做安全限制，一个订单查询接口，后续添加访问控制。\n\n\n# 配置资源服务器和授权服务器\n\n由于是两个oauth2的核心配置，我们放到一个配置类中。 为了方便下载代码直接运行，我这里将客户端信息放到了内存中，生产中可以配置到数据库中。token的存储一般选择使用redis，一是性能比较好，二是自动过期的机制，符合token的特性。\n\n@Configuration\npublic class OAuth2ServerConfig {\n\n    private static final String DEMO_RESOURCE_ID = "order";\n\n    @Configuration\n    @EnableResourceServer\n    protected static class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {\n\n        @Override\n        public void configure(ResourceServerSecurityConfigurer resources) {\n            resources.resourceId(DEMO_RESOURCE_ID).stateless(true);\n        }\n\n        @Override\n        public void configure(HttpSecurity http) throws Exception {\n            // @formatter:off\n            http\n                    // Since we want the protected resources to be accessible in the UI as well we need\n                    // session creation to be allowed (it\'s disabled by default in 2.0.6)\n                    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)\n                    .and()\n                    .requestMatchers().anyRequest()\n                    .and()\n                    .anonymous()\n                    .and()\n                    .authorizeRequests()\n//                    .antMatchers("/product/**").access("#oauth2.hasScope(\'select\') and hasRole(\'ROLE_USER\')")\n                    .antMatchers("/order/**").authenticated();//配置order访问控制，必须认证过后才可以访问\n            // @formatter:on\n        }\n    }\n\n    @Configuration\n    @EnableAuthorizationServer\n    protected static class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter {\n\n        @Autowired\n        AuthenticationManager authenticationManager;\n        @Autowired\n        RedisConnectionFactory redisConnectionFactory;\n\n        @Override\n        public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n            //配置两个客户端,一个用于password认证一个用于client认证\n            clients.inMemory().withClient("client_1")\n                    .resourceIds(DEMO_RESOURCE_ID)\n                    .authorizedGrantTypes("client_credentials", "refresh_token")\n                    .scopes("select")\n                    .authorities("client")\n                    .secret("123456")\n                    .and().withClient("client_2")\n                    .resourceIds(DEMO_RESOURCE_ID)\n                    .authorizedGrantTypes("password", "refresh_token")\n                    .scopes("select")\n                    .authorities("client")\n                    .secret("123456");\n        }\n\n        @Override\n        public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {\n            endpoints\n                    .tokenStore(new RedisTokenStore(redisConnectionFactory))\n                    .authenticationManager(authenticationManager);\n        }\n\n        @Override\n        public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {\n            //允许表单认证\n            oauthServer.allowFormAuthenticationForClients();\n        }\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n简单说下spring security oauth2的认证思路。\n\n * client模式，没有用户的概念，直接与认证服务器交互，用配置中的客户端信息去申请accessToken，客户端有自己的client_id,client_secret对应于用户的username,password，而客户端也拥有自己的authorities，当采取client模式认证时，对应的权限也就是客户端自己的authorities。\n * password模式，自己本身有一套用户体系，在认证时需要带上自己的用户名和密码，以及客户端的client_id,client_secret。此时，accessToken所包含的权限是用户本身的权限，而不是客户端的权限。\n\n我对于两种模式的理解便是，如果你的系统已经有了一套用户体系，每个用户也有了一定的权限，可以采用password模式；如果仅仅是接口的对接，不考虑用户，则可以使用client模式。\n\n\n# 配置spring security\n\n在spring security的版本迭代中，产生了多种配置方式，建造者模式，适配器模式等等设计模式的使用，spring security内部的认证flow也是错综复杂，在我一开始学习ss也产生了不少困惑，总结了一下配置经验：使用了springboot之后，spring security其实是有不少自动配置的，我们可以仅仅修改自己需要的那一部分，并且遵循一个原则，直接覆盖最需要的那一部分。这一说法比较抽象，举个例子。比如配置内存中的用户认证器。有两种配置方式\n\nplanA：\n\n@Bean\nprotected UserDetailsService userDetailsService(){\n    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();\n    manager.createUser(User.withUsername("user_1").password("123456").authorities("USER").build());\n    manager.createUser(User.withUsername("user_2").password("123456").authorities("USER").build());\n    return manager;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nplanB：\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.inMemoryAuthentication()\n                .withUser("user_1").password("123456").authorities("USER")\n                .and()\n                .withUser("user_2").password("123456").authorities("USER");\n   }\n\n   @Bean\n   @Override\n   public AuthenticationManager authenticationManagerBean() throws Exception {\n       AuthenticationManager manager = super.authenticationManagerBean();\n        return manager;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n你最终都能得到配置在内存中的两个用户，前者是直接替换掉了容器中的UserDetailsService，这么做比较直观；后者是替换了AuthenticationManager，当然你还会在SecurityConfiguration 复写其他配置，这么配置最终会由一个委托者去认证。如果你熟悉spring security，会知道AuthenticationManager和AuthenticationProvider以及UserDetailsService的关系，他们都是顶级的接口，实现类之间错综复杂的聚合关系…配置方式千差万别，但理解清楚认证流程，知道各个实现类对应的职责才是掌握spring security的关键。\n\n下面给出我最终的配置：\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    @Bean\n    @Override\n    protected UserDetailsService userDetailsService(){\n        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();\n        manager.createUser(User.withUsername("user_1").password("123456").authorities("USER").build());\n        manager.createUser(User.withUsername("user_2").password("123456").authorities("USER").build());\n        return manager;\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        // @formatter:off\n        http\n            .requestMatchers().anyRequest()\n            .and()\n                .authorizeRequests()\n                .antMatchers("/oauth/*").permitAll();\n        // @formatter:on\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n重点就是配置了一个UserDetailsService，和ClientDetailsService一样，为了方便运行，使用内存中的用户，实际项目中，一般使用的是数据库保存用户，具体的实现类可以使用JdbcDaoImpl或者JdbcUserDetailsManager。\n\n\n# 获取token\n\n进行如上配置之后，启动springboot应用就可以发现多了一些自动创建的endpoints：\n\n{[/oauth/authorize]}\n{[/oauth/authorize],methods=[POST]\n{[/oauth/token],methods=[GET]}\n{[/oauth/token],methods=[POST]}\n{[/oauth/check_token]}\n{[/oauth/error]}\n\n\n1\n2\n3\n4\n5\n6\n\n\n重点关注一下/oauth/token，它是获取的token的endpoint。启动springboot应用之后，使用http工具访问 password模式：\n\nhttp://localhost:8080/oauth/token?username=user_1&password=123456&grant_type=password&scope=select&client_id=client_2&client_secret=123456\n\n\n1\n\n\n响应如下： {"access_token":"950a7cc9-5a8a-42c9-a693-40e817b1a4b0","token_type":"bearer","refresh_token":"773a0fcd-6023-45f8-8848-e141296cb3cb","expires_in":27036,"scope":"select"}\n\nclient模式： http://localhost:8080/oauth/token?grant_type=client_credentials&scope=select&client_id=client_1&client_secret=123456\n\n响应如下： {"access_token":"56465b41-429d-436c-ad8d-613d476ff322","token_type":"bearer","expires_in":25074,"scope":"select"}\n\n在配置中，我们已经配置了对order资源的保护，如果直接访问:http://localhost:8080/order/1会得到这样的响应:{"error":"unauthorized","error_description":"Full authentication is required to access this resource"} （这样的错误响应可以通过重写配置来修改）\n\n而对于未受保护的product资源http://localhost:8080/product/1则可以直接访问，得到响应product id : 1\n\n携带accessToken参数访问受保护的资源：\n\n使用password模式获得的token:http://localhost:8080/order/1?access_token=950a7cc9-5a8a-42c9-a693-40e817b1a4b0，得到了之前匿名访问无法获取的资源：order id : 1\n\n使用client模式获得的token:http://localhost:8080/order/1?access_token=56465b41-429d-436c-ad8d-613d476ff322，同上的响应order id : 1\n\n我们重点关注一下debug后，对资源访问时系统记录的用户认证信息，可以看到如下的debug信息\n\npassword模式： password模式\n\nclient模式： client模式\n\n和我们的配置是一致的，仔细看可以发现两者的身份有些许的不同。想要查看更多的debug信息，可以选择下载demo代码自己查看，为了方便读者调试和验证，我去除了很多复杂的特性，基本实现了一个最简配置，涉及到数据库的地方也尽量配置到了内存中，这点记住在实际使用时一定要修改。\n\n到这儿，一个简单的oauth2入门示例就完成了，一个简单的配置教程。token的工作原理是什么，它包含了哪些信息？spring内部如何对身份信息进行验证？以及上述的配置到底影响了什么？这些内容会放到后面的文章中去分析。\n\n\n# 示例代码下载\n\n全部的代码可以在我的github上进行下载，项目使用springboot+maven构建： <https://github.com/lexburner/oauth2-demo',normalizedContent:'摘要: 原创出处 [https://www.cnkirito.moe/re%ef%bc%9a%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e7%9a%84spring%20security%20oauth2%ef%bc%88%e4%b8%80%ef%bc%89/](https://www.cnkirito.moe/re：从零开始的spring security oauth2（一）/) 「老徐」欢迎转载，保留摘要，谢谢！\n\n * 前言\n * 概述\n * 项目准备\n * 配置资源服务器和授权服务器\n * 配置spring security\n * 获取token\n * 示例代码下载\n\n----------------------------------------\n\n----------------------------------------\n\n\n# 前言\n\n今天来聊聊一个接口对接的场景，a厂家有一套http接口需要提供给b厂家使用，由于是外网环境，所以需要有一套安全机制保障，这个时候oauth2就可以作为一个方案。\n\n关于oauth2，其实是一个规范，本文重点讲解spring对他进行的实现，如果你还不清楚授权服务器，资源服务器，认证授权等基础概念，可以移步理解oauth 2.0 - 阮一峰，这是一篇对于oauth2很好的科普文章。\n\n需要对spring security有一定的配置使用经验，用户认证这一块，spring security oauth2建立在spring security的基础之上。第一篇文章主要是讲解使用springboot搭建一个简易的授权，资源服务器，在文末会给出具体代码的github地址。后续文章会进行spring security oauth2的相关源码分析。java中的安全框架如shrio，已经有跟我学shiro - 开涛，非常成体系地，深入浅出地讲解了apache的这个开源安全框架，但是spring security包括oauth2一直没有成体系的文章，学习它们大多依赖于较少的官方文档，理解一下基本的使用配置；通过零散的博客，了解一下他人的使用经验；打断点，分析内部的工作流程；看源码中的接口设计，以及注释，了解设计者的用意。spring的各个框架都运用了很多的设计模式，在学习源码的过程中，也大概了解了一些套路。spring也在必要的地方添加了适当的注释，避免了源码阅读者对于一些细节设计的理解产生偏差，让我更加感叹，spring不仅仅是一个工具框架，更像是一个艺术品。\n\n\n# 概述\n\n使用oauth2保护你的应用，可以分为简易的分为三个步骤\n\n * 配置资源服务器\n * 配置认证服务器\n * 配置spring security\n\n前两点是oauth2的主体内容，但前面我已经描述过了，spring security oauth2是建立在spring security基础之上的，所以有一些体系是公用的。\n\noauth2根据使用场景不同，分成了4种模式\n\n * 授权码模式（authorization code）\n * 简化模式（implicit）\n * 密码模式（resource owner password credentials）\n * 客户端模式（client credentials）\n\n本文重点讲解接口对接中常使用的密码模式（以下简称password模式）和客户端模式（以下简称client模式）。授权码模式使用到了回调地址，是最为复杂的方式，通常网站中经常出现的微博，qq第三方登录，都会采用这个形式。简化模式不常用。\n\n\n# 项目准备\n\n主要的maven依赖如下\n\n\x3c!-- 注意是starter,自动配置 --\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-security</artifactid>\n</dependency>\n\x3c!-- 不是starter,手动配置 --\x3e\n<dependency>\n    <groupid>org.springframework.security.oauth</groupid>\n    <artifactid>spring-security-oauth2</artifactid>\n</dependency>\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n\x3c!-- 将token存储在redis中 --\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n我们给自己先定个目标，要干什么事？既然说到保护应用，那必须得先有一些资源，我们创建一个endpoint作为提供给外部的接口：\n\n@restcontroller\npublic class testendpoints {\n\n    @getmapping("/product/{id}")\n    public string getproduct(@pathvariable string id) {\n        //for debug\n        authentication authentication = securitycontextholder.getcontext().getauthentication();\n        return "product id : " + id;\n    }\n\n    @getmapping("/order/{id}")\n    public string getorder(@pathvariable string id) {\n\t    //for debug\n        authentication authentication = securitycontextholder.getcontext().getauthentication();\n        return "order id : " + id;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n暴露一个商品查询接口，后续不做安全限制，一个订单查询接口，后续添加访问控制。\n\n\n# 配置资源服务器和授权服务器\n\n由于是两个oauth2的核心配置，我们放到一个配置类中。 为了方便下载代码直接运行，我这里将客户端信息放到了内存中，生产中可以配置到数据库中。token的存储一般选择使用redis，一是性能比较好，二是自动过期的机制，符合token的特性。\n\n@configuration\npublic class oauth2serverconfig {\n\n    private static final string demo_resource_id = "order";\n\n    @configuration\n    @enableresourceserver\n    protected static class resourceserverconfiguration extends resourceserverconfigureradapter {\n\n        @override\n        public void configure(resourceserversecurityconfigurer resources) {\n            resources.resourceid(demo_resource_id).stateless(true);\n        }\n\n        @override\n        public void configure(httpsecurity http) throws exception {\n            // @formatter:off\n            http\n                    // since we want the protected resources to be accessible in the ui as well we need\n                    // session creation to be allowed (it\'s disabled by default in 2.0.6)\n                    .sessionmanagement().sessioncreationpolicy(sessioncreationpolicy.if_required)\n                    .and()\n                    .requestmatchers().anyrequest()\n                    .and()\n                    .anonymous()\n                    .and()\n                    .authorizerequests()\n//                    .antmatchers("/product/**").access("#oauth2.hasscope(\'select\') and hasrole(\'role_user\')")\n                    .antmatchers("/order/**").authenticated();//配置order访问控制，必须认证过后才可以访问\n            // @formatter:on\n        }\n    }\n\n    @configuration\n    @enableauthorizationserver\n    protected static class authorizationserverconfiguration extends authorizationserverconfigureradapter {\n\n        @autowired\n        authenticationmanager authenticationmanager;\n        @autowired\n        redisconnectionfactory redisconnectionfactory;\n\n        @override\n        public void configure(clientdetailsserviceconfigurer clients) throws exception {\n            //配置两个客户端,一个用于password认证一个用于client认证\n            clients.inmemory().withclient("client_1")\n                    .resourceids(demo_resource_id)\n                    .authorizedgranttypes("client_credentials", "refresh_token")\n                    .scopes("select")\n                    .authorities("client")\n                    .secret("123456")\n                    .and().withclient("client_2")\n                    .resourceids(demo_resource_id)\n                    .authorizedgranttypes("password", "refresh_token")\n                    .scopes("select")\n                    .authorities("client")\n                    .secret("123456");\n        }\n\n        @override\n        public void configure(authorizationserverendpointsconfigurer endpoints) throws exception {\n            endpoints\n                    .tokenstore(new redistokenstore(redisconnectionfactory))\n                    .authenticationmanager(authenticationmanager);\n        }\n\n        @override\n        public void configure(authorizationserversecurityconfigurer oauthserver) throws exception {\n            //允许表单认证\n            oauthserver.allowformauthenticationforclients();\n        }\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n简单说下spring security oauth2的认证思路。\n\n * client模式，没有用户的概念，直接与认证服务器交互，用配置中的客户端信息去申请accesstoken，客户端有自己的client_id,client_secret对应于用户的username,password，而客户端也拥有自己的authorities，当采取client模式认证时，对应的权限也就是客户端自己的authorities。\n * password模式，自己本身有一套用户体系，在认证时需要带上自己的用户名和密码，以及客户端的client_id,client_secret。此时，accesstoken所包含的权限是用户本身的权限，而不是客户端的权限。\n\n我对于两种模式的理解便是，如果你的系统已经有了一套用户体系，每个用户也有了一定的权限，可以采用password模式；如果仅仅是接口的对接，不考虑用户，则可以使用client模式。\n\n\n# 配置spring security\n\n在spring security的版本迭代中，产生了多种配置方式，建造者模式，适配器模式等等设计模式的使用，spring security内部的认证flow也是错综复杂，在我一开始学习ss也产生了不少困惑，总结了一下配置经验：使用了springboot之后，spring security其实是有不少自动配置的，我们可以仅仅修改自己需要的那一部分，并且遵循一个原则，直接覆盖最需要的那一部分。这一说法比较抽象，举个例子。比如配置内存中的用户认证器。有两种配置方式\n\nplana：\n\n@bean\nprotected userdetailsservice userdetailsservice(){\n    inmemoryuserdetailsmanager manager = new inmemoryuserdetailsmanager();\n    manager.createuser(user.withusername("user_1").password("123456").authorities("user").build());\n    manager.createuser(user.withusername("user_2").password("123456").authorities("user").build());\n    return manager;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nplanb：\n\n@configuration\n@enablewebsecurity\npublic class securityconfiguration extends websecurityconfigureradapter {\n\n    @override\n    protected void configure(authenticationmanagerbuilder auth) throws exception {\n        auth.inmemoryauthentication()\n                .withuser("user_1").password("123456").authorities("user")\n                .and()\n                .withuser("user_2").password("123456").authorities("user");\n   }\n\n   @bean\n   @override\n   public authenticationmanager authenticationmanagerbean() throws exception {\n       authenticationmanager manager = super.authenticationmanagerbean();\n        return manager;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n你最终都能得到配置在内存中的两个用户，前者是直接替换掉了容器中的userdetailsservice，这么做比较直观；后者是替换了authenticationmanager，当然你还会在securityconfiguration 复写其他配置，这么配置最终会由一个委托者去认证。如果你熟悉spring security，会知道authenticationmanager和authenticationprovider以及userdetailsservice的关系，他们都是顶级的接口，实现类之间错综复杂的聚合关系…配置方式千差万别，但理解清楚认证流程，知道各个实现类对应的职责才是掌握spring security的关键。\n\n下面给出我最终的配置：\n\n@configuration\n@enablewebsecurity\npublic class securityconfiguration extends websecurityconfigureradapter {\n\n    @bean\n    @override\n    protected userdetailsservice userdetailsservice(){\n        inmemoryuserdetailsmanager manager = new inmemoryuserdetailsmanager();\n        manager.createuser(user.withusername("user_1").password("123456").authorities("user").build());\n        manager.createuser(user.withusername("user_2").password("123456").authorities("user").build());\n        return manager;\n    }\n\n    @override\n    protected void configure(httpsecurity http) throws exception {\n        // @formatter:off\n        http\n            .requestmatchers().anyrequest()\n            .and()\n                .authorizerequests()\n                .antmatchers("/oauth/*").permitall();\n        // @formatter:on\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n重点就是配置了一个userdetailsservice，和clientdetailsservice一样，为了方便运行，使用内存中的用户，实际项目中，一般使用的是数据库保存用户，具体的实现类可以使用jdbcdaoimpl或者jdbcuserdetailsmanager。\n\n\n# 获取token\n\n进行如上配置之后，启动springboot应用就可以发现多了一些自动创建的endpoints：\n\n{[/oauth/authorize]}\n{[/oauth/authorize],methods=[post]\n{[/oauth/token],methods=[get]}\n{[/oauth/token],methods=[post]}\n{[/oauth/check_token]}\n{[/oauth/error]}\n\n\n1\n2\n3\n4\n5\n6\n\n\n重点关注一下/oauth/token，它是获取的token的endpoint。启动springboot应用之后，使用http工具访问 password模式：\n\nhttp://localhost:8080/oauth/token?username=user_1&password=123456&grant_type=password&scope=select&client_id=client_2&client_secret=123456\n\n\n1\n\n\n响应如下： {"access_token":"950a7cc9-5a8a-42c9-a693-40e817b1a4b0","token_type":"bearer","refresh_token":"773a0fcd-6023-45f8-8848-e141296cb3cb","expires_in":27036,"scope":"select"}\n\nclient模式： http://localhost:8080/oauth/token?grant_type=client_credentials&scope=select&client_id=client_1&client_secret=123456\n\n响应如下： {"access_token":"56465b41-429d-436c-ad8d-613d476ff322","token_type":"bearer","expires_in":25074,"scope":"select"}\n\n在配置中，我们已经配置了对order资源的保护，如果直接访问:http://localhost:8080/order/1会得到这样的响应:{"error":"unauthorized","error_description":"full authentication is required to access this resource"} （这样的错误响应可以通过重写配置来修改）\n\n而对于未受保护的product资源http://localhost:8080/product/1则可以直接访问，得到响应product id : 1\n\n携带accesstoken参数访问受保护的资源：\n\n使用password模式获得的token:http://localhost:8080/order/1?access_token=950a7cc9-5a8a-42c9-a693-40e817b1a4b0，得到了之前匿名访问无法获取的资源：order id : 1\n\n使用client模式获得的token:http://localhost:8080/order/1?access_token=56465b41-429d-436c-ad8d-613d476ff322，同上的响应order id : 1\n\n我们重点关注一下debug后，对资源访问时系统记录的用户认证信息，可以看到如下的debug信息\n\npassword模式： password模式\n\nclient模式： client模式\n\n和我们的配置是一致的，仔细看可以发现两者的身份有些许的不同。想要查看更多的debug信息，可以选择下载demo代码自己查看，为了方便读者调试和验证，我去除了很多复杂的特性，基本实现了一个最简配置，涉及到数据库的地方也尽量配置到了内存中，这点记住在实际使用时一定要修改。\n\n到这儿，一个简单的oauth2入门示例就完成了，一个简单的配置教程。token的工作原理是什么，它包含了哪些信息？spring内部如何对身份信息进行验证？以及上述的配置到底影响了什么？这些内容会放到后面的文章中去分析。\n\n\n# 示例代码下载\n\n全部的代码可以在我的github上进行下载，项目使用springboot+maven构建： <https://github.com/lexburner/oauth2-demo',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"【老徐】从零开始的 Spring Security OAuth2（二）",frontmatter:{title:"【老徐】从零开始的 Spring Security OAuth2（二）",date:"2022-02-03T00:03:27.000Z",permalink:"/pages/3e6453/",categories:["后端","Spring Security"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/25.Spring%20Security/07.%E3%80%90%E8%80%81%E5%BE%90%E3%80%91%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%20Spring%20Security%20OAuth2%EF%BC%88%E4%BA%8C%EF%BC%89.html",relativePath:"10.框架/25.Spring Security/07.【老徐】从零开始的 Spring Security OAuth2（二）.md",key:"v-2bdfec00",path:"/pages/3e6453/",headers:[{level:2,title:"准备工作",slug:"准备工作",normalizedTitle:"准备工作",charIndex:3},{level:2,title:"@EnableAuthorizationServer",slug:"enableauthorizationserver",normalizedTitle:"@enableauthorizationserver",charIndex:11},{level:2,title:"客户端身份认证核心过滤器ClientCredentialsTokenEndpointFilter（掌握）",slug:"客户端身份认证核心过滤器clientcredentialstokenendpointfilter-掌握",normalizedTitle:"客户端身份认证核心过滤器clientcredentialstokenendpointfilter（掌握）",charIndex:41},{level:2,title:"顶级身份管理者AuthenticationManager（掌握）",slug:"顶级身份管理者authenticationmanager-掌握",normalizedTitle:"顶级身份管理者authenticationmanager（掌握）",charIndex:97},{level:2,title:"Token处理端点TokenEndpoint（掌握）",slug:"token处理端点tokenendpoint-掌握",normalizedTitle:"token处理端点tokenendpoint（掌握）",charIndex:3423},{level:2,title:"TokenGranter（掌握）",slug:"tokengranter-掌握",normalizedTitle:"tokengranter（掌握）",charIndex:6192},{level:2,title:"AuthorizationServerTokenServices（了解）",slug:"authorizationservertokenservices-了解",normalizedTitle:"authorizationservertokenservices（了解）",charIndex:133},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:173}],headersStr:"准备工作 @EnableAuthorizationServer 客户端身份认证核心过滤器ClientCredentialsTokenEndpointFilter（掌握） 顶级身份管理者AuthenticationManager（掌握） Token处理端点TokenEndpoint（掌握） TokenGranter（掌握） AuthorizationServerTokenServices（了解） 总结",content:' * 准备工作\n * @EnableAuthorizationServer\n * 客户端身份认证核心过滤器ClientCredentialsTokenEndpointFilter（掌握）\n * 顶级身份管理者AuthenticationManager（掌握）\n * AuthorizationServerTokenServices（了解）\n * 总结\n\n----------------------------------------\n\n----------------------------------------\n\n本文开始从源码的层面，讲解一些Spring Security Oauth2的认证流程。本文较长，适合在空余时间段观看。且涉及了较多的源码，非关键性代码以…代替。\n\n\n# 准备工作\n\n首先开启debug信息：\n\nlogging:\n  level:\n    org.springframework: DEBUG\n\n\n1\n2\n3\n\n\n可以完整的看到内部的运转流程。\n\nclient模式稍微简单一些，使用client模式获取token http://localhost:8080/oauth/token?client_id=client_1&client_secret=123456&scope=select&grant_type=client_credentials\n\n由于debug信息太多了，我简单按照顺序列了一下关键的几个类：\n\nClientCredentialsTokenEndpointFilter\nDaoAuthenticationProvider\nTokenEndpoint\nTokenGranter\n\n\n1\n2\n3\n4\n\n\n\n# @EnableAuthorizationServer\n\n上一篇博客中我们尝试使用了password模式和client模式，有一个比较关键的endpoint：/oauth/token。从这个入口开始分析，spring security oauth2内部是如何生成token的。获取token，与第一篇文章中的两个重要概念之一有关，也就是AuthorizationServer与ResourceServer中的AuthorizationServer。\n\n在之前的配置中\n\n@Configuration\n@EnableAuthorizationServer\nprotected static class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter {}\n\n\n1\n2\n3\n\n\n出现了AuthorizationServerConfigurerAdapter 关键类，他关联了三个重要的配置类，分别是\n\npublic class AuthorizationServerConfigurerAdapter implements AuthorizationServerConfigurer {\n\t@Override\n\tpublic void configure(AuthorizationServerSecurityConfigurer security <1>) throws Exception{\n\t}\n\n\t@Override\n\tpublic void configure(ClientDetailsServiceConfigurer clients <2>) throws Exception {\n\t}\n\n\t@Override\n\tpublic void configure(AuthorizationServerEndpointsConfigurer endpoints <3>) throws Exception {\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n<1> 配置AuthorizationServer安全认证的相关信息，创建ClientCredentialsTokenEndpointFilter核心过滤器\n\n<2> 配置OAuth2的客户端相关信息\n\n<3> 配置AuthorizationServerEndpointsConfigurer众多相关类，包括配置身份认证器，配置认证方式，TokenStore，TokenGranter，OAuth2RequestFactory\n\n我们逐步分析其中关键的类\n\n\n# 客户端身份认证核心过滤器ClientCredentialsTokenEndpointFilter（掌握）\n\n截取关键的代码，可以分析出大概的流程 在请求到达/oauth/token之前经过了ClientCredentialsTokenEndpointFilter这个过滤器，关键方法如下\n\npublic Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows AuthenticationException, IOException, ServletException {\n\t...\n\tString clientId = request.getParameter("client_id");\n\tString clientSecret = request.getParameter("client_secret");\n\n\t...\n\tclientId = clientId.trim();\n\tUsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(clientId,\n\t\t\tclientSecret);\n\n\treturn this.getAuthenticationManager().authenticate(authRequest);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 顶级身份管理者AuthenticationManager（掌握）\n\n用来从请求中获取client_id,client_secret，组装成一个UsernamePasswordAuthenticationToken作为身份标识，使用容器中的顶级身份管理器AuthenticationManager去进行身份认证（AuthenticationManager的实现类一般是ProviderManager。而ProviderManager内部维护了一个List,真正的身份认证是由一系列AuthenticationProvider去完成。而AuthenticationProvider的常用实现类则是DaoAuthenticationProvider，DaoAuthenticationProvider内部又聚合了一个UserDetailsService接口，UserDetailsService才是获取用户详细信息的最终接口，而我们上一篇文章中在内存中配置用户，就是使用了UserDetailsService的一个实现类InMemoryUserDetailsManager）。UML类图可以大概理解下这些类的关系，省略了授权部分。 认证相关\n\n图1 认证相关UML类图\n\n可能机智的读者会发现一个问题，我前面一篇文章已经提到了client模式是不存在“用户”的概念的，那么这里的身份认证是在认证什么呢？debug可以发现UserDetailsService的实现被适配成了ClientDetailsUserDetailsService，这个设计是将client客户端的信息（client_id,client_secret）适配成用户的信息(username,password)，这样我们的认证流程就不需要修改了。\n\n经过ClientCredentialsTokenEndpointFilter之后，身份信息已经得到了AuthenticationManager的验证。接着便到达了\n\nTokenEndpoint。\n\n\n# Token处理端点TokenEndpoint（掌握）\n\n前面的两个ClientCredentialsTokenEndpointFilter和AuthenticationManager可以理解为一些前置校验，和身份封装，而这个类一看名字就知道和我们的token是密切相关的。\n\n@FrameworkEndpoint\npublic class TokenEndpoint extends AbstractEndpoint {\n\n\t@RequestMapping(value = "/oauth/token", method=RequestMethod.POST)\n\tpublic ResponseEntity<OAuth2AccessToken> postAccessToken(Principal principal, @RequestParam\n\tMap<String, String> parameters) throws HttpRequestMethodNotSupportedException {\n\t\t ...\n\t\tString clientId = getClientId(principal);\n\t\tClientDetails authenticatedClient = getClientDetailsService().loadClientByClientId(clientId);//<1>\n\t\t...\n\t\tTokenRequest tokenRequest = getOAuth2RequestFactory().createTokenRequest(parameters, authenticatedClient);//<2>\n\t\t...\n\t\tOAuth2AccessToken token = getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);//<3>\n\t\t...\n\t\treturn getResponse(token);\n\n\t}\n\n\tprivate TokenGranter tokenGranter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n<1> 加载客户端信息\n\n<2> 结合请求信息，创建TokenRequest\n\n<3> 将TokenRequest传递给TokenGranter颁发token\n\n省略了一些校验代码之后，真正的/oauth/token端点暴露在了我们眼前，其中方法参数中的Principal经过之前的过滤器，已经被填充了相关的信息，而方法的内部则是依赖了一个TokenGranter 来颁发token。其中OAuth2AccessToken的实现类DefaultOAuth2AccessToken就是最终在控制台得到的token序列化之前的原始类:\n\npublic class DefaultOAuth2AccessToken implements Serializable, OAuth2AccessToken {\n  private static final long serialVersionUID = 914967629530462926L;\n  private String value;\n  private Date expiration;\n  private String tokenType = BEARER_TYPE.toLowerCase();\n  private OAuth2RefreshToken refreshToken;\n  private Set<String> scope;\n  private Map<String, Object> additionalInformation = Collections.emptyMap();\n  //getter,setter\n}\n@org.codehaus.jackson.map.annotate.JsonSerialize(using = OAuth2AccessTokenJackson1Serializer.class)\n@org.codehaus.jackson.map.annotate.JsonDeserialize(using = OAuth2AccessTokenJackson1Deserializer.class)\n@com.fasterxml.jackson.databind.annotation.JsonSerialize(using = OAuth2AccessTokenJackson2Serializer.class)\n@com.fasterxml.jackson.databind.annotation.JsonDeserialize(using = OAuth2AccessTokenJackson2Deserializer.class)\npublic interface OAuth2AccessToken {\n\tpublic static String BEARER_TYPE = "Bearer";\n\tpublic static String OAUTH2_TYPE = "OAuth2";\n\tpublic static String ACCESS_TOKEN = "access_token";\n\tpublic static String TOKEN_TYPE = "token_type";\n\tpublic static String EXPIRES_IN = "expires_in";\n\tpublic static String REFRESH_TOKEN = "refresh_token";\n\tpublic static String SCOPE = "scope";\n\t...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n一个典型的样例token响应,如下所示，就是上述类序列化后的结果：\n\n{\n\t"access_token":"950a7cc9-5a8a-42c9-a693-40e817b1a4b0",\n\t"token_type":"bearer",\n\t"refresh_token":"773a0fcd-6023-45f8-8848-e141296cb3cb",\n\t"expires_in":27036,\n\t"scope":"select"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# TokenGranter（掌握）\n\n先从UML类图对TokenGranter接口的设计有一个宏观的认识\n\n\n\n图2 TokenGranter相关UML类图\n\nTokenGranter的设计思路是使用CompositeTokenGranter管理一个List列表，每一种grantType对应一个具体的真正授权者，在debug过程中可以发现CompositeTokenGranter 内部就是在循环调用五种TokenGranter实现类的grant方法，而granter内部则是通过grantType来区分是否是各自的授权类型。\n\npublic class CompositeTokenGranter implements TokenGranter {\n\n\tprivate final List<TokenGranter> tokenGranters;\n\n\tpublic CompositeTokenGranter(List<TokenGranter> tokenGranters) {\n\t\tthis.tokenGranters = new ArrayList<TokenGranter>(tokenGranters);\n\t}\n\n\tpublic OAuth2AccessToken grant(String grantType, TokenRequest tokenRequest) {\n\t\tfor (TokenGranter granter : tokenGranters) {\n\t\t\tOAuth2AccessToken grant = granter.grant(grantType, tokenRequest);\n\t\t\tif (grant!=null) {\n\t\t\t\treturn grant;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n五种类型分别是：\n\n * ResourceOwnerPasswordTokenGranter ==> password密码模式\n * AuthorizationCodeTokenGranter ==> authorization_code授权码模式\n * ClientCredentialsTokenGranter ==> client_credentials客户端模式\n * ImplicitTokenGranter ==> implicit简化模式\n * RefreshTokenGranter ==>refresh_token 刷新token专用\n\n以客户端模式为例，思考如何产生token的，则需要继续研究5种授权者的抽象类：AbstractTokenGranter\n\npublic abstract class AbstractTokenGranter implements TokenGranter {\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\t//与token相关的service，重点\n\tprivate final AuthorizationServerTokenServices tokenServices;\n\t//与clientDetails相关的service，重点\n\tprivate final ClientDetailsService clientDetailsService;\n\t//创建oauth2Request的工厂，重点\n\tprivate final OAuth2RequestFactory requestFactory;\n\n\tprivate final String grantType;\n\t...\n\n\tpublic OAuth2AccessToken grant(String grantType, TokenRequest tokenRequest) {\n\n\t\t...\n\t\tString clientId = tokenRequest.getClientId();\n\t\tClientDetails client = clientDetailsService.loadClientByClientId(clientId);\n\t\tvalidateGrantType(grantType, client);\n\n\t\tlogger.debug("Getting access token for: " + clientId);\n\n\t\treturn getAccessToken(client, tokenRequest);\n\n\t}\n\n\tprotected OAuth2AccessToken getAccessToken(ClientDetails client, TokenRequest tokenRequest) {\n\t\treturn tokenServices.createAccessToken(getOAuth2Authentication(client, tokenRequest));\n\t}\n\n\tprotected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) {\n\t\tOAuth2Request storedOAuth2Request = requestFactory.createOAuth2Request(client, tokenRequest);\n\t\treturn new OAuth2Authentication(storedOAuth2Request, null);\n\t}\n\n\t...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n回过头去看TokenEndpoint中，正是调用了这里的三个重要的类变量的相关方法。由于篇幅限制，不能延展太多，不然没完没了，所以重点分析下AuthorizationServerTokenServices是何方神圣。\n\n\n# AuthorizationServerTokenServices（了解）\n\nAuthorizationServer端的token操作service，接口设计如下：\n\npublic interface AuthorizationServerTokenServices {\n\t//创建token\n\tOAuth2AccessToken createAccessToken(OAuth2Authentication authentication) throws AuthenticationException;\n\t//刷新token\n\tOAuth2AccessToken refreshAccessToken(String refreshToken, TokenRequest tokenRequest)\n\t\t\tthrows AuthenticationException;\n\t//获取token\n\tOAuth2AccessToken getAccessToken(OAuth2Authentication authentication);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在默认的实现类DefaultTokenServices中，可以看到token是如何产生的，并且了解了框架对token进行哪些信息的关联。\n\n@Transactional\npublic OAuth2AccessToken createAccessToken(OAuth2Authentication authentication) throws AuthenticationException {\n\n\tOAuth2AccessToken existingAccessToken = tokenStore.getAccessToken(authentication);\n\tOAuth2RefreshToken refreshToken = null;\n\tif (existingAccessToken != null) {\n\t\tif (existingAccessToken.isExpired()) {\n\t\t\tif (existingAccessToken.getRefreshToken() != null) {\n\t\t\t\trefreshToken = existingAccessToken.getRefreshToken();\n\t\t\t\t// The token store could remove the refresh token when the\n\t\t\t\t// access token is removed, but we want to\n\t\t\t\t// be sure...\n\t\t\t\ttokenStore.removeRefreshToken(refreshToken);\n\t\t\t}\n\t\t\ttokenStore.removeAccessToken(existingAccessToken);\n\t\t}\n\t\telse {\n\t\t\t// Re-store the access token in case the authentication has changed\n\t\t\ttokenStore.storeAccessToken(existingAccessToken, authentication);\n\t\t\treturn existingAccessToken;\n\t\t}\n\t}\n\n\t// Only create a new refresh token if there wasn\'t an existing one\n\t// associated with an expired access token.\n\t// Clients might be holding existing refresh tokens, so we re-use it in\n\t// the case that the old access token\n\t// expired.\n\tif (refreshToken == null) {\n\t\trefreshToken = createRefreshToken(authentication);\n\t}\n\t// But the refresh token itself might need to be re-issued if it has\n\t// expired.\n\telse if (refreshToken instanceof ExpiringOAuth2RefreshToken) {\n\t\tExpiringOAuth2RefreshToken expiring = (ExpiringOAuth2RefreshToken) refreshToken;\n\t\tif (System.currentTimeMillis() > expiring.getExpiration().getTime()) {\n\t\t\trefreshToken = createRefreshToken(authentication);\n\t\t}\n\t}\n\n\tOAuth2AccessToken accessToken = createAccessToken(authentication, refreshToken);\n\ttokenStore.storeAccessToken(accessToken, authentication);\n\t// In case it was modified\n\trefreshToken = accessToken.getRefreshToken();\n\tif (refreshToken != null) {\n\t\ttokenStore.storeRefreshToken(refreshToken, authentication);\n\t}\n\treturn accessToken;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n简单总结一下AuthorizationServerTokenServices的作用，他提供了创建token，刷新token，获取token的实现。在创建token时，他会调用tokenStore对产生的token和相关信息存储到对应的实现类中，可以是redis，数据库，内存，jwt。\n\n\n# 总结\n\n本篇总结了使用客户端模式获取Token时，spring security oauth2内部的运作流程，重点是在分析AuthenticationServer相关的类。其他模式有一定的不同，但抽象功能是固定的，只是具体的实现类会被相应地替换。阅读spring的源码，会发现它的设计中出现了非常多的抽象接口，这对我们理清楚内部工作流程产生了不小的困扰，我的方式是可以借助UML类图，先从宏观理清楚作者的设计思路，这会让我们的分析事半功倍。\n\n下一篇文章重点分析用户携带token访问受限资源时，spring security oauth2内部的工作流程。即ResourceServer相关的类。',normalizedContent:' * 准备工作\n * @enableauthorizationserver\n * 客户端身份认证核心过滤器clientcredentialstokenendpointfilter（掌握）\n * 顶级身份管理者authenticationmanager（掌握）\n * authorizationservertokenservices（了解）\n * 总结\n\n----------------------------------------\n\n----------------------------------------\n\n本文开始从源码的层面，讲解一些spring security oauth2的认证流程。本文较长，适合在空余时间段观看。且涉及了较多的源码，非关键性代码以…代替。\n\n\n# 准备工作\n\n首先开启debug信息：\n\nlogging:\n  level:\n    org.springframework: debug\n\n\n1\n2\n3\n\n\n可以完整的看到内部的运转流程。\n\nclient模式稍微简单一些，使用client模式获取token http://localhost:8080/oauth/token?client_id=client_1&client_secret=123456&scope=select&grant_type=client_credentials\n\n由于debug信息太多了，我简单按照顺序列了一下关键的几个类：\n\nclientcredentialstokenendpointfilter\ndaoauthenticationprovider\ntokenendpoint\ntokengranter\n\n\n1\n2\n3\n4\n\n\n\n# @enableauthorizationserver\n\n上一篇博客中我们尝试使用了password模式和client模式，有一个比较关键的endpoint：/oauth/token。从这个入口开始分析，spring security oauth2内部是如何生成token的。获取token，与第一篇文章中的两个重要概念之一有关，也就是authorizationserver与resourceserver中的authorizationserver。\n\n在之前的配置中\n\n@configuration\n@enableauthorizationserver\nprotected static class authorizationserverconfiguration extends authorizationserverconfigureradapter {}\n\n\n1\n2\n3\n\n\n出现了authorizationserverconfigureradapter 关键类，他关联了三个重要的配置类，分别是\n\npublic class authorizationserverconfigureradapter implements authorizationserverconfigurer {\n\t@override\n\tpublic void configure(authorizationserversecurityconfigurer security <1>) throws exception{\n\t}\n\n\t@override\n\tpublic void configure(clientdetailsserviceconfigurer clients <2>) throws exception {\n\t}\n\n\t@override\n\tpublic void configure(authorizationserverendpointsconfigurer endpoints <3>) throws exception {\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n<1> 配置authorizationserver安全认证的相关信息，创建clientcredentialstokenendpointfilter核心过滤器\n\n<2> 配置oauth2的客户端相关信息\n\n<3> 配置authorizationserverendpointsconfigurer众多相关类，包括配置身份认证器，配置认证方式，tokenstore，tokengranter，oauth2requestfactory\n\n我们逐步分析其中关键的类\n\n\n# 客户端身份认证核心过滤器clientcredentialstokenendpointfilter（掌握）\n\n截取关键的代码，可以分析出大概的流程 在请求到达/oauth/token之前经过了clientcredentialstokenendpointfilter这个过滤器，关键方法如下\n\npublic authentication attemptauthentication(httpservletrequest request, httpservletresponse response)\n\t\tthrows authenticationexception, ioexception, servletexception {\n\t...\n\tstring clientid = request.getparameter("client_id");\n\tstring clientsecret = request.getparameter("client_secret");\n\n\t...\n\tclientid = clientid.trim();\n\tusernamepasswordauthenticationtoken authrequest = new usernamepasswordauthenticationtoken(clientid,\n\t\t\tclientsecret);\n\n\treturn this.getauthenticationmanager().authenticate(authrequest);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 顶级身份管理者authenticationmanager（掌握）\n\n用来从请求中获取client_id,client_secret，组装成一个usernamepasswordauthenticationtoken作为身份标识，使用容器中的顶级身份管理器authenticationmanager去进行身份认证（authenticationmanager的实现类一般是providermanager。而providermanager内部维护了一个list,真正的身份认证是由一系列authenticationprovider去完成。而authenticationprovider的常用实现类则是daoauthenticationprovider，daoauthenticationprovider内部又聚合了一个userdetailsservice接口，userdetailsservice才是获取用户详细信息的最终接口，而我们上一篇文章中在内存中配置用户，就是使用了userdetailsservice的一个实现类inmemoryuserdetailsmanager）。uml类图可以大概理解下这些类的关系，省略了授权部分。 认证相关\n\n图1 认证相关uml类图\n\n可能机智的读者会发现一个问题，我前面一篇文章已经提到了client模式是不存在“用户”的概念的，那么这里的身份认证是在认证什么呢？debug可以发现userdetailsservice的实现被适配成了clientdetailsuserdetailsservice，这个设计是将client客户端的信息（client_id,client_secret）适配成用户的信息(username,password)，这样我们的认证流程就不需要修改了。\n\n经过clientcredentialstokenendpointfilter之后，身份信息已经得到了authenticationmanager的验证。接着便到达了\n\ntokenendpoint。\n\n\n# token处理端点tokenendpoint（掌握）\n\n前面的两个clientcredentialstokenendpointfilter和authenticationmanager可以理解为一些前置校验，和身份封装，而这个类一看名字就知道和我们的token是密切相关的。\n\n@frameworkendpoint\npublic class tokenendpoint extends abstractendpoint {\n\n\t@requestmapping(value = "/oauth/token", method=requestmethod.post)\n\tpublic responseentity<oauth2accesstoken> postaccesstoken(principal principal, @requestparam\n\tmap<string, string> parameters) throws httprequestmethodnotsupportedexception {\n\t\t ...\n\t\tstring clientid = getclientid(principal);\n\t\tclientdetails authenticatedclient = getclientdetailsservice().loadclientbyclientid(clientid);//<1>\n\t\t...\n\t\ttokenrequest tokenrequest = getoauth2requestfactory().createtokenrequest(parameters, authenticatedclient);//<2>\n\t\t...\n\t\toauth2accesstoken token = gettokengranter().grant(tokenrequest.getgranttype(), tokenrequest);//<3>\n\t\t...\n\t\treturn getresponse(token);\n\n\t}\n\n\tprivate tokengranter tokengranter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n<1> 加载客户端信息\n\n<2> 结合请求信息，创建tokenrequest\n\n<3> 将tokenrequest传递给tokengranter颁发token\n\n省略了一些校验代码之后，真正的/oauth/token端点暴露在了我们眼前，其中方法参数中的principal经过之前的过滤器，已经被填充了相关的信息，而方法的内部则是依赖了一个tokengranter 来颁发token。其中oauth2accesstoken的实现类defaultoauth2accesstoken就是最终在控制台得到的token序列化之前的原始类:\n\npublic class defaultoauth2accesstoken implements serializable, oauth2accesstoken {\n  private static final long serialversionuid = 914967629530462926l;\n  private string value;\n  private date expiration;\n  private string tokentype = bearer_type.tolowercase();\n  private oauth2refreshtoken refreshtoken;\n  private set<string> scope;\n  private map<string, object> additionalinformation = collections.emptymap();\n  //getter,setter\n}\n@org.codehaus.jackson.map.annotate.jsonserialize(using = oauth2accesstokenjackson1serializer.class)\n@org.codehaus.jackson.map.annotate.jsondeserialize(using = oauth2accesstokenjackson1deserializer.class)\n@com.fasterxml.jackson.databind.annotation.jsonserialize(using = oauth2accesstokenjackson2serializer.class)\n@com.fasterxml.jackson.databind.annotation.jsondeserialize(using = oauth2accesstokenjackson2deserializer.class)\npublic interface oauth2accesstoken {\n\tpublic static string bearer_type = "bearer";\n\tpublic static string oauth2_type = "oauth2";\n\tpublic static string access_token = "access_token";\n\tpublic static string token_type = "token_type";\n\tpublic static string expires_in = "expires_in";\n\tpublic static string refresh_token = "refresh_token";\n\tpublic static string scope = "scope";\n\t...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n一个典型的样例token响应,如下所示，就是上述类序列化后的结果：\n\n{\n\t"access_token":"950a7cc9-5a8a-42c9-a693-40e817b1a4b0",\n\t"token_type":"bearer",\n\t"refresh_token":"773a0fcd-6023-45f8-8848-e141296cb3cb",\n\t"expires_in":27036,\n\t"scope":"select"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# tokengranter（掌握）\n\n先从uml类图对tokengranter接口的设计有一个宏观的认识\n\n\n\n图2 tokengranter相关uml类图\n\ntokengranter的设计思路是使用compositetokengranter管理一个list列表，每一种granttype对应一个具体的真正授权者，在debug过程中可以发现compositetokengranter 内部就是在循环调用五种tokengranter实现类的grant方法，而granter内部则是通过granttype来区分是否是各自的授权类型。\n\npublic class compositetokengranter implements tokengranter {\n\n\tprivate final list<tokengranter> tokengranters;\n\n\tpublic compositetokengranter(list<tokengranter> tokengranters) {\n\t\tthis.tokengranters = new arraylist<tokengranter>(tokengranters);\n\t}\n\n\tpublic oauth2accesstoken grant(string granttype, tokenrequest tokenrequest) {\n\t\tfor (tokengranter granter : tokengranters) {\n\t\t\toauth2accesstoken grant = granter.grant(granttype, tokenrequest);\n\t\t\tif (grant!=null) {\n\t\t\t\treturn grant;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n五种类型分别是：\n\n * resourceownerpasswordtokengranter ==> password密码模式\n * authorizationcodetokengranter ==> authorization_code授权码模式\n * clientcredentialstokengranter ==> client_credentials客户端模式\n * implicittokengranter ==> implicit简化模式\n * refreshtokengranter ==>refresh_token 刷新token专用\n\n以客户端模式为例，思考如何产生token的，则需要继续研究5种授权者的抽象类：abstracttokengranter\n\npublic abstract class abstracttokengranter implements tokengranter {\n\tprotected final log logger = logfactory.getlog(getclass());\n\t//与token相关的service，重点\n\tprivate final authorizationservertokenservices tokenservices;\n\t//与clientdetails相关的service，重点\n\tprivate final clientdetailsservice clientdetailsservice;\n\t//创建oauth2request的工厂，重点\n\tprivate final oauth2requestfactory requestfactory;\n\n\tprivate final string granttype;\n\t...\n\n\tpublic oauth2accesstoken grant(string granttype, tokenrequest tokenrequest) {\n\n\t\t...\n\t\tstring clientid = tokenrequest.getclientid();\n\t\tclientdetails client = clientdetailsservice.loadclientbyclientid(clientid);\n\t\tvalidategranttype(granttype, client);\n\n\t\tlogger.debug("getting access token for: " + clientid);\n\n\t\treturn getaccesstoken(client, tokenrequest);\n\n\t}\n\n\tprotected oauth2accesstoken getaccesstoken(clientdetails client, tokenrequest tokenrequest) {\n\t\treturn tokenservices.createaccesstoken(getoauth2authentication(client, tokenrequest));\n\t}\n\n\tprotected oauth2authentication getoauth2authentication(clientdetails client, tokenrequest tokenrequest) {\n\t\toauth2request storedoauth2request = requestfactory.createoauth2request(client, tokenrequest);\n\t\treturn new oauth2authentication(storedoauth2request, null);\n\t}\n\n\t...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n回过头去看tokenendpoint中，正是调用了这里的三个重要的类变量的相关方法。由于篇幅限制，不能延展太多，不然没完没了，所以重点分析下authorizationservertokenservices是何方神圣。\n\n\n# authorizationservertokenservices（了解）\n\nauthorizationserver端的token操作service，接口设计如下：\n\npublic interface authorizationservertokenservices {\n\t//创建token\n\toauth2accesstoken createaccesstoken(oauth2authentication authentication) throws authenticationexception;\n\t//刷新token\n\toauth2accesstoken refreshaccesstoken(string refreshtoken, tokenrequest tokenrequest)\n\t\t\tthrows authenticationexception;\n\t//获取token\n\toauth2accesstoken getaccesstoken(oauth2authentication authentication);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在默认的实现类defaulttokenservices中，可以看到token是如何产生的，并且了解了框架对token进行哪些信息的关联。\n\n@transactional\npublic oauth2accesstoken createaccesstoken(oauth2authentication authentication) throws authenticationexception {\n\n\toauth2accesstoken existingaccesstoken = tokenstore.getaccesstoken(authentication);\n\toauth2refreshtoken refreshtoken = null;\n\tif (existingaccesstoken != null) {\n\t\tif (existingaccesstoken.isexpired()) {\n\t\t\tif (existingaccesstoken.getrefreshtoken() != null) {\n\t\t\t\trefreshtoken = existingaccesstoken.getrefreshtoken();\n\t\t\t\t// the token store could remove the refresh token when the\n\t\t\t\t// access token is removed, but we want to\n\t\t\t\t// be sure...\n\t\t\t\ttokenstore.removerefreshtoken(refreshtoken);\n\t\t\t}\n\t\t\ttokenstore.removeaccesstoken(existingaccesstoken);\n\t\t}\n\t\telse {\n\t\t\t// re-store the access token in case the authentication has changed\n\t\t\ttokenstore.storeaccesstoken(existingaccesstoken, authentication);\n\t\t\treturn existingaccesstoken;\n\t\t}\n\t}\n\n\t// only create a new refresh token if there wasn\'t an existing one\n\t// associated with an expired access token.\n\t// clients might be holding existing refresh tokens, so we re-use it in\n\t// the case that the old access token\n\t// expired.\n\tif (refreshtoken == null) {\n\t\trefreshtoken = createrefreshtoken(authentication);\n\t}\n\t// but the refresh token itself might need to be re-issued if it has\n\t// expired.\n\telse if (refreshtoken instanceof expiringoauth2refreshtoken) {\n\t\texpiringoauth2refreshtoken expiring = (expiringoauth2refreshtoken) refreshtoken;\n\t\tif (system.currenttimemillis() > expiring.getexpiration().gettime()) {\n\t\t\trefreshtoken = createrefreshtoken(authentication);\n\t\t}\n\t}\n\n\toauth2accesstoken accesstoken = createaccesstoken(authentication, refreshtoken);\n\ttokenstore.storeaccesstoken(accesstoken, authentication);\n\t// in case it was modified\n\trefreshtoken = accesstoken.getrefreshtoken();\n\tif (refreshtoken != null) {\n\t\ttokenstore.storerefreshtoken(refreshtoken, authentication);\n\t}\n\treturn accesstoken;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n简单总结一下authorizationservertokenservices的作用，他提供了创建token，刷新token，获取token的实现。在创建token时，他会调用tokenstore对产生的token和相关信息存储到对应的实现类中，可以是redis，数据库，内存，jwt。\n\n\n# 总结\n\n本篇总结了使用客户端模式获取token时，spring security oauth2内部的运作流程，重点是在分析authenticationserver相关的类。其他模式有一定的不同，但抽象功能是固定的，只是具体的实现类会被相应地替换。阅读spring的源码，会发现它的设计中出现了非常多的抽象接口，这对我们理清楚内部工作流程产生了不小的困扰，我的方式是可以借助uml类图，先从宏观理清楚作者的设计思路，这会让我们的分析事半功倍。\n\n下一篇文章重点分析用户携带token访问受限资源时，spring security oauth2内部的工作流程。即resourceserver相关的类。',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"【老徐】从零开始的 Spring Security OAuth2（三）",frontmatter:{title:"【老徐】从零开始的 Spring Security OAuth2（三）",date:"2022-02-03T00:03:27.000Z",permalink:"/pages/202614/",categories:["后端","Spring Security"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/25.Spring%20Security/08.%E3%80%90%E8%80%81%E5%BE%90%E3%80%91%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%20Spring%20Security%20OAuth2%EF%BC%88%E4%B8%89%EF%BC%89.html",relativePath:"10.框架/25.Spring Security/08.【老徐】从零开始的 Spring Security OAuth2（三）.md",key:"v-f7677c3c",path:"/pages/202614/",headers:[{level:2,title:"@EnableResourceServer与@EnableAuthorizationServer",slug:"enableresourceserver与-enableauthorizationserver",normalizedTitle:"@enableresourceserver与@enableauthorizationserver",charIndex:3},{level:2,title:"ResourceServerSecurityConfigurer（了解）",slug:"resourceserversecurityconfigurer-了解",normalizedTitle:"resourceserversecurityconfigurer（了解）",charIndex:55},{level:2,title:"核心过滤器 OAuth2AuthenticationProcessingFilter（掌握）",slug:"核心过滤器-oauth2authenticationprocessingfilter-掌握",normalizedTitle:"核心过滤器 oauth2authenticationprocessingfilter（掌握）",charIndex:95},{level:2,title:"OAuth2的身份管理器–OAuth2AuthenticationManager（掌握）",slug:"oauth2的身份管理器-oauth2authenticationmanager-掌握",normalizedTitle:"oauth2的身份管理器–oauth2authenticationmanager（掌握）",charIndex:145},{level:2,title:"TokenExtractor（了解）",slug:"tokenextractor-了解",normalizedTitle:"tokenextractor（了解）",charIndex:193},{level:2,title:"异常处理",slug:"异常处理",normalizedTitle:"异常处理",charIndex:215},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:223}],headersStr:"@EnableResourceServer与@EnableAuthorizationServer ResourceServerSecurityConfigurer（了解） 核心过滤器 OAuth2AuthenticationProcessingFilter（掌握） OAuth2的身份管理器–OAuth2AuthenticationManager（掌握） TokenExtractor（了解） 异常处理 总结",content:' * @EnableResourceServer与@EnableAuthorizationServer\n * ResourceServerSecurityConfigurer（了解）\n * 核心过滤器 OAuth2AuthenticationProcessingFilter（掌握）\n * OAuth2的身份管理器–OAuth2AuthenticationManager（掌握）\n * TokenExtractor（了解）\n * 异常处理\n * 总结\n\n----------------------------------------\n\n----------------------------------------\n\n上一篇文章中我们介绍了获取token的流程，这一篇重点分析一下，携带token访问受限资源时，内部的工作流程。\n\n\n# @EnableResourceServer与@EnableAuthorizationServer\n\n还记得我们在第一节中就介绍过了OAuth2的两个核心概念，资源服务器与身份认证服务器。我们对两个注解进行配置的同时，到底触发了内部的什么相关配置呢？\n\n上一篇文章重点介绍的其实是与身份认证相关的流程，即如果获取token，而本节要分析的携带token访问受限资源，自然便是与@EnableResourceServer相关的资源服务器配置了。\n\n我们注意到其相关配置类是ResourceServerConfigurer，内部关联了ResourceServerSecurityConfigurer和HttpSecurity。前者与资源安全配置相关，后者与http安全配置相关。（类名比较类似，注意区分，以Adapter结尾的是适配器，以Configurer结尾的是配置器，以Builder结尾的是建造器，他们分别代表不同的设计模式，对设计模式有所了解可以更加方便理解其设计思路）\n\npublic class ResourceServerConfigurerAdapter implements ResourceServerConfigurer {\n\t@Override\n\tpublic void configure(ResourceServerSecurityConfigurer resources <1> ) throws Exception {\n\t}\n\n\t@Override\n\tpublic void configure(HttpSecurity http) throws Exception {\n\t\thttp.authorizeRequests().anyRequest().authenticated();\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n<1> ResourceServerSecurityConfigurer显然便是我们分析的重点了。\n\n\n# ResourceServerSecurityConfigurer（了解）\n\n其核心配置如下所示：\n\npublic void configure(HttpSecurity http) throws Exception {\n\tAuthenticationManager oauthAuthenticationManager = oauthAuthenticationManager(http);\n\tresourcesServerFilter = new OAuth2AuthenticationProcessingFilter();//<1>\n\tresourcesServerFilter.setAuthenticationEntryPoint(authenticationEntryPoint);\n\tresourcesServerFilter.setAuthenticationManager(oauthAuthenticationManager);//<2>\n\tif (eventPublisher != null) {\n\t\tresourcesServerFilter.setAuthenticationEventPublisher(eventPublisher);\n\t}\n\tif (tokenExtractor != null) {\n\t\tresourcesServerFilter.setTokenExtractor(tokenExtractor);//<3>\n\t}\n\tresourcesServerFilter = postProcess(resourcesServerFilter);\n\tresourcesServerFilter.setStateless(stateless);\n\n\t// @formatter:off\n\thttp\n\t\t.authorizeRequests().expressionHandler(expressionHandler)\n\t.and()\n\t\t.addFilterBefore(resourcesServerFilter, AbstractPreAuthenticatedProcessingFilter.class)\n\t\t.exceptionHandling()\n\t\t\t.accessDeniedHandler(accessDeniedHandler)//<4>\n\t\t\t.authenticationEntryPoint(authenticationEntryPoint);\n\t// @formatter:on\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n这段是整个oauth2与HttpSecurity相关的核心配置，其中有非常多的注意点，顺带的都强调一下：\n\n<1> 创建OAuth2AuthenticationProcessingFilter，即下一节所要介绍的OAuth2核心过滤器。\n\n<2> 为OAuth2AuthenticationProcessingFilter提供固定的AuthenticationManager即OAuth2AuthenticationManager，它并没有将OAuth2AuthenticationManager添加到spring的容器中，不然可能会影响spring security的普通认证流程（非oauth2请求），只有被OAuth2AuthenticationProcessingFilter拦截到的oauth2相关请求才被特殊的身份认证器处理。\n\n<3> 设置了TokenExtractor默认的实现—-BearerTokenExtractor，这个类在下一节介绍。\n\n<4> 相关的异常处理器，可以重写相关实现，达到自定义异常的目的。\n\n还记得我们在一开始的配置中配置了资源服务器，是它触发了相关的配置。\n\n@Configuration\n@EnableResourceServer\nprotected static class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {}\n\n\n1\n2\n3\n\n\n\n# 核心过滤器 OAuth2AuthenticationProcessingFilter（掌握）\n\n回顾一下我们之前是如何携带token访问受限资源的： http://localhost:8080/order/1?access_token=950a7cc9-5a8a-42c9-a693-40e817b1a4b0 唯一的身份凭证，便是这个access_token，携带它进行访问，会进入OAuth2AuthenticationProcessingFilter之中，其核心代码如下：\n\npublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain){\n\tfinal HttpServletRequest request = (HttpServletRequest) req;\n\tfinal HttpServletResponse response = (HttpServletResponse) res;\n\n\ttry {\n\t\t//从请求中取出身份信息，即access_token\n\t\tAuthentication authentication = tokenExtractor.extract(request);\n\n\t\tif (authentication == null) {\n\t\t\t...\n\t\t}\n\t\telse {\n\t\t\trequest.setAttribute(OAuth2AuthenticationDetails.ACCESS_TOKEN_VALUE, authentication.getPrincipal());\n\t\t\tif (authentication instanceof AbstractAuthenticationToken) {\n\t\t\t\tAbstractAuthenticationToken needsDetails = (AbstractAuthenticationToken) authentication;\n\t\t\t\tneedsDetails.setDetails(authenticationDetailsSource.buildDetails(request));\n\t\t\t}\n\t\t\t//认证身份\n\t\t\tAuthentication authResult = authenticationManager.authenticate(authentication);\n\t\t\t...\n\t\t\teventPublisher.publishAuthenticationSuccess(authResult);\n\t\t\t//将身份信息绑定到SecurityContextHolder中\n\t\t\tSecurityContextHolder.getContext().setAuthentication(authResult);\n\t\t}\n\t}\n\tcatch (OAuth2Exception failed) {\n\t\t...\n\t\treturn;\n\t}\n\n\tchain.doFilter(request, response);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n整个过滤器便是oauth2身份鉴定的关键，在源码中，对这个类有一段如下的描述\n\n> A pre-authentication filter for OAuth2 protected resources. Extracts an OAuth2 token from the incoming request and uses it to populate the Spring Security context with an {@link OAuth2Authentication} (if used in conjunction with an {@link OAuth2AuthenticationManager}). OAuth2保护资源的预先认证过滤器。如果与OAuth2AuthenticationManager结合使用，则会从到来的请求之中提取一个OAuth2 token，之后使用OAuth2Authentication来填充Spring Security上下文。\n\n其中涉及到了两个关键的类TokenExtractor，AuthenticationManager。相信后者这个接口大家已经不陌生，但前面这个类之前还未出现在我们的视野中。\n\n\n# OAuth2的身份管理器–OAuth2AuthenticationManager（掌握）\n\n在之前的OAuth2核心过滤器中出现的AuthenticationManager其实在我们意料之中，携带access_token必定得经过身份认证，但是在我们debug进入其中后，发现了一个出乎意料的事，AuthenticationManager的实现类并不是我们在前面文章中聊到的常用实现类ProviderManager，而是OAuth2AuthenticationManager。\n\nOAuth2AuthenticationManager\n\n图1 新的AuthenticationManager实现类OAuth2AuthenticationManager\n\n回顾我们第一篇文章的配置，压根没有出现过这个OAuth2AuthenticationManager，并且它脱离了我们熟悉的认证流程（第二篇文章中的认证管理器UML图是一张经典的spring security结构类图），它直接重写了容器的顶级身份认证接口，内部维护了一个ClientDetailService和ResourceServerTokenServices，这两个核心类在 Re：从零开始的Spring Security Oauth2（二）有分析过。在ResourceServerSecurityConfigurer的小节中我们已经知晓了它是如何被框架自动配置的，这里要强调的是OAuth2AuthenticationManager是密切与token认证相关的，而不是与获取token密切相关的。\n\n其判别身份的关键代码如下：\n\npublic Authentication authenticate(Authentication authentication) throws AuthenticationException {\n\t...\n\tString token = (String) authentication.getPrincipal();\n\t//最终还是借助tokenServices根据token加载身份信息\n\tOAuth2Authentication auth = tokenServices.loadAuthentication(token);\n\t...\n\n\tcheckClientDetails(auth);\n\n\tif (authentication.getDetails() instanceof OAuth2AuthenticationDetails) {\n\t\tOAuth2AuthenticationDetails details = (OAuth2AuthenticationDetails) authentication.getDetails();\n\t\t...\n\t}\n\tauth.setDetails(authentication.getDetails());\n\tauth.setAuthenticated(true);\n\treturn auth;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n说到tokenServices这个密切与token相关的接口，这里要强调下，避免产生误解。tokenServices分为两类，一个是用在AuthenticationServer端，第二篇文章中介绍的\n\npublic interface AuthorizationServerTokenServices {\n    //创建token\n    OAuth2AccessToken createAccessToken(OAuth2Authentication authentication) throws AuthenticationException;\n    //刷新token\n    OAuth2AccessToken refreshAccessToken(String refreshToken, TokenRequest tokenRequest)\n            throws AuthenticationException;\n    //获取token\n    OAuth2AccessToken getAccessToken(OAuth2Authentication authentication);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n而在ResourceServer端有自己的tokenServices接口：\n\npublic interface ResourceServerTokenServices {\n\t//根据accessToken加载客户端信息\n\tOAuth2Authentication loadAuthentication(String accessToken) throws AuthenticationException, InvalidTokenException;\n\n\t//根据accessToken获取完整的访问令牌详细信息。\n\tOAuth2AccessToken readAccessToken(String accessToken);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n具体内部如何加载，和AuthorizationServer大同小异，只是从tokenStore中取出相应身份的流程有点区别，不再详细看实现类了。\n\n\n# TokenExtractor（了解）\n\n这个接口只有一个实现类，而且代码非常简单\n\npublic class BearerTokenExtractor implements TokenExtractor {\n\tprivate final static Log logger = LogFactory.getLog(BearerTokenExtractor.class);\n\t@Override\n\tpublic Authentication extract(HttpServletRequest request) {\n\t\tString tokenValue = extractToken(request);\n\t\tif (tokenValue != null) {\n\t\t\tPreAuthenticatedAuthenticationToken authentication = new PreAuthenticatedAuthenticationToken(tokenValue, "");\n\t\t\treturn authentication;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected String extractToken(HttpServletRequest request) {\n\t\t// first check the header...\n\t\tString token = extractHeaderToken(request);\n\n\t\t// bearer type allows a request parameter as well\n\t\tif (token == null) {\n\t\t\t...\n\t\t\t//从requestParameter中获取token\n\t\t}\n\n\t\treturn token;\n\t}\n\n    /**\n\t * Extract the OAuth bearer token from a header.\n\t */\n\tprotected String extractHeaderToken(HttpServletRequest request) {\n\t\tEnumeration<String> headers = request.getHeaders("Authorization");\n\t\twhile (headers.hasMoreElements()) { // typically there is only one (most servers enforce that)\n\t\t\t...\n\t\t\t//从Header中获取token\n\t\t}\n\t\treturn null;\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n它的作用在于分离出请求中包含的token。也启示了我们可以使用多种方式携带token。 1 在Header中携带\n\nhttp://localhost:8080/order/1\nHeader：\nAuthentication：Bearer f732723d-af7f-41bb-bd06-2636ab2be135\n\n\n1\n2\n3\n\n\n2 拼接在url中作为requestParam\n\nhttp://localhost:8080/order/1?access_token=f732723d-af7f-41bb-bd06-2636ab2be135\n\n\n1\n\n\n3 在form表单中携带\n\nhttp://localhost:8080/order/1\nform param：\naccess_token=f732723d-af7f-41bb-bd06-2636ab2be135\n\n\n1\n2\n3\n\n\n\n# 异常处理\n\nOAuth2在资源服务器端的异常处理不算特别完善，但基本够用，如果想要重写异常机制，可以直接替换掉相关的Handler，如权限相关的AccessDeniedHandler。具体的配置应该在@EnableResourceServer中被覆盖，这是适配器+配置器的好处。\n\n\n# 总结\n\n到这儿，Spring Security OAuth2的整个内部流程就算是分析结束了。本系列的文章只能算是揭示一个大概的流程，重点还是介绍相关设计+接口，想要了解更多的细节，需要自己去翻看源码，研究各个实现类。在分析源码过程中总结出的一点经验，与君共勉：\n\n 1. 先掌握宏观，如研究UML类图，搞清楚关联\n 2. 分析顶级接口，设计是面向接口的，不重要的部分，具体实现类甚至都可以忽略\n 3. 学会对比，如ResourceServer和AuthenticationServer是一种对称的设计，整个框架内部的类非常多，但分门别类的记忆，会加深记忆。如ResourceServerTokenServices ，AuthenticationServerTokenServices就一定是作用相关，但所属领域不同的两个接口\n 4. 熟悉设计模式，spring中涉及了大量的设计模式，在框架的设计中也是遵循着设计模式的规范，如以Adapter结尾，便是运用了适配器模式；以Factory结尾，便是运用了工厂模式；Template结尾，便是运用了模板方法模式；Builder结尾，便是运用了建造者模式…\n 5. 一点自己的理解：对源码的理解和灵感，这一切都建立自身的编码经验之上，自己遵循规范便能更好的理解别人同样遵守规范的代码。相对的，阅读好的源码，也能帮助我们自身提升编码规范。',normalizedContent:' * @enableresourceserver与@enableauthorizationserver\n * resourceserversecurityconfigurer（了解）\n * 核心过滤器 oauth2authenticationprocessingfilter（掌握）\n * oauth2的身份管理器–oauth2authenticationmanager（掌握）\n * tokenextractor（了解）\n * 异常处理\n * 总结\n\n----------------------------------------\n\n----------------------------------------\n\n上一篇文章中我们介绍了获取token的流程，这一篇重点分析一下，携带token访问受限资源时，内部的工作流程。\n\n\n# @enableresourceserver与@enableauthorizationserver\n\n还记得我们在第一节中就介绍过了oauth2的两个核心概念，资源服务器与身份认证服务器。我们对两个注解进行配置的同时，到底触发了内部的什么相关配置呢？\n\n上一篇文章重点介绍的其实是与身份认证相关的流程，即如果获取token，而本节要分析的携带token访问受限资源，自然便是与@enableresourceserver相关的资源服务器配置了。\n\n我们注意到其相关配置类是resourceserverconfigurer，内部关联了resourceserversecurityconfigurer和httpsecurity。前者与资源安全配置相关，后者与http安全配置相关。（类名比较类似，注意区分，以adapter结尾的是适配器，以configurer结尾的是配置器，以builder结尾的是建造器，他们分别代表不同的设计模式，对设计模式有所了解可以更加方便理解其设计思路）\n\npublic class resourceserverconfigureradapter implements resourceserverconfigurer {\n\t@override\n\tpublic void configure(resourceserversecurityconfigurer resources <1> ) throws exception {\n\t}\n\n\t@override\n\tpublic void configure(httpsecurity http) throws exception {\n\t\thttp.authorizerequests().anyrequest().authenticated();\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n<1> resourceserversecurityconfigurer显然便是我们分析的重点了。\n\n\n# resourceserversecurityconfigurer（了解）\n\n其核心配置如下所示：\n\npublic void configure(httpsecurity http) throws exception {\n\tauthenticationmanager oauthauthenticationmanager = oauthauthenticationmanager(http);\n\tresourcesserverfilter = new oauth2authenticationprocessingfilter();//<1>\n\tresourcesserverfilter.setauthenticationentrypoint(authenticationentrypoint);\n\tresourcesserverfilter.setauthenticationmanager(oauthauthenticationmanager);//<2>\n\tif (eventpublisher != null) {\n\t\tresourcesserverfilter.setauthenticationeventpublisher(eventpublisher);\n\t}\n\tif (tokenextractor != null) {\n\t\tresourcesserverfilter.settokenextractor(tokenextractor);//<3>\n\t}\n\tresourcesserverfilter = postprocess(resourcesserverfilter);\n\tresourcesserverfilter.setstateless(stateless);\n\n\t// @formatter:off\n\thttp\n\t\t.authorizerequests().expressionhandler(expressionhandler)\n\t.and()\n\t\t.addfilterbefore(resourcesserverfilter, abstractpreauthenticatedprocessingfilter.class)\n\t\t.exceptionhandling()\n\t\t\t.accessdeniedhandler(accessdeniedhandler)//<4>\n\t\t\t.authenticationentrypoint(authenticationentrypoint);\n\t// @formatter:on\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n这段是整个oauth2与httpsecurity相关的核心配置，其中有非常多的注意点，顺带的都强调一下：\n\n<1> 创建oauth2authenticationprocessingfilter，即下一节所要介绍的oauth2核心过滤器。\n\n<2> 为oauth2authenticationprocessingfilter提供固定的authenticationmanager即oauth2authenticationmanager，它并没有将oauth2authenticationmanager添加到spring的容器中，不然可能会影响spring security的普通认证流程（非oauth2请求），只有被oauth2authenticationprocessingfilter拦截到的oauth2相关请求才被特殊的身份认证器处理。\n\n<3> 设置了tokenextractor默认的实现—-bearertokenextractor，这个类在下一节介绍。\n\n<4> 相关的异常处理器，可以重写相关实现，达到自定义异常的目的。\n\n还记得我们在一开始的配置中配置了资源服务器，是它触发了相关的配置。\n\n@configuration\n@enableresourceserver\nprotected static class resourceserverconfiguration extends resourceserverconfigureradapter {}\n\n\n1\n2\n3\n\n\n\n# 核心过滤器 oauth2authenticationprocessingfilter（掌握）\n\n回顾一下我们之前是如何携带token访问受限资源的： http://localhost:8080/order/1?access_token=950a7cc9-5a8a-42c9-a693-40e817b1a4b0 唯一的身份凭证，便是这个access_token，携带它进行访问，会进入oauth2authenticationprocessingfilter之中，其核心代码如下：\n\npublic void dofilter(servletrequest req, servletresponse res, filterchain chain){\n\tfinal httpservletrequest request = (httpservletrequest) req;\n\tfinal httpservletresponse response = (httpservletresponse) res;\n\n\ttry {\n\t\t//从请求中取出身份信息，即access_token\n\t\tauthentication authentication = tokenextractor.extract(request);\n\n\t\tif (authentication == null) {\n\t\t\t...\n\t\t}\n\t\telse {\n\t\t\trequest.setattribute(oauth2authenticationdetails.access_token_value, authentication.getprincipal());\n\t\t\tif (authentication instanceof abstractauthenticationtoken) {\n\t\t\t\tabstractauthenticationtoken needsdetails = (abstractauthenticationtoken) authentication;\n\t\t\t\tneedsdetails.setdetails(authenticationdetailssource.builddetails(request));\n\t\t\t}\n\t\t\t//认证身份\n\t\t\tauthentication authresult = authenticationmanager.authenticate(authentication);\n\t\t\t...\n\t\t\teventpublisher.publishauthenticationsuccess(authresult);\n\t\t\t//将身份信息绑定到securitycontextholder中\n\t\t\tsecuritycontextholder.getcontext().setauthentication(authresult);\n\t\t}\n\t}\n\tcatch (oauth2exception failed) {\n\t\t...\n\t\treturn;\n\t}\n\n\tchain.dofilter(request, response);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n整个过滤器便是oauth2身份鉴定的关键，在源码中，对这个类有一段如下的描述\n\n> a pre-authentication filter for oauth2 protected resources. extracts an oauth2 token from the incoming request and uses it to populate the spring security context with an {@link oauth2authentication} (if used in conjunction with an {@link oauth2authenticationmanager}). oauth2保护资源的预先认证过滤器。如果与oauth2authenticationmanager结合使用，则会从到来的请求之中提取一个oauth2 token，之后使用oauth2authentication来填充spring security上下文。\n\n其中涉及到了两个关键的类tokenextractor，authenticationmanager。相信后者这个接口大家已经不陌生，但前面这个类之前还未出现在我们的视野中。\n\n\n# oauth2的身份管理器–oauth2authenticationmanager（掌握）\n\n在之前的oauth2核心过滤器中出现的authenticationmanager其实在我们意料之中，携带access_token必定得经过身份认证，但是在我们debug进入其中后，发现了一个出乎意料的事，authenticationmanager的实现类并不是我们在前面文章中聊到的常用实现类providermanager，而是oauth2authenticationmanager。\n\noauth2authenticationmanager\n\n图1 新的authenticationmanager实现类oauth2authenticationmanager\n\n回顾我们第一篇文章的配置，压根没有出现过这个oauth2authenticationmanager，并且它脱离了我们熟悉的认证流程（第二篇文章中的认证管理器uml图是一张经典的spring security结构类图），它直接重写了容器的顶级身份认证接口，内部维护了一个clientdetailservice和resourceservertokenservices，这两个核心类在 re：从零开始的spring security oauth2（二）有分析过。在resourceserversecurityconfigurer的小节中我们已经知晓了它是如何被框架自动配置的，这里要强调的是oauth2authenticationmanager是密切与token认证相关的，而不是与获取token密切相关的。\n\n其判别身份的关键代码如下：\n\npublic authentication authenticate(authentication authentication) throws authenticationexception {\n\t...\n\tstring token = (string) authentication.getprincipal();\n\t//最终还是借助tokenservices根据token加载身份信息\n\toauth2authentication auth = tokenservices.loadauthentication(token);\n\t...\n\n\tcheckclientdetails(auth);\n\n\tif (authentication.getdetails() instanceof oauth2authenticationdetails) {\n\t\toauth2authenticationdetails details = (oauth2authenticationdetails) authentication.getdetails();\n\t\t...\n\t}\n\tauth.setdetails(authentication.getdetails());\n\tauth.setauthenticated(true);\n\treturn auth;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n说到tokenservices这个密切与token相关的接口，这里要强调下，避免产生误解。tokenservices分为两类，一个是用在authenticationserver端，第二篇文章中介绍的\n\npublic interface authorizationservertokenservices {\n    //创建token\n    oauth2accesstoken createaccesstoken(oauth2authentication authentication) throws authenticationexception;\n    //刷新token\n    oauth2accesstoken refreshaccesstoken(string refreshtoken, tokenrequest tokenrequest)\n            throws authenticationexception;\n    //获取token\n    oauth2accesstoken getaccesstoken(oauth2authentication authentication);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n而在resourceserver端有自己的tokenservices接口：\n\npublic interface resourceservertokenservices {\n\t//根据accesstoken加载客户端信息\n\toauth2authentication loadauthentication(string accesstoken) throws authenticationexception, invalidtokenexception;\n\n\t//根据accesstoken获取完整的访问令牌详细信息。\n\toauth2accesstoken readaccesstoken(string accesstoken);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n具体内部如何加载，和authorizationserver大同小异，只是从tokenstore中取出相应身份的流程有点区别，不再详细看实现类了。\n\n\n# tokenextractor（了解）\n\n这个接口只有一个实现类，而且代码非常简单\n\npublic class bearertokenextractor implements tokenextractor {\n\tprivate final static log logger = logfactory.getlog(bearertokenextractor.class);\n\t@override\n\tpublic authentication extract(httpservletrequest request) {\n\t\tstring tokenvalue = extracttoken(request);\n\t\tif (tokenvalue != null) {\n\t\t\tpreauthenticatedauthenticationtoken authentication = new preauthenticatedauthenticationtoken(tokenvalue, "");\n\t\t\treturn authentication;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected string extracttoken(httpservletrequest request) {\n\t\t// first check the header...\n\t\tstring token = extractheadertoken(request);\n\n\t\t// bearer type allows a request parameter as well\n\t\tif (token == null) {\n\t\t\t...\n\t\t\t//从requestparameter中获取token\n\t\t}\n\n\t\treturn token;\n\t}\n\n    /**\n\t * extract the oauth bearer token from a header.\n\t */\n\tprotected string extractheadertoken(httpservletrequest request) {\n\t\tenumeration<string> headers = request.getheaders("authorization");\n\t\twhile (headers.hasmoreelements()) { // typically there is only one (most servers enforce that)\n\t\t\t...\n\t\t\t//从header中获取token\n\t\t}\n\t\treturn null;\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n它的作用在于分离出请求中包含的token。也启示了我们可以使用多种方式携带token。 1 在header中携带\n\nhttp://localhost:8080/order/1\nheader：\nauthentication：bearer f732723d-af7f-41bb-bd06-2636ab2be135\n\n\n1\n2\n3\n\n\n2 拼接在url中作为requestparam\n\nhttp://localhost:8080/order/1?access_token=f732723d-af7f-41bb-bd06-2636ab2be135\n\n\n1\n\n\n3 在form表单中携带\n\nhttp://localhost:8080/order/1\nform param：\naccess_token=f732723d-af7f-41bb-bd06-2636ab2be135\n\n\n1\n2\n3\n\n\n\n# 异常处理\n\noauth2在资源服务器端的异常处理不算特别完善，但基本够用，如果想要重写异常机制，可以直接替换掉相关的handler，如权限相关的accessdeniedhandler。具体的配置应该在@enableresourceserver中被覆盖，这是适配器+配置器的好处。\n\n\n# 总结\n\n到这儿，spring security oauth2的整个内部流程就算是分析结束了。本系列的文章只能算是揭示一个大概的流程，重点还是介绍相关设计+接口，想要了解更多的细节，需要自己去翻看源码，研究各个实现类。在分析源码过程中总结出的一点经验，与君共勉：\n\n 1. 先掌握宏观，如研究uml类图，搞清楚关联\n 2. 分析顶级接口，设计是面向接口的，不重要的部分，具体实现类甚至都可以忽略\n 3. 学会对比，如resourceserver和authenticationserver是一种对称的设计，整个框架内部的类非常多，但分门别类的记忆，会加深记忆。如resourceservertokenservices ，authenticationservertokenservices就一定是作用相关，但所属领域不同的两个接口\n 4. 熟悉设计模式，spring中涉及了大量的设计模式，在框架的设计中也是遵循着设计模式的规范，如以adapter结尾，便是运用了适配器模式；以factory结尾，便是运用了工厂模式；template结尾，便是运用了模板方法模式；builder结尾，便是运用了建造者模式…\n 5. 一点自己的理解：对源码的理解和灵感，这一切都建立自身的编码经验之上，自己遵循规范便能更好的理解别人同样遵守规范的代码。相对的，阅读好的源码，也能帮助我们自身提升编码规范。',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Spring Security 入门篇",frontmatter:{title:"Spring Security 入门篇",date:"2022-02-03T00:03:27.000Z",permalink:"/pages/605664/",categories:["后端","Spring Security"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/25.Spring%20Security/10.Spring%20Security%20%E5%85%A5%E9%97%A8%E7%AF%87.html",relativePath:"10.框架/25.Spring Security/10.Spring Security 入门篇.md",key:"v-83400752",path:"/pages/605664/",headers:[{level:2,title:"学习目标",slug:"学习目标",normalizedTitle:"学习目标",charIndex:53},{level:2,title:"SpringSecurity",slug:"springsecurity",normalizedTitle:"springsecurity",charIndex:64},{level:3,title:"SpringSecurity简介",slug:"springsecurity简介",normalizedTitle:"springsecurity简介",charIndex:83},{level:3,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:1481},{level:3,title:"UserDetailsService详解",slug:"userdetailsservice详解",normalizedTitle:"userdetailsservice详解",charIndex:4235},{level:3,title:"PasswordEncoder 密码解析器详解",slug:"passwordencoder-密码解析器详解",normalizedTitle:"passwordencoder 密码解析器详解",charIndex:5263},{level:3,title:"自定义登录逻辑",slug:"自定义登录逻辑",normalizedTitle:"自定义登录逻辑",charIndex:5333},{level:3,title:"自定义登录页面",slug:"自定义登录页面",normalizedTitle:"自定义登录页面",charIndex:8786},{level:3,title:"认证过程其他常用配置",slug:"认证过程其他常用配置",normalizedTitle:"认证过程其他常用配置",charIndex:11639},{level:3,title:"访问控制url匹配",slug:"访问控制url匹配",normalizedTitle:"访问控制url匹配",charIndex:17602},{level:3,title:"内置访问控制方法",slug:"内置访问控制方法",normalizedTitle:"内置访问控制方法",charIndex:19233},{level:3,title:"角色权限判断",slug:"角色权限判断",normalizedTitle:"角色权限判断",charIndex:19679},{level:3,title:"自定义403处理方案",slug:"自定义403处理方案",normalizedTitle:"自定义403处理方案",charIndex:20783},{level:3,title:"基于表达式的访问控制",slug:"基于表达式的访问控制",normalizedTitle:"基于表达式的访问控制",charIndex:22220},{level:3,title:"基于注解的访问控制",slug:"基于注解的访问控制",normalizedTitle:"基于注解的访问控制",charIndex:24351},{level:3,title:"RememberMe功能实现",slug:"rememberme功能实现",normalizedTitle:"rememberme功能实现",charIndex:26538},{level:3,title:"Thymeleaf中SpringSecurity的使用（了解）",slug:"thymeleaf中springsecurity的使用-了解",normalizedTitle:"thymeleaf中springsecurity的使用（了解）",charIndex:29448},{level:3,title:"退出登录",slug:"退出登录",normalizedTitle:"退出登录",charIndex:32176},{level:3,title:"SpringSecurity中的CSRF",slug:"springsecurity中的csrf",normalizedTitle:"springsecurity中的csrf",charIndex:32829},{level:2,title:"Oauth2认证",slug:"oauth2认证",normalizedTitle:"oauth2认证",charIndex:34218},{level:3,title:"Oauth2简介",slug:"oauth2简介",normalizedTitle:"oauth2简介",charIndex:34231},{level:3,title:"授权模式",slug:"授权模式",normalizedTitle:"授权模式",charIndex:36184},{level:2,title:"Spring Security Oauth2",slug:"spring-security-oauth2",normalizedTitle:"spring security oauth2",charIndex:36333},{level:3,title:"授权服务器（熟悉）",slug:"授权服务器-熟悉",normalizedTitle:"授权服务器（熟悉）",charIndex:36360},{level:3,title:"Spring Security Oauth2架构（熟悉）",slug:"spring-security-oauth2架构-熟悉",normalizedTitle:"spring security oauth2架构（熟悉）",charIndex:36526},{level:3,title:"Spring Security Oauth2授权码模式",slug:"spring-security-oauth2授权码模式",normalizedTitle:"spring security oauth2授权码模式",charIndex:36926},{level:3,title:"Spring Security Oauth2 密码模式",slug:"spring-security-oauth2-密码模式",normalizedTitle:"spring security oauth2 密码模式",charIndex:46840},{level:3,title:"在Redis中存储token",slug:"在redis中存储token",normalizedTitle:"在redis中存储token",charIndex:50904},{level:2,title:"JWT",slug:"jwt",normalizedTitle:"jwt",charIndex:54889},{level:3,title:"常见的认证机制",slug:"常见的认证机制",normalizedTitle:"常见的认证机制",charIndex:54897},{level:3,title:"JWT简介",slug:"jwt简介",normalizedTitle:"jwt简介",charIndex:56795},{level:3,title:"JJWT简介",slug:"jjwt简介",normalizedTitle:"jjwt简介",charIndex:59093},{level:2,title:"Spring Security Oauth2 整合JWT",slug:"spring-security-oauth2-整合jwt",normalizedTitle:"spring security oauth2 整合jwt",charIndex:66907},{level:3,title:"整合JWT",slug:"整合jwt",normalizedTitle:"整合jwt",charIndex:66930},{level:3,title:"扩展JWT中存储的内容",slug:"扩展jwt中存储的内容",normalizedTitle:"扩展jwt中存储的内容",charIndex:71004},{level:3,title:"Java中解析JWT中的内容",slug:"java中解析jwt中的内容",normalizedTitle:"java中解析jwt中的内容",charIndex:76802},{level:3,title:"刷新令牌",slug:"刷新令牌-2",normalizedTitle:"刷新令牌",charIndex:35790},{level:2,title:"Spring Security Oauth2 整合单点登录（SSO）",slug:"spring-security-oauth2-整合单点登录-sso",normalizedTitle:"spring security oauth2 整合单点登录（sso）",charIndex:79064},{level:3,title:"创建客户端",slug:"创建客户端",normalizedTitle:"创建客户端",charIndex:79103},{level:3,title:"添加依赖",slug:"添加依赖-2",normalizedTitle:"添加依赖",charIndex:26676},{level:3,title:"修改配置文件",slug:"修改配置文件",normalizedTitle:"修改配置文件",charIndex:81650},{level:3,title:"在启动类上添加@EnableOAuth2Sso注解来启用单点登录功能",slug:"在启动类上添加-enableoauth2sso注解来启用单点登录功能",normalizedTitle:"在启动类上添加@enableoauth2sso注解来启用单点登录功能",charIndex:82191},{level:3,title:"添加接口用于获取当前登录用户信息",slug:"添加接口用于获取当前登录用户信息",normalizedTitle:"添加接口用于获取当前登录用户信息",charIndex:82726},{level:3,title:"修改认证服务器配置",slug:"修改认证服务器配置",normalizedTitle:"修改认证服务器配置",charIndex:83303},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:5844}],headersStr:"学习目标 SpringSecurity SpringSecurity简介 快速入门 UserDetailsService详解 PasswordEncoder 密码解析器详解 自定义登录逻辑 自定义登录页面 认证过程其他常用配置 访问控制url匹配 内置访问控制方法 角色权限判断 自定义403处理方案 基于表达式的访问控制 基于注解的访问控制 RememberMe功能实现 Thymeleaf中SpringSecurity的使用（了解） 退出登录 SpringSecurity中的CSRF Oauth2认证 Oauth2简介 授权模式 Spring Security Oauth2 授权服务器（熟悉） Spring Security Oauth2架构（熟悉） Spring Security Oauth2授权码模式 Spring Security Oauth2 密码模式 在Redis中存储token JWT 常见的认证机制 JWT简介 JJWT简介 Spring Security Oauth2 整合JWT 整合JWT 扩展JWT中存储的内容 Java中解析JWT中的内容 刷新令牌 Spring Security Oauth2 整合单点登录（SSO） 创建客户端 添加依赖 修改配置文件 在启动类上添加@EnableOAuth2Sso注解来启用单点登录功能 添加接口用于获取当前登录用户信息 修改认证服务器配置 测试",content:'视频地址：https://www.bilibili.com/video/BV1gb4y1b7XE\n\n\n# 学习目标\n\n\n\n\n# SpringSecurity\n\n\n# SpringSecurity简介\n\n# 安全框架概述\n\n什么是安全框架？ 解决系统安全问题的框架。如果没有安全框架，我们需要手动处理每个资源的访问控制，非常麻烦。使用安全框架，我们可以通过配置的方式实现对资源的访问限制。\n\n# 常用安全框架\n\n * Spring Security：Spring家族一员。是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。\n * Apache Shiro：一个功能强大且易于使用的Java安全框架,提供了认证,授权,加密,和会话管理。\n\n# Spring Security简介\n\n# 概述（熟悉）\n\n> Spring Security是一个高度自定义的安全框架。利用 Spring IoC/DI和AOP功能，为系统提供了声明式安全访问控制功能，减少了为系统安全而编写大量重复代码的工作。使用 Spring Secruity 的原因有很多，但大部分都是发现了 javaEE的 Servlet 规范或 EJB 规范中的安全功能缺乏典型企业应用场景。同时认识到他们在 WAR 或 EAR 级别无法移植。因此如果你更换服务器环境，还需要大量工作去重新配置你的应用程序。使用 Spring Security解决了这些问题，也为你提供许多其他有用的、可定制的安全功能。正如你可能知道的两个应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两点也是 Spring Security 重要核心功能。“认证”，是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统），通俗点说就是系统认为用户是否能登录。“授权”指确定一个主体是否允许在你的应用程序执行一个动作的过程。通俗点讲就是系统判断用户是否有权限去做某些事情。\n\n# 历史（了解）\n\n> Spring Security 以“The Acegi Secutity System for Spring”的名字始于2003年年底。其前身为 acegi 项目。起因是 Spring 开发者邮件列表中一个问题，有人提问是否考虑提供一个基于 Spring 的安全实现。限制于时间问题，开发出了一个简单的安全实现，但是并没有深入研究。几周后，Spring 社区中其他成员同样询问了安全问题，代码提供给了这些人。2004 年 1 月份已经有 20 人左右使用这个项目。随着更多人的加入，在 2004 年 3 月左右在 sourceforge 中建立了一个项目。在最开始并没有认证模块，所有的认证功能都是依赖容器完成的，而 acegi 则注重授权。但是随着更多人的使用，基于容器的认证就显现出了不足。acegi 中也加入了认证功能。大约 1 年后 acegi 成为 Spring子项目。在 2006 年 5 月发布了 acegi 1.0.0 版本。2007 年底 acegi 更名为Spring Security。\n\n\n# 快速入门\n\n# 导入依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n   <modelVersion>4.0.0</modelVersion>\n   <parent>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-parent</artifactId>\n      <version>2.2.2.RELEASE</version>\n      <relativePath/> \x3c!-- lookup parent from repository --\x3e\n   </parent>\n  \n   <groupId>com.yjxxt</groupId>\n   <artifactId>springsecurity-demo</artifactId>\n   <version>0.0.1-SNAPSHOT</version>\n   <name>springsecurity-demo</name>\n   <description>Demo project for Spring Boot</description>\n\n   <properties>\n      <java.version>1.8</java.version>\n   </properties>\n\n   <dependencies>\n      \x3c!--spring security 组件--\x3e\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-security</artifactId>\n      </dependency>\n      \x3c!--web 组件--\x3e\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-web</artifactId>\n      </dependency>\n      \x3c!-- test 组件--\x3e\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-test</artifactId>\n         <scope>test</scope>\n         <exclusions>\n            <exclusion>\n               <groupId>org.junit.vintage</groupId>\n               <artifactId>junit-vintage-engine</artifactId>\n            </exclusion>\n         </exclusions>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.security</groupId>\n         <artifactId>spring-security-test</artifactId>\n         <scope>test</scope>\n      </dependency>\n   </dependencies>\n\n   <build>\n      <plugins>\n         <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n         </plugin>\n      </plugins>\n   </build>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n# 前端页面\n\nlogin.html\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<form action="/login" method="post">\n    用户名：<input type="text" name="username" /><br/>\n    密码：<input type="password" name="password" /><br/>\n    <input type="submit" value="登录" />\n</form>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 访问页面\n\n导入spring-boot-starter-security 启动器后，Spring Security 已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。\n\n\n\n默认的 username 为 user，password 打印在控制台中。\n\n\n\n在浏览器中输入账号和密码后会显示 login.html 页面内容。\n\n\n# UserDetailsService详解\n\n当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。所以我们要通过自定义逻辑控制认证逻辑。如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。接口定义如下：\n\n\n\n# 返回值\n\n返回值 UserDetails 是一个接口，定义如下\n\n\n\n要想返回 UserDetails的实例就只能返回接口的实现类。SpringSecurity 中提供了如下的实例。对于我们只需要使用里面的 User类即可。注意 User 的全限定路径是：\n\norg.springframework.security.core.userdetails.User此处经常和系统中自己开发的 User 类弄混。\n\n\n\n在 User 类中提供了很多方法和属性。\n\n\n\n其中构造方法有两个，调用其中任何一个都可以实例化UserDetails实现类 User类的实例。而三个参数的构造方法实际上也是调用 7 个参数的构造方法。\n\n * username:用户名\n\n * password:密码\n\n * authorities：用户具有的权限。此处不允许为 null\n\n\n\nSpring Security 会根据 User 中的 password和客户端传递过来的 password进行比较。如果相同则表示认证通过，如果不相同表示认证失败。\n\nauthorities里面的权限对于后面学习授权是很有必要的，包含的所有内容为此用户具有的权限，如有里面没有包含某个权限，而在做某个事情时必须包含某个权限则会出现 403。\n\n通常都是通过AuthorityUtils.commaSeparatedStringToAuthorityList(“”) 来创建authorities 集合对象的。参数是一个字符串，多个权限使用逗号分隔。\n\n# 方法参数\n\n方法参数表示用户名。此值是客户端表单传递过来的数据。默认情况下必须叫 username，否则无法接收。\n\n# 异常\n\nUsernameNotFoundException用户名没有发现异常。在loadUserByUsername中是需要通过自己的逻辑从数据库中取值的。如果通过用户名没有查询到对应的数据，应该抛出UsernameNotFoundException，系统就知道用户名没有查询到。\n\n\n# PasswordEncoder 密码解析器详解\n\nSpring Security 要求容器中必须有PasswordEncoder实例。所以当自定义登录逻辑时要求必须给容器注入PaswordEncoder的bean对象。\n\n# 接口介绍\n\n * encode()：把参数按照特定的解析规则进行解析。\n\n * matches() ：验证从存储中获取的密码（编码过的）与表单提交的原始密码（未编码）是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要表单传过来的原始密码。第二个参数表示存储的编码密码。\n\n * upgradeEncoding()：如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回 false。默认返回 false。\n\n\n\n# 内置解析器介绍\n\n在 Spring Security 中内置了很多解析器。\n\n\n\n# BCryptPasswordEncoder 简介\n\nBCryptPasswordEncoder 是 Spring Security 官方推荐的密码解析器，平时多使用这个解析器。\n\nBCryptPasswordEncoder 是对 bcrypt强散列方法的具体实现。是基于Hash算法实现的单向加密。可以通过strength控制加密强度，默认 10.\n\n# 代码演示\n\n新建测试方法BCryptPasswordEncoder 用法。\n\npackage com.yjxxt.springsecuritydemo;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@SpringBootTest\npublic class MyTest {\n\n   @Test\n   public void test(){\n      //创建解析器\n      PasswordEncoder pw = new BCryptPasswordEncoder();\n      //对密码加密\n      String encode = pw.encode("123");\n      System.out.println(encode);\n\n      //判断原字符和加密后内容是否匹配\n      boolean matches = pw.matches("1234", encode);\n      System.out.println("==================="+matches);\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 自定义登录逻辑\n\n当 进 行 自 定 义 登 录 逻 辑 时 需 要 用 到 之 前 讲 解 的UserDetailsService和 PasswordEncoder。但是 Spring Security 要求：当进行自定义登录逻辑时容器内必须有 PasswordEncoder实例。所以不能直接 new 对象。\n\n# 编写配置类\n\npackage com.yjxxt.springsecuritydemo.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@Configuration\npublic class SecurityConfig {\n\n   @Bean\n   public PasswordEncoder getPw(){\n      return new BCryptPasswordEncoder();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 自定义逻辑\n\n在 Spring Security 中实现 UserDetailService 就表示为用户详情服务。在这个类中编写用户认证逻辑。\n\npackage com.yjxxt.springsecuritydemo.service;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.authority.AuthorityUtils;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@Service\npublic class UserServiceImpl implements UserDetailsService {\n   @Autowired\n   private PasswordEncoder pw;\n\n   @Override\n   public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n      //1.查询数据库判断用户名是否存在，如果不存在抛出UsernameNotFoundException异常\n      if (!"admin".equals(username)){\n         throw new UsernameNotFoundException("用户名不存在");\n      }\n      //2.把查询出来的密码（注册时已经加密过）进行解析，或直接把密码放入构造方法中\n      String password = pw.encode("123");\n      return new User(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList("admin,normal"));\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 查看效果\n\n重启项目后，在浏览器中输入账号：admin，密码：123。后可以正确进入到 login.html 页面。\n\n\n# 自定义登录页面\n\n虽然 Spring Security 给我们提供了登录页面，但是对于实际项目中，大多喜欢使用自己的登录页面。所以 Spring Security 中不仅仅提供了登录页面，还支持用户自定义登录页面。实现过程也比较简单，只需要修改配置类即可。\n\n# 编写登录页面\n\nlogin.html\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<form action="/login1" method="post">\n    用户名：<input type="text" name="username" /><br/>\n    密码：<input type="password" name="password" /><br/>\n    <input type="submit" value="登录" />\n</form>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 修改配置类\n\n修改配置类中主要是设置哪个页面是登录页面。配置类需要继承WebSecurityConfigurerAdapter,并重写 configure 方法。\n\n * successForwardUrl()：登录成功后转发地址\n\n * loginPage() ：指定登录页面\n\n * loginProcessingUrl：指定后端处理登录请求的的方法，必须和表单登陆页面中的action属性保持一致\n\n * antMatchers()：匹配内容\n\n * permitAll()：允许\n\npackage com.yjxxt.springsecuritydemo.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n   @Override\n   protected void configure(HttpSecurity http) throws Exception {\n      //表单提交\n      http.formLogin()\n            //自定义登录页面\n            .loginPage("/login.html")\n            //当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl\n            .loginProcessingUrl("/login1")\n            //登录成功后跳转页面，POST请求\n            .successForwardUrl("/toMain");\n\n\n      http.authorizeRequests()\n            //login.html不需要被认证\n            .antMatchers("/login.html").permitAll()\n            //所有请求都必须被认证，必须登录后被访问\n            .anyRequest().authenticated();\n\n      //关闭csrf防护\n      http.csrf().disable();\n   }\n\n   @Bean\n   public PasswordEncoder getPw(){\n      return new BCryptPasswordEncoder();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n# 编写控制器\n\npackage com.yjxxt.springsecuritydemo.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n/**\n * 登录\n *\n * @author zhoubin\n * @since 1.0.0\n */\n@Controller\npublic class LoginController {\n   // 该方法不执行：因为登录请求都是被各种过滤器提前执行的，到不了这里\n   // @RequestMapping("/login")\n   // public String login(){\n   //     System.out.println("登录方法");\n   //     return "main.html";\n   // }\n\n   /**\n    * 成功后跳转页面\n    * @return\n    */\n   @RequestMapping("/toMain")\n   public String toMain(){\n      return "redirect:/main.html";\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 认证过程其他常用配置\n\n# 失败跳转\n\n表单处理中成功会跳转到一个地址，失败也可以跳转到一个地址。\n\n编写页面error.html\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n操作失败，请重新登录 <a href= "/login.html">跳转</a>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n修改表单配置\n\n在配置方法中表单认证部分添加failureForwardUrl()方法，表示登录失败跳转的 url。此处依然是 POST 请求，所以跳转到可以接收 POST请求的控制器中。\n\n//表单提交\nhttp.formLogin()\n      //自定义登录页面\n      .loginPage("/login.html")\n      //当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl\n      .loginProcessingUrl("/login1")\n      //登录成功后跳转页面，POST请求\n      .successForwardUrl("/toMain")\n      //登录失败后跳转页面，POST请求\n      .failureForwardUrl("/toError");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n添加控制器的方法\n\n在控制器类中添加控制器方法，方法映射路径/toError。此处要注意：由于是 POST 请求访问/toError。所以如果返回值直接转发到 error.html 中，控制台会报警告，提示 error.html 不支持 POST 访问方式。所以必须用重定向。\n\n/**\n * 失败后跳转页面\n * @return\n */\n@RequestMapping("/toError")\npublic String toError(){\n   return "redirect:/error.html";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n设置error.html不需要认证\n\nhttp.authorizeRequests()\n      //login.html不需要被认证\n      .antMatchers("/login.html").permitAll()\n      //error.html不需要被认证\n      .antMatchers("/error.html").permitAll()\n      //所有请求都必须被认证，必须登录后被访问\n      .anyRequest().authenticated();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 设置请求账户和密码的参数名\n\n源码简介\n\n当进行登录时会执行 UsernamePasswordAuthenticationFilter 过滤器。\n\n * usernamePasrameter：账户参数名\n\n * passwordParameter：密码参数名\n\n * postOnly=true：默认情况下只允许POST请求。\n\n\n\n修改配置\n\n//表单提交\nhttp.formLogin()\n      //自定义登录页面\n      .loginPage("/login.html")\n      //当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl\n      .loginProcessingUrl("/login1")\n      //登录成功后跳转页面，POST请求\n      .successForwardUrl("/toMain")\n      //登录失败后跳转页面，POST请求\n      .failureForwardUrl("/toError")\n      .usernameParameter("myusername")\n      .passwordParameter("mypassword");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n修改login.html\n\n<form action="/login1" method="post">\n    用户名：<input type="text" name="myusername" /><br/>\n    密码：<input type="password" name="mypassword" /><br/>\n    <input type="submit" value="登录" />\n</form>\n\n\n1\n2\n3\n4\n5\n\n\n# 自定义登录成功处理器\n\n源码分析\n\n使用successForwardUrl()时表示成功后转发请求到地址。内部是通过 successHandler()方法进行控制成功后交给哪个类进行处理\n\n\n\nForwardAuthenticationSuccessHandler内部就是最简单的请求转发。由于是请求转发，当遇到需要跳转到站外或在前后端分离的项目中就无法使用了。\n\n\n\n当需要控制登录成功后去做一些事情时，可以进行自定义认证成功控制器。\n\n代码实现\n\n新建类 com.yjxxt.handler.MyAuthenticationSuccessHandler 编写如下：\n\npackage com.yjxxt.springsecuritydemo.handler;\n\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.web.authentication.AuthenticationSuccessHandler;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\npublic class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler {\n\n   private String url;\n\n   public MyAuthenticationSuccessHandler(String url) {\n      this.url = url;\n   }\n\n   @Override\n   public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n      //Principal 主体，存放了登录用户的信息\n      User user = (User) authentication.getPrincipal();\n      System.out.println(user.getUsername());\n      //输出null\n      System.out.println(user.getPassword());\n      System.out.println(user.getAuthorities());\n      response.sendRedirect(url);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n修改配置项\n\n使用 successHandler()方法设置成功后交给哪个对象进行处理\n\n//表单提交\nhttp.formLogin()\n      //自定义登录页面\n      .loginPage("/login.html")\n      //当发现/login1时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl\n      .loginProcessingUrl("/login1")\n      //登录成功后跳转页面，POST请求\n      // .successForwardUrl("/toMain")\n      //和successForwardUrl不能共存\n      .successHandler(new MyAuthenticationSuccessHandler("http://www.baidu.com"))\n      //登录失败后跳转页面，POST请求\n      .failureForwardUrl("/toError")\n      .usernameParameter("myusername")\n      .passwordParameter("mypassword");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 自定义登录失败处理器\n\n源码分析\n\nfailureForwardUrl()内部调用的是failureHandler()方法\n\n\n\nForwardAuthenticationFailureHandler 中也是一个请求转发，并在request 作用域中设置 SPRING_SECURITY_LAST_EXCEPTION的 key，内容为异常对象。\n\n\n\n代码实现\n\n新建控制器\n\n新建 com.yjxxt.handler.MyForwardAuthenticationFailureHandler 实现AuthenticationFailureHandler。在方法中添加重定向语句\n\npackage com.yjxxt.springsecuritydemo.handler;\n\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.security.web.authentication.AuthenticationFailureHandler;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\npublic class MyForwardAuthenticationFailureHandler implements AuthenticationFailureHandler {\n\n   private String url;\n\n   public MyForwardAuthenticationFailureHandler(String url) {\n      this.url = url;\n   }\n\n   @Override\n   public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\n      response.sendRedirect(url);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n修改配置类\n\n修改配置类中表单登录部分。设置失败时交给失败处理器进行操作。failureForwardUrl和 failureHandler不可共存\n\n//表单提交\nhttp.formLogin()\n      //自定义登录页面\n      .loginPage("/login.html")\n      //当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl\n      .loginProcessingUrl("/login")\t\n      //登录成功后跳转页面，POST请求\n      // .successForwardUrl("/toMain")\n      //和successForwardUrl不能共存\n      .successHandler(new MyAuthenticationSuccessHandler("http://www.baidu.com"))\n      //登录失败后跳转页面，POST请求\n      // .failureForwardUrl("/toError")\n      .failureHandler(new MyForwardAuthenticationFailureHandler("/error.html"))\n      .usernameParameter("myusername")\n      .passwordParameter("mypassword");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 访问控制url匹配\n\n在前面讲解了认证中所有常用配置，主要是对http.formLogin()进行操作。而在配置类中 http.authorizeRequests()主要是对url进行控制，也就是我们所说的授权（访问控制）。http.authorizeRequests()也支持连缀写法，总体公式为：\n\n【URL匹配规则】.【权限控制方法】\n\n通过上面的公式可以有很多 url 匹配规则和很多权限控制方法。这些内容进行各种组合就形成了Spring Security中的授权。\n\n在所有匹配规则中取所有规则的交集。配置顺序影响了之后授权效果，越是具体的应该放在前面，越是笼统的应该放到后面。\n\n# anyRequest()\n\n在之前认证过程中我们就已经使用过 anyRequest()，表示匹配所有的请求。一般情况下此方法都会使用，设置全部内容都需要进行认证。\n\n.anyRequest().authenticated();\n\n\n1\n\n\n# antMatcher()\n\n方法定义如下\n\npublic C antMatchers(String... antPatterns)\n\n\n1\n\n\n参数是不定向参数，每个参数是一个 ant 表达式，用于匹配 URL规则。\n\n规则如下：\n\n * ?： 匹配一个字符\n\n * *：匹配 0 个或多个字符\n\n * ** ：匹配 0 个或多个目录\n\n在实际项目中经常需要放行所有静态资源，下面演示放行 js 文件夹下所有脚本文件。\n\n.antMatchers("/js/**","/css/**").permitAll()\n\n\n1\n\n\n还有一种配置方式是只要是.js 文件都放行\n\n.antMatchers("/**/*.js").permitAll()\n\n\n1\n\n\n# regexMatchers()\n\n# 介绍\n\n使用正则表达式进行匹配。和 antMatchers()主要的区别就是参数，antMatchers()参数是 ant 表达式，regexMatchers()参数是正则表达式。\n\n演示所有以.js 结尾的文件都被放行。\n\n.regexMatchers( ".+[.]js").permitAll()\n\n\n1\n\n\n# 两个参数时使用方式\n\n无论是antMatchers()还是regexMatchers()都具有两个参数的方法，其中第一个参数都是 HttpMethod，表示请求方式，当设置了HttpMethod后表示只有设定的特定的请求方式才执行对应的权限设置。\n\n枚举类型 HttpMethod内置属性如下：\n\n\n\n# mvcMatchers()\n\nmvcMatchers()适用于配置了 servletPath 的情况。\n\nservletPath 就是所有的 URL 的统一前缀。在 SpringBoot 整合SpringMVC 的项目中可以在 application.properties 中添加下面内容设置 ServletPath\n\nspring.mvc.servlet.path=/yjxxt\n\n\n1\n\n\n在 Spring Security 的配置类中配置servletPath()是 mvcMatchers()返回值特有的方法，antMatchers()和 regexMatchers()没有这个方法。在servletPath()中配置了servletPath后，mvcMatchers()直接写 SpringMVC 中@RequestMapping()中设置的路径即可。\n\n.mvcMatchers("/demo").servletPath("/yjxxt").permitAll()\n\n\n1\n\n\n如果不习惯使用 mvcMatchers()也可以使用 antMatchers()，下面代码和上面代码是等效\n\n.antMatchers("/yjxxt/demo").permitAll()\n\n\n1\n\n\n\n# 内置访问控制方法\n\nSpring Security 匹配了 URL 后调用了permitAll()表示不需要认证，随意访问。在 Spring Security 中提供了多种内置控制。\n\n# permitAll()\n\npermitAll()表示所匹配的 URL 任何人都允许访问。\n\n\n\n# authenticated()\n\nauthenticated()表示所匹配的 URL 都需要被认证才能访问。\n\n\n\n# anonymous()\n\nanonymous()表示可以匿名访问匹配的URL。和permitAll()效果类似，只是设置为 anonymous()的 url 会执行 filter 链中\n\n\n\n# denyAll()\n\ndenyAll()表示所匹配的 URL 都不允许被访问。\n\n\n\n# rememberMe()\n\n被“remember me”的用户允许访问\n\n\n\n# fullyAuthenticated()\n\n如果用户不是被 remember me 的，才可以访问。\n\n\n\n\n# 角色权限判断\n\n除了之前讲解的内置权限控制。Spring Security 中还支持很多其他权限控制。这些方法一般都用于用户已经被认证后，判断用户是否具有特定的要求。\n\n# hasAuthority(String)\n\n判断用户是否具有特定的权限，用户的权限是在自定义登录逻辑中创建 User 对象时指定的。下图中 admin和normal 就是用户的权限。admin和normal 严格区分大小写。\n\n\n\n在配置类中通过 hasAuthority(“admin”)设置具有 admin 权限时才能访问。\n\n.antMatchers("/main1.html").hasAuthority("admin")\n\n\n1\n\n\n# hasAnyAuthority(String ...)\n\n如果用户具备给定权限中某一个，就允许访问。\n\n下面代码中由于大小写和用户的权限不相同，所以用户无权访问\n\n.antMatchers("/main1.html").hasAnyAuthority("adMin","admiN")\n\n\n1\n\n\n# hasRole(String)\n\n如果用户具备给定角色就允许访问。否则出现 403。\n\n参数取值来源于自定义登录逻辑 UserDetailsService实现类中创建 User 对象时给 User 赋予的授权。\n\n在给用户赋予角色时角色需要以：ROLE_开头，后面添加角色名称。例如：ROLE_abc 其中 abc 是角色名，ROLE_是固定的字符开头。\n\n使用 hasRole()时参数也只写 abc 即可。否则启动报错。\n\n给用户赋予角色：\n\n\n\n在配置类中直接写 abc 即可。\n\n.antMatchers("/main1.html").hasRole("abc")\n\n\n1\n\n\n# hasAnyRole(String ...)\n\n如果用户具备给定角色的任意一个，就允许被访问\n\n# hasIpAddress(String)\n\n如果请求是指定的 IP 就运行访问。\n\n可以通过 request.getRemoteAddr()获取 ip 地址。\n\n需要注意的是在本机进行测试时 localhost 和 127.0.0.1 输出的 ip地址是不一样的。\n\n当浏览器中通过 localhost 进行访问时控制台打印的内容：\n\n\n\n当浏览器中通过 127.0.0.1 访问时控制台打印的内容：\n\n\n\n当浏览器中通过具体 ip 进行访问时控制台打印内容：\n\n\n\n.antMatchers("/main1.html").hasIpAddress("127.0.0.1")\n\n\n1\n\n\n\n# 自定义403处理方案\n\n使用 Spring Security 时经常会看见 403（无权限），默认情况下显示的效果如下：\n\n\n\n而在实际项目中可能都是一个异步请求，显示上述效果对于用户就不是特别友好了。Spring Security 支持自定义权限受限。\n\n# 新建类\n\n新建类实现 AccessDeniedHandler\n\npackage com.yjxxt.springsecuritydemo.handler;\n\nimport org.springframework.security.access.AccessDeniedException;\nimport org.springframework.security.web.access.AccessDeniedHandler;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@Component\npublic class MyAccessDeniedHandler implements AccessDeniedHandler {\n\n   @Override\n   public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\n      response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n      response.setHeader("Content-Type", "application/json;charset=utf-8");\n      PrintWriter out = response.getWriter();\n      out.write("{\\"status\\":\\"error\\",\\"msg\\":\\"权限不足，请联系管理员！\\"}");\n      out.flush();\n      out.close();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 修改配置类\n\n配置类中重点添加异常处理器。设置访问受限后交给哪个对象进行处理。\n\nmyAccessDeniedHandler 是在配置类中进行自动注入的。\n\n//异常处理\nhttp.exceptionHandling()\n      .accessDeniedHandler(myAccessDeniedHandler);\n\n\n1\n2\n3\n\n\n\n# 基于表达式的访问控制\n\n# access()方法使用\n\n之前学习的登录用户权限判断实际上底层实现都是调用access(表达式)\n\n\n\n可以通过access()实现和之前学习的权限控制完成相同的功能。\n\n以 hasRole 和 和 permitAll 举例\n\n\n\n# 使用自定义方法\n\n虽然这里面已经包含了很多的表达式(方法)但是在实际项目中很有可能出现需要自己自定义逻辑的情况。\n\n判断登录用户是否具有访问当前 URL 权限。\n\n# 新建接口及实现类\n\nMyService.java\n\npackage com.yjxxt.springsecuritydemo.service;\n\nimport org.springframework.security.core.Authentication;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic interface MyService {\n   boolean hasPermission(HttpServletRequest request, Authentication authentication);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nMyServiceImpl.java\n\npackage com.yjxxt.springsecuritydemo.service.impl;\n\nimport com.yjxxt.springsecuritydemo.service.MyService;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.Collection;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@Component\npublic class MyServiceImpl implements MyService {\n\n   @Override\n   public boolean hasPermission(HttpServletRequest request, Authentication authentication) {\n      Object obj = authentication.getPrincipal();\n      if (obj instanceof UserDetails){\n         UserDetails userDetails = (UserDetails) obj;\n         Collection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();\n         return authorities.contains(new SimpleGrantedAuthority(request.getRequestURI()));\n      }\n      return false;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 修改配置类\n\n在 access 中通过@bean的id名.方法(参数)的形式进行调用配置类中修改如下：\n\n//url拦截\nhttp.authorizeRequests()\n      //login.html不需要被认证\n      // .antMatchers("/login.html").permitAll()\n      .antMatchers("/login.html").access("permitAll")\n      // .antMatchers("/main.html").hasRole("abc")\n      .antMatchers("/main.html").access("hasRole(\'abc\')")\n      .anyRequest().access("@myServiceImpl.hasPermission(request,authentication)")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 基于注解的访问控制\n\n在 Spring Security 中提供了一些访问控制的注解。这些注解都是默认是都不可用的，需要通过@EnableGlobalMethodSecurity进行开启后使用。\n\n如果设置的条件允许，程序正常执行。如果不允许会报 500\n\n\n\n这些注解可以写到 Service 接口或方法上，也可以写到 Controller或 Controller 的方法上。通常情况下都是写在控制器方法上的，控制接口URL是否允许被访问。\n\n# @Secured\n\n@Secured 是专门用于判断是否具有角色的。能写在方法或类上。参数要以 ROLE_开头。\n\n\n\n# 开启注解\n\n在 启 动 类 ( 也 可 以 在 配 置 类 等 能 够 扫 描 的 类 上 ) 上 添 加@EnableGlobalMethodSecurity(securedEnabled = true)\n\n@SpringBootApplication\n@EnableGlobalMethodSecurity(securedEnabled = true)\npublic class SpringsecurityDemoApplication {\n\n   public static void main(String[] args) {\n      SpringApplication.run(SpringsecurityDemoApplication.class, args);\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 在控制器方法上添加 @Secured 注解\n\n/**\n * 成功后跳转页面\n * @return\n */\n@Secured("ROLE_abc")\n@RequestMapping("/toMain")\npublic String toMain(){\n   return "redirect:/main.html";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 配置类\n\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n   //表单提交\n   http.formLogin()\n         //自定义登录页面\n         .loginPage("/login.html")\n         //当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl\n         .loginProcessingUrl("/login")\n         //登录成功后跳转页面，POST请求\n         .successForwardUrl("/toMain")\n         \n   //url拦截\n   http.authorizeRequests()\n         //login.html不需要被认证\n         .antMatchers("/login.html").permitAll()\n         //所有请求都必须被认证，必须登录后被访问\n         .anyRequest().authenticated();\n   //关闭csrf防护\n   http.csrf().disable();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# @PreAuthorize/@PostAuthorize\n\n@PreAuthorize 和@PostAuthorize 都是方法或类级别注解。\n\n\n\n * @PreAuthorize表示访问方法或类在执行之前先判断权限，大多情况下都是使用这个注解，注解的参数和access()方法参数取值相同，都是权限表达式。\n * @PostAuthorize 表示方法或类执行结束后判断权限，此注解很少被使用到。\n\n# 开启注解\n\n@SpringBootApplication\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class SpringsecurityDemoApplication {\n\n   public static void main(String[] args) {\n      SpringApplication.run(SpringsecurityDemoApplication.class, args);\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 添加@PreAuthorize\n\n在控制器方法上添加@PreAuthorize，参数可以是任何 access()支持的表达式\n\n/**\n * 成功后跳转页面\n * @return\n */\n@PreAuthorize("hasRole(\'ROLE_abc\')")\n@RequestMapping("/toMain")\npublic String toMain(){\n   return "redirect:/main.html";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# RememberMe功能实现\n\nSpring Security 中 Remember Me 为“记住我”功能，用户只需要在登录时添加 remember-me复选框，取值为true。Spring Security 会自动把用户信息存储到数据源中，以后就可以不登录进行访问\n\n# 添加依赖\n\nSpring Security 实 现 Remember Me 功 能 时 底 层 实 现 依 赖Spring-JDBC，所以需要导入 Spring-JDBC。以后多使用 MyBatis 框架而很少直接导入 spring-jdbc，所以此处导入 mybatis 启动器同时还需要添加 MySQL 驱动\n\n\x3c!-- mybatis 依赖 --\x3e\n<dependency>\n   <groupId>org.mybatis.spring.boot</groupId>\n   <artifactId>mybatis-spring-boot-starter</artifactId>\n   <version>2.1.1</version>\n</dependency>\n\x3c!-- mysql 数据库依赖 --\x3e\n<dependency>\n   <groupId>mysql</groupId>\n   <artifactId>mysql-connector-java</artifactId>\n   <version>8.0.18</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 配置数据源\n\n在 application.properties 中配置数据源。请确保数据库中已经存在shop数据库\n\nspring.datasource.driver-class-name= com.mysql.cj.jdbc.Driver\nspring.datasource.url= jdbc:mysql://localhost:3306/security?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai\nspring.datasource.username= root\nspring.datasource.password= root\n\n\n1\n2\n3\n4\n\n\n# 编写配置\n\nRememberMeConfig.java\n\npackage com.yjxxt.springsecuritydemo.config;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl;\nimport org.springframework.security.web.authentication.rememberme.PersistentTokenRepository;\n\nimport javax.sql.DataSource;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@Configuration\npublic class RememberMeConfig {\n\n   @Autowired\n   private DataSource dataSource;\n\n   @Bean\n   public PersistentTokenRepository getPersistentTokenRepository(){\n      JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();\n      jdbcTokenRepository.setDataSource(dataSource);\n      //自动建表，第一次启动时需要，第二次启动时注释掉\n      jdbcTokenRepository.setCreateTableOnStartup(true);\n      return jdbcTokenRepository;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 修改SecurityConfig.java\n\n在SecurityConfig中添加RememberMeConfig和UserDetailsService实现类对象，并自动注入。\n\n在 configure 中添加下面配置内容。\n\nhttp.rememberMe()\n      //登录逻辑交给哪个对象\n      .userDetailsService(userService)\n      // 持久层对象\n      .tokenRepository(persistentTokenRepository);\n\n\n1\n2\n3\n4\n5\n\n\n# 在客户端页面添加复选框\n\n在客户端登录页面中添加 remember-me 的复选框，只要用户勾选了复选框下次就不需要进行登录了。\n\n<form action="/login" method="post">\n    用户名：<input type="text" name="username" /><br/>\n    密码：<input type="password" name="password" /><br/>\n    <input type="checkbox" name="remember-me" value="true"/><br/>\n    <input type="submit" value="登录" />\n</form>\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 有效时间\n\n默认情况下重启项目后登录状态失效了。但是可以通过设置状态有效时间，即使项目重新启动下次也可以正常登录。\n\nhttp.rememberMe()\n      //失效时间，单位秒\n      .tokenValiditySeconds(120)\n      //登录逻辑交给哪个对象\n      .userDetailsService(userService)\n      // 持久层对象\n      .tokenRepository(persistentTokenRepository);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Thymeleaf中SpringSecurity的使用（了解）\n\nSpring Security 可以在一些视图技术中进行控制显示效果。例如：JSP或 Thymeleaf。在非前后端分离且使用 Spring Boot 的项目中多使用 Thymeleaf作为视图展示技术。\n\nThymeleaf 对 Spring Security 的 支 持 都 放 在thymeleaf-extras-springsecurityX中，目前最新版本为 5。所以需要在项目中添加此 jar 包的依赖和 thymeleaf 的依赖。。\n\n\x3c!--thymeleaf springsecurity5 依赖--\x3e\n<dependency>\n   <groupId>org.thymeleaf.extras</groupId>\n   <artifactId>thymeleaf-extras-springsecurity5</artifactId>\n</dependency>\n\x3c!--thymeleaf依赖--\x3e\n<dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在 html 页面中引入 thymeleaf 命名空间和 security 命名空间\n\n<html xmlns="http://www.w3.org/1999/xhtml"\n      xmlns:th="http://www.thymeleaf.org"\n      xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity5">\n\n\n1\n2\n3\n\n\n# 获取属性\n\n可以在html页面中通过sec:authentication=""获取\n\nUsernamePasswordAuthenticationToken中所有 getXXX的内容，包含父类中的 getXXX的内容。\n\n根据源码得出下面属性：\n\n * name：登录账号名称\n\n * principal：登录主体，在自定义登录逻辑中是 UserDetails\n\n * credentials：凭证\n\n * authorities：权限和角色\n\n * details：实际上是 WebAuthenticationDetails的实例。可以获取remoteAddress(客户端 ip)和 sessionId(当前 sessionId)\n\n# 新建demo.html\n\n在项目 resources 中新建 templates 文件夹，在 templates 中新建demo.html 页面\n\n<!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml"\n      xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity5">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n    登录账号:<span sec:authentication="name"></span><br/>\n    登录账号:<span sec:authentication="principal.username"></span><br/>\n    凭证：<span sec:authentication="credentials"></span><br/>\n    权限和角色：<span sec:authentication="authorities"></span><br/>\n    客户端地址：<span sec:authentication="details.remoteAddress"></span><br/>\n    sessionId：<span sec:authentication="details.sessionId"></span><br/>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 编写Controller\n\nthymeleaf 页面需要控制转发，在控制器类中编写下面方法\n\n@RequestMapping("/demo")\npublic String demo(){\n   return "demo";\n}\n\n\n1\n2\n3\n4\n\n\n# 权限判断\n\n# 设置用户角色和权限\n\n设定用户具有 admin，/insert，/delete 权限 ROLE_abc 角色。\n\nreturn new User(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList("admin,ROLE_abc,/insert,/delete"));\n\n\n1\n\n\n# 控制页面显示效果\n\n在页面中根据用户权限和角色判断页面中显示的内容\n\n通过权限判断：\n<button sec:authorize="hasAuthority(\'/insert\')">新增</button>\n<button sec:authorize="hasAuthority(\'/delete\')">删除</button>\n<button sec:authorize="hasAuthority(\'/update\')">修改</button>\n<button sec:authorize="hasAuthority(\'/select\')">查看</button>\n<br/>\n通过角色判断：\n<button sec:authorize="hasRole(\'abc\')">新增</button>\n<button sec:authorize="hasRole(\'abc\')">删除</button>\n<button sec:authorize="hasRole(\'abc\')">修改</button>\n<button sec:authorize="hasRole(\'abc\')">查看</button>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 退出登录\n\n用户只需要向 Spring Security 项目中发送/logout退出请求即可。\n\n# 退出登录\n\n实现退出非常简单，只要在页面中添加/logout 的超链接即可。\n\n<a href="/logout">退出登录</a>\n\n\n1\n\n\n为了实现更好的效果，通常添加退出的配置。默认的退出 url 为/logout，退出成功后跳转到/login?logout\n\n\n\n如果不希望使用默认值，可以通过下面的方法进行修改。\n\nhttp.logout()\n      .logoutUrl("/logout")\n      .logoutSuccessUrl("/login.html");\n\n\n1\n2\n3\n\n\n# logout其他常用配置源码解读\n\n# addLogoutHandler(LogoutHandler)\n\n默认是 contextLogoutHandler\n\n\n\n默认实例内容\n\n\n\n# clearAuthentication(boolean)\n\n是否清除认证状态，默认为 true\n\n\n\n# invalidateHttpSession(boolean)\n\n是否销毁 HttpSession 对象，默认为 true\n\n\n\n# logoutSuccessHandler(LogoutSuccessHandler)\n\n退出成功处理器\n\n\n\n也可以自己进行定义退出成功处理器。只要实现了LogoutSuccessHandler接口。与之前讲解的登录成功处理器和登录失败处理器极其类似。\n\n\n# SpringSecurity中的CSRF\n\n从刚开始学习Spring Security时，在配置类中一直存在这样一行代码：http.csrf().disable();如果没有这行代码导致用户无法被认证。这行代码的含义是：关闭 csrf 防护。\n\n# 1. 什么是CSRF\n\nCSRF（Cross-site request forgery）跨站请求伪造，也被称为“OneClick Attack” 或者 Session Riding。通过伪造用户请求访问受信任站点的非法请求访问。\n\n跨域：只要网络协议，ip 地址，端口中任何一个不相同就是跨域请求。\n\n客户端与服务进行交互时，由于 http 协议本身是无状态协议，所以引入了cookie进行记录客户端身份。在cookie中会存放session id用来识别客户端身份的。在跨域的情况下，session id 可能被第三方恶意劫持，通过这个 session id 向服务端发起请求时，服务端会认为这个请求是合法的，可能发生很多意想不到的事情。\n\n# 2. Spring Security中的CSRF\n\n从 Spring Security4开始CSRF防护默认开启。默认会拦截请求，进行CSRF处理。CSRF为了保证不是其他第三方网站访问，要求访问时携带参数名为_csrf值为token(token 在服务端产生)的内容，如果token和服务端的token匹配成功，则正常访问。\n\n# 2.1、编写控制器方法\n\n编写控制器方法，跳转到 templates 中 login.html 页面。\n\n@RequestMapping("/showLogin")\npublic String showLogin(){\n   return "login";\n}\n\n\n1\n2\n3\n4\n\n\n# 2.2、新建login.html\n\n红色部分是必须存在的否则无法正常登录。\n\n<!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml"\n      xmlns:th="http://www.thymeleaf.org"\n>\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<form action="/login" method="post">\n    <input type="hidden" th:value="${_csrf.token}" name="_csrf" th:if="${_csrf}"/>\n    用户名：<input type="text" name="username" /><br/>\n    密码：<input type="password" name="password" /><br/>\n    <input type="submit" value="登录" />\n</form>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 修改配置类\n\n在配置类中注释掉 CSRF 防护失效\n\n// 关闭csrf防护\n// http.csrf().disable();\n\n\n1\n2\n\n\n\n# Oauth2认证\n\n\n# Oauth2简介\n\n# 简介\n\n第三方认证技术方案最主要是解决认证协议的通用标准问题，因为要实现跨系统认证，各系统之间要遵循一定的接口协议。\n\nOAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。\n\nOauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。\n\n下边分析一个Oauth2认证的例子，网站使用微信认证的过程：\n\n\n\n 1. 用户进入网站的登录页面，点击微信的图标以微信账号登录系统，用户是自己在微信里信息的资源拥有者。\n\n\n\n点击“微信”出现一个二维码，此时用户扫描二维码，开始给网站授权。\n\n\n\n * 资源拥有者同意给客户端授权\n   \n   > 资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证，验证通过后，微信会询问用户是否给授权网站访问自己的微信数据，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码，并重定向到网站。\n\n * 客户端获取到授权码，请求认证服务器申请令牌\n   \n   > 此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。\n\n * 认证服务器向客户端响应令牌\n   \n   > 认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。此交互过程用户看不到，当客户端拿到令牌后，用户在网站看到已经登录成功。\n\n * 客户端请求资源服务器的资源\n   \n   > 客户端携带令牌访问资源服务器的资源。网站携带令牌请求访问微信服务器获取用户的基本信息。\n\n * 资源服务器返回受保护资源\n   \n   > 资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。\n\n注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务资源服务器通常要请求认证服务器来校验令牌的合法性。\n\nOauth2.0认证流程如下：\n\n引自Oauth2.0协议rfc6749 https://tools.ietf.org/html/rfc6749\n\n\n\n# 角色\n\n客户端\n\n本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。\n\n资源拥有者\n\n通常为用户，也可以是应用程序，即该资源的拥有者。\n\n授权服务器（也称认证服务器）\n\n用来对资源拥有者的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授权后方可访问。\n\n资源服务器\n\n存储资源的服务器，比如，网站用户管理服务器存储了网站用户信息，网站相册服务器存储了用户的相册信息，微信的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。\n\n# 常用术语\n\n * 客户凭证(client Credentials)：客户端的clientId和密码用于认证客户\n\n * 令牌(tokens)：授权服务器在接收到客户请求后，颁发的访问令牌\n\n * 作用域(scopes)：客户请求访问令牌时，由资源拥有者额外指定的细分权限(permission)\n\n# 令牌类型\n\n * 授权码：仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌\n\n * 访问令牌：用于代表一个用户或服务直接去访问受保护的资源\n\n * 刷新令牌：用于去授权服务器获取一个刷新访问令牌\n\n * BearerToken：不管谁拿到Token都可以访问资源，类似现金\n\n * Proof of Possession(PoP) Token：可以校验client是否对Token有明确的拥有权\n\n# 特点\n\n优点：\n\n * 更安全，客户端不接触用户密码，服务器端更易集中保护\n * 广泛传播并被持续采用\n * 短寿命和封装的token\n * 资源服务器和授权服务器解耦\n * 集中式授权，简化客户端\n * HTTP/JSON友好，易于请求和传递token\n * 考虑多种客户端架构场景\n * 客户可以具有不同的信任级别\n\n缺点：\n\n * 协议框架太宽泛，造成各种实现的兼容性和互操作性差\n * 不是一个认证协议，本身并不能告诉你任何用户信息。\n\n\n# 授权模式\n\n# 授权码模式（Authorization Code）\n\n\n\n# 简化授权模式（Implicit）\n\n\n\n# 密码模式（Resource Owner PasswordCredentials）\n\n\n\n# 客户端模式（Client Credentials）\n\n\n\n# 刷新令牌\n\n\n\n\n# Spring Security Oauth2\n\n\n# 授权服务器（熟悉）\n\n\n\n * Authorize Endpoint：授权端点，进行授权\n\n * Token Endpoint：令牌端点，经过授权拿到对应的Token\n\n * Introspection Endpoint：校验端点，校验Token的合法性\n\n * Revocation Endpoint：撤销端点，撤销授权\n\n\n# Spring Security Oauth2架构（熟悉）\n\n\n\n流程：\n\n 1. 用户访问，此时没有Token。Oauth2RestTemplate会报错，这个报错信息会被Oauth2ClientContextFilter捕获并重定向到认证服务器\n 2. 认证服务器通过Authorization Endpoint进行授权，并通过AuthorizationServerTokenServices生成授权码并返回给客户端\n 3. 客户端拿到授权码去认证服务器通过Token Endpoint调用AuthorizationServerTokenServices生成Token并返回给客户端\n 4. 客户端拿到Token去资源服务器访问资源，一般会通过Oauth2AuthenticationManager调用ResourceServerTokenServices进行校验。校验通过可以获取资源。\n\n\n# Spring Security Oauth2授权码模式\n\n# 1. 创建项目\n\n\n\n\n\n\n\n\n\n# 2、添加依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n   <modelVersion>4.0.0</modelVersion>\n   <parent>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-parent</artifactId>\n      <version>2.2.2.RELEASE</version>\n      <relativePath/> \x3c!-- lookup parent from repository --\x3e\n   </parent>\n  \n   <groupId>com.yjxxt</groupId>\n   <artifactId>springsecurityoauth2demo</artifactId>\n   <version>0.0.1-SNAPSHOT</version>\n  \n   <name>springsecurityoauth2demo</name>\n   <description>Demo project for Spring Boot</description>\n\n   <properties>\n      <java.version>1.8</java.version>\n      <spring-cloud.version>Greenwich.SR2</spring-cloud.version>\n   </properties>\n\n   <dependencies>\n      <dependency>\n         <groupId>org.springframework.cloud</groupId>\n         <artifactId>spring-cloud-starter-oauth2</artifactId>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.cloud</groupId>\n         <artifactId>spring-cloud-starter-security</artifactId>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-web</artifactId>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-test</artifactId>\n         <scope>test</scope>\n      </dependency>\n   </dependencies>\n\n   <dependencyManagement>\n      <dependencies>\n         <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-dependencies</artifactId>\n            <version>${spring-cloud.version}</version>\n            <type>pom</type>\n            <scope>import</scope>\n         </dependency>\n      </dependencies>\n   </dependencyManagement>\n\n   <build>\n      <plugins>\n         <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n         </plugin>\n      </plugins>\n   </build>\n\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 3、编写实体类\n\nUser.java\n\npackage com.yjxxt.springsecurityoauth2demo.pojo;\n\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * 用户类\n */\npublic class User implements UserDetails {\n\n    private String username;\n    private String password;\n    private List<GrantedAuthority> authorities;\n\n    public User(String username, String password, List<GrantedAuthority> authorities) {\n        this.username = username;\n        this.password = password;\n        this.authorities = authorities;\n    }\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return authorities;\n    }\n\n    @Override\n    public String getPassword() {\n        return password;\n    }\n\n    @Override\n    public String getUsername() {\n        return username;\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n# 4、编写Service\n\nUserService.java\n\npackage com.yjxxt.springsecurityoauth2demo.service;\n\nimport com.yjxxt.springsecurityoauth2demo.pojo.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.authority.AuthorityUtils;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@Service\npublic class UserService implements UserDetailsService {\n\n   @Autowired\n   private PasswordEncoder passwordEncoder;\n\n   @Override\n   public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n      String password = passwordEncoder.encode("123456");\n      return new User("admin",password, AuthorityUtils.commaSeparatedStringToAuthorityList("admin"));\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 5、编写Controller\n\nUserController.java\n\npackage com.yjxxt.springsecurityoauth2demo.controller;\n\nimport org.springframework.security.core.Authentication;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@RestController\n@RequestMapping("/user")\npublic class UserController {\n\n   @GetMapping("/getCurrentUser")\n   public Object getCurrentUser(Authentication authentication) {\n      return authentication.getPrincipal();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 6、编写配置类\n\nSecurityConfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\n/**\n * Spring Security 配置类\n *\n * @author zhoubin\n */\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n   @Bean\n   public PasswordEncoder passwordEncoder() {\n      return new BCryptPasswordEncoder();\n   }\n\n\n   @Override\n   public void configure(HttpSecurity http) throws Exception {\n      http.csrf()\n            .disable()\n            .authorizeRequests()\n            .antMatchers("/oauth/**", "/login/**", "/logout/**")\n            .permitAll()\n            .anyRequest()\n            .authenticated()\n            .and()\n            .formLogin()\n            .permitAll();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\nAuthorizationServerConfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;\n\n/**\n * 授权服务器配置\n * @author zhoubin\n * @since 1.0.0\n */\n@Configuration\n@EnableAuthorizationServer\npublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n        clients.inMemory()\n                //配置client_id\n                .withClient("admin")\n                //配置client-secret\n                .secret(passwordEncoder.encode("112233"))\n                //配置redirect_uri，用于授权成功后跳转\n                .redirectUris("http://www.baidu.com")\n                //配置申请的权限范围\n                .scopes("all")\n                //配置grant_type，表示授权类型\n                .authorizedGrantTypes("authorization_code");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\nResourceServerConfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;\n\n/**\n * 资源服务器配置\n *\n * @author zhoubin\n * @since 1.0.0\n */\n@Configuration\n@EnableResourceServer\npublic class ResourceServerConfig extends ResourceServerConfigurerAdapter {\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n                .anyRequest()\n                .authenticated()\n                .and()\n                .requestMatchers()\n                .antMatchers("/user/**");//配置需要保护的资源路径\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 7、测试\n\n# 获取授权码\n\nhttp://localhost:8080/oauth/authorize?response_type=code&client_id=admin&redirect_uri=http://www.baidu.com&scope=all\n\n\n\n输入账户密码\n\n\n\n点击授权获取授权码\n\n\n\n# 根据授权码获取令牌（POST请求）\n\n\n\n\n\n * grant_type：授权类型，填写authorization_code，表示授权码模式\n\n * code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。\n\n * client_id:客户端标识\n\n * redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。\n\n * scope:授权范围。\n\n认证失败服务端返回 401 Unauthorized\n\n注意：此时无法请求到令牌，访问服务器会报错\n\n\n\n# 根据token去资源服务器拿资源\n\n\n\n如果修改token就会报错\n\n\n\n\n# Spring Security Oauth2 密码模式\n\n在上面的代码中进行适当的修改即可\n\nSecurityConfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\n/**\n * Spring Security 配置类\n *\n * @author zhoubin\n */\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n   @Bean\n   public PasswordEncoder passwordEncoder() {\n      return new BCryptPasswordEncoder();\n   }\n\n   /**\n     * 使用密码模式需要配置\n     */\n   @Bean\n   @Override\n   public AuthenticationManager authenticationManagerBean() throws Exception {\n      return super.authenticationManagerBean();\n   }\n\n   @Override\n   public void configure(HttpSecurity http) throws Exception {\n      http.csrf()\n            .disable()\n            .authorizeRequests()\n            .antMatchers("/oauth/**", "/login/**", "/logout/**")\n            .permitAll()\n            .anyRequest()\n            .authenticated()\n            .and()\n            .formLogin()\n            .permitAll();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\nAuthorizationServerConfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport com.yjxxt.springsecurityoauth2demo.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;\nimport org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;\n\n/**\n * 授权服务器配置\n * @author zhoubin\n * @since 1.0.0\n */\n@Configuration\n@EnableAuthorizationServer\npublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private UserService userService;\n\n    /**\n     * 使用密码模式需要配置\n     */\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n        endpoints.authenticationManager(authenticationManager)\n                .userDetailsService(userService);\n    }\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n        clients.inMemory()\n                //配置client_id\n                .withClient("admin")\n                //配置client-secret\n                .secret(passwordEncoder.encode("112233"))\n                //配置访问token的有效期\n                .accessTokenValiditySeconds(3600)\n                //配置刷新token的有效期\n                .refreshTokenValiditySeconds(864000)\n                //配置redirect_uri，用于授权成功后跳转\n                .redirectUris("http://www.baidu.com")\n                //配置申请的权限范围\n                .scopes("all")\n                //配置grant_type，表示授权类型\n                .authorizedGrantTypes("authorization_code","password");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n测试：\n\n\n\n\n\n\n# 在Redis中存储token\n\n之前的代码我们将token直接存在内存中，这在生产环境中是不合理的，下面我们将其改造成存储在Redis中\n\n# 添加依赖及配置\n\npom.xml\n\n\x3c!--redis 依赖--\x3e\n<dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\x3c!-- commons-pool2 对象池依赖 --\x3e\n<dependency>\n   <groupId>org.apache.commons</groupId>\n   <artifactId>commons-pool2</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\napplication.properties\n\n# Redis配置\nspring.redis.host=192.168.10.100\n\n\n1\n2\n\n\n# 编写Redis配置类\n\nRedisConfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.security.oauth2.provider.token.TokenStore;\nimport org.springframework.security.oauth2.provider.token.store.redis.RedisTokenStore;\n\n/**\n * 使用redis存储token的配置\n * @author zhoubin\n * @since 1.0.0\n */\n@Configuration\npublic class RedisConfig {\n   @Autowired\n   private RedisConnectionFactory redisConnectionFactory;\n\n   @Bean\n   public TokenStore redisTokenStore(){\n      return new RedisTokenStore(redisConnectionFactory);\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 在认证服务器配置中指定令牌的存储策略为Redis\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport com.yjxxt.springsecurityoauth2demo.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;\nimport org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;\nimport org.springframework.security.oauth2.provider.token.TokenStore;\n\n/**\n * 授权服务器配置\n * @author zhoubin\n * @since 1.0.0\n */\n@Configuration\n@EnableAuthorizationServer\npublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    @Qualifier("redisTokenStore")\n    private TokenStore tokenStore;\n\n    /**\n     * 使用密码模式需要配置\n     */\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n        endpoints.authenticationManager(authenticationManager)\n                .userDetailsService(userService)\n                .tokenStore(tokenStore);\n    }\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n        clients.inMemory()\n                //配置client_id\n                .withClient("admin")\n                //配置client-secret\n                .secret(passwordEncoder.encode("112233"))\n                //配置访问token的有效期\n                .accessTokenValiditySeconds(3600)\n                //配置刷新token的有效期\n                .refreshTokenValiditySeconds(864000)\n                //配置redirect_uri，用于授权成功后跳转\n                .redirectUris("http://www.baidu.com")\n                //配置申请的权限范围\n                .scopes("all")\n                //配置grant_type，表示授权类型\n                .authorizedGrantTypes("password");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n测试：\n\n使用密码模式请求token\n\n\n\n\n\n\n# JWT\n\n\n# 常见的认证机制\n\n# HTTP Basic Auth\n\nHTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth。\n\n# Cookie Auth\n\nCookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效。\n\n\n\n# OAuth\n\nOAuth（开放授权,Open Authorization）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。如网站通过微信、微博登录等，主要用于第三方登录。\n\nOAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。\n\n下面是OAuth2.0的流程：\n\n\n\n这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。\n\n缺点：过重。\n\n# Token Auth\n\n使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：\n\n 1. 客户端使用用户名跟密码请求登录\n 2. 服务端收到请求，去验证用户名与密码\n 3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端\n 4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里\n 5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token\n 6. 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据\n\n\n\n比第一种方式更安全，比第二种方式更节约服务器资源，比第三种方式更加轻量。\n\n具体，Token Auth的优点（Token机制相对于Cookie机制又有什么好处呢？）：\n\n * 支持跨域访问：Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.\n * 无状态(也称：服务端可扩展行)：Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.\n * 更适用CDN：可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.\n * 去耦：不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.\n * 更适用于移动应用：当你的客户端是一个原生平台（iOS, Android，Windows 10等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。\n * CSRF：因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。\n * 性能：一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多.\n * 不需要为登录页面做特殊处理：如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.\n * 基于标准化：你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.\n\n\n# JWT简介\n\n# 什么是JWT\n\nJSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。\n\n官网： https://jwt.io/\n\n标准： https://tools.ietf.org/html/rfc7519\n\nJWT令牌的优点：\n\n * jwt基于json，非常方便解析。\n * 可以在令牌中自定义丰富的内容，易扩展。\n * 通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。\n * 资源服务使用JWT可不依赖认证服务即可完成授权。\n\n缺点：\n\n 1. JWT令牌较长，占存储空间比较大。\n\n# JWT组成\n\n一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。\n\n# 头部(Header)\n\n头部用于描述关于该JWT的最基本的信息，例如其类型（即JWT）以及签名所用的算法（如HMAC SHA256或RSA）等。这也可以被表示成一个JSON对象。\n\n{\n  "alg": "HS256",\n  "typ": "JWT"\n}\n\n\n1\n2\n3\n4\n\n * typ：是类型。\n * alg：签名的算法，这里使用的算法是HS256算法\n\n我们对头部的json字符串进行BASE64编码（网上有很多在线编码的网站），编码后的字符串如下：\n\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\n\n\n1\n\n\nBase64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。JDK 中提供了非常方便的 BASE64Encoder和 BASE64Decoder，用它们可以非常方便的完成基于 BASE64 的编码和解码。\n\n# 负载(Payload)\n\n第二部分是负载，就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：\n\n * 标准中注册的声明（建议但不强制使用）\n\niss: jwt签发者\nsub: jwt所面向的用户\naud: 接收jwt的一方\nexp: jwt的过期时间，这个过期时间必须要大于签发时间\nnbf: 定义在什么时间之前，该jwt都是不可用的.\niat: jwt的签发时间\njti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n * 公共的声明\n   \n   公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.\n\n * 私有的声明\n   \n   私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。\n\n这个指的就是自定义的claim。比如下面那个举例中的name都属于自定的claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的claim进行验证(还不知道是否能够验证)；而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。\n\n{\n  "sub": "1234567890",\n  "name": "John Doe",\n  "iat": 1516239022\n}\n\n\n1\n2\n3\n4\n5\n\n\n其中sub是标准的声明，name是自定义的声明（公共的或私有的）\n\n然后将其进行base64编码，得到Jwt的第二部分：\n\n eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphbWVzIiwiYWRtaW4iOnRydWV9\n\n\n1\n\n\n提示：声明中不要放一些敏感信息。\n\n# 签证、签名（signature）\n\njwt的第三部分是一个签证信息，这个签证信息由三部分组成：\n\n * header (base64后的)\n\n * payload (base64后的)\n\n * secret（盐，一定要保密）\n\n这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分：\n\n8HI-Lod0ncfVDnbKIPJJqLH998duF9DSDGkx3gRPNVI\n\n\n1\n\n\n将这三部分用.连接成一个完整的字符串,构成了最终的jwt:\n\neyJhbGciOiJIUzI1NiIsInR9cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.8HI-Lod0ncfVDnbKIPJJqLH998duF9DSDGkx3gRPNVI\n\n\n1\n\n\n注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。\n\n\n# JJWT简介\n\n# 什么是JJWT\n\nJJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(Apache License，版本2.0)，JJW很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。\n\n规范官网：https://jwt.io/\n\n# 快速入门\n\n# token的创建\n\n创建SpringBoot工程，引入依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n   <modelVersion>4.0.0</modelVersion>\n   <parent>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-parent</artifactId>\n      <version>2.2.2.RELEASE</version>\n      <relativePath/> \x3c!-- lookup parent from repository --\x3e\n   </parent>\n  \n   <groupId>com.yjxxt</groupId>\n   <artifactId>jwtdemo</artifactId>\n   <version>0.0.1-SNAPSHOT</version>\n  \n   <name>jwtdemo</name>\n   <description>Demo project for Spring Boot</description>\n\n   <properties>\n      <java.version>1.8</java.version>\n   </properties>\n\n   <dependencies>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-web</artifactId>\n      </dependency>\n      \x3c!--JWT依赖--\x3e\n      <dependency>\n         <groupId>io.jsonwebtoken</groupId>\n         <artifactId>jjwt</artifactId>\n         <version>0.9.0</version>\n      </dependency>\n\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-test</artifactId>\n         <scope>test</scope>\n         <exclusions>\n            <exclusion>\n               <groupId>org.junit.vintage</groupId>\n               <artifactId>junit-vintage-engine</artifactId>\n            </exclusion>\n         </exclusions>\n      </dependency>\n   </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n创建测试类JwtTest，用于生成token：\n\npackage com.yjxxt.jwtdemo;\n\nimport io.jsonwebtoken.JwtBuilder;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport io.jsonwebtoken.impl.Base64Codec;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\n\nimport java.util.Date;\n\n@SpringBootTest\npublic class JwtdemoApplicationTests {\n\n   /**\n    * 创建token\n    */\n   @Test\n   public void testCreatToken() {\n      //创建一个JwtBuilder对象\n      JwtBuilder jwtBuilder = Jwts.builder()\n            //声明的标识{"jti":"888"}\n            .setId("888")\n            //主体，用户{"sub":"Rose"}\n            .setSubject("Rose")\n            //创建日期{"ita":"yjxxtxx"}\n            .setIssuedAt(new Date())\n            //签名手段，参数1：算法，参数2：盐\n            .signWith(SignatureAlgorithm.HS256,"yjxxt");\n       \n      //获取jwt的token\n      String token = jwtBuilder.compact();\n      System.out.println(token);\n\n      //三部分的base64解密\n      System.out.println("--------------------");\n      String[] split = token.split("\\\\.");\n      System.out.println(Base64Codec.BASE64.decodeToString(split[0]));\n      System.out.println(Base64Codec.BASE64.decodeToString(split[1]));\n      //无法解密\n      System.out.println(Base64Codec.BASE64.decodeToString(split[2]));\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n运行结果如下\n\n\n\n再次运行，会发现每次运行的结果是不一样的，因为我们的载荷中包含了时间\n\n# token的验证解析\n\n我们刚才已经创建了token ，在web应用中这个操作是由服务端进行然后发给客户端，客户端在下次向服务端发送请求时需要携带这个token（这就好像是拿着一张门票一样），那服务端接到这个token 应该解析出token中的信息（例如用户id）,根据这些信息查询数据库返回相应的结果。\n\n@Test\npublic void testParseToken(){\n   //token\n   String token = "eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNTc4ODE0MjUyfQ" +\n         ".-FYFMHyfTcGzq900f_Drfdsges0ge2UjaWvPW9gCDto";\n   //解析token获取负载中的声明对象\n   Claims claims = Jwts.parser()\n         .setSigningKey("yjxxt")\n         .parseClaimsJws(token)\n         .getBody();\n   //打印声明的属性\n   System.out.println("id:"+claims.getId());\n   System.out.println("subject:"+claims.getSubject());\n   System.out.println("issuedAt:"+claims.getIssuedAt());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n试着将token或签名秘钥篡改一下，会发现运行时就会报错，所以解析token也就是验证token\n\n# token过期校验\n\n有很多时候，我们并不希望签发的token是永久生效的（上节的token是永久的），所以我们可以为token添加一个过期时间。原因：从服务器发出的token，服务器自己并不做记录，就存在一个弊端就是，服务端无法主动控制某token的立刻失效。\n\n测试用例：\n\n@Test\npublic void testCreatTokenHasExp() {\n   //当前系统时间的长整型\n   long now = System.currentTimeMillis();\n   //过期时间，这里是1分钟后的时间长整型\n   long exp = now + 60 * 1000;\n   //创建一个JwtBuilder对象\n   JwtBuilder jwtBuilder = Jwts.builder()\n         //声明的标识{"jti":"888"}\n         .setId("888")\n         //主体，用户{"sub":"Rose"}\n         .setSubject("Rose")\n         //创建日期{"ita":"yjxxtxx"}\n         .setIssuedAt(new Date())\n         //签名手段，参数1：算法，参数2：盐\n         .signWith(SignatureAlgorithm.HS256, "yjxxt")\n         //设置过期时间\n         .setExpiration(new Date(exp));\n   //获取jwt的token\n   String token = jwtBuilder.compact();\n   System.out.println(token);\n}\n\n\n@Test\npublic void testParseTokenHasExp() {\n   //token\n   String token = "eyJhbGciOiJIUzI1NiJ9" +\n         ".eyJqdGkiOiI4ODgiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNTc4ODE1MDYyLCJleHAiOjE1Nzg4MTUxMjIsInJvbGVzIjoiYWRtaW4iLCJsb2dvIjoic2hzeHQuanBnIn0.hKog0RsZ9_6II_R8kUCp0HLAouUAYXAJVbz3xtLTUh4";\n   //解析token获取负载中的声明对象\n   Claims claims = Jwts.parser()\n         .setSigningKey("yjxxt")\n         .parseClaimsJws(token)\n         .getBody();\n   //打印声明的属性\n   System.out.println("id:" + claims.getId());\n   System.out.println("subject:" + claims.getSubject());\n   System.out.println("issuedAt:" + claims.getIssuedAt());\n   DateFormat sf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n   System.out.println("签发时间:"+sf.format(claims.getIssuedAt()));\n   System.out.println("过期时间:"+sf.format(claims.getExpiration()));\n   System.out.println("当前时间:"+sf.format(new Date()));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n测试：当未过期时可以正常读取，当过期时会引发io.jsonwebtoken.ExpiredJwtException异常。\n\n\n\n# 自定义claims\n\n我们刚才的例子只是存储了id和subject两个信息，如果你想存储更多的信息（例如角色）可以定义自定义claims\n\n测试用例：\n\n@Test\npublic void testCreatTokenByClaims() {\n   //当前系统时间的长整型\n   long now = System.currentTimeMillis();\n   //过期时间，这里是1分钟后的时间长整型\n   long exp = now + 60 * 1000;\n   //创建一个JwtBuilder对象\n   JwtBuilder jwtBuilder = Jwts.builder()\n         //声明的标识{"jti":"888"}\n         .setId("888")\n         //主体，用户{"sub":"Rose"}\n         .setSubject("Rose")\n         //创建日期{"ita":"yjxxtxx"}\n         .setIssuedAt(new Date())\n         //签名手段，参数1：算法，参数2：盐\n         .signWith(SignatureAlgorithm.HS256, "yjxxt")\n         //设置过期时间\n         .setExpiration(new Date(exp))\n         //直接传入map\n         // .addClaims(map)\n         .claim("roles","admin")\n         .claim("logo","yjxxt.jpg");\n   //获取jwt的token\n   String token = jwtBuilder.compact();\n   System.out.println(token);\n}\n\n\n@Test\npublic void testParseTokenByClaims() {\n   //token\n   String token = "eyJhbGciOiJIUzI1NiJ9" +\n         ".eyJqdGkiOiI4ODgiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNTc4ODE1MDYyLCJleHAiOjE1Nzg4MTUxMjIsInJvbGVzIjoiYWRtaW4iLCJsb2dvIjoic2hzeHQuanBnIn0.hKog0RsZ9_6II_R8kUCp0HLAouUAYXAJVbz3xtLTUh4";\n   //解析token获取负载中的声明对象\n   Claims claims = Jwts.parser()\n         .setSigningKey("yjxxt")\n         .parseClaimsJws(token)\n         .getBody();\n   //打印声明的属性\n   System.out.println("id:" + claims.getId());\n   System.out.println("subject:" + claims.getSubject());\n   System.out.println("issuedAt:" + claims.getIssuedAt());\n   DateFormat sf =new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n   System.out.println("签发时间:"+sf.format(claims.getIssuedAt()));\n   System.out.println("过期时间:"+sf.format(claims.getExpiration()));\n   System.out.println("当前时间:"+sf.format(new Date()));\n\n   System.out.println("roles:"+claims.get("roles"));\n   System.out.println("logo:"+claims.get("logo"));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# Spring Security Oauth2 整合JWT\n\n\n# 整合JWT\n\n我们拿之前Spring Security Oauth2的完整代码进行修改\n\n添加配置文件JwtTokenStoreConfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.oauth2.provider.token.TokenStore;\nimport org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;\nimport org.springframework.security.oauth2.provider.token.store.JwtTokenStore;\n\n/**\n * 使用Jwt存储token的配置\n * @author zhoubin\n * @since 1.0.0\n */\n@Configuration\npublic class JwtTokenStoreConfig {\n\n   @Bean\n   public TokenStore jwtTokenStore(){\n      return new JwtTokenStore(jwtAccessTokenConverter());\n   }\n\n   @Bean\n   public JwtAccessTokenConverter jwtAccessTokenConverter(){\n      JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter();\n      //配置JWT使用的秘钥\n      accessTokenConverter.setSigningKey("test_key");\n      return accessTokenConverter;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n在认证服务器配置中指定令牌的存储策略为JWT\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport com.yjxxt.springsecurityoauth2demo.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;\nimport org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;\nimport org.springframework.security.oauth2.provider.token.TokenStore;\nimport org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;\n\n/**\n * 授权服务器配置\n * @author zhoubin\n * @since 1.0.0\n */\n@Configuration\n@EnableAuthorizationServer\npublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private UserService userService;\n    \n    @Autowired\n    @Qualifier("jwtTokenStore")\n    private TokenStore tokenStore;\n\n    @Autowired\n    private JwtAccessTokenConverter jwtAccessTokenConverter;\n\n\n    /**\n     * 使用密码模式需要配置\n     */\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n        endpoints.authenticationManager(authenticationManager)\n                .userDetailsService(userService)\n                //配置存储令牌策略\n                .tokenStore(tokenStore)\n                .accessTokenConverter(jwtAccessTokenConverter);\n    }\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n        clients.inMemory()\n                //配置client_id\n                .withClient("admin")\n                //配置client-secret\n                .secret(passwordEncoder.encode("112233"))\n                //配置访问token的有效期\n                .accessTokenValiditySeconds(3600)\n                //配置刷新token的有效期\n                .refreshTokenValiditySeconds(864000)\n                //配置redirect_uri，用于授权成功后跳转\n                .redirectUris("http://www.baidu.com")\n                //配置申请的权限范围\n                .scopes("all")\n                //配置grant_type，表示授权类型\n                .authorizedGrantTypes("authorization_code","password");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n用密码模式测试：\n\n\n\n发现获取到的令牌已经变成了JWT令牌，将access_token拿到https://jwt.io/ 网站上去解析下可以获得其中内容。\n\n\n\n\n# 扩展JWT中存储的内容\n\n有时候我们需要扩展JWT中存储的内容，这里我们在JWT中扩展一个key为enhance，value为enhance info的数据。\n\n继承TokenEnhancer实现一个JWT内容增强器\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.security.oauth2.common.DefaultOAuth2AccessToken;\nimport org.springframework.security.oauth2.common.OAuth2AccessToken;\nimport org.springframework.security.oauth2.provider.OAuth2Authentication;\nimport org.springframework.security.oauth2.provider.token.TokenEnhancer;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * JWT内容增强器\n * @author zhoubin\n * @since 1.0.0\n */\npublic class JwtTokenEnhancer implements TokenEnhancer {\n\n   @Override\n   public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {\n      Map<String,Object> info = new HashMap<>();\n      info.put("enhance","enhance info");\n      ((DefaultOAuth2AccessToken)accessToken).setAdditionalInformation(info);\n      return accessToken;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n创建一个JwtTokenEnhancer实例\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.oauth2.provider.token.TokenStore;\nimport org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;\nimport org.springframework.security.oauth2.provider.token.store.JwtTokenStore;\n\n/**\n * 使用Jwt存储token的配置\n * @author zhoubin\n * @since 1.0.0\n */\n@Configuration\npublic class JwtTokenStoreConfig {\n\n   @Bean\n   public TokenStore jwtTokenStore(){\n      return new JwtTokenStore(jwtAccessTokenConverter());\n   }\n\n   @Bean\n   public JwtAccessTokenConverter jwtAccessTokenConverter(){\n      JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter();\n      //配置JWT使用的秘钥\n      accessTokenConverter.setSigningKey("test_key");\n      return accessTokenConverter;\n   }\n\n   @Bean\n   public JwtTokenEnhancer jwtTokenEnhancer() {\n      return new JwtTokenEnhancer();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n在认证服务器配置中配置JWT的内容增强器\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport com.yjxxt.springsecurityoauth2demo.component.JwtTokenEnhancer;\nimport com.yjxxt.springsecurityoauth2demo.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;\nimport org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;\nimport org.springframework.security.oauth2.provider.token.TokenEnhancer;\nimport org.springframework.security.oauth2.provider.token.TokenEnhancerChain;\nimport org.springframework.security.oauth2.provider.token.TokenStore;\nimport org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 授权服务器配置\n * @author zhoubin\n * @since 1.0.0\n */\n@Configuration\n@EnableAuthorizationServer\npublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    @Qualifier("jwtTokenStore")\n    private TokenStore tokenStore;\n    @Autowired\n    private JwtAccessTokenConverter jwtAccessTokenConverter;\n    @Autowired\n    private JwtTokenEnhancer jwtTokenEnhancer;\n\n    /**\n     * 使用密码模式需要配置\n     */\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n        TokenEnhancerChain enhancerChain = new TokenEnhancerChain();\n        List<TokenEnhancer> delegates = new ArrayList<>();\n        //配置JWT的内容增强器\n        delegates.add(jwtTokenEnhancer);\n        delegates.add(jwtAccessTokenConverter);\n        enhancerChain.setTokenEnhancers(delegates);\n        endpoints.authenticationManager(authenticationManager)\n                .userDetailsService(userService)\n                //配置存储令牌策略\n                .tokenStore(tokenStore)\n                .accessTokenConverter(jwtAccessTokenConverter)\n                .tokenEnhancer(enhancerChain);\n    }\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n        clients.inMemory()\n                //配置client_id\n                .withClient("admin")\n                //配置client-secret\n                .secret(passwordEncoder.encode("112233"))\n                //配置访问token的有效期\n                .accessTokenValiditySeconds(3600)\n                //配置刷新token的有效期\n                .refreshTokenValiditySeconds(864000)\n                //配置redirect_uri，用于授权成功后跳转\n                .redirectUris("http://www.baidu.com")\n                //配置申请的权限范围\n                .scopes("all")\n                //配置grant_type，表示授权类型\n                .authorizedGrantTypes("authorization_code","password");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n运行项目后使用密码模式来获取令牌，之后对令牌进行解析，发现已经包含扩展的内容。\n\n\n\n\n# Java中解析JWT中的内容\n\n添加依赖\n\n\x3c!--jwt 依赖--\x3e\n<dependency>\n   <groupId>io.jsonwebtoken</groupId>\n   <artifactId>jjwt</artifactId>\n   <version>0.9.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n修改UserController类，使用jjwt工具类来解析Authorization头中存储的JWT内容\n\npackage com.yjxxt.springsecurityoauth2demo.controller;\n\nimport io.jsonwebtoken.Jwts;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.nio.charset.StandardCharsets;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@RestController\n@RequestMapping("/user")\npublic class UserController {\n\n   @GetMapping("/getCurrentUser")\n   public Object getCurrentUser(Authentication authentication, HttpServletRequest request) {\n      String header = request.getHeader("Authorization");\n      String token = header.substring(header.indexOf("bearer") + 7);\n      return Jwts.parser()\n            .setSigningKey("test_key".getBytes(StandardCharsets.UTF_8))\n            .parseClaimsJws(token)\n            .getBody();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n将令牌放入Authorization头中，访问如下地址获取信息：\n\nhttp://localhost:8080/user/getCurrentUser\n\n\n\n\n# 刷新令牌\n\n在Spring Cloud Security 中使用oauth2时，如果令牌失效了，可以使用刷新令牌通过refresh_token的授权模式再次获取access_token。\n\n只需修改认证服务器的配置，添加refresh_token的授权模式即可。\n\n@Override\npublic void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n    clients.inMemory()\n            //配置client_id\n            .withClient("admin")\n            //配置client-secret\n            .secret(passwordEncoder.encode("112233"))\n            //配置访问token的有效期\n            .accessTokenValiditySeconds(3600)\n            //配置刷新token的有效期\n            .refreshTokenValiditySeconds(86400)\n            //配置redirect_uri，用于授权成功后跳转\n            .redirectUris("http://www.baidu.com")\n            //配置申请的权限范围\n            .scopes("all")\n            //配置grant_type，表示授权类型\n            .authorizedGrantTypes("authorization_code","password","refresh_token");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n使用刷新令牌模式来获取新的令牌，访问如下地址：\n\nhttp://localhost:8080/oauth/token\n\n\n\n\n# Spring Security Oauth2 整合单点登录（SSO）\n\n\n# 创建客户端\n\n\n\n\n\n\n# 添加依赖\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n   <modelVersion>4.0.0</modelVersion>\n   <parent>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-parent</artifactId>\n      <version>2.2.2.RELEASE</version>\n      <relativePath/> \x3c!-- lookup parent from repository --\x3e\n   </parent>\n  \n   <groupId>com.yjxxt</groupId>\n   <artifactId>oauth2client01demo</artifactId>\n   <version>0.0.1-SNAPSHOT</version>\n  \n   <name>oauth2client01demo</name>\n   <description>Demo project for Spring Boot</description>\n\n   <properties>\n      <java.version>1.8</java.version>\n      <spring-cloud.version>Greenwich.SR2</spring-cloud.version>\n   </properties>\n\n   <dependencies>\n      <dependency>\n         <groupId>org.springframework.cloud</groupId>\n         <artifactId>spring-cloud-starter-oauth2</artifactId>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.cloud</groupId>\n         <artifactId>spring-cloud-starter-security</artifactId>\n      </dependency>\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-web</artifactId>\n      </dependency>\n      <dependency>\n         <groupId>io.jsonwebtoken</groupId>\n         <artifactId>jjwt</artifactId>\n         <version>0.9.0</version>\n      </dependency>\n\n      <dependency>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-test</artifactId>\n         <scope>test</scope>\n      </dependency>\n   </dependencies>\n\n   <dependencyManagement>\n      <dependencies>\n         <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-dependencies</artifactId>\n            <version>${spring-cloud.version}</version>\n            <type>pom</type>\n            <scope>import</scope>\n         </dependency>\n      </dependencies>\n   </dependencyManagement>\n\n   <build>\n      <plugins>\n         <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n         </plugin>\n      </plugins>\n   </build>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 修改配置文件\n\napplication.properties\n\nserver.port=8081\n#防止Cookie冲突，冲突会导致登录验证不通过\nserver.servlet.session.cookie.name=OAUTH2-CLIENT-SESSIONID01\n#授权服务器地址\noauth2-server-url=http://localhost:8080\n#与授权服务器对应的配置\nsecurity.oauth2.client.client-id=admin\nsecurity.oauth2.client.client-secret=112233\nsecurity.oauth2.client.user-authorization-uri=${oauth2-server-url}/oauth/authorize\nsecurity.oauth2.client.access-token-uri=${oauth2-server-url}/oauth/token\nsecurity.oauth2.resource.jwt.key-uri=${oauth2-server-url}/oauth/token_key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 在启动类上添加@EnableOAuth2Sso注解来启用单点登录功能\n\npackage com.yjxxt.oauth2client01demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.autoconfigure.security.oauth2.client.EnableOAuth2Sso;\n\n@SpringBootApplication\n@EnableOAuth2Sso\npublic class Oauth2client01demoApplication {\n\n   public static void main(String[] args) {\n      SpringApplication.run(Oauth2client01demoApplication.class, args);\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 添加接口用于获取当前登录用户信息\n\npackage com.yjxxt.oauth2client01demo.controller;\n\nimport org.springframework.security.core.Authentication;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping("/user")\npublic class UserController {\n    \n    @GetMapping("/getCurrentUser")\n    public Object getCurrentUser(Authentication authentication) {\n        return authentication;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 修改认证服务器配置\n\n修改授权服务器中的AuthorizationServerConfig类，将绑定的跳转路径为\n\nhttp://localhost:8081/login，并添加获取秘钥时的身份认证\n\n@Override\npublic void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n    clients.inMemory()\n            //配置client_id\n            .withClient("admin")\n            //配置client-secret\n            .secret(passwordEncoder.encode("112233"))\n            //配置访问token的有效期\n            .accessTokenValiditySeconds(3600)\n            //配置刷新token的有效期\n            .refreshTokenValiditySeconds(864000)\n            //配置redirect_uri，用于授权成功后跳转\n            // .redirectUris("http://www.baidu.com")\n            //单点登录时配置\n            .redirectUris("http://localhost:8081/login")\n            //配置申请的权限范围\n            .scopes("all")\n            //自动授权配置\n            .autoApprove(true) \n            //配置grant_type，表示授权类型\n            .authorizedGrantTypes("authorization_code","password","refresh_token");\n}\n\n@Override\npublic void configure(AuthorizationServerSecurityConfigurer security) {\n    // 获取密钥需要身份认证，使用单点登录时必须配置\n    security.tokenKeyAccess("isAuthenticated()");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 测试\n\n启动授权服务和客户端服务；\n\n访问客户端需要授权的接口http://localhost:8081/user/getCurrentUser\n\n会跳转到授权服务的登录界面；\n\n\n\n授权后会跳转到原来需要权限的接口地址，展示登录用户信息；\n\n',normalizedContent:'视频地址：https://www.bilibili.com/video/bv1gb4y1b7xe\n\n\n# 学习目标\n\n\n\n\n# springsecurity\n\n\n# springsecurity简介\n\n# 安全框架概述\n\n什么是安全框架？ 解决系统安全问题的框架。如果没有安全框架，我们需要手动处理每个资源的访问控制，非常麻烦。使用安全框架，我们可以通过配置的方式实现对资源的访问限制。\n\n# 常用安全框架\n\n * spring security：spring家族一员。是一个能够为基于spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在spring应用上下文中配置的bean，充分利用了spring ioc，di（控制反转inversion of control,di:dependency injection 依赖注入）和aop（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。\n * apache shiro：一个功能强大且易于使用的java安全框架,提供了认证,授权,加密,和会话管理。\n\n# spring security简介\n\n# 概述（熟悉）\n\n> spring security是一个高度自定义的安全框架。利用 spring ioc/di和aop功能，为系统提供了声明式安全访问控制功能，减少了为系统安全而编写大量重复代码的工作。使用 spring secruity 的原因有很多，但大部分都是发现了 javaee的 servlet 规范或 ejb 规范中的安全功能缺乏典型企业应用场景。同时认识到他们在 war 或 ear 级别无法移植。因此如果你更换服务器环境，还需要大量工作去重新配置你的应用程序。使用 spring security解决了这些问题，也为你提供许多其他有用的、可定制的安全功能。正如你可能知道的两个应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两点也是 spring security 重要核心功能。“认证”，是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统），通俗点说就是系统认为用户是否能登录。“授权”指确定一个主体是否允许在你的应用程序执行一个动作的过程。通俗点讲就是系统判断用户是否有权限去做某些事情。\n\n# 历史（了解）\n\n> spring security 以“the acegi secutity system for spring”的名字始于2003年年底。其前身为 acegi 项目。起因是 spring 开发者邮件列表中一个问题，有人提问是否考虑提供一个基于 spring 的安全实现。限制于时间问题，开发出了一个简单的安全实现，但是并没有深入研究。几周后，spring 社区中其他成员同样询问了安全问题，代码提供给了这些人。2004 年 1 月份已经有 20 人左右使用这个项目。随着更多人的加入，在 2004 年 3 月左右在 sourceforge 中建立了一个项目。在最开始并没有认证模块，所有的认证功能都是依赖容器完成的，而 acegi 则注重授权。但是随着更多人的使用，基于容器的认证就显现出了不足。acegi 中也加入了认证功能。大约 1 年后 acegi 成为 spring子项目。在 2006 年 5 月发布了 acegi 1.0.0 版本。2007 年底 acegi 更名为spring security。\n\n\n# 快速入门\n\n# 导入依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n   <modelversion>4.0.0</modelversion>\n   <parent>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-parent</artifactid>\n      <version>2.2.2.release</version>\n      <relativepath/> \x3c!-- lookup parent from repository --\x3e\n   </parent>\n  \n   <groupid>com.yjxxt</groupid>\n   <artifactid>springsecurity-demo</artifactid>\n   <version>0.0.1-snapshot</version>\n   <name>springsecurity-demo</name>\n   <description>demo project for spring boot</description>\n\n   <properties>\n      <java.version>1.8</java.version>\n   </properties>\n\n   <dependencies>\n      \x3c!--spring security 组件--\x3e\n      <dependency>\n         <groupid>org.springframework.boot</groupid>\n         <artifactid>spring-boot-starter-security</artifactid>\n      </dependency>\n      \x3c!--web 组件--\x3e\n      <dependency>\n         <groupid>org.springframework.boot</groupid>\n         <artifactid>spring-boot-starter-web</artifactid>\n      </dependency>\n      \x3c!-- test 组件--\x3e\n      <dependency>\n         <groupid>org.springframework.boot</groupid>\n         <artifactid>spring-boot-starter-test</artifactid>\n         <scope>test</scope>\n         <exclusions>\n            <exclusion>\n               <groupid>org.junit.vintage</groupid>\n               <artifactid>junit-vintage-engine</artifactid>\n            </exclusion>\n         </exclusions>\n      </dependency>\n      <dependency>\n         <groupid>org.springframework.security</groupid>\n         <artifactid>spring-security-test</artifactid>\n         <scope>test</scope>\n      </dependency>\n   </dependencies>\n\n   <build>\n      <plugins>\n         <plugin>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-maven-plugin</artifactid>\n         </plugin>\n      </plugins>\n   </build>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n# 前端页面\n\nlogin.html\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n<body>\n<form action="/login" method="post">\n    用户名：<input type="text" name="username" /><br/>\n    密码：<input type="password" name="password" /><br/>\n    <input type="submit" value="登录" />\n</form>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 访问页面\n\n导入spring-boot-starter-security 启动器后，spring security 已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。\n\n\n\n默认的 username 为 user，password 打印在控制台中。\n\n\n\n在浏览器中输入账号和密码后会显示 login.html 页面内容。\n\n\n# userdetailsservice详解\n\n当什么也没有配置的时候，账号和密码是由 spring security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。所以我们要通过自定义逻辑控制认证逻辑。如果需要自定义逻辑时，只需要实现 userdetailsservice 接口即可。接口定义如下：\n\n\n\n# 返回值\n\n返回值 userdetails 是一个接口，定义如下\n\n\n\n要想返回 userdetails的实例就只能返回接口的实现类。springsecurity 中提供了如下的实例。对于我们只需要使用里面的 user类即可。注意 user 的全限定路径是：\n\norg.springframework.security.core.userdetails.user此处经常和系统中自己开发的 user 类弄混。\n\n\n\n在 user 类中提供了很多方法和属性。\n\n\n\n其中构造方法有两个，调用其中任何一个都可以实例化userdetails实现类 user类的实例。而三个参数的构造方法实际上也是调用 7 个参数的构造方法。\n\n * username:用户名\n\n * password:密码\n\n * authorities：用户具有的权限。此处不允许为 null\n\n\n\nspring security 会根据 user 中的 password和客户端传递过来的 password进行比较。如果相同则表示认证通过，如果不相同表示认证失败。\n\nauthorities里面的权限对于后面学习授权是很有必要的，包含的所有内容为此用户具有的权限，如有里面没有包含某个权限，而在做某个事情时必须包含某个权限则会出现 403。\n\n通常都是通过authorityutils.commaseparatedstringtoauthoritylist(“”) 来创建authorities 集合对象的。参数是一个字符串，多个权限使用逗号分隔。\n\n# 方法参数\n\n方法参数表示用户名。此值是客户端表单传递过来的数据。默认情况下必须叫 username，否则无法接收。\n\n# 异常\n\nusernamenotfoundexception用户名没有发现异常。在loaduserbyusername中是需要通过自己的逻辑从数据库中取值的。如果通过用户名没有查询到对应的数据，应该抛出usernamenotfoundexception，系统就知道用户名没有查询到。\n\n\n# passwordencoder 密码解析器详解\n\nspring security 要求容器中必须有passwordencoder实例。所以当自定义登录逻辑时要求必须给容器注入paswordencoder的bean对象。\n\n# 接口介绍\n\n * encode()：把参数按照特定的解析规则进行解析。\n\n * matches() ：验证从存储中获取的密码（编码过的）与表单提交的原始密码（未编码）是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要表单传过来的原始密码。第二个参数表示存储的编码密码。\n\n * upgradeencoding()：如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回 false。默认返回 false。\n\n\n\n# 内置解析器介绍\n\n在 spring security 中内置了很多解析器。\n\n\n\n# bcryptpasswordencoder 简介\n\nbcryptpasswordencoder 是 spring security 官方推荐的密码解析器，平时多使用这个解析器。\n\nbcryptpasswordencoder 是对 bcrypt强散列方法的具体实现。是基于hash算法实现的单向加密。可以通过strength控制加密强度，默认 10.\n\n# 代码演示\n\n新建测试方法bcryptpasswordencoder 用法。\n\npackage com.yjxxt.springsecuritydemo;\n\nimport org.junit.jupiter.api.test;\nimport org.springframework.boot.test.context.springboottest;\nimport org.springframework.security.crypto.bcrypt.bcryptpasswordencoder;\nimport org.springframework.security.crypto.password.passwordencoder;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@springboottest\npublic class mytest {\n\n   @test\n   public void test(){\n      //创建解析器\n      passwordencoder pw = new bcryptpasswordencoder();\n      //对密码加密\n      string encode = pw.encode("123");\n      system.out.println(encode);\n\n      //判断原字符和加密后内容是否匹配\n      boolean matches = pw.matches("1234", encode);\n      system.out.println("==================="+matches);\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 自定义登录逻辑\n\n当 进 行 自 定 义 登 录 逻 辑 时 需 要 用 到 之 前 讲 解 的userdetailsservice和 passwordencoder。但是 spring security 要求：当进行自定义登录逻辑时容器内必须有 passwordencoder实例。所以不能直接 new 对象。\n\n# 编写配置类\n\npackage com.yjxxt.springsecuritydemo.config;\n\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.crypto.bcrypt.bcryptpasswordencoder;\nimport org.springframework.security.crypto.password.passwordencoder;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@configuration\npublic class securityconfig {\n\n   @bean\n   public passwordencoder getpw(){\n      return new bcryptpasswordencoder();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 自定义逻辑\n\n在 spring security 中实现 userdetailservice 就表示为用户详情服务。在这个类中编写用户认证逻辑。\n\npackage com.yjxxt.springsecuritydemo.service;\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.security.core.authority.authorityutils;\nimport org.springframework.security.core.userdetails.user;\nimport org.springframework.security.core.userdetails.userdetails;\nimport org.springframework.security.core.userdetails.userdetailsservice;\nimport org.springframework.security.core.userdetails.usernamenotfoundexception;\nimport org.springframework.security.crypto.password.passwordencoder;\nimport org.springframework.stereotype.service;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@service\npublic class userserviceimpl implements userdetailsservice {\n   @autowired\n   private passwordencoder pw;\n\n   @override\n   public userdetails loaduserbyusername(string username) throws usernamenotfoundexception {\n      //1.查询数据库判断用户名是否存在，如果不存在抛出usernamenotfoundexception异常\n      if (!"admin".equals(username)){\n         throw new usernamenotfoundexception("用户名不存在");\n      }\n      //2.把查询出来的密码（注册时已经加密过）进行解析，或直接把密码放入构造方法中\n      string password = pw.encode("123");\n      return new user(username,password, authorityutils.commaseparatedstringtoauthoritylist("admin,normal"));\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 查看效果\n\n重启项目后，在浏览器中输入账号：admin，密码：123。后可以正确进入到 login.html 页面。\n\n\n# 自定义登录页面\n\n虽然 spring security 给我们提供了登录页面，但是对于实际项目中，大多喜欢使用自己的登录页面。所以 spring security 中不仅仅提供了登录页面，还支持用户自定义登录页面。实现过程也比较简单，只需要修改配置类即可。\n\n# 编写登录页面\n\nlogin.html\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n<body>\n<form action="/login1" method="post">\n    用户名：<input type="text" name="username" /><br/>\n    密码：<input type="password" name="password" /><br/>\n    <input type="submit" value="登录" />\n</form>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 修改配置类\n\n修改配置类中主要是设置哪个页面是登录页面。配置类需要继承websecurityconfigureradapter,并重写 configure 方法。\n\n * successforwardurl()：登录成功后转发地址\n\n * loginpage() ：指定登录页面\n\n * loginprocessingurl：指定后端处理登录请求的的方法，必须和表单登陆页面中的action属性保持一致\n\n * antmatchers()：匹配内容\n\n * permitall()：允许\n\npackage com.yjxxt.springsecuritydemo.config;\n\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.config.annotation.web.builders.httpsecurity;\nimport org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter;\nimport org.springframework.security.crypto.bcrypt.bcryptpasswordencoder;\nimport org.springframework.security.crypto.password.passwordencoder;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@configuration\npublic class securityconfig extends websecurityconfigureradapter {\n\n   @override\n   protected void configure(httpsecurity http) throws exception {\n      //表单提交\n      http.formlogin()\n            //自定义登录页面\n            .loginpage("/login.html")\n            //当发现/login时认为是登录，必须和表单提交的地址一样。去执行userserviceimpl\n            .loginprocessingurl("/login1")\n            //登录成功后跳转页面，post请求\n            .successforwardurl("/tomain");\n\n\n      http.authorizerequests()\n            //login.html不需要被认证\n            .antmatchers("/login.html").permitall()\n            //所有请求都必须被认证，必须登录后被访问\n            .anyrequest().authenticated();\n\n      //关闭csrf防护\n      http.csrf().disable();\n   }\n\n   @bean\n   public passwordencoder getpw(){\n      return new bcryptpasswordencoder();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n# 编写控制器\n\npackage com.yjxxt.springsecuritydemo.controller;\n\nimport org.springframework.stereotype.controller;\nimport org.springframework.web.bind.annotation.requestmapping;\n\n/**\n * 登录\n *\n * @author zhoubin\n * @since 1.0.0\n */\n@controller\npublic class logincontroller {\n   // 该方法不执行：因为登录请求都是被各种过滤器提前执行的，到不了这里\n   // @requestmapping("/login")\n   // public string login(){\n   //     system.out.println("登录方法");\n   //     return "main.html";\n   // }\n\n   /**\n    * 成功后跳转页面\n    * @return\n    */\n   @requestmapping("/tomain")\n   public string tomain(){\n      return "redirect:/main.html";\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 认证过程其他常用配置\n\n# 失败跳转\n\n表单处理中成功会跳转到一个地址，失败也可以跳转到一个地址。\n\n编写页面error.html\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n<body>\n操作失败，请重新登录 <a href= "/login.html">跳转</a>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n修改表单配置\n\n在配置方法中表单认证部分添加failureforwardurl()方法，表示登录失败跳转的 url。此处依然是 post 请求，所以跳转到可以接收 post请求的控制器中。\n\n//表单提交\nhttp.formlogin()\n      //自定义登录页面\n      .loginpage("/login.html")\n      //当发现/login时认为是登录，必须和表单提交的地址一样。去执行userserviceimpl\n      .loginprocessingurl("/login1")\n      //登录成功后跳转页面，post请求\n      .successforwardurl("/tomain")\n      //登录失败后跳转页面，post请求\n      .failureforwardurl("/toerror");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n添加控制器的方法\n\n在控制器类中添加控制器方法，方法映射路径/toerror。此处要注意：由于是 post 请求访问/toerror。所以如果返回值直接转发到 error.html 中，控制台会报警告，提示 error.html 不支持 post 访问方式。所以必须用重定向。\n\n/**\n * 失败后跳转页面\n * @return\n */\n@requestmapping("/toerror")\npublic string toerror(){\n   return "redirect:/error.html";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n设置error.html不需要认证\n\nhttp.authorizerequests()\n      //login.html不需要被认证\n      .antmatchers("/login.html").permitall()\n      //error.html不需要被认证\n      .antmatchers("/error.html").permitall()\n      //所有请求都必须被认证，必须登录后被访问\n      .anyrequest().authenticated();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 设置请求账户和密码的参数名\n\n源码简介\n\n当进行登录时会执行 usernamepasswordauthenticationfilter 过滤器。\n\n * usernamepasrameter：账户参数名\n\n * passwordparameter：密码参数名\n\n * postonly=true：默认情况下只允许post请求。\n\n\n\n修改配置\n\n//表单提交\nhttp.formlogin()\n      //自定义登录页面\n      .loginpage("/login.html")\n      //当发现/login时认为是登录，必须和表单提交的地址一样。去执行userserviceimpl\n      .loginprocessingurl("/login1")\n      //登录成功后跳转页面，post请求\n      .successforwardurl("/tomain")\n      //登录失败后跳转页面，post请求\n      .failureforwardurl("/toerror")\n      .usernameparameter("myusername")\n      .passwordparameter("mypassword");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n修改login.html\n\n<form action="/login1" method="post">\n    用户名：<input type="text" name="myusername" /><br/>\n    密码：<input type="password" name="mypassword" /><br/>\n    <input type="submit" value="登录" />\n</form>\n\n\n1\n2\n3\n4\n5\n\n\n# 自定义登录成功处理器\n\n源码分析\n\n使用successforwardurl()时表示成功后转发请求到地址。内部是通过 successhandler()方法进行控制成功后交给哪个类进行处理\n\n\n\nforwardauthenticationsuccesshandler内部就是最简单的请求转发。由于是请求转发，当遇到需要跳转到站外或在前后端分离的项目中就无法使用了。\n\n\n\n当需要控制登录成功后去做一些事情时，可以进行自定义认证成功控制器。\n\n代码实现\n\n新建类 com.yjxxt.handler.myauthenticationsuccesshandler 编写如下：\n\npackage com.yjxxt.springsecuritydemo.handler;\n\nimport org.springframework.security.core.authentication;\nimport org.springframework.security.core.userdetails.user;\nimport org.springframework.security.web.authentication.authenticationsuccesshandler;\n\nimport javax.servlet.servletexception;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\nimport java.io.ioexception;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\npublic class myauthenticationsuccesshandler implements authenticationsuccesshandler {\n\n   private string url;\n\n   public myauthenticationsuccesshandler(string url) {\n      this.url = url;\n   }\n\n   @override\n   public void onauthenticationsuccess(httpservletrequest request, httpservletresponse response, authentication authentication) throws ioexception, servletexception {\n      //principal 主体，存放了登录用户的信息\n      user user = (user) authentication.getprincipal();\n      system.out.println(user.getusername());\n      //输出null\n      system.out.println(user.getpassword());\n      system.out.println(user.getauthorities());\n      response.sendredirect(url);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n修改配置项\n\n使用 successhandler()方法设置成功后交给哪个对象进行处理\n\n//表单提交\nhttp.formlogin()\n      //自定义登录页面\n      .loginpage("/login.html")\n      //当发现/login1时认为是登录，必须和表单提交的地址一样。去执行userserviceimpl\n      .loginprocessingurl("/login1")\n      //登录成功后跳转页面，post请求\n      // .successforwardurl("/tomain")\n      //和successforwardurl不能共存\n      .successhandler(new myauthenticationsuccesshandler("http://www.baidu.com"))\n      //登录失败后跳转页面，post请求\n      .failureforwardurl("/toerror")\n      .usernameparameter("myusername")\n      .passwordparameter("mypassword");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 自定义登录失败处理器\n\n源码分析\n\nfailureforwardurl()内部调用的是failurehandler()方法\n\n\n\nforwardauthenticationfailurehandler 中也是一个请求转发，并在request 作用域中设置 spring_security_last_exception的 key，内容为异常对象。\n\n\n\n代码实现\n\n新建控制器\n\n新建 com.yjxxt.handler.myforwardauthenticationfailurehandler 实现authenticationfailurehandler。在方法中添加重定向语句\n\npackage com.yjxxt.springsecuritydemo.handler;\n\nimport org.springframework.security.core.authenticationexception;\nimport org.springframework.security.web.authentication.authenticationfailurehandler;\n\nimport javax.servlet.servletexception;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\nimport java.io.ioexception;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\npublic class myforwardauthenticationfailurehandler implements authenticationfailurehandler {\n\n   private string url;\n\n   public myforwardauthenticationfailurehandler(string url) {\n      this.url = url;\n   }\n\n   @override\n   public void onauthenticationfailure(httpservletrequest request, httpservletresponse response, authenticationexception exception) throws ioexception, servletexception {\n      response.sendredirect(url);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n修改配置类\n\n修改配置类中表单登录部分。设置失败时交给失败处理器进行操作。failureforwardurl和 failurehandler不可共存\n\n//表单提交\nhttp.formlogin()\n      //自定义登录页面\n      .loginpage("/login.html")\n      //当发现/login时认为是登录，必须和表单提交的地址一样。去执行userserviceimpl\n      .loginprocessingurl("/login")\t\n      //登录成功后跳转页面，post请求\n      // .successforwardurl("/tomain")\n      //和successforwardurl不能共存\n      .successhandler(new myauthenticationsuccesshandler("http://www.baidu.com"))\n      //登录失败后跳转页面，post请求\n      // .failureforwardurl("/toerror")\n      .failurehandler(new myforwardauthenticationfailurehandler("/error.html"))\n      .usernameparameter("myusername")\n      .passwordparameter("mypassword");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 访问控制url匹配\n\n在前面讲解了认证中所有常用配置，主要是对http.formlogin()进行操作。而在配置类中 http.authorizerequests()主要是对url进行控制，也就是我们所说的授权（访问控制）。http.authorizerequests()也支持连缀写法，总体公式为：\n\n【url匹配规则】.【权限控制方法】\n\n通过上面的公式可以有很多 url 匹配规则和很多权限控制方法。这些内容进行各种组合就形成了spring security中的授权。\n\n在所有匹配规则中取所有规则的交集。配置顺序影响了之后授权效果，越是具体的应该放在前面，越是笼统的应该放到后面。\n\n# anyrequest()\n\n在之前认证过程中我们就已经使用过 anyrequest()，表示匹配所有的请求。一般情况下此方法都会使用，设置全部内容都需要进行认证。\n\n.anyrequest().authenticated();\n\n\n1\n\n\n# antmatcher()\n\n方法定义如下\n\npublic c antmatchers(string... antpatterns)\n\n\n1\n\n\n参数是不定向参数，每个参数是一个 ant 表达式，用于匹配 url规则。\n\n规则如下：\n\n * ?： 匹配一个字符\n\n * *：匹配 0 个或多个字符\n\n * ** ：匹配 0 个或多个目录\n\n在实际项目中经常需要放行所有静态资源，下面演示放行 js 文件夹下所有脚本文件。\n\n.antmatchers("/js/**","/css/**").permitall()\n\n\n1\n\n\n还有一种配置方式是只要是.js 文件都放行\n\n.antmatchers("/**/*.js").permitall()\n\n\n1\n\n\n# regexmatchers()\n\n# 介绍\n\n使用正则表达式进行匹配。和 antmatchers()主要的区别就是参数，antmatchers()参数是 ant 表达式，regexmatchers()参数是正则表达式。\n\n演示所有以.js 结尾的文件都被放行。\n\n.regexmatchers( ".+[.]js").permitall()\n\n\n1\n\n\n# 两个参数时使用方式\n\n无论是antmatchers()还是regexmatchers()都具有两个参数的方法，其中第一个参数都是 httpmethod，表示请求方式，当设置了httpmethod后表示只有设定的特定的请求方式才执行对应的权限设置。\n\n枚举类型 httpmethod内置属性如下：\n\n\n\n# mvcmatchers()\n\nmvcmatchers()适用于配置了 servletpath 的情况。\n\nservletpath 就是所有的 url 的统一前缀。在 springboot 整合springmvc 的项目中可以在 application.properties 中添加下面内容设置 servletpath\n\nspring.mvc.servlet.path=/yjxxt\n\n\n1\n\n\n在 spring security 的配置类中配置servletpath()是 mvcmatchers()返回值特有的方法，antmatchers()和 regexmatchers()没有这个方法。在servletpath()中配置了servletpath后，mvcmatchers()直接写 springmvc 中@requestmapping()中设置的路径即可。\n\n.mvcmatchers("/demo").servletpath("/yjxxt").permitall()\n\n\n1\n\n\n如果不习惯使用 mvcmatchers()也可以使用 antmatchers()，下面代码和上面代码是等效\n\n.antmatchers("/yjxxt/demo").permitall()\n\n\n1\n\n\n\n# 内置访问控制方法\n\nspring security 匹配了 url 后调用了permitall()表示不需要认证，随意访问。在 spring security 中提供了多种内置控制。\n\n# permitall()\n\npermitall()表示所匹配的 url 任何人都允许访问。\n\n\n\n# authenticated()\n\nauthenticated()表示所匹配的 url 都需要被认证才能访问。\n\n\n\n# anonymous()\n\nanonymous()表示可以匿名访问匹配的url。和permitall()效果类似，只是设置为 anonymous()的 url 会执行 filter 链中\n\n\n\n# denyall()\n\ndenyall()表示所匹配的 url 都不允许被访问。\n\n\n\n# rememberme()\n\n被“remember me”的用户允许访问\n\n\n\n# fullyauthenticated()\n\n如果用户不是被 remember me 的，才可以访问。\n\n\n\n\n# 角色权限判断\n\n除了之前讲解的内置权限控制。spring security 中还支持很多其他权限控制。这些方法一般都用于用户已经被认证后，判断用户是否具有特定的要求。\n\n# hasauthority(string)\n\n判断用户是否具有特定的权限，用户的权限是在自定义登录逻辑中创建 user 对象时指定的。下图中 admin和normal 就是用户的权限。admin和normal 严格区分大小写。\n\n\n\n在配置类中通过 hasauthority(“admin”)设置具有 admin 权限时才能访问。\n\n.antmatchers("/main1.html").hasauthority("admin")\n\n\n1\n\n\n# hasanyauthority(string ...)\n\n如果用户具备给定权限中某一个，就允许访问。\n\n下面代码中由于大小写和用户的权限不相同，所以用户无权访问\n\n.antmatchers("/main1.html").hasanyauthority("admin","admin")\n\n\n1\n\n\n# hasrole(string)\n\n如果用户具备给定角色就允许访问。否则出现 403。\n\n参数取值来源于自定义登录逻辑 userdetailsservice实现类中创建 user 对象时给 user 赋予的授权。\n\n在给用户赋予角色时角色需要以：role_开头，后面添加角色名称。例如：role_abc 其中 abc 是角色名，role_是固定的字符开头。\n\n使用 hasrole()时参数也只写 abc 即可。否则启动报错。\n\n给用户赋予角色：\n\n\n\n在配置类中直接写 abc 即可。\n\n.antmatchers("/main1.html").hasrole("abc")\n\n\n1\n\n\n# hasanyrole(string ...)\n\n如果用户具备给定角色的任意一个，就允许被访问\n\n# hasipaddress(string)\n\n如果请求是指定的 ip 就运行访问。\n\n可以通过 request.getremoteaddr()获取 ip 地址。\n\n需要注意的是在本机进行测试时 localhost 和 127.0.0.1 输出的 ip地址是不一样的。\n\n当浏览器中通过 localhost 进行访问时控制台打印的内容：\n\n\n\n当浏览器中通过 127.0.0.1 访问时控制台打印的内容：\n\n\n\n当浏览器中通过具体 ip 进行访问时控制台打印内容：\n\n\n\n.antmatchers("/main1.html").hasipaddress("127.0.0.1")\n\n\n1\n\n\n\n# 自定义403处理方案\n\n使用 spring security 时经常会看见 403（无权限），默认情况下显示的效果如下：\n\n\n\n而在实际项目中可能都是一个异步请求，显示上述效果对于用户就不是特别友好了。spring security 支持自定义权限受限。\n\n# 新建类\n\n新建类实现 accessdeniedhandler\n\npackage com.yjxxt.springsecuritydemo.handler;\n\nimport org.springframework.security.access.accessdeniedexception;\nimport org.springframework.security.web.access.accessdeniedhandler;\nimport org.springframework.stereotype.component;\n\nimport javax.servlet.servletexception;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\nimport java.io.ioexception;\nimport java.io.printwriter;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@component\npublic class myaccessdeniedhandler implements accessdeniedhandler {\n\n   @override\n   public void handle(httpservletrequest request, httpservletresponse response, accessdeniedexception accessdeniedexception) throws ioexception, servletexception {\n      response.setstatus(httpservletresponse.sc_forbidden);\n      response.setheader("content-type", "application/json;charset=utf-8");\n      printwriter out = response.getwriter();\n      out.write("{\\"status\\":\\"error\\",\\"msg\\":\\"权限不足，请联系管理员！\\"}");\n      out.flush();\n      out.close();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 修改配置类\n\n配置类中重点添加异常处理器。设置访问受限后交给哪个对象进行处理。\n\nmyaccessdeniedhandler 是在配置类中进行自动注入的。\n\n//异常处理\nhttp.exceptionhandling()\n      .accessdeniedhandler(myaccessdeniedhandler);\n\n\n1\n2\n3\n\n\n\n# 基于表达式的访问控制\n\n# access()方法使用\n\n之前学习的登录用户权限判断实际上底层实现都是调用access(表达式)\n\n\n\n可以通过access()实现和之前学习的权限控制完成相同的功能。\n\n以 hasrole 和 和 permitall 举例\n\n\n\n# 使用自定义方法\n\n虽然这里面已经包含了很多的表达式(方法)但是在实际项目中很有可能出现需要自己自定义逻辑的情况。\n\n判断登录用户是否具有访问当前 url 权限。\n\n# 新建接口及实现类\n\nmyservice.java\n\npackage com.yjxxt.springsecuritydemo.service;\n\nimport org.springframework.security.core.authentication;\n\nimport javax.servlet.http.httpservletrequest;\n\npublic interface myservice {\n   boolean haspermission(httpservletrequest request, authentication authentication);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nmyserviceimpl.java\n\npackage com.yjxxt.springsecuritydemo.service.impl;\n\nimport com.yjxxt.springsecuritydemo.service.myservice;\nimport org.springframework.security.core.authentication;\nimport org.springframework.security.core.grantedauthority;\nimport org.springframework.security.core.authority.simplegrantedauthority;\nimport org.springframework.security.core.userdetails.userdetails;\nimport org.springframework.stereotype.component;\n\nimport javax.servlet.http.httpservletrequest;\nimport java.util.collection;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@component\npublic class myserviceimpl implements myservice {\n\n   @override\n   public boolean haspermission(httpservletrequest request, authentication authentication) {\n      object obj = authentication.getprincipal();\n      if (obj instanceof userdetails){\n         userdetails userdetails = (userdetails) obj;\n         collection<? extends grantedauthority> authorities = userdetails.getauthorities();\n         return authorities.contains(new simplegrantedauthority(request.getrequesturi()));\n      }\n      return false;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 修改配置类\n\n在 access 中通过@bean的id名.方法(参数)的形式进行调用配置类中修改如下：\n\n//url拦截\nhttp.authorizerequests()\n      //login.html不需要被认证\n      // .antmatchers("/login.html").permitall()\n      .antmatchers("/login.html").access("permitall")\n      // .antmatchers("/main.html").hasrole("abc")\n      .antmatchers("/main.html").access("hasrole(\'abc\')")\n      .anyrequest().access("@myserviceimpl.haspermission(request,authentication)")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 基于注解的访问控制\n\n在 spring security 中提供了一些访问控制的注解。这些注解都是默认是都不可用的，需要通过@enableglobalmethodsecurity进行开启后使用。\n\n如果设置的条件允许，程序正常执行。如果不允许会报 500\n\n\n\n这些注解可以写到 service 接口或方法上，也可以写到 controller或 controller 的方法上。通常情况下都是写在控制器方法上的，控制接口url是否允许被访问。\n\n# @secured\n\n@secured 是专门用于判断是否具有角色的。能写在方法或类上。参数要以 role_开头。\n\n\n\n# 开启注解\n\n在 启 动 类 ( 也 可 以 在 配 置 类 等 能 够 扫 描 的 类 上 ) 上 添 加@enableglobalmethodsecurity(securedenabled = true)\n\n@springbootapplication\n@enableglobalmethodsecurity(securedenabled = true)\npublic class springsecuritydemoapplication {\n\n   public static void main(string[] args) {\n      springapplication.run(springsecuritydemoapplication.class, args);\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 在控制器方法上添加 @secured 注解\n\n/**\n * 成功后跳转页面\n * @return\n */\n@secured("role_abc")\n@requestmapping("/tomain")\npublic string tomain(){\n   return "redirect:/main.html";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 配置类\n\n@override\nprotected void configure(httpsecurity http) throws exception {\n   //表单提交\n   http.formlogin()\n         //自定义登录页面\n         .loginpage("/login.html")\n         //当发现/login时认为是登录，必须和表单提交的地址一样。去执行userserviceimpl\n         .loginprocessingurl("/login")\n         //登录成功后跳转页面，post请求\n         .successforwardurl("/tomain")\n         \n   //url拦截\n   http.authorizerequests()\n         //login.html不需要被认证\n         .antmatchers("/login.html").permitall()\n         //所有请求都必须被认证，必须登录后被访问\n         .anyrequest().authenticated();\n   //关闭csrf防护\n   http.csrf().disable();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# @preauthorize/@postauthorize\n\n@preauthorize 和@postauthorize 都是方法或类级别注解。\n\n\n\n * @preauthorize表示访问方法或类在执行之前先判断权限，大多情况下都是使用这个注解，注解的参数和access()方法参数取值相同，都是权限表达式。\n * @postauthorize 表示方法或类执行结束后判断权限，此注解很少被使用到。\n\n# 开启注解\n\n@springbootapplication\n@enableglobalmethodsecurity(prepostenabled = true)\npublic class springsecuritydemoapplication {\n\n   public static void main(string[] args) {\n      springapplication.run(springsecuritydemoapplication.class, args);\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 添加@preauthorize\n\n在控制器方法上添加@preauthorize，参数可以是任何 access()支持的表达式\n\n/**\n * 成功后跳转页面\n * @return\n */\n@preauthorize("hasrole(\'role_abc\')")\n@requestmapping("/tomain")\npublic string tomain(){\n   return "redirect:/main.html";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# rememberme功能实现\n\nspring security 中 remember me 为“记住我”功能，用户只需要在登录时添加 remember-me复选框，取值为true。spring security 会自动把用户信息存储到数据源中，以后就可以不登录进行访问\n\n# 添加依赖\n\nspring security 实 现 remember me 功 能 时 底 层 实 现 依 赖spring-jdbc，所以需要导入 spring-jdbc。以后多使用 mybatis 框架而很少直接导入 spring-jdbc，所以此处导入 mybatis 启动器同时还需要添加 mysql 驱动\n\n\x3c!-- mybatis 依赖 --\x3e\n<dependency>\n   <groupid>org.mybatis.spring.boot</groupid>\n   <artifactid>mybatis-spring-boot-starter</artifactid>\n   <version>2.1.1</version>\n</dependency>\n\x3c!-- mysql 数据库依赖 --\x3e\n<dependency>\n   <groupid>mysql</groupid>\n   <artifactid>mysql-connector-java</artifactid>\n   <version>8.0.18</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 配置数据源\n\n在 application.properties 中配置数据源。请确保数据库中已经存在shop数据库\n\nspring.datasource.driver-class-name= com.mysql.cj.jdbc.driver\nspring.datasource.url= jdbc:mysql://localhost:3306/security?useunicode=true&characterencoding=utf-8&servertimezone=asia/shanghai\nspring.datasource.username= root\nspring.datasource.password= root\n\n\n1\n2\n3\n4\n\n\n# 编写配置\n\nremembermeconfig.java\n\npackage com.yjxxt.springsecuritydemo.config;\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.web.authentication.rememberme.jdbctokenrepositoryimpl;\nimport org.springframework.security.web.authentication.rememberme.persistenttokenrepository;\n\nimport javax.sql.datasource;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@configuration\npublic class remembermeconfig {\n\n   @autowired\n   private datasource datasource;\n\n   @bean\n   public persistenttokenrepository getpersistenttokenrepository(){\n      jdbctokenrepositoryimpl jdbctokenrepository = new jdbctokenrepositoryimpl();\n      jdbctokenrepository.setdatasource(datasource);\n      //自动建表，第一次启动时需要，第二次启动时注释掉\n      jdbctokenrepository.setcreatetableonstartup(true);\n      return jdbctokenrepository;\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 修改securityconfig.java\n\n在securityconfig中添加remembermeconfig和userdetailsservice实现类对象，并自动注入。\n\n在 configure 中添加下面配置内容。\n\nhttp.rememberme()\n      //登录逻辑交给哪个对象\n      .userdetailsservice(userservice)\n      // 持久层对象\n      .tokenrepository(persistenttokenrepository);\n\n\n1\n2\n3\n4\n5\n\n\n# 在客户端页面添加复选框\n\n在客户端登录页面中添加 remember-me 的复选框，只要用户勾选了复选框下次就不需要进行登录了。\n\n<form action="/login" method="post">\n    用户名：<input type="text" name="username" /><br/>\n    密码：<input type="password" name="password" /><br/>\n    <input type="checkbox" name="remember-me" value="true"/><br/>\n    <input type="submit" value="登录" />\n</form>\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 有效时间\n\n默认情况下重启项目后登录状态失效了。但是可以通过设置状态有效时间，即使项目重新启动下次也可以正常登录。\n\nhttp.rememberme()\n      //失效时间，单位秒\n      .tokenvalidityseconds(120)\n      //登录逻辑交给哪个对象\n      .userdetailsservice(userservice)\n      // 持久层对象\n      .tokenrepository(persistenttokenrepository);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# thymeleaf中springsecurity的使用（了解）\n\nspring security 可以在一些视图技术中进行控制显示效果。例如：jsp或 thymeleaf。在非前后端分离且使用 spring boot 的项目中多使用 thymeleaf作为视图展示技术。\n\nthymeleaf 对 spring security 的 支 持 都 放 在thymeleaf-extras-springsecurityx中，目前最新版本为 5。所以需要在项目中添加此 jar 包的依赖和 thymeleaf 的依赖。。\n\n\x3c!--thymeleaf springsecurity5 依赖--\x3e\n<dependency>\n   <groupid>org.thymeleaf.extras</groupid>\n   <artifactid>thymeleaf-extras-springsecurity5</artifactid>\n</dependency>\n\x3c!--thymeleaf依赖--\x3e\n<dependency>\n   <groupid>org.springframework.boot</groupid>\n   <artifactid>spring-boot-starter-thymeleaf</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在 html 页面中引入 thymeleaf 命名空间和 security 命名空间\n\n<html xmlns="http://www.w3.org/1999/xhtml"\n      xmlns:th="http://www.thymeleaf.org"\n      xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity5">\n\n\n1\n2\n3\n\n\n# 获取属性\n\n可以在html页面中通过sec:authentication=""获取\n\nusernamepasswordauthenticationtoken中所有 getxxx的内容，包含父类中的 getxxx的内容。\n\n根据源码得出下面属性：\n\n * name：登录账号名称\n\n * principal：登录主体，在自定义登录逻辑中是 userdetails\n\n * credentials：凭证\n\n * authorities：权限和角色\n\n * details：实际上是 webauthenticationdetails的实例。可以获取remoteaddress(客户端 ip)和 sessionid(当前 sessionid)\n\n# 新建demo.html\n\n在项目 resources 中新建 templates 文件夹，在 templates 中新建demo.html 页面\n\n<!doctype html>\n<html xmlns="http://www.w3.org/1999/xhtml"\n      xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity5">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n<body>\n    登录账号:<span sec:authentication="name"></span><br/>\n    登录账号:<span sec:authentication="principal.username"></span><br/>\n    凭证：<span sec:authentication="credentials"></span><br/>\n    权限和角色：<span sec:authentication="authorities"></span><br/>\n    客户端地址：<span sec:authentication="details.remoteaddress"></span><br/>\n    sessionid：<span sec:authentication="details.sessionid"></span><br/>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 编写controller\n\nthymeleaf 页面需要控制转发，在控制器类中编写下面方法\n\n@requestmapping("/demo")\npublic string demo(){\n   return "demo";\n}\n\n\n1\n2\n3\n4\n\n\n# 权限判断\n\n# 设置用户角色和权限\n\n设定用户具有 admin，/insert，/delete 权限 role_abc 角色。\n\nreturn new user(username,password, authorityutils.commaseparatedstringtoauthoritylist("admin,role_abc,/insert,/delete"));\n\n\n1\n\n\n# 控制页面显示效果\n\n在页面中根据用户权限和角色判断页面中显示的内容\n\n通过权限判断：\n<button sec:authorize="hasauthority(\'/insert\')">新增</button>\n<button sec:authorize="hasauthority(\'/delete\')">删除</button>\n<button sec:authorize="hasauthority(\'/update\')">修改</button>\n<button sec:authorize="hasauthority(\'/select\')">查看</button>\n<br/>\n通过角色判断：\n<button sec:authorize="hasrole(\'abc\')">新增</button>\n<button sec:authorize="hasrole(\'abc\')">删除</button>\n<button sec:authorize="hasrole(\'abc\')">修改</button>\n<button sec:authorize="hasrole(\'abc\')">查看</button>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 退出登录\n\n用户只需要向 spring security 项目中发送/logout退出请求即可。\n\n# 退出登录\n\n实现退出非常简单，只要在页面中添加/logout 的超链接即可。\n\n<a href="/logout">退出登录</a>\n\n\n1\n\n\n为了实现更好的效果，通常添加退出的配置。默认的退出 url 为/logout，退出成功后跳转到/login?logout\n\n\n\n如果不希望使用默认值，可以通过下面的方法进行修改。\n\nhttp.logout()\n      .logouturl("/logout")\n      .logoutsuccessurl("/login.html");\n\n\n1\n2\n3\n\n\n# logout其他常用配置源码解读\n\n# addlogouthandler(logouthandler)\n\n默认是 contextlogouthandler\n\n\n\n默认实例内容\n\n\n\n# clearauthentication(boolean)\n\n是否清除认证状态，默认为 true\n\n\n\n# invalidatehttpsession(boolean)\n\n是否销毁 httpsession 对象，默认为 true\n\n\n\n# logoutsuccesshandler(logoutsuccesshandler)\n\n退出成功处理器\n\n\n\n也可以自己进行定义退出成功处理器。只要实现了logoutsuccesshandler接口。与之前讲解的登录成功处理器和登录失败处理器极其类似。\n\n\n# springsecurity中的csrf\n\n从刚开始学习spring security时，在配置类中一直存在这样一行代码：http.csrf().disable();如果没有这行代码导致用户无法被认证。这行代码的含义是：关闭 csrf 防护。\n\n# 1. 什么是csrf\n\ncsrf（cross-site request forgery）跨站请求伪造，也被称为“oneclick attack” 或者 session riding。通过伪造用户请求访问受信任站点的非法请求访问。\n\n跨域：只要网络协议，ip 地址，端口中任何一个不相同就是跨域请求。\n\n客户端与服务进行交互时，由于 http 协议本身是无状态协议，所以引入了cookie进行记录客户端身份。在cookie中会存放session id用来识别客户端身份的。在跨域的情况下，session id 可能被第三方恶意劫持，通过这个 session id 向服务端发起请求时，服务端会认为这个请求是合法的，可能发生很多意想不到的事情。\n\n# 2. spring security中的csrf\n\n从 spring security4开始csrf防护默认开启。默认会拦截请求，进行csrf处理。csrf为了保证不是其他第三方网站访问，要求访问时携带参数名为_csrf值为token(token 在服务端产生)的内容，如果token和服务端的token匹配成功，则正常访问。\n\n# 2.1、编写控制器方法\n\n编写控制器方法，跳转到 templates 中 login.html 页面。\n\n@requestmapping("/showlogin")\npublic string showlogin(){\n   return "login";\n}\n\n\n1\n2\n3\n4\n\n\n# 2.2、新建login.html\n\n红色部分是必须存在的否则无法正常登录。\n\n<!doctype html>\n<html xmlns="http://www.w3.org/1999/xhtml"\n      xmlns:th="http://www.thymeleaf.org"\n>\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n<body>\n<form action="/login" method="post">\n    <input type="hidden" th:value="${_csrf.token}" name="_csrf" th:if="${_csrf}"/>\n    用户名：<input type="text" name="username" /><br/>\n    密码：<input type="password" name="password" /><br/>\n    <input type="submit" value="登录" />\n</form>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 修改配置类\n\n在配置类中注释掉 csrf 防护失效\n\n// 关闭csrf防护\n// http.csrf().disable();\n\n\n1\n2\n\n\n\n# oauth2认证\n\n\n# oauth2简介\n\n# 简介\n\n第三方认证技术方案最主要是解决认证协议的通用标准问题，因为要实现跨系统认证，各系统之间要遵循一定的接口协议。\n\noauth协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用oauth认证服务，任何服务提供商都可以实现自身的oauth认证服务，因而oauth是开放的。业界提供了oauth的多种实现如php、javascript，java，ruby等各种语言开发包，大大节约了程序员的时间，因而oauth是简易的。互联网很多服务如open api，很多大公司如google，yahoo，microsoft等都提供了oauth认证服务，这些都足以说明oauth标准逐渐成为开放资源授权的标准。\n\noauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。\n\n下边分析一个oauth2认证的例子，网站使用微信认证的过程：\n\n\n\n 1. 用户进入网站的登录页面，点击微信的图标以微信账号登录系统，用户是自己在微信里信息的资源拥有者。\n\n\n\n点击“微信”出现一个二维码，此时用户扫描二维码，开始给网站授权。\n\n\n\n * 资源拥有者同意给客户端授权\n   \n   > 资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证，验证通过后，微信会询问用户是否给授权网站访问自己的微信数据，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码，并重定向到网站。\n\n * 客户端获取到授权码，请求认证服务器申请令牌\n   \n   > 此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。\n\n * 认证服务器向客户端响应令牌\n   \n   > 认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。此交互过程用户看不到，当客户端拿到令牌后，用户在网站看到已经登录成功。\n\n * 客户端请求资源服务器的资源\n   \n   > 客户端携带令牌访问资源服务器的资源。网站携带令牌请求访问微信服务器获取用户的基本信息。\n\n * 资源服务器返回受保护资源\n   \n   > 资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。\n\n注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务资源服务器通常要请求认证服务器来校验令牌的合法性。\n\noauth2.0认证流程如下：\n\n引自oauth2.0协议rfc6749 https://tools.ietf.org/html/rfc6749\n\n\n\n# 角色\n\n客户端\n\n本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：android客户端、web客户端（浏览器端）、微信客户端等。\n\n资源拥有者\n\n通常为用户，也可以是应用程序，即该资源的拥有者。\n\n授权服务器（也称认证服务器）\n\n用来对资源拥有者的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授权后方可访问。\n\n资源服务器\n\n存储资源的服务器，比如，网站用户管理服务器存储了网站用户信息，网站相册服务器存储了用户的相册信息，微信的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。\n\n# 常用术语\n\n * 客户凭证(client credentials)：客户端的clientid和密码用于认证客户\n\n * 令牌(tokens)：授权服务器在接收到客户请求后，颁发的访问令牌\n\n * 作用域(scopes)：客户请求访问令牌时，由资源拥有者额外指定的细分权限(permission)\n\n# 令牌类型\n\n * 授权码：仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌\n\n * 访问令牌：用于代表一个用户或服务直接去访问受保护的资源\n\n * 刷新令牌：用于去授权服务器获取一个刷新访问令牌\n\n * bearertoken：不管谁拿到token都可以访问资源，类似现金\n\n * proof of possession(pop) token：可以校验client是否对token有明确的拥有权\n\n# 特点\n\n优点：\n\n * 更安全，客户端不接触用户密码，服务器端更易集中保护\n * 广泛传播并被持续采用\n * 短寿命和封装的token\n * 资源服务器和授权服务器解耦\n * 集中式授权，简化客户端\n * http/json友好，易于请求和传递token\n * 考虑多种客户端架构场景\n * 客户可以具有不同的信任级别\n\n缺点：\n\n * 协议框架太宽泛，造成各种实现的兼容性和互操作性差\n * 不是一个认证协议，本身并不能告诉你任何用户信息。\n\n\n# 授权模式\n\n# 授权码模式（authorization code）\n\n\n\n# 简化授权模式（implicit）\n\n\n\n# 密码模式（resource owner passwordcredentials）\n\n\n\n# 客户端模式（client credentials）\n\n\n\n# 刷新令牌\n\n\n\n\n# spring security oauth2\n\n\n# 授权服务器（熟悉）\n\n\n\n * authorize endpoint：授权端点，进行授权\n\n * token endpoint：令牌端点，经过授权拿到对应的token\n\n * introspection endpoint：校验端点，校验token的合法性\n\n * revocation endpoint：撤销端点，撤销授权\n\n\n# spring security oauth2架构（熟悉）\n\n\n\n流程：\n\n 1. 用户访问，此时没有token。oauth2resttemplate会报错，这个报错信息会被oauth2clientcontextfilter捕获并重定向到认证服务器\n 2. 认证服务器通过authorization endpoint进行授权，并通过authorizationservertokenservices生成授权码并返回给客户端\n 3. 客户端拿到授权码去认证服务器通过token endpoint调用authorizationservertokenservices生成token并返回给客户端\n 4. 客户端拿到token去资源服务器访问资源，一般会通过oauth2authenticationmanager调用resourceservertokenservices进行校验。校验通过可以获取资源。\n\n\n# spring security oauth2授权码模式\n\n# 1. 创建项目\n\n\n\n\n\n\n\n\n\n# 2、添加依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n   <modelversion>4.0.0</modelversion>\n   <parent>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-parent</artifactid>\n      <version>2.2.2.release</version>\n      <relativepath/> \x3c!-- lookup parent from repository --\x3e\n   </parent>\n  \n   <groupid>com.yjxxt</groupid>\n   <artifactid>springsecurityoauth2demo</artifactid>\n   <version>0.0.1-snapshot</version>\n  \n   <name>springsecurityoauth2demo</name>\n   <description>demo project for spring boot</description>\n\n   <properties>\n      <java.version>1.8</java.version>\n      <spring-cloud.version>greenwich.sr2</spring-cloud.version>\n   </properties>\n\n   <dependencies>\n      <dependency>\n         <groupid>org.springframework.cloud</groupid>\n         <artifactid>spring-cloud-starter-oauth2</artifactid>\n      </dependency>\n      <dependency>\n         <groupid>org.springframework.cloud</groupid>\n         <artifactid>spring-cloud-starter-security</artifactid>\n      </dependency>\n      <dependency>\n         <groupid>org.springframework.boot</groupid>\n         <artifactid>spring-boot-starter-web</artifactid>\n      </dependency>\n      <dependency>\n         <groupid>org.springframework.boot</groupid>\n         <artifactid>spring-boot-starter-test</artifactid>\n         <scope>test</scope>\n      </dependency>\n   </dependencies>\n\n   <dependencymanagement>\n      <dependencies>\n         <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-dependencies</artifactid>\n            <version>${spring-cloud.version}</version>\n            <type>pom</type>\n            <scope>import</scope>\n         </dependency>\n      </dependencies>\n   </dependencymanagement>\n\n   <build>\n      <plugins>\n         <plugin>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-maven-plugin</artifactid>\n         </plugin>\n      </plugins>\n   </build>\n\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 3、编写实体类\n\nuser.java\n\npackage com.yjxxt.springsecurityoauth2demo.pojo;\n\nimport org.springframework.security.core.grantedauthority;\nimport org.springframework.security.core.userdetails.userdetails;\n\nimport java.util.collection;\nimport java.util.list;\n\n/**\n * 用户类\n */\npublic class user implements userdetails {\n\n    private string username;\n    private string password;\n    private list<grantedauthority> authorities;\n\n    public user(string username, string password, list<grantedauthority> authorities) {\n        this.username = username;\n        this.password = password;\n        this.authorities = authorities;\n    }\n\n    @override\n    public collection<? extends grantedauthority> getauthorities() {\n        return authorities;\n    }\n\n    @override\n    public string getpassword() {\n        return password;\n    }\n\n    @override\n    public string getusername() {\n        return username;\n    }\n\n    @override\n    public boolean isaccountnonexpired() {\n        return true;\n    }\n\n    @override\n    public boolean isaccountnonlocked() {\n        return true;\n    }\n\n    @override\n    public boolean iscredentialsnonexpired() {\n        return true;\n    }\n\n    @override\n    public boolean isenabled() {\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n# 4、编写service\n\nuserservice.java\n\npackage com.yjxxt.springsecurityoauth2demo.service;\n\nimport com.yjxxt.springsecurityoauth2demo.pojo.user;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.security.core.authority.authorityutils;\nimport org.springframework.security.core.userdetails.userdetails;\nimport org.springframework.security.core.userdetails.userdetailsservice;\nimport org.springframework.security.core.userdetails.usernamenotfoundexception;\nimport org.springframework.security.crypto.password.passwordencoder;\nimport org.springframework.stereotype.service;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@service\npublic class userservice implements userdetailsservice {\n\n   @autowired\n   private passwordencoder passwordencoder;\n\n   @override\n   public userdetails loaduserbyusername(string username) throws usernamenotfoundexception {\n      string password = passwordencoder.encode("123456");\n      return new user("admin",password, authorityutils.commaseparatedstringtoauthoritylist("admin"));\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 5、编写controller\n\nusercontroller.java\n\npackage com.yjxxt.springsecurityoauth2demo.controller;\n\nimport org.springframework.security.core.authentication;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@restcontroller\n@requestmapping("/user")\npublic class usercontroller {\n\n   @getmapping("/getcurrentuser")\n   public object getcurrentuser(authentication authentication) {\n      return authentication.getprincipal();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 6、编写配置类\n\nsecurityconfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.config.annotation.web.builders.httpsecurity;\nimport org.springframework.security.config.annotation.web.configuration.enablewebsecurity;\nimport org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter;\nimport org.springframework.security.crypto.bcrypt.bcryptpasswordencoder;\nimport org.springframework.security.crypto.password.passwordencoder;\n\n/**\n * spring security 配置类\n *\n * @author zhoubin\n */\n@configuration\n@enablewebsecurity\npublic class securityconfig extends websecurityconfigureradapter {\n\n   @bean\n   public passwordencoder passwordencoder() {\n      return new bcryptpasswordencoder();\n   }\n\n\n   @override\n   public void configure(httpsecurity http) throws exception {\n      http.csrf()\n            .disable()\n            .authorizerequests()\n            .antmatchers("/oauth/**", "/login/**", "/logout/**")\n            .permitall()\n            .anyrequest()\n            .authenticated()\n            .and()\n            .formlogin()\n            .permitall();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\nauthorizationserverconfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.crypto.password.passwordencoder;\nimport org.springframework.security.oauth2.config.annotation.configurers.clientdetailsserviceconfigurer;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.authorizationserverconfigureradapter;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.enableauthorizationserver;\n\n/**\n * 授权服务器配置\n * @author zhoubin\n * @since 1.0.0\n */\n@configuration\n@enableauthorizationserver\npublic class authorizationserverconfig extends authorizationserverconfigureradapter {\n\n    @autowired\n    private passwordencoder passwordencoder;\n\n\n    @override\n    public void configure(clientdetailsserviceconfigurer clients) throws exception {\n        clients.inmemory()\n                //配置client_id\n                .withclient("admin")\n                //配置client-secret\n                .secret(passwordencoder.encode("112233"))\n                //配置redirect_uri，用于授权成功后跳转\n                .redirecturis("http://www.baidu.com")\n                //配置申请的权限范围\n                .scopes("all")\n                //配置grant_type，表示授权类型\n                .authorizedgranttypes("authorization_code");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\nresourceserverconfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.config.annotation.web.builders.httpsecurity;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.enableresourceserver;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.resourceserverconfigureradapter;\n\n/**\n * 资源服务器配置\n *\n * @author zhoubin\n * @since 1.0.0\n */\n@configuration\n@enableresourceserver\npublic class resourceserverconfig extends resourceserverconfigureradapter {\n\n    @override\n    public void configure(httpsecurity http) throws exception {\n        http.authorizerequests()\n                .anyrequest()\n                .authenticated()\n                .and()\n                .requestmatchers()\n                .antmatchers("/user/**");//配置需要保护的资源路径\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 7、测试\n\n# 获取授权码\n\nhttp://localhost:8080/oauth/authorize?response_type=code&client_id=admin&redirect_uri=http://www.baidu.com&scope=all\n\n\n\n输入账户密码\n\n\n\n点击授权获取授权码\n\n\n\n# 根据授权码获取令牌（post请求）\n\n\n\n\n\n * grant_type：授权类型，填写authorization_code，表示授权码模式\n\n * code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。\n\n * client_id:客户端标识\n\n * redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。\n\n * scope:授权范围。\n\n认证失败服务端返回 401 unauthorized\n\n注意：此时无法请求到令牌，访问服务器会报错\n\n\n\n# 根据token去资源服务器拿资源\n\n\n\n如果修改token就会报错\n\n\n\n\n# spring security oauth2 密码模式\n\n在上面的代码中进行适当的修改即可\n\nsecurityconfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.authentication.authenticationmanager;\nimport org.springframework.security.config.annotation.web.builders.httpsecurity;\nimport org.springframework.security.config.annotation.web.configuration.enablewebsecurity;\nimport org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter;\nimport org.springframework.security.crypto.bcrypt.bcryptpasswordencoder;\nimport org.springframework.security.crypto.password.passwordencoder;\n\n/**\n * spring security 配置类\n *\n * @author zhoubin\n */\n@configuration\n@enablewebsecurity\npublic class securityconfig extends websecurityconfigureradapter {\n\n   @bean\n   public passwordencoder passwordencoder() {\n      return new bcryptpasswordencoder();\n   }\n\n   /**\n     * 使用密码模式需要配置\n     */\n   @bean\n   @override\n   public authenticationmanager authenticationmanagerbean() throws exception {\n      return super.authenticationmanagerbean();\n   }\n\n   @override\n   public void configure(httpsecurity http) throws exception {\n      http.csrf()\n            .disable()\n            .authorizerequests()\n            .antmatchers("/oauth/**", "/login/**", "/logout/**")\n            .permitall()\n            .anyrequest()\n            .authenticated()\n            .and()\n            .formlogin()\n            .permitall();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\nauthorizationserverconfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport com.yjxxt.springsecurityoauth2demo.service.userservice;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.authentication.authenticationmanager;\nimport org.springframework.security.crypto.password.passwordencoder;\nimport org.springframework.security.oauth2.config.annotation.configurers.clientdetailsserviceconfigurer;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.authorizationserverconfigureradapter;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.enableauthorizationserver;\nimport org.springframework.security.oauth2.config.annotation.web.configurers.authorizationserverendpointsconfigurer;\n\n/**\n * 授权服务器配置\n * @author zhoubin\n * @since 1.0.0\n */\n@configuration\n@enableauthorizationserver\npublic class authorizationserverconfig extends authorizationserverconfigureradapter {\n\n    @autowired\n    private passwordencoder passwordencoder;\n\n    @autowired\n    private authenticationmanager authenticationmanager;\n\n    @autowired\n    private userservice userservice;\n\n    /**\n     * 使用密码模式需要配置\n     */\n    @override\n    public void configure(authorizationserverendpointsconfigurer endpoints) {\n        endpoints.authenticationmanager(authenticationmanager)\n                .userdetailsservice(userservice);\n    }\n\n    @override\n    public void configure(clientdetailsserviceconfigurer clients) throws exception {\n        clients.inmemory()\n                //配置client_id\n                .withclient("admin")\n                //配置client-secret\n                .secret(passwordencoder.encode("112233"))\n                //配置访问token的有效期\n                .accesstokenvalidityseconds(3600)\n                //配置刷新token的有效期\n                .refreshtokenvalidityseconds(864000)\n                //配置redirect_uri，用于授权成功后跳转\n                .redirecturis("http://www.baidu.com")\n                //配置申请的权限范围\n                .scopes("all")\n                //配置grant_type，表示授权类型\n                .authorizedgranttypes("authorization_code","password");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n测试：\n\n\n\n\n\n\n# 在redis中存储token\n\n之前的代码我们将token直接存在内存中，这在生产环境中是不合理的，下面我们将其改造成存储在redis中\n\n# 添加依赖及配置\n\npom.xml\n\n\x3c!--redis 依赖--\x3e\n<dependency>\n   <groupid>org.springframework.boot</groupid>\n   <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\x3c!-- commons-pool2 对象池依赖 --\x3e\n<dependency>\n   <groupid>org.apache.commons</groupid>\n   <artifactid>commons-pool2</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\napplication.properties\n\n# redis配置\nspring.redis.host=192.168.10.100\n\n\n1\n2\n\n\n# 编写redis配置类\n\nredisconfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.data.redis.connection.redisconnectionfactory;\nimport org.springframework.security.oauth2.provider.token.tokenstore;\nimport org.springframework.security.oauth2.provider.token.store.redis.redistokenstore;\n\n/**\n * 使用redis存储token的配置\n * @author zhoubin\n * @since 1.0.0\n */\n@configuration\npublic class redisconfig {\n   @autowired\n   private redisconnectionfactory redisconnectionfactory;\n\n   @bean\n   public tokenstore redistokenstore(){\n      return new redistokenstore(redisconnectionfactory);\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 在认证服务器配置中指定令牌的存储策略为redis\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport com.yjxxt.springsecurityoauth2demo.service.userservice;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.beans.factory.annotation.qualifier;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.authentication.authenticationmanager;\nimport org.springframework.security.crypto.password.passwordencoder;\nimport org.springframework.security.oauth2.config.annotation.configurers.clientdetailsserviceconfigurer;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.authorizationserverconfigureradapter;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.enableauthorizationserver;\nimport org.springframework.security.oauth2.config.annotation.web.configurers.authorizationserverendpointsconfigurer;\nimport org.springframework.security.oauth2.provider.token.tokenstore;\n\n/**\n * 授权服务器配置\n * @author zhoubin\n * @since 1.0.0\n */\n@configuration\n@enableauthorizationserver\npublic class authorizationserverconfig extends authorizationserverconfigureradapter {\n\n    @autowired\n    private passwordencoder passwordencoder;\n\n    @autowired\n    private authenticationmanager authenticationmanager;\n\n    @autowired\n    private userservice userservice;\n\n    @autowired\n    @qualifier("redistokenstore")\n    private tokenstore tokenstore;\n\n    /**\n     * 使用密码模式需要配置\n     */\n    @override\n    public void configure(authorizationserverendpointsconfigurer endpoints) {\n        endpoints.authenticationmanager(authenticationmanager)\n                .userdetailsservice(userservice)\n                .tokenstore(tokenstore);\n    }\n\n    @override\n    public void configure(clientdetailsserviceconfigurer clients) throws exception {\n        clients.inmemory()\n                //配置client_id\n                .withclient("admin")\n                //配置client-secret\n                .secret(passwordencoder.encode("112233"))\n                //配置访问token的有效期\n                .accesstokenvalidityseconds(3600)\n                //配置刷新token的有效期\n                .refreshtokenvalidityseconds(864000)\n                //配置redirect_uri，用于授权成功后跳转\n                .redirecturis("http://www.baidu.com")\n                //配置申请的权限范围\n                .scopes("all")\n                //配置grant_type，表示授权类型\n                .authorizedgranttypes("password");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n测试：\n\n使用密码模式请求token\n\n\n\n\n\n\n# jwt\n\n\n# 常见的认证机制\n\n# http basic auth\n\nhttp basic auth简单点说明就是每次请求api时都提供用户的username和password，简言之，basic auth是配合restful api 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的restful api时，尽量避免采用http basic auth。\n\n# cookie auth\n\ncookie认证机制就是为一次请求认证在服务端创建一个session对象，同时在客户端的浏览器端创建了一个cookie对象；通过客户端带上来cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效。\n\n\n\n# oauth\n\noauth（开放授权,open authorization）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。如网站通过微信、微博登录等，主要用于第三方登录。\n\noauth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，oauth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。\n\n下面是oauth2.0的流程：\n\n\n\n这种基于oauth的认证机制适用于个人消费者类的互联网产品，如社交类app等应用，但是不太适合拥有自有认证权限管理的企业应用。\n\n缺点：过重。\n\n# token auth\n\n使用基于 token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：\n\n 1. 客户端使用用户名跟密码请求登录\n 2. 服务端收到请求，去验证用户名与密码\n 3. 验证成功后，服务端会签发一个 token，再把这个 token 发送给客户端\n 4. 客户端收到 token 以后可以把它存储起来，比如放在 cookie 里\n 5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 token\n 6. 服务端收到请求，然后去验证客户端请求里面带着的 token，如果验证成功，就向客户端返回请求的数据\n\n\n\n比第一种方式更安全，比第二种方式更节约服务器资源，比第三种方式更加轻量。\n\n具体，token auth的优点（token机制相对于cookie机制又有什么好处呢？）：\n\n * 支持跨域访问：cookie是不允许垮域访问的，这一点对token机制是不存在的，前提是传输的用户认证信息通过http头传输.\n * 无状态(也称：服务端可扩展行)：token机制在服务端不需要存储session信息，因为token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.\n * 更适用cdn：可以通过内容分发网络请求你服务端的所有资料（如：javascript，html,图片等），而你的服务端只要提供api即可.\n * 去耦：不需要绑定到一个特定的身份验证方案。token可以在任何地方生成，只要在你的api被调用的时候，你可以进行token生成调用即可.\n * 更适用于移动应用：当你的客户端是一个原生平台（ios, android，windows 10等）时，cookie是不被支持的（你需要通过cookie容器进行处理），这时采用token认证机制就会简单得多。\n * csrf：因为不再依赖于cookie，所以你就不需要考虑对csrf（跨站请求伪造）的防范。\n * 性能：一次网络往返时间（通过数据库查询session信息）总比做一次hmacsha256计算的token验证和解析要费时得多.\n * 不需要为登录页面做特殊处理：如果你使用protractor 做功能测试的时候，不再需要为登录页面做特殊处理.\n * 基于标准化：你的api可以采用标准化的 json web token (jwt). 这个标准已经存在多个后端库（.net, ruby, java,python, php）和多家公司的支持（如：firebase,google, microsoft）.\n\n\n# jwt简介\n\n# 什么是jwt\n\njson web token（jwt）是一个开放的行业标准（rfc 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。jwt可以使用hmac算法或使用rsa的公钥/私钥对来签名，防止被篡改。\n\n官网： https://jwt.io/\n\n标准： https://tools.ietf.org/html/rfc7519\n\njwt令牌的优点：\n\n * jwt基于json，非常方便解析。\n * 可以在令牌中自定义丰富的内容，易扩展。\n * 通过非对称加密算法及数字签名技术，jwt防止篡改，安全性高。\n * 资源服务使用jwt可不依赖认证服务即可完成授权。\n\n缺点：\n\n 1. jwt令牌较长，占存储空间比较大。\n\n# jwt组成\n\n一个jwt实际上就是一个字符串，它由三部分组成，头部、载荷与签名。\n\n# 头部(header)\n\n头部用于描述关于该jwt的最基本的信息，例如其类型（即jwt）以及签名所用的算法（如hmac sha256或rsa）等。这也可以被表示成一个json对象。\n\n{\n  "alg": "hs256",\n  "typ": "jwt"\n}\n\n\n1\n2\n3\n4\n\n * typ：是类型。\n * alg：签名的算法，这里使用的算法是hs256算法\n\n我们对头部的json字符串进行base64编码（网上有很多在线编码的网站），编码后的字符串如下：\n\neyjhbgcioijiuzi1niisinr5cci6ikpxvcj9\n\n\n1\n\n\nbase64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个base64单元，即3个字节需要用4个可打印字符来表示。jdk 中提供了非常方便的 base64encoder和 base64decoder，用它们可以非常方便的完成基于 base64 的编码和解码。\n\n# 负载(payload)\n\n第二部分是负载，就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：\n\n * 标准中注册的声明（建议但不强制使用）\n\niss: jwt签发者\nsub: jwt所面向的用户\naud: 接收jwt的一方\nexp: jwt的过期时间，这个过期时间必须要大于签发时间\nnbf: 定义在什么时间之前，该jwt都是不可用的.\niat: jwt的签发时间\njti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n * 公共的声明\n   \n   公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.\n\n * 私有的声明\n   \n   私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。\n\n这个指的就是自定义的claim。比如下面那个举例中的name都属于自定的claim。这些claim跟jwt标准规定的claim区别在于：jwt规定的claim，jwt的接收方在拿到jwt之后，都知道怎么对这些标准的claim进行验证(还不知道是否能够验证)；而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。\n\n{\n  "sub": "1234567890",\n  "name": "john doe",\n  "iat": 1516239022\n}\n\n\n1\n2\n3\n4\n5\n\n\n其中sub是标准的声明，name是自定义的声明（公共的或私有的）\n\n然后将其进行base64编码，得到jwt的第二部分：\n\n eyjzdwiioiixmjm0nty3odkwiiwibmftzsi6ikphbwvziiwiywrtaw4ionrydwv9\n\n\n1\n\n\n提示：声明中不要放一些敏感信息。\n\n# 签证、签名（signature）\n\njwt的第三部分是一个签证信息，这个签证信息由三部分组成：\n\n * header (base64后的)\n\n * payload (base64后的)\n\n * secret（盐，一定要保密）\n\n这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分：\n\n8hi-lod0ncfvdnbkipjjqlh998duf9dsdgkx3grpnvi\n\n\n1\n\n\n将这三部分用.连接成一个完整的字符串,构成了最终的jwt:\n\neyjhbgcioijiuzi1niisinr9cci6ikpxvcj9.eyjzdwiioiixmjm0nty3odkwiiwibmftzsi6ikpvag4grg9liiwiawf0ijoxnte2mjm5mdiyfq.8hi-lod0ncfvdnbkipjjqlh998duf9dsdgkx3grpnvi\n\n\n1\n\n\n注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。\n\n\n# jjwt简介\n\n# 什么是jjwt\n\njjwt是一个提供端到端的jwt创建和验证的java库。永远免费和开源(apache license，版本2.0)，jjw很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。\n\n规范官网：https://jwt.io/\n\n# 快速入门\n\n# token的创建\n\n创建springboot工程，引入依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n   <modelversion>4.0.0</modelversion>\n   <parent>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-parent</artifactid>\n      <version>2.2.2.release</version>\n      <relativepath/> \x3c!-- lookup parent from repository --\x3e\n   </parent>\n  \n   <groupid>com.yjxxt</groupid>\n   <artifactid>jwtdemo</artifactid>\n   <version>0.0.1-snapshot</version>\n  \n   <name>jwtdemo</name>\n   <description>demo project for spring boot</description>\n\n   <properties>\n      <java.version>1.8</java.version>\n   </properties>\n\n   <dependencies>\n      <dependency>\n         <groupid>org.springframework.boot</groupid>\n         <artifactid>spring-boot-starter-web</artifactid>\n      </dependency>\n      \x3c!--jwt依赖--\x3e\n      <dependency>\n         <groupid>io.jsonwebtoken</groupid>\n         <artifactid>jjwt</artifactid>\n         <version>0.9.0</version>\n      </dependency>\n\n      <dependency>\n         <groupid>org.springframework.boot</groupid>\n         <artifactid>spring-boot-starter-test</artifactid>\n         <scope>test</scope>\n         <exclusions>\n            <exclusion>\n               <groupid>org.junit.vintage</groupid>\n               <artifactid>junit-vintage-engine</artifactid>\n            </exclusion>\n         </exclusions>\n      </dependency>\n   </dependencies>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n创建测试类jwttest，用于生成token：\n\npackage com.yjxxt.jwtdemo;\n\nimport io.jsonwebtoken.jwtbuilder;\nimport io.jsonwebtoken.jwts;\nimport io.jsonwebtoken.signaturealgorithm;\nimport io.jsonwebtoken.impl.base64codec;\nimport org.junit.jupiter.api.test;\nimport org.springframework.boot.test.context.springboottest;\n\nimport java.util.date;\n\n@springboottest\npublic class jwtdemoapplicationtests {\n\n   /**\n    * 创建token\n    */\n   @test\n   public void testcreattoken() {\n      //创建一个jwtbuilder对象\n      jwtbuilder jwtbuilder = jwts.builder()\n            //声明的标识{"jti":"888"}\n            .setid("888")\n            //主体，用户{"sub":"rose"}\n            .setsubject("rose")\n            //创建日期{"ita":"yjxxtxx"}\n            .setissuedat(new date())\n            //签名手段，参数1：算法，参数2：盐\n            .signwith(signaturealgorithm.hs256,"yjxxt");\n       \n      //获取jwt的token\n      string token = jwtbuilder.compact();\n      system.out.println(token);\n\n      //三部分的base64解密\n      system.out.println("--------------------");\n      string[] split = token.split("\\\\.");\n      system.out.println(base64codec.base64.decodetostring(split[0]));\n      system.out.println(base64codec.base64.decodetostring(split[1]));\n      //无法解密\n      system.out.println(base64codec.base64.decodetostring(split[2]));\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n运行结果如下\n\n\n\n再次运行，会发现每次运行的结果是不一样的，因为我们的载荷中包含了时间\n\n# token的验证解析\n\n我们刚才已经创建了token ，在web应用中这个操作是由服务端进行然后发给客户端，客户端在下次向服务端发送请求时需要携带这个token（这就好像是拿着一张门票一样），那服务端接到这个token 应该解析出token中的信息（例如用户id）,根据这些信息查询数据库返回相应的结果。\n\n@test\npublic void testparsetoken(){\n   //token\n   string token = "eyjhbgcioijiuzi1nij9.eyjqdgkioii4odgilcjzdwiioijsb3nliiwiawf0ijoxntc4ode0mjuyfq" +\n         ".-fyfmhyftcgzq900f_drfdsges0ge2ujawvpw9gcdto";\n   //解析token获取负载中的声明对象\n   claims claims = jwts.parser()\n         .setsigningkey("yjxxt")\n         .parseclaimsjws(token)\n         .getbody();\n   //打印声明的属性\n   system.out.println("id:"+claims.getid());\n   system.out.println("subject:"+claims.getsubject());\n   system.out.println("issuedat:"+claims.getissuedat());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n试着将token或签名秘钥篡改一下，会发现运行时就会报错，所以解析token也就是验证token\n\n# token过期校验\n\n有很多时候，我们并不希望签发的token是永久生效的（上节的token是永久的），所以我们可以为token添加一个过期时间。原因：从服务器发出的token，服务器自己并不做记录，就存在一个弊端就是，服务端无法主动控制某token的立刻失效。\n\n测试用例：\n\n@test\npublic void testcreattokenhasexp() {\n   //当前系统时间的长整型\n   long now = system.currenttimemillis();\n   //过期时间，这里是1分钟后的时间长整型\n   long exp = now + 60 * 1000;\n   //创建一个jwtbuilder对象\n   jwtbuilder jwtbuilder = jwts.builder()\n         //声明的标识{"jti":"888"}\n         .setid("888")\n         //主体，用户{"sub":"rose"}\n         .setsubject("rose")\n         //创建日期{"ita":"yjxxtxx"}\n         .setissuedat(new date())\n         //签名手段，参数1：算法，参数2：盐\n         .signwith(signaturealgorithm.hs256, "yjxxt")\n         //设置过期时间\n         .setexpiration(new date(exp));\n   //获取jwt的token\n   string token = jwtbuilder.compact();\n   system.out.println(token);\n}\n\n\n@test\npublic void testparsetokenhasexp() {\n   //token\n   string token = "eyjhbgcioijiuzi1nij9" +\n         ".eyjqdgkioii4odgilcjzdwiioijsb3nliiwiawf0ijoxntc4ode1mdyylcjlehaioje1nzg4mtuxmjisinjvbgvzijoiywrtaw4ilcjsb2dvijoic2hzehquanbnin0.hkog0rsz9_6ii_r8kucp0hlaouuayxajvbz3xtltuh4";\n   //解析token获取负载中的声明对象\n   claims claims = jwts.parser()\n         .setsigningkey("yjxxt")\n         .parseclaimsjws(token)\n         .getbody();\n   //打印声明的属性\n   system.out.println("id:" + claims.getid());\n   system.out.println("subject:" + claims.getsubject());\n   system.out.println("issuedat:" + claims.getissuedat());\n   dateformat sf = new simpledateformat("yyyy-mm-dd hh:mm:ss");\n   system.out.println("签发时间:"+sf.format(claims.getissuedat()));\n   system.out.println("过期时间:"+sf.format(claims.getexpiration()));\n   system.out.println("当前时间:"+sf.format(new date()));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n测试：当未过期时可以正常读取，当过期时会引发io.jsonwebtoken.expiredjwtexception异常。\n\n\n\n# 自定义claims\n\n我们刚才的例子只是存储了id和subject两个信息，如果你想存储更多的信息（例如角色）可以定义自定义claims\n\n测试用例：\n\n@test\npublic void testcreattokenbyclaims() {\n   //当前系统时间的长整型\n   long now = system.currenttimemillis();\n   //过期时间，这里是1分钟后的时间长整型\n   long exp = now + 60 * 1000;\n   //创建一个jwtbuilder对象\n   jwtbuilder jwtbuilder = jwts.builder()\n         //声明的标识{"jti":"888"}\n         .setid("888")\n         //主体，用户{"sub":"rose"}\n         .setsubject("rose")\n         //创建日期{"ita":"yjxxtxx"}\n         .setissuedat(new date())\n         //签名手段，参数1：算法，参数2：盐\n         .signwith(signaturealgorithm.hs256, "yjxxt")\n         //设置过期时间\n         .setexpiration(new date(exp))\n         //直接传入map\n         // .addclaims(map)\n         .claim("roles","admin")\n         .claim("logo","yjxxt.jpg");\n   //获取jwt的token\n   string token = jwtbuilder.compact();\n   system.out.println(token);\n}\n\n\n@test\npublic void testparsetokenbyclaims() {\n   //token\n   string token = "eyjhbgcioijiuzi1nij9" +\n         ".eyjqdgkioii4odgilcjzdwiioijsb3nliiwiawf0ijoxntc4ode1mdyylcjlehaioje1nzg4mtuxmjisinjvbgvzijoiywrtaw4ilcjsb2dvijoic2hzehquanbnin0.hkog0rsz9_6ii_r8kucp0hlaouuayxajvbz3xtltuh4";\n   //解析token获取负载中的声明对象\n   claims claims = jwts.parser()\n         .setsigningkey("yjxxt")\n         .parseclaimsjws(token)\n         .getbody();\n   //打印声明的属性\n   system.out.println("id:" + claims.getid());\n   system.out.println("subject:" + claims.getsubject());\n   system.out.println("issuedat:" + claims.getissuedat());\n   dateformat sf =new simpledateformat("yyyy-mm-dd hh:mm:ss");\n   system.out.println("签发时间:"+sf.format(claims.getissuedat()));\n   system.out.println("过期时间:"+sf.format(claims.getexpiration()));\n   system.out.println("当前时间:"+sf.format(new date()));\n\n   system.out.println("roles:"+claims.get("roles"));\n   system.out.println("logo:"+claims.get("logo"));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# spring security oauth2 整合jwt\n\n\n# 整合jwt\n\n我们拿之前spring security oauth2的完整代码进行修改\n\n添加配置文件jwttokenstoreconfig.java\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.oauth2.provider.token.tokenstore;\nimport org.springframework.security.oauth2.provider.token.store.jwtaccesstokenconverter;\nimport org.springframework.security.oauth2.provider.token.store.jwttokenstore;\n\n/**\n * 使用jwt存储token的配置\n * @author zhoubin\n * @since 1.0.0\n */\n@configuration\npublic class jwttokenstoreconfig {\n\n   @bean\n   public tokenstore jwttokenstore(){\n      return new jwttokenstore(jwtaccesstokenconverter());\n   }\n\n   @bean\n   public jwtaccesstokenconverter jwtaccesstokenconverter(){\n      jwtaccesstokenconverter accesstokenconverter = new jwtaccesstokenconverter();\n      //配置jwt使用的秘钥\n      accesstokenconverter.setsigningkey("test_key");\n      return accesstokenconverter;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n在认证服务器配置中指定令牌的存储策略为jwt\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport com.yjxxt.springsecurityoauth2demo.service.userservice;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.beans.factory.annotation.qualifier;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.authentication.authenticationmanager;\nimport org.springframework.security.crypto.password.passwordencoder;\nimport org.springframework.security.oauth2.config.annotation.configurers.clientdetailsserviceconfigurer;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.authorizationserverconfigureradapter;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.enableauthorizationserver;\nimport org.springframework.security.oauth2.config.annotation.web.configurers.authorizationserverendpointsconfigurer;\nimport org.springframework.security.oauth2.provider.token.tokenstore;\nimport org.springframework.security.oauth2.provider.token.store.jwtaccesstokenconverter;\n\n/**\n * 授权服务器配置\n * @author zhoubin\n * @since 1.0.0\n */\n@configuration\n@enableauthorizationserver\npublic class authorizationserverconfig extends authorizationserverconfigureradapter {\n\n    @autowired\n    private passwordencoder passwordencoder;\n\n    @autowired\n    private authenticationmanager authenticationmanager;\n\n    @autowired\n    private userservice userservice;\n    \n    @autowired\n    @qualifier("jwttokenstore")\n    private tokenstore tokenstore;\n\n    @autowired\n    private jwtaccesstokenconverter jwtaccesstokenconverter;\n\n\n    /**\n     * 使用密码模式需要配置\n     */\n    @override\n    public void configure(authorizationserverendpointsconfigurer endpoints) {\n        endpoints.authenticationmanager(authenticationmanager)\n                .userdetailsservice(userservice)\n                //配置存储令牌策略\n                .tokenstore(tokenstore)\n                .accesstokenconverter(jwtaccesstokenconverter);\n    }\n\n    @override\n    public void configure(clientdetailsserviceconfigurer clients) throws exception {\n        clients.inmemory()\n                //配置client_id\n                .withclient("admin")\n                //配置client-secret\n                .secret(passwordencoder.encode("112233"))\n                //配置访问token的有效期\n                .accesstokenvalidityseconds(3600)\n                //配置刷新token的有效期\n                .refreshtokenvalidityseconds(864000)\n                //配置redirect_uri，用于授权成功后跳转\n                .redirecturis("http://www.baidu.com")\n                //配置申请的权限范围\n                .scopes("all")\n                //配置grant_type，表示授权类型\n                .authorizedgranttypes("authorization_code","password");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n用密码模式测试：\n\n\n\n发现获取到的令牌已经变成了jwt令牌，将access_token拿到https://jwt.io/ 网站上去解析下可以获得其中内容。\n\n\n\n\n# 扩展jwt中存储的内容\n\n有时候我们需要扩展jwt中存储的内容，这里我们在jwt中扩展一个key为enhance，value为enhance info的数据。\n\n继承tokenenhancer实现一个jwt内容增强器\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.security.oauth2.common.defaultoauth2accesstoken;\nimport org.springframework.security.oauth2.common.oauth2accesstoken;\nimport org.springframework.security.oauth2.provider.oauth2authentication;\nimport org.springframework.security.oauth2.provider.token.tokenenhancer;\n\nimport java.util.hashmap;\nimport java.util.map;\n\n/**\n * jwt内容增强器\n * @author zhoubin\n * @since 1.0.0\n */\npublic class jwttokenenhancer implements tokenenhancer {\n\n   @override\n   public oauth2accesstoken enhance(oauth2accesstoken accesstoken, oauth2authentication authentication) {\n      map<string,object> info = new hashmap<>();\n      info.put("enhance","enhance info");\n      ((defaultoauth2accesstoken)accesstoken).setadditionalinformation(info);\n      return accesstoken;\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n创建一个jwttokenenhancer实例\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.oauth2.provider.token.tokenstore;\nimport org.springframework.security.oauth2.provider.token.store.jwtaccesstokenconverter;\nimport org.springframework.security.oauth2.provider.token.store.jwttokenstore;\n\n/**\n * 使用jwt存储token的配置\n * @author zhoubin\n * @since 1.0.0\n */\n@configuration\npublic class jwttokenstoreconfig {\n\n   @bean\n   public tokenstore jwttokenstore(){\n      return new jwttokenstore(jwtaccesstokenconverter());\n   }\n\n   @bean\n   public jwtaccesstokenconverter jwtaccesstokenconverter(){\n      jwtaccesstokenconverter accesstokenconverter = new jwtaccesstokenconverter();\n      //配置jwt使用的秘钥\n      accesstokenconverter.setsigningkey("test_key");\n      return accesstokenconverter;\n   }\n\n   @bean\n   public jwttokenenhancer jwttokenenhancer() {\n      return new jwttokenenhancer();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n在认证服务器配置中配置jwt的内容增强器\n\npackage com.yjxxt.springsecurityoauth2demo.config;\n\nimport com.yjxxt.springsecurityoauth2demo.component.jwttokenenhancer;\nimport com.yjxxt.springsecurityoauth2demo.service.userservice;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.beans.factory.annotation.qualifier;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.security.authentication.authenticationmanager;\nimport org.springframework.security.crypto.password.passwordencoder;\nimport org.springframework.security.oauth2.config.annotation.configurers.clientdetailsserviceconfigurer;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.authorizationserverconfigureradapter;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.enableauthorizationserver;\nimport org.springframework.security.oauth2.config.annotation.web.configurers.authorizationserverendpointsconfigurer;\nimport org.springframework.security.oauth2.provider.token.tokenenhancer;\nimport org.springframework.security.oauth2.provider.token.tokenenhancerchain;\nimport org.springframework.security.oauth2.provider.token.tokenstore;\nimport org.springframework.security.oauth2.provider.token.store.jwtaccesstokenconverter;\n\nimport java.util.arraylist;\nimport java.util.list;\n\n/**\n * 授权服务器配置\n * @author zhoubin\n * @since 1.0.0\n */\n@configuration\n@enableauthorizationserver\npublic class authorizationserverconfig extends authorizationserverconfigureradapter {\n\n    @autowired\n    private passwordencoder passwordencoder;\n\n    @autowired\n    private authenticationmanager authenticationmanager;\n\n    @autowired\n    private userservice userservice;\n\n    @autowired\n    @qualifier("jwttokenstore")\n    private tokenstore tokenstore;\n    @autowired\n    private jwtaccesstokenconverter jwtaccesstokenconverter;\n    @autowired\n    private jwttokenenhancer jwttokenenhancer;\n\n    /**\n     * 使用密码模式需要配置\n     */\n    @override\n    public void configure(authorizationserverendpointsconfigurer endpoints) {\n        tokenenhancerchain enhancerchain = new tokenenhancerchain();\n        list<tokenenhancer> delegates = new arraylist<>();\n        //配置jwt的内容增强器\n        delegates.add(jwttokenenhancer);\n        delegates.add(jwtaccesstokenconverter);\n        enhancerchain.settokenenhancers(delegates);\n        endpoints.authenticationmanager(authenticationmanager)\n                .userdetailsservice(userservice)\n                //配置存储令牌策略\n                .tokenstore(tokenstore)\n                .accesstokenconverter(jwtaccesstokenconverter)\n                .tokenenhancer(enhancerchain);\n    }\n\n    @override\n    public void configure(clientdetailsserviceconfigurer clients) throws exception {\n        clients.inmemory()\n                //配置client_id\n                .withclient("admin")\n                //配置client-secret\n                .secret(passwordencoder.encode("112233"))\n                //配置访问token的有效期\n                .accesstokenvalidityseconds(3600)\n                //配置刷新token的有效期\n                .refreshtokenvalidityseconds(864000)\n                //配置redirect_uri，用于授权成功后跳转\n                .redirecturis("http://www.baidu.com")\n                //配置申请的权限范围\n                .scopes("all")\n                //配置grant_type，表示授权类型\n                .authorizedgranttypes("authorization_code","password");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n运行项目后使用密码模式来获取令牌，之后对令牌进行解析，发现已经包含扩展的内容。\n\n\n\n\n# java中解析jwt中的内容\n\n添加依赖\n\n\x3c!--jwt 依赖--\x3e\n<dependency>\n   <groupid>io.jsonwebtoken</groupid>\n   <artifactid>jjwt</artifactid>\n   <version>0.9.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n修改usercontroller类，使用jjwt工具类来解析authorization头中存储的jwt内容\n\npackage com.yjxxt.springsecurityoauth2demo.controller;\n\nimport io.jsonwebtoken.jwts;\nimport org.springframework.security.core.authentication;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\nimport javax.servlet.http.httpservletrequest;\nimport java.nio.charset.standardcharsets;\n\n/**\n * @author zhoubin\n * @since 1.0.0\n */\n@restcontroller\n@requestmapping("/user")\npublic class usercontroller {\n\n   @getmapping("/getcurrentuser")\n   public object getcurrentuser(authentication authentication, httpservletrequest request) {\n      string header = request.getheader("authorization");\n      string token = header.substring(header.indexof("bearer") + 7);\n      return jwts.parser()\n            .setsigningkey("test_key".getbytes(standardcharsets.utf_8))\n            .parseclaimsjws(token)\n            .getbody();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n将令牌放入authorization头中，访问如下地址获取信息：\n\nhttp://localhost:8080/user/getcurrentuser\n\n\n\n\n# 刷新令牌\n\n在spring cloud security 中使用oauth2时，如果令牌失效了，可以使用刷新令牌通过refresh_token的授权模式再次获取access_token。\n\n只需修改认证服务器的配置，添加refresh_token的授权模式即可。\n\n@override\npublic void configure(clientdetailsserviceconfigurer clients) throws exception {\n    clients.inmemory()\n            //配置client_id\n            .withclient("admin")\n            //配置client-secret\n            .secret(passwordencoder.encode("112233"))\n            //配置访问token的有效期\n            .accesstokenvalidityseconds(3600)\n            //配置刷新token的有效期\n            .refreshtokenvalidityseconds(86400)\n            //配置redirect_uri，用于授权成功后跳转\n            .redirecturis("http://www.baidu.com")\n            //配置申请的权限范围\n            .scopes("all")\n            //配置grant_type，表示授权类型\n            .authorizedgranttypes("authorization_code","password","refresh_token");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n使用刷新令牌模式来获取新的令牌，访问如下地址：\n\nhttp://localhost:8080/oauth/token\n\n\n\n\n# spring security oauth2 整合单点登录（sso）\n\n\n# 创建客户端\n\n\n\n\n\n\n# 添加依赖\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n   <modelversion>4.0.0</modelversion>\n   <parent>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-parent</artifactid>\n      <version>2.2.2.release</version>\n      <relativepath/> \x3c!-- lookup parent from repository --\x3e\n   </parent>\n  \n   <groupid>com.yjxxt</groupid>\n   <artifactid>oauth2client01demo</artifactid>\n   <version>0.0.1-snapshot</version>\n  \n   <name>oauth2client01demo</name>\n   <description>demo project for spring boot</description>\n\n   <properties>\n      <java.version>1.8</java.version>\n      <spring-cloud.version>greenwich.sr2</spring-cloud.version>\n   </properties>\n\n   <dependencies>\n      <dependency>\n         <groupid>org.springframework.cloud</groupid>\n         <artifactid>spring-cloud-starter-oauth2</artifactid>\n      </dependency>\n      <dependency>\n         <groupid>org.springframework.cloud</groupid>\n         <artifactid>spring-cloud-starter-security</artifactid>\n      </dependency>\n      <dependency>\n         <groupid>org.springframework.boot</groupid>\n         <artifactid>spring-boot-starter-web</artifactid>\n      </dependency>\n      <dependency>\n         <groupid>io.jsonwebtoken</groupid>\n         <artifactid>jjwt</artifactid>\n         <version>0.9.0</version>\n      </dependency>\n\n      <dependency>\n         <groupid>org.springframework.boot</groupid>\n         <artifactid>spring-boot-starter-test</artifactid>\n         <scope>test</scope>\n      </dependency>\n   </dependencies>\n\n   <dependencymanagement>\n      <dependencies>\n         <dependency>\n            <groupid>org.springframework.cloud</groupid>\n            <artifactid>spring-cloud-dependencies</artifactid>\n            <version>${spring-cloud.version}</version>\n            <type>pom</type>\n            <scope>import</scope>\n         </dependency>\n      </dependencies>\n   </dependencymanagement>\n\n   <build>\n      <plugins>\n         <plugin>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-maven-plugin</artifactid>\n         </plugin>\n      </plugins>\n   </build>\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 修改配置文件\n\napplication.properties\n\nserver.port=8081\n#防止cookie冲突，冲突会导致登录验证不通过\nserver.servlet.session.cookie.name=oauth2-client-sessionid01\n#授权服务器地址\noauth2-server-url=http://localhost:8080\n#与授权服务器对应的配置\nsecurity.oauth2.client.client-id=admin\nsecurity.oauth2.client.client-secret=112233\nsecurity.oauth2.client.user-authorization-uri=${oauth2-server-url}/oauth/authorize\nsecurity.oauth2.client.access-token-uri=${oauth2-server-url}/oauth/token\nsecurity.oauth2.resource.jwt.key-uri=${oauth2-server-url}/oauth/token_key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 在启动类上添加@enableoauth2sso注解来启用单点登录功能\n\npackage com.yjxxt.oauth2client01demo;\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.boot.autoconfigure.security.oauth2.client.enableoauth2sso;\n\n@springbootapplication\n@enableoauth2sso\npublic class oauth2client01demoapplication {\n\n   public static void main(string[] args) {\n      springapplication.run(oauth2client01demoapplication.class, args);\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 添加接口用于获取当前登录用户信息\n\npackage com.yjxxt.oauth2client01demo.controller;\n\nimport org.springframework.security.core.authentication;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.bind.annotation.restcontroller;\n\n@restcontroller\n@requestmapping("/user")\npublic class usercontroller {\n    \n    @getmapping("/getcurrentuser")\n    public object getcurrentuser(authentication authentication) {\n        return authentication;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 修改认证服务器配置\n\n修改授权服务器中的authorizationserverconfig类，将绑定的跳转路径为\n\nhttp://localhost:8081/login，并添加获取秘钥时的身份认证\n\n@override\npublic void configure(clientdetailsserviceconfigurer clients) throws exception {\n    clients.inmemory()\n            //配置client_id\n            .withclient("admin")\n            //配置client-secret\n            .secret(passwordencoder.encode("112233"))\n            //配置访问token的有效期\n            .accesstokenvalidityseconds(3600)\n            //配置刷新token的有效期\n            .refreshtokenvalidityseconds(864000)\n            //配置redirect_uri，用于授权成功后跳转\n            // .redirecturis("http://www.baidu.com")\n            //单点登录时配置\n            .redirecturis("http://localhost:8081/login")\n            //配置申请的权限范围\n            .scopes("all")\n            //自动授权配置\n            .autoapprove(true) \n            //配置grant_type，表示授权类型\n            .authorizedgranttypes("authorization_code","password","refresh_token");\n}\n\n@override\npublic void configure(authorizationserversecurityconfigurer security) {\n    // 获取密钥需要身份认证，使用单点登录时必须配置\n    security.tokenkeyaccess("isauthenticated()");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 测试\n\n启动授权服务和客户端服务；\n\n访问客户端需要授权的接口http://localhost:8081/user/getcurrentuser\n\n会跳转到授权服务的登录界面；\n\n\n\n授权后会跳转到原来需要权限的接口地址，展示登录用户信息；\n\n',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"【老徐】该如何设计你的 PasswordEncoder",frontmatter:{title:"【老徐】该如何设计你的 PasswordEncoder",date:"2022-02-03T00:03:27.000Z",permalink:"/pages/9be0a1/",categories:["后端","Spring Security"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/25.Spring%20Security/09.%E3%80%90%E8%80%81%E5%BE%90%E3%80%91%E8%AF%A5%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%BD%A0%E7%9A%84%20PasswordEncoder.html",relativePath:"10.框架/25.Spring Security/09.【老徐】该如何设计你的 PasswordEncoder.md",key:"v-6c08538d",path:"/pages/9be0a1/",headers:[{level:3,title:"缘起",slug:"缘起",normalizedTitle:"缘起",charIndex:117},{level:3,title:"密码存储演进史",slug:"密码存储演进史",normalizedTitle:"密码存储演进史",charIndex:1321},{level:3,title:"慢 hash 算法真的安全吗？",slug:"慢-hash-算法真的安全吗",normalizedTitle:"慢 hash 算法真的安全吗？",charIndex:2910},{level:3,title:"spring security 废弃的接口",slug:"spring-security-废弃的接口",normalizedTitle:"spring security 废弃的接口",charIndex:3795},{level:3,title:"更深层的思考",slug:"更深层的思考",normalizedTitle:"更深层的思考",charIndex:4307},{level:3,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:6669},{level:3,title:"show me the code",slug:"show-me-the-code",normalizedTitle:"show me the code",charIndex:6751}],headersStr:"缘起 密码存储演进史 慢 hash 算法真的安全吗？ spring security 废弃的接口 更深层的思考 参考 show me the code",content:'摘要: 原创出处 https://www.cnkirito.moe/spring-security-6/ 「老徐」欢迎转载，保留摘要，谢谢！\n\n----------------------------------------\n\n\n# 缘起\n\n前端时间将一个集成了 spring-security-oauth2 的旧项目改造了一番，将 springboot 升级成了 springboot 2.0，众所周知 springboot 2.0 依赖的是 spring5，并且许多相关的依赖都发生了较大的改动，与本文相关的改动罗列如下，有兴趣的同学可以看看：Spring Security 5.0 New Features ，增强了 oauth2 集成的功能以及和一个比较有意思的改动—重构了密码编码器的实现（Password Encoding，由于大多数 PasswordEncoder 相关的算法是 hash 算法，所以本文将 PasswordEncoder 翻译成‘密码编码器’和并非‘密码加密器’）官方称之为\n\nModernized Password Encoding — 现代化的密码编码方式 另外，springboot2.0 的自动配置也做了一些调整，其中也有几点和 spring-security 相关，戳这里看所有细节 springboot2.0 迁移指南\n\n一开始，我仅仅修改了依赖，将\n\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.5.4.RELEASE</version>\n</parent>\n\n\n1\n2\n3\n4\n5\n\n\n升级成了\n\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.0.1.RELEASE</version>\n</parent>\n\n\n1\n2\n3\n4\n5\n\n\n不出意料出现了兼容性的问题，我在尝试登录时，出现了如下的报错\n\njava.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id "null"\n\n\n1\n\n\n原因也很明显，正如 spring security 的更新文档中描述的那样，spring security 5 对 PasswordEncoder 做了相关的重构，原先默认配置的 PlainTextPasswordEncoder（明文密码）被移除了。这引起了我的兴趣，spring security 在新版本中对于 passwordEncoder 进行了哪些改造，这些改造背后又是出于什么样的目的呢？卖个关子，先从远古时期的案例来一步步演化出所谓的“现代化密码编码方式”。\n\n\n# 密码存储演进史\n\n自从互联网有了用户的那一刻起，存储用户密码这件事便成为了一个健全的系统不得不面对的一件事。远古时期，明文存储密码可能还不被认为是一个很大的系统缺陷（事实上这是一件很恐怖的事）。提及明文存储密码，我立刻联想到的是 CSDN 社区在 2011 年末发生的 600 万用户密码泄露的事件，谁也不会想到这个和程序员密切相关的网站会犯如此低级的错误。明文存储密码使得恶意用户可以通过 sql 注入等攻击方式来获取用户名和密码，虽然安全框架和良好的编码规范可以规避很多类似的攻击，但依旧避免不了系统管理员，DBA 有途径获取用户密码这一事实。事实上，不用明文存储存储密码，程序员们早在 n 多年前就已经达成了共识。\n\n不能明文存储，一些 hash 算法便被广泛用做密码的编码器，对密码进行单向 hash 处理后存储数据库，当用户登录时，计算用户输入的密码的 hash 值，将两者进行比对。单向 hash 算法，顾名思义，它无法（或者用不能轻易更为合适）被反向解析还原出原密码。这杜绝了管理员直接获取密码的途径，可仅仅依赖于普通的 hash 算法（如 md5，sha256）是不合适的，他主要有 3 个特点：\n\n 1. 同一密码生成的 hash 值一定相同\n 2. 不同密码的生成的 hash 值可能相同（md5 的碰撞问题相比 sha256 还要严重）\n 3. 计算速度快。\n\n以上三点结合在一起，破解此类算法成了不是那么困难的一件事，尤其是第三点，会在下文中再次提到，多快才算非常快？按照相关资料的说法：\n\n> modern hardware perform billions of hash calculations a second.\n\n考虑到大多数用户使用的密码多为数字+字母+特殊符号的组合，攻击者将常用的密码进行枚举，甚至通过排列组合来暴力破解，这被称为 rainbow table。算法爱好者能够立刻看懂到上述的方案，这被亲切地称之为—打表，一种暴力美学，这张表是可以被复用的。\n\n虽然仅仅依赖于传统 hash 算法的思路被否决了，但这种 hash 后比对的思路，几乎被后续所有的优化方案继承。\n\nhash 方案迎来的第一个改造是对引入一个“随机的因子”来掺杂进明文中进行 hash 计算，这样的随机因子通常被称之为盐 （salt）。salt 一般是用户相关的，每个用户持有各自的 salt。此时狗蛋和二丫的密码即使相同，由于 salt 的影响，存储在数据库中的密码也是不同的，除非…为每个用户单独建议一张 rainbow table。很明显 salted hash 相比普通的单向 hash 方案加大了 hacker 攻击的难度。但了解过 GPU 并行计算能力之强大的童鞋，都能够意识到，虽然破解 salted hash 比较麻烦，却并非不可行，勤劳勇敢的安全专家似乎也对这个方案不够满意。\n\n为解决上述 salted hash 仍然存在的问题，一些新型的单向 hash 算法被研究了出来。其中就包括：Bcrypt，PBKDF2，Scrypt，Argon2。为什么这些 hash 算法能保证密码存储的安全性？因为他们足够慢，恰到好处的慢。这么说不严谨，只是为了给大家留个深刻的映像：慢。这类算法有一个特点，存在一个影响因子，可以用来控制计算强度，这直接决定了破解密码所需要的资源和时间，直观的体会可以见下图，在一年内破解如下算法所需要的硬件资源花费（折算成美元）\n\n一年内破解如下算法所需要的硬件资源花费\n\n这使得破解成了一件极其困难的事，并且，其中的计算强度因子是可控的，这样，即使未来量子计算机的计算能力爆表，也可以通过其控制计算强度以防破解。注意，普通的验证过程只需要计算一次 hash 计算，使用此类 hash 算法并不会影响到用户体验。\n\n\n# 慢 hash 算法真的安全吗？\n\nBcrypt，Scrypt，PBKDF2 这些慢 hash 算法是目前最为推崇的 password encoding 方式，好奇心驱使我思考了这样一个问题：慢 hash 算法真的安全吗？\n\n我暂时还没有精力仔细去研究他们中每一个算法的具体实现，只能通过一些文章来拾人牙慧，简单看看这几个算法的原理和安全性。\n\nPBKDF2 被设计的很简单，它的基本原理是通过一个伪随机函数（例如 HMAC 函数），把明文和一个盐值作为输入参数，然后按照设置的计算强度因子重复进行运算，并最终产生密钥。这样的重复 hash 已经被认为足够安全，但也有人提出了不同意见，此类算法对于传统的 CPU 来说的确是足够安全，但 GPU 被搬了出来，前文提到过 GPU 的并行计算能力非常强大。\n\nBcrypt 强大的一点在于，其不仅仅是 CPU 密集型，还是 RAM 密集型！双重的限制因素，导致 GPU，ASIC（专用集成电路）无法应对 Bcrypt 带来的破解困境。\n\n然后…看了 Scrypt 的相关资料之后我才意识到这个坑有多深。一个熟悉又陌生的词出现在了我面前：FPGA（现场可编程逻辑门阵列），这货就比较厉害了。现成的芯片指令结构如传统的 CPU，GPU，ASIC 都无法破解 Bcrypt，但是 FPGA 支持烧录逻辑门（如AND、OR、XOR、NOT），通过编程的方式烧录指令集的这一特性使得可以定制硬件来破解 Bcrypt。尽管我不认为懂这个技术的人会去想办法破解真正的系统，但，只要这是一个可能性，就总有方法会被发明出来与之对抗。Scrypt 比 Bcrypt 额外考虑到的就是大规模的自定义硬件攻击 ，从而刻意设计需要大量内存运算。\n\n理论终归是理论，实际上 Bcrypt 算法被发明至今 18 年，使用范围广，且从未因为安全问题而被修改，其有限性是已经被验证过的，相比之下 Scrypt 据我看到的文章显示是 9 年的历史，没有 Bcrypt 使用的广泛。从破解成本和权威性的角度来看，Bcrypt 用作密码编码器是不错的选择。\n\n\n# spring security 废弃的接口\n\n回到文档中，spring security 5 对 PasswordEncoder 做了相关的重构，原先默认配置的 PlainTextPasswordEncoder（明文密码）被移除了，想要做到明文存储密码，只能使用一个过期的类来过渡\n\n@Bean\nPasswordEncoder passwordEncoder(){\n    return NoOpPasswordEncoder.getInstance();\n}\n\n\n1\n2\n3\n4\n\n\n实际上，spring security 提供了 BCryptPasswordEncoder 来进行密码编码，并作为了相关配置的默认配置，只不过没有暴露为全局的 Bean。使用明文存储的风险在文章一开始就已经强调过，NoOpPasswordEncoder 只能存在于 demo 中。\n\n@Bean\nPasswordEncoder passwordEncoder(){\n    return new BCryptPasswordEncoder();\n}\n\n\n1\n2\n3\n4\n\n\n别忘了对你数据库中的密码进行同样的编码，否则无法对应。\n\n\n# 更深层的思考\n\n实际上，spring security 5 的另一个设计是促使我写成本文的初衷。\n\n不知道有没有读者产生跟我相同的困扰：\n\n 1. 如果我要设计一个 QPS 很高的登录系统，使用 spring security 推荐的 BCrypt 会不会存在性能问题？\n 2. spring security 怎么这么坑，原来的密码编码器都给改了，我需要怎么迁移旧密码编码的应用程序？\n 3. 万一以后出了更高效的加密算法，这种笨重的硬编码方式配置密码编码器是不是不够灵活？\n\n在 spring security 5 提供了这样一个思路，应该将密码编码之后的 hash 值和加密方式一起存储，并提供了一个 DelegatingPasswordEncoder 来作为众多密码密码编码方式的集合。\n\n@Bean\nPasswordEncoder passwordEncoder(){\n    return PasswordEncoderFactories.createDelegatingPasswordEncoder();\n}\n\n\n1\n2\n3\n4\n\n\n负责生产 DelegatingPasswordEncoder 的工厂方法：\n\npublic class PasswordEncoderFactories {\n\n   public static PasswordEncoder createDelegatingPasswordEncoder() {\n      String encodingId = "bcrypt";\n      Map<String, PasswordEncoder> encoders = new HashMap<>();\n      encoders.put(encodingId, new BCryptPasswordEncoder());\n      encoders.put("ldap", new LdapShaPasswordEncoder());\n      encoders.put("MD4", new Md4PasswordEncoder());\n      encoders.put("MD5", new MessageDigestPasswordEncoder("MD5"));\n      encoders.put("noop", NoOpPasswordEncoder.getInstance());\n      encoders.put("pbkdf2", new Pbkdf2PasswordEncoder());\n      encoders.put("scrypt", new SCryptPasswordEncoder());\n      encoders.put("SHA-1", new MessageDigestPasswordEncoder("SHA-1"));\n      encoders.put("SHA-256", new MessageDigestPasswordEncoder("SHA-256"));\n      encoders.put("sha256", new StandardPasswordEncoder());\n\n      return new DelegatingPasswordEncoder(encodingId, encoders);\n   }\n\n   private PasswordEncoderFactories() {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n如此注入 PasswordEncoder 之后，我们在数据库中需要这么存储数据：\n\n{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG\n{noop}password\n{pbkdf2}5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc\n{scrypt}$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc=\n{sha256}97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0\n\n\n1\n2\n3\n4\n5\n\n\n还记得文章开始的报错吗？\n\njava.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id "null"\n\n\n1\n\n\n这个 id 就是因为我们没有为数据库中的密码添加 {bcrypt} 此类的前缀导致的。\n\n> 你会不会担心密码泄露后，{bcrypt}，{pbkdf2}，{scrypt}，{sha256} 此类前缀会直接暴露密码的编码方式？其实这个考虑是多余的，因为密码存储的依赖算法并不是一个秘密。大多数能搞到你密码的 hacker 都可以轻松的知道你用的是什么算法，例如，bcrypt 算法通常以 $2a$ 开头\n\n稍微思考下，前面的三个疑问就可以迎刃而解，这就是文档中所谓的：能够自适应服务器性能的现代化密码编码方案。\n\n\n# 参考\n\nPassword Hashing: PBKDF2, Scrypt, Bcrypt\n\ncore-services-password-encoding\n\n\n# show me the code\n\nspring security oauth2 的 github 代码示例，体会下 spring security 4 -> spring security 5 的相关变化。\n\nhttps://github.com/lexburner/oauth2-demo',normalizedContent:'摘要: 原创出处 https://www.cnkirito.moe/spring-security-6/ 「老徐」欢迎转载，保留摘要，谢谢！\n\n----------------------------------------\n\n\n# 缘起\n\n前端时间将一个集成了 spring-security-oauth2 的旧项目改造了一番，将 springboot 升级成了 springboot 2.0，众所周知 springboot 2.0 依赖的是 spring5，并且许多相关的依赖都发生了较大的改动，与本文相关的改动罗列如下，有兴趣的同学可以看看：spring security 5.0 new features ，增强了 oauth2 集成的功能以及和一个比较有意思的改动—重构了密码编码器的实现（password encoding，由于大多数 passwordencoder 相关的算法是 hash 算法，所以本文将 passwordencoder 翻译成‘密码编码器’和并非‘密码加密器’）官方称之为\n\nmodernized password encoding — 现代化的密码编码方式 另外，springboot2.0 的自动配置也做了一些调整，其中也有几点和 spring-security 相关，戳这里看所有细节 springboot2.0 迁移指南\n\n一开始，我仅仅修改了依赖，将\n\n<parent>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-parent</artifactid>\n    <version>1.5.4.release</version>\n</parent>\n\n\n1\n2\n3\n4\n5\n\n\n升级成了\n\n<parent>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-parent</artifactid>\n    <version>2.0.1.release</version>\n</parent>\n\n\n1\n2\n3\n4\n5\n\n\n不出意料出现了兼容性的问题，我在尝试登录时，出现了如下的报错\n\njava.lang.illegalargumentexception: there is no passwordencoder mapped for the id "null"\n\n\n1\n\n\n原因也很明显，正如 spring security 的更新文档中描述的那样，spring security 5 对 passwordencoder 做了相关的重构，原先默认配置的 plaintextpasswordencoder（明文密码）被移除了。这引起了我的兴趣，spring security 在新版本中对于 passwordencoder 进行了哪些改造，这些改造背后又是出于什么样的目的呢？卖个关子，先从远古时期的案例来一步步演化出所谓的“现代化密码编码方式”。\n\n\n# 密码存储演进史\n\n自从互联网有了用户的那一刻起，存储用户密码这件事便成为了一个健全的系统不得不面对的一件事。远古时期，明文存储密码可能还不被认为是一个很大的系统缺陷（事实上这是一件很恐怖的事）。提及明文存储密码，我立刻联想到的是 csdn 社区在 2011 年末发生的 600 万用户密码泄露的事件，谁也不会想到这个和程序员密切相关的网站会犯如此低级的错误。明文存储密码使得恶意用户可以通过 sql 注入等攻击方式来获取用户名和密码，虽然安全框架和良好的编码规范可以规避很多类似的攻击，但依旧避免不了系统管理员，dba 有途径获取用户密码这一事实。事实上，不用明文存储存储密码，程序员们早在 n 多年前就已经达成了共识。\n\n不能明文存储，一些 hash 算法便被广泛用做密码的编码器，对密码进行单向 hash 处理后存储数据库，当用户登录时，计算用户输入的密码的 hash 值，将两者进行比对。单向 hash 算法，顾名思义，它无法（或者用不能轻易更为合适）被反向解析还原出原密码。这杜绝了管理员直接获取密码的途径，可仅仅依赖于普通的 hash 算法（如 md5，sha256）是不合适的，他主要有 3 个特点：\n\n 1. 同一密码生成的 hash 值一定相同\n 2. 不同密码的生成的 hash 值可能相同（md5 的碰撞问题相比 sha256 还要严重）\n 3. 计算速度快。\n\n以上三点结合在一起，破解此类算法成了不是那么困难的一件事，尤其是第三点，会在下文中再次提到，多快才算非常快？按照相关资料的说法：\n\n> modern hardware perform billions of hash calculations a second.\n\n考虑到大多数用户使用的密码多为数字+字母+特殊符号的组合，攻击者将常用的密码进行枚举，甚至通过排列组合来暴力破解，这被称为 rainbow table。算法爱好者能够立刻看懂到上述的方案，这被亲切地称之为—打表，一种暴力美学，这张表是可以被复用的。\n\n虽然仅仅依赖于传统 hash 算法的思路被否决了，但这种 hash 后比对的思路，几乎被后续所有的优化方案继承。\n\nhash 方案迎来的第一个改造是对引入一个“随机的因子”来掺杂进明文中进行 hash 计算，这样的随机因子通常被称之为盐 （salt）。salt 一般是用户相关的，每个用户持有各自的 salt。此时狗蛋和二丫的密码即使相同，由于 salt 的影响，存储在数据库中的密码也是不同的，除非…为每个用户单独建议一张 rainbow table。很明显 salted hash 相比普通的单向 hash 方案加大了 hacker 攻击的难度。但了解过 gpu 并行计算能力之强大的童鞋，都能够意识到，虽然破解 salted hash 比较麻烦，却并非不可行，勤劳勇敢的安全专家似乎也对这个方案不够满意。\n\n为解决上述 salted hash 仍然存在的问题，一些新型的单向 hash 算法被研究了出来。其中就包括：bcrypt，pbkdf2，scrypt，argon2。为什么这些 hash 算法能保证密码存储的安全性？因为他们足够慢，恰到好处的慢。这么说不严谨，只是为了给大家留个深刻的映像：慢。这类算法有一个特点，存在一个影响因子，可以用来控制计算强度，这直接决定了破解密码所需要的资源和时间，直观的体会可以见下图，在一年内破解如下算法所需要的硬件资源花费（折算成美元）\n\n一年内破解如下算法所需要的硬件资源花费\n\n这使得破解成了一件极其困难的事，并且，其中的计算强度因子是可控的，这样，即使未来量子计算机的计算能力爆表，也可以通过其控制计算强度以防破解。注意，普通的验证过程只需要计算一次 hash 计算，使用此类 hash 算法并不会影响到用户体验。\n\n\n# 慢 hash 算法真的安全吗？\n\nbcrypt，scrypt，pbkdf2 这些慢 hash 算法是目前最为推崇的 password encoding 方式，好奇心驱使我思考了这样一个问题：慢 hash 算法真的安全吗？\n\n我暂时还没有精力仔细去研究他们中每一个算法的具体实现，只能通过一些文章来拾人牙慧，简单看看这几个算法的原理和安全性。\n\npbkdf2 被设计的很简单，它的基本原理是通过一个伪随机函数（例如 hmac 函数），把明文和一个盐值作为输入参数，然后按照设置的计算强度因子重复进行运算，并最终产生密钥。这样的重复 hash 已经被认为足够安全，但也有人提出了不同意见，此类算法对于传统的 cpu 来说的确是足够安全，但 gpu 被搬了出来，前文提到过 gpu 的并行计算能力非常强大。\n\nbcrypt 强大的一点在于，其不仅仅是 cpu 密集型，还是 ram 密集型！双重的限制因素，导致 gpu，asic（专用集成电路）无法应对 bcrypt 带来的破解困境。\n\n然后…看了 scrypt 的相关资料之后我才意识到这个坑有多深。一个熟悉又陌生的词出现在了我面前：fpga（现场可编程逻辑门阵列），这货就比较厉害了。现成的芯片指令结构如传统的 cpu，gpu，asic 都无法破解 bcrypt，但是 fpga 支持烧录逻辑门（如and、or、xor、not），通过编程的方式烧录指令集的这一特性使得可以定制硬件来破解 bcrypt。尽管我不认为懂这个技术的人会去想办法破解真正的系统，但，只要这是一个可能性，就总有方法会被发明出来与之对抗。scrypt 比 bcrypt 额外考虑到的就是大规模的自定义硬件攻击 ，从而刻意设计需要大量内存运算。\n\n理论终归是理论，实际上 bcrypt 算法被发明至今 18 年，使用范围广，且从未因为安全问题而被修改，其有限性是已经被验证过的，相比之下 scrypt 据我看到的文章显示是 9 年的历史，没有 bcrypt 使用的广泛。从破解成本和权威性的角度来看，bcrypt 用作密码编码器是不错的选择。\n\n\n# spring security 废弃的接口\n\n回到文档中，spring security 5 对 passwordencoder 做了相关的重构，原先默认配置的 plaintextpasswordencoder（明文密码）被移除了，想要做到明文存储密码，只能使用一个过期的类来过渡\n\n@bean\npasswordencoder passwordencoder(){\n    return nooppasswordencoder.getinstance();\n}\n\n\n1\n2\n3\n4\n\n\n实际上，spring security 提供了 bcryptpasswordencoder 来进行密码编码，并作为了相关配置的默认配置，只不过没有暴露为全局的 bean。使用明文存储的风险在文章一开始就已经强调过，nooppasswordencoder 只能存在于 demo 中。\n\n@bean\npasswordencoder passwordencoder(){\n    return new bcryptpasswordencoder();\n}\n\n\n1\n2\n3\n4\n\n\n别忘了对你数据库中的密码进行同样的编码，否则无法对应。\n\n\n# 更深层的思考\n\n实际上，spring security 5 的另一个设计是促使我写成本文的初衷。\n\n不知道有没有读者产生跟我相同的困扰：\n\n 1. 如果我要设计一个 qps 很高的登录系统，使用 spring security 推荐的 bcrypt 会不会存在性能问题？\n 2. spring security 怎么这么坑，原来的密码编码器都给改了，我需要怎么迁移旧密码编码的应用程序？\n 3. 万一以后出了更高效的加密算法，这种笨重的硬编码方式配置密码编码器是不是不够灵活？\n\n在 spring security 5 提供了这样一个思路，应该将密码编码之后的 hash 值和加密方式一起存储，并提供了一个 delegatingpasswordencoder 来作为众多密码密码编码方式的集合。\n\n@bean\npasswordencoder passwordencoder(){\n    return passwordencoderfactories.createdelegatingpasswordencoder();\n}\n\n\n1\n2\n3\n4\n\n\n负责生产 delegatingpasswordencoder 的工厂方法：\n\npublic class passwordencoderfactories {\n\n   public static passwordencoder createdelegatingpasswordencoder() {\n      string encodingid = "bcrypt";\n      map<string, passwordencoder> encoders = new hashmap<>();\n      encoders.put(encodingid, new bcryptpasswordencoder());\n      encoders.put("ldap", new ldapshapasswordencoder());\n      encoders.put("md4", new md4passwordencoder());\n      encoders.put("md5", new messagedigestpasswordencoder("md5"));\n      encoders.put("noop", nooppasswordencoder.getinstance());\n      encoders.put("pbkdf2", new pbkdf2passwordencoder());\n      encoders.put("scrypt", new scryptpasswordencoder());\n      encoders.put("sha-1", new messagedigestpasswordencoder("sha-1"));\n      encoders.put("sha-256", new messagedigestpasswordencoder("sha-256"));\n      encoders.put("sha256", new standardpasswordencoder());\n\n      return new delegatingpasswordencoder(encodingid, encoders);\n   }\n\n   private passwordencoderfactories() {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n如此注入 passwordencoder 之后，我们在数据库中需要这么存储数据：\n\n{bcrypt}$2a$10$dxj3sw6g7p50lgmmkkmwe.20cqqubk3.hzwzg3yb1tlry.fqvm/bg\n{noop}password\n{pbkdf2}5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc\n{scrypt}$e0801$8bwjasu2iksn9z9km+tpxfoc/9bdysrn1od9qfvthwewdrtno7re7ei+fuzrj68k9ltyuteup4of4g24hhnazw==$oaoec05+bxxvuu/1qz6nur+xqyvyv7bel1qxwrpy5pc=\n{sha256}97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0\n\n\n1\n2\n3\n4\n5\n\n\n还记得文章开始的报错吗？\n\njava.lang.illegalargumentexception: there is no passwordencoder mapped for the id "null"\n\n\n1\n\n\n这个 id 就是因为我们没有为数据库中的密码添加 {bcrypt} 此类的前缀导致的。\n\n> 你会不会担心密码泄露后，{bcrypt}，{pbkdf2}，{scrypt}，{sha256} 此类前缀会直接暴露密码的编码方式？其实这个考虑是多余的，因为密码存储的依赖算法并不是一个秘密。大多数能搞到你密码的 hacker 都可以轻松的知道你用的是什么算法，例如，bcrypt 算法通常以 $2a$ 开头\n\n稍微思考下，前面的三个疑问就可以迎刃而解，这就是文档中所谓的：能够自适应服务器性能的现代化密码编码方案。\n\n\n# 参考\n\npassword hashing: pbkdf2, scrypt, bcrypt\n\ncore-services-password-encoding\n\n\n# show me the code\n\nspring security oauth2 的 github 代码示例，体会下 spring security 4 -> spring security 5 的相关变化。\n\nhttps://github.com/lexburner/oauth2-demo',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/d07b16/"},regularPath:"/10.%E6%A1%86%E6%9E%B6/30.Mybatis/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"10.框架/30.Mybatis/10.Redis高级客户端Lettuce详解.md",key:"v-4c61c5bc",path:"/pages/d07b16/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/d35a9e/"},regularPath:"/10.%E6%A1%86%E6%9E%B6/35.Mybatis%20Plus/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"10.框架/35.Mybatis Plus/10.Redis高级客户端Lettuce详解.md",key:"v-3f5b59cf",path:"/pages/d35a9e/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/b8166d/"},regularPath:"/10.%E6%A1%86%E6%9E%B6/40.Redis/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"10.框架/40.Redis/10.Redis高级客户端Lettuce详解.md",key:"v-a5a12a48",path:"/pages/b8166d/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"EXISTS（NOT EXISTS ） 语句",frontmatter:{title:"EXISTS（NOT EXISTS ） 语句",date:"2022-02-03T22:57:00.000Z",permalink:"/pages/ee8f7b/",categories:["框架","Mysql","SQL"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/45.Mysql/05.SQL/05.EXISTS%EF%BC%88NOT%20EXISTS%20%EF%BC%89%20%E8%AF%AD%E5%8F%A5.html",relativePath:"10.框架/45.Mysql/05.SQL/05.EXISTS（NOT EXISTS ） 语句.md",key:"v-58f14e65",path:"/pages/ee8f7b/",headersStr:null,content:"EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False\n\nEXISTS 指定一个子查询，检测 行 的存在。\n\nEXISTS(包括 NOT EXISTS )子句的返回值是一个BOOL值。 EXISTS内部有一个子查询语句(SELECT ... FROM...)， 我将其称为EXIST的内查询语句。其内查询语句返回一个结果集。 EXISTS子句根据其内查询语句的结果集空或者非空，返回一个布尔值。\n\n一种通俗的可以理解为：将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果取非空值，则EXISTS子句返回TRUE，这一行行可作为外查询的结果行，否则不能作为结果。\n\nhttps://www.cnblogs.com/xuanhai/p/5810918.html\n\n\n\n\n\n\n\n\n\n",normalizedContent:"exists用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值true或false\n\nexists 指定一个子查询，检测 行 的存在。\n\nexists(包括 not exists )子句的返回值是一个bool值。 exists内部有一个子查询语句(select ... from...)， 我将其称为exist的内查询语句。其内查询语句返回一个结果集。 exists子句根据其内查询语句的结果集空或者非空，返回一个布尔值。\n\n一种通俗的可以理解为：将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果取非空值，则exists子句返回true，这一行行可作为外查询的结果行，否则不能作为结果。\n\nhttps://www.cnblogs.com/xuanhai/p/5810918.html\n\n\n\n\n\n\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"实例详解ZooKeeper ZAB协议、分布式锁与领导选举",frontmatter:{title:"实例详解ZooKeeper ZAB协议、分布式锁与领导选举",date:"2022-02-03T00:03:41.000Z",permalink:"/pages/bc1a45/",categories:["后端","Zookeeper"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/50.Zookeeper/10.%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3ZooKeeper%20ZAB%E5%8D%8F%E8%AE%AE%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B8%8E%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE.html",relativePath:"10.框架/50.Zookeeper/10.实例详解ZooKeeper ZAB协议、分布式锁与领导选举.md",key:"v-35bfa9e0",path:"/pages/bc1a45/",headers:[{level:2,title:"ZooKeeper是什么",slug:"zookeeper是什么",normalizedTitle:"zookeeper是什么",charIndex:254},{level:2,title:"ZooKeeper服务器角色",slug:"zookeeper服务器角色",normalizedTitle:"zookeeper服务器角色",charIndex:516},{level:2,title:"原子广播（ZAB）",slug:"原子广播-zab",normalizedTitle:"原子广播（zab）",charIndex:857},{level:3,title:"1、写Leader",slug:"_1、写leader",normalizedTitle:"1、写leader",charIndex:1136},{level:3,title:"2、写Follower/Observer",slug:"_2、写follower-observer",normalizedTitle:"2、写follower/observer",charIndex:1612},{level:3,title:"3、读操作",slug:"_3、读操作",normalizedTitle:"3、读操作",charIndex:1771},{level:2,title:"支持的领导选举算法",slug:"支持的领导选举算法",normalizedTitle:"支持的领导选举算法",charIndex:1901},{level:2,title:"FastLeaderElection原理",slug:"fastleaderelection原理",normalizedTitle:"fastleaderelection原理",charIndex:2177},{level:3,title:"1、myid",slug:"_1、myid",normalizedTitle:"1、myid",charIndex:2202},{level:3,title:"2、zxid",slug:"_2、zxid",normalizedTitle:"2、zxid",charIndex:2490},{level:3,title:"3、服务器状态",slug:"_3、服务器状态",normalizedTitle:"3、服务器状态",charIndex:2683},{level:3,title:"4、选票数据结构",slug:"_4、选票数据结构",normalizedTitle:"4、选票数据结构",charIndex:2936},{level:3,title:"5、投票流程",slug:"_5、投票流程",normalizedTitle:"5、投票流程",charIndex:3170},{level:2,title:"集群启动领导选举",slug:"集群启动领导选举",normalizedTitle:"集群启动领导选举",charIndex:4441},{level:3,title:"1、初始投票给自己",slug:"_1、初始投票给自己",normalizedTitle:"1、初始投票给自己",charIndex:4454},{level:3,title:"2、更新选票",slug:"_2、更新选票",normalizedTitle:"2、更新选票",charIndex:4701},{level:3,title:"3、根据选票确定角色",slug:"_3、根据选票确定角色",normalizedTitle:"3、根据选票确定角色",charIndex:5133},{level:2,title:"Follower重启选举",slug:"follower重启选举",normalizedTitle:"follower重启选举",charIndex:5249},{level:3,title:"1、Follower重启投票给自己",slug:"_1、follower重启投票给自己",normalizedTitle:"1、follower重启投票给自己",charIndex:5266},{level:3,title:"2、发现已有Leader后成为Follower",slug:"_2、发现已有leader后成为follower",normalizedTitle:"2、发现已有leader后成为follower",charIndex:5342},{level:2,title:"Leader重启选举",slug:"leader重启选举",normalizedTitle:"leader重启选举",charIndex:5530},{level:3,title:"1、Follower发起新投票",slug:"_1、follower发起新投票",normalizedTitle:"1、follower发起新投票",charIndex:5545},{level:3,title:"2、广播更新选票",slug:"_2、广播更新选票",normalizedTitle:"2、广播更新选票",charIndex:5645},{level:3,title:"3、选出新Leader",slug:"_3、选出新leader",normalizedTitle:"3、选出新leader",charIndex:5955},{level:3,title:"4、旧Leader恢复后发起选举",slug:"_4、旧leader恢复后发起选举",normalizedTitle:"4、旧leader恢复后发起选举",charIndex:6048},{level:3,title:"5、旧Leader成为Follower",slug:"_5、旧leader成为follower",normalizedTitle:"5、旧leader成为follower",charIndex:6202},{level:2,title:"Commit过的数据不丢失",slug:"commit过的数据不丢失",normalizedTitle:"commit过的数据不丢失",charIndex:6290},{level:3,title:"1、Failover前状态",slug:"_1、failover前状态",normalizedTitle:"1、failover前状态",charIndex:6308},{level:3,title:"2、选出新Leader",slug:"_2、选出新leader",normalizedTitle:"2、选出新leader",charIndex:6690},{level:3,title:"3、通知Follower可对外服务",slug:"_3、通知follower可对外服务",normalizedTitle:"3、通知follower可对外服务",charIndex:6989},{level:2,title:"未Commit过的消息对客户端不可见",slug:"未commit过的消息对客户端不可见",normalizedTitle:"未commit过的消息对客户端不可见",charIndex:7125},{level:2,title:"本节总结",slug:"本节总结",normalizedTitle:"本节总结",charIndex:7880},{level:2,title:"基于ZooKeeper的分布式锁与领导选举",slug:"基于zookeeper的分布式锁与领导选举",normalizedTitle:"基于zookeeper的分布式锁与领导选举",charIndex:8095},{level:3,title:"ZooKeeper节点类型",slug:"zookeeper节点类型",normalizedTitle:"zookeeper节点类型",charIndex:8166},{level:3,title:"ZooKeeper语义保证",slug:"zookeeper语义保证",normalizedTitle:"zookeeper语义保证",charIndex:8639},{level:3,title:"ZooKeeper Watch机制",slug:"zookeeper-watch机制",normalizedTitle:"zookeeper watch机制",charIndex:9065},{level:3,title:"分布式锁与领导选举关键点",slug:"分布式锁与领导选举关键点",normalizedTitle:"分布式锁与领导选举关键点",charIndex:9433},{level:3,title:"非公平领导选举",slug:"非公平领导选举",normalizedTitle:"非公平领导选举",charIndex:9942},{level:3,title:"公平领导选举",slug:"公平领导选举",normalizedTitle:"公平领导选举",charIndex:9943},{level:3,title:"重新选举",slug:"重新选举",normalizedTitle:"重新选举",charIndex:10616}],headersStr:"ZooKeeper是什么 ZooKeeper服务器角色 原子广播（ZAB） 1、写Leader 2、写Follower/Observer 3、读操作 支持的领导选举算法 FastLeaderElection原理 1、myid 2、zxid 3、服务器状态 4、选票数据结构 5、投票流程 集群启动领导选举 1、初始投票给自己 2、更新选票 3、根据选票确定角色 Follower重启选举 1、Follower重启投票给自己 2、发现已有Leader后成为Follower Leader重启选举 1、Follower发起新投票 2、广播更新选票 3、选出新Leader 4、旧Leader恢复后发起选举 5、旧Leader成为Follower Commit过的数据不丢失 1、Failover前状态 2、选出新Leader 3、通知Follower可对外服务 未Commit过的消息对客户端不可见 本节总结 基于ZooKeeper的分布式锁与领导选举 ZooKeeper节点类型 ZooKeeper语义保证 ZooKeeper Watch机制 分布式锁与领导选举关键点 非公平领导选举 公平领导选举 重新选举",content:"作者介绍\n\n**郭俊，**专注于大数据架构，熟悉Kafka和Flume源码；熟悉Hadoop和Spark原理；精通数据（仓）库模型设计和SQL调优。公众号：大数据架构，博客：http://www.jasongj.com/，\n\n本文经作者授权转载，禁止二次转载。\n\n本节将介绍ZooKeeper的架构，并结合实例分析原子广播(ZAB)协议的原理，包括但不限于ZooKeeper的读写流程，FastLeaderElection算法的原理，ZAB如何保证Leader Failover过程中的数据一致性。\n\n\n# ZooKeeper是什么\n\nZooKeeper是一个分布式协调服务，可用于服务发现、分布式锁、分布式领导选举、配置管理等。\n\n这一切的基础，都是ZooKeeper提供了一个类似于Linux文件系统的树形结构（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与通知机制。\n\n既然是一个文件系统，就不得不提ZooKeeper是如何保证数据的一致性的。本节将将介绍ZooKeeper如何保证数据一致性，如何进行领导选举，以及数据监控/通知机制的语义保证。\n\n\n# ZooKeeper服务器角色\n\nZooKeeper集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种：\n\n * Leader 一个ZooKeeper集群同一时间只会有一个实际工作的Leader，它会发起并维护与各Follwer及Observer间的心跳。所有的写操作必须要通过Leader完成再由Leader将写操作广播给其它服务器。\n * Follower 一个ZooKeeper集群可能同时存在多个Follower，它会响应Leader的心跳。Follower可直接处理并返回客户端的读请求，同时会将写请求转发给Leader处理，并且负责在Leader处理写请求时对请求进行投票。\n * Observer 角色与Follower类似，但是无投票权。\n\n\n# 原子广播（ZAB）\n\n为了保证写操作的一致性与可用性，ZooKeeper专门设计了一种名为原子广播（ZAB）的支持崩溃恢复的一致性协议。基于该协议，ZooKeeper实现了一种主从模式的系统架构来保持集群中各个副本之间的数据一致性。\n\n根据ZAB协议，所有的写操作都必须通过Leader完成，Leader写入本地日志后再复制到所有的Follower节点。\n\n一旦Leader节点无法工作，ZAB协议能够自动从Follower节点中重新选出一个合适的替代者，即新的Leader，该过程即为领导选举。该领导选举过程，是ZAB协议中最为重要和复杂的过程。\n\n\n# 1、写Leader\n\n通过Leader进行写操作流程如下图所示：\n\n由上图可见，通过Leader进行写操作，主要分为五步：\n\n 1. 客户端向Leader发起写请求\n 2. Leader将写请求以Proposal的形式发给所有Follower并等待ACK\n 3. Follower收到Leader的Proposal后返回ACK\n 4. Leader得到过半数的ACK（Leader对自己默认有一个ACK）后向所有的Follower和Observer发送Commit\n 5. Leader将处理结果返回给客户端\n\n这里要注意：\n\n * Leader并不需要得到Observer的ACK，即Observer无投票权\n * Leader不需要得到所有Follower的ACK，只要收到过半的ACK即可，同时Leader本身对自己有一个ACK。上图中有4个Follower，只需其中两个返回ACK即可，因为(2+1) / (4+1) > 1/2\n * Observer虽然无投票权，但仍须同步Leader的数据从而在处理读请求时可以返回尽可能新的数据\n\n\n# 2、写Follower/Observer\n\n通过Follower/Observer进行写操作流程如下图所示：\n\n\n\n从上图可见：\n\n * Follower/Observer均可接受写请求，但不能直接处理，而需要将写请求转发给Leader处理\n * 除了多了一步请求转发，其它流程与直接写Leader无任何区别\n\n\n# 3、读操作\n\nLeader/Follower/Observer都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。\n\n\n\n由于处理读请求不需要服务器之间的交互，Follower/Observer越多，整体可处理的读请求量越大，也即读性能越好。\n\n\n# 支持的领导选举算法\n\n可通过electionAlg配置项设置ZooKeeper用于领导选举的算法。\n\n到3.4.10版本为止，可选项有：\n\n * 0 基于UDP的LeaderElection\n * 1 基于UDP的FastLeaderElection\n * 2 基于UDP和认证的FastLeaderElection\n * 3 基于TCP的FastLeaderElection\n\n在3.4.10版本中，默认值为3，也即基于TCP的FastLeaderElection。另外三种算法已经被弃用，并且有计划在之后的版本中将它们彻底删除而不再支持。\n\n\n# FastLeaderElection原理\n\n\n# 1、myid\n\n每个ZooKeeper服务器，都需要在数据文件夹下创建一个名为myid的文件，该文件包含整个ZooKeeper集群唯一的ID（整数）。例如，某ZooKeeper集群包含三台服务器，hostname分别为zoo1、zoo2和zoo3，其myid分别为1、2和3，则在配置文件中其ID与hostname必须一一对应，如下所示。在该配置文件中，server.后面的数据即为myid\n\nserver.1=zoo1:2888:3888\n\nserver.2=zoo2:2888:3888\n\nserver.3=zoo3:2888:3888\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2、zxid\n\n类似于RDBMS中的事务ID，用于标识一次更新操作的Proposal ID。为了保证顺序性，该zkid必须单调递增。因此ZooKeeper使用一个64位的数来表示，高32位是Leader的epoch，从1开始，每次选出新的Leader，epoch加一。低32位为该epoch内的序号，每次epoch变化，都将低32位的序号重置。这样保证了zkid的全局递增性。\n\n\n# 3、服务器状态\n\n * LOOKING 不确定Leader状态。该状态下的服务器认为当前集群中没有Leader，会发起Leader选举。\n * FOLLOWING 跟随者状态。表明当前服务器角色是Follower，并且它知道Leader是谁。\n * LEADING 领导者状态。表明当前服务器角色是Leader，它会维护与Follower间的心跳。\n * OBSERVING 观察者状态。表明当前服务器角色是Observer，与Folower唯一的不同在于不参与选举，也不参与集群写操作时的投票。\n\n\n# 4、选票数据结构\n\n每个服务器在进行领导选举时，会发送如下关键信息：\n\n * logicClock 每个服务器会维护一个自增的整数，名为logicClock，它表示这是该服务器发起的第多少轮投票\n * state 当前服务器的状态\n * self_id 当前服务器的myid\n * self_zxid 当前服务器上所保存的数据的最大zxid\n * vote_id 被推举的服务器的myid\n * vote_zxid 被推举的服务器上所保存的数据的最大zxid\n\n\n# 5、投票流程\n\n自增选举轮次\n\nZooKeeper规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的logicClock进行自增操作。\n\n初始化选票\n\n每个服务器在广播自己的选票前，会将自己的投票箱清空。该投票箱记录了所收到的选票。例：服务器2投票给服务器3，服务器3投票给服务器1，则服务器1的投票箱为(2, 3), (3, 1), (1, 1)。票箱中只会记录每一投票者的最后一票，如投票者更新自己的选票，则其它服务器收到该新选票后会在自己票箱中更新该服务器的选票。\n\n发送初始化选票\n\n每个服务器最开始都是通过广播把票投给自己。\n\n接收外部投票\n\n服务器会尝试从其它服务器获取投票，并记入自己的投票箱内。如果无法获取任何外部投票，则会确认自己是否与集群中其它服务器保持着有效连接。如果是，则再次发送自己的投票；如果否，则马上与之建立连接。\n\n判断选举轮次\n\n收到外部投票后，首先会根据投票信息中所包含的logicClock来进行不同处理：\n\n * 外部投票的logicClock大于自己的logicClock。说明该服务器的选举轮次落后于其它服务器的选举轮次，立即清空自己的投票箱并将自己的logicClock更新为收到的logicClock，然后再对比自己之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去。\n * 外部投票的logicClock小于自己的logicClock。当前服务器直接忽略该投票，继续处理下一个投票。\n * 外部投票的logickClock与自己的相等。当时进行选票PK。\n\n选票PK\n\n选票PK是基于(self_id, self_zxid)与(vote_id, vote_zxid)的对比：\n\n * 外部投票的logicClock大于自己的logicClock，则将自己的logicClock及自己的选票的logicClock变更为收到的logicClock\n * 若logicClock一致，则对比二者的vote_zxid，若外部投票的vote_zxid比较大，则将自己的票中的vote_zxid与vote_myid更新为收到的票中的vote_zxid与vote_myid并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在(self_myid, self_zxid)相同的选票，则直接覆盖\n * 若二者vote_zxid一致，则比较二者的vote_myid，若外部投票的vote_myid比较大，则将自己的票中的vote_myid更新为收到的票中的vote_myid并广播出去，另外将收到的票及自己更新后的票放入自己的票箱\n\n统计选票\n\n如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票。否则继续接收其它服务器的投票。\n\n更新服务器状态\n\n投票终止后，服务器开始更新自身状态。若过半的票投给了自己，则将自己的服务器状态更新为LEADING，否则将自己的状态更新为FOLLOWING。\n\n\n# 集群启动领导选举\n\n\n# 1、初始投票给自己\n\n集群刚启动时，所有服务器的logicClock都为1，zxid都为0。各服务器初始化后，都投票给自己，并将自己的一票存入自己的票箱，如下图所示。\n\n在上图中，(1, 1, 0)第一位数代表投出该选票的服务器的logicClock，第二位数代表被推荐的服务器的myid，第三位代表被推荐的服务器的最大的zxid。由于该步骤中所有选票都投给自己，所以第二位的myid即是自己的myid，第三位的zxid即是自己的zxid。\n\n此时各自的票箱中只有自己投给自己的一票。\n\n\n# 2、更新选票\n\n服务器收到外部投票后，进行选票PK，相应更新自己的选票并广播出去，并将合适的选票存入自己的票箱，如下图所示。\n\n服务器1收到服务器2的选票（1, 2, 0）和服务器3的选票（1, 3, 0）后，由于所有的logicClock都相等，所有的zxid都相等，因此根据myid判断应该将自己的选票按照服务器3的选票更新为（1, 3, 0），并将自己的票箱全部清空，再将服务器3的选票与自己的选票存入自己的票箱，接着将自己更新后的选票广播出去。此时服务器1票箱内的选票为(1, 3)，(3, 3)。\n\n同理，服务器2收到服务器3的选票后也将自己的选票更新为（1, 3, 0）并存入票箱然后广播。此时服务器2票箱内的选票为(2, 3)，(3, ,3)。\n\n服务器3根据上述规则，无须更新选票，自身的票箱内选票仍为（3, 3）。\n\n服务器1与服务器2更新后的选票广播出去后，由于三个服务器最新选票都相同，最后三者的票箱内都包含三张投给服务器3的选票。\n\n\n# 3、根据选票确定角色\n\n根据上述选票，三个服务器一致认为此时服务器3应该是Leader。因此服务器1和2都进入FOLLOWING状态，而服务器3进入LEADING状态。之后Leader发起并维护与Follower间的心跳。\n\n\n# Follower重启选举\n\n\n# 1、Follower重启投票给自己\n\nFollower重启，或者发生网络分区后找不到Leader，会进入LOOKING状态并发起新的一轮投票。\n\n\n# 2、发现已有Leader后成为Follower\n\n服务器3收到服务器1的投票后，将自己的状态LEADING以及选票返回给服务器1。服务器2收到服务器1的投票后，将自己的状态FOLLOWING及选票返回给服务器1。此时服务器1知道服务器3是Leader，并且通过服务器2与服务器3的选票可以确定服务器3确实得到了超过半数的选票。因此服务器1进入FOLLOWING状态。\n\n\n# Leader重启选举\n\n\n# 1、Follower发起新投票\n\nLeader（服务器3）宕机后，Follower（服务器1和2）发现Leader不工作了，因此进入LOOKING状态并发起新的一轮投票，并且都将票投给自己。\n\n\n# 2、广播更新选票\n\n服务器1和2根据外部投票确定是否要更新自身的选票。这里有两种情况：\n\n * 服务器1和2的zxid相同。例如在服务器3宕机前服务器1与2完全与之同步。此时选票的更新主要取决于myid的大小\n * 服务器1和2的zxid不同。在旧Leader宕机之前，其所主导的写操作，只需过半服务器确认即可，而不需所有服务器确认。换句话说，服务器1和2可能一个与旧Leader同步（即zxid与之相同）另一个不同步（即zxid比之小）。此时选票的更新主要取决于谁的zxid较大\n\n在上图中，服务器1的zxid为11，而服务器2的zxid为10，因此服务器2将自身选票更新为（3, 1, 11），如下图所示。\n\n\n# 3、选出新Leader\n\n经过上一步选票更新后，服务器1与服务器2均将选票投给服务器1，因此服务器2成为Follower，而服务器1成为新的Leader并维护与服务器2的心跳。\n\n\n# 4、旧Leader恢复后发起选举\n\n旧的Leader恢复后，进入LOOKING状态并发起新一轮领导选举，并将选票投给自己。此时服务器1会将自己的LEADING状态及选票（3, 1, 11）返回给服务器3，而服务器2将自己的FOLLOWING状态及选票（3, 1, 11）返回给服务器3。如下图所示。\n\n\n# 5、旧Leader成为Follower\n\n服务器3了解到Leader为服务器1，且根据选票了解到服务器1确实得到过半服务器的选票，因此自己进入FOLLOWING状态。\n\n\n# Commit过的数据不丢失\n\n\n# 1、Failover前状态\n\n为更好演示Leader Failover过程，本例中共使用5个ZooKeeper服务器。A作为Leader，共收到P1、P2、P3三条消息，并且Commit了1和2，且总体顺序为P1、P2、C1、P3、C2。根据顺序性原则，其它Follower收到的消息的顺序肯定与之相同。其中B与A完全同步，C收到P1、P2、C1，D收到P1、P2，E收到P1，如下图所示。\n\n这里要注意：\n\n * 由于A没有C3，意味着收到P3的服务器的总个数不会超过一半，也即包含A在内最多只有两台服务器收到P3。在这里A和B收到P3，其它服务器均未收到P3\n * 由于A已写入C1、C2，说明它已经Commit了P1、P2，因此整个集群有超过一半的服务器，即最少三个服务器收到P1、P2。在这里所有服务器都收到了P1，除E外其它服务器也都收到了P2\n\n\n# 2、选出新Leader\n\n旧Leader也即A宕机后，其它服务器根据上述FastLeaderElection算法选出B作为新的Leader。C、D和E成为Follower且以B为Leader后，会主动将自己最大的zxid发送给B，B会将Follower的zxid与自身zxid间的所有被Commit过的消息同步给Follower，如下图所示。\n\n在上图中：\n\n * P1和P2都被A Commit，因此B会通过同步保证P1、P2、C1与C2都存在于C、D和E中\n * P3由于未被A Commit，同时幸存的所有服务器中P3未存在于大多数据服务器中，因此它不会被同步到其它Follower\n\n\n# 3、通知Follower可对外服务\n\n同步完数据后，B会向D、C和E发送NEWLEADER命令并等待大多数服务器的ACK（下图中D和E已返回ACK，加上B自身，已经占集群的大多数），然后向所有服务器广播UPTODATE命令。收到该命令后的服务器即可对外提供服务。\n\n\n# 未Commit过的消息对客户端不可见\n\n在上例中，P3未被A Commit过，同时因为没有过半的服务器收到P3，因此B也未Commit P3（如果有过半服务器收到P3，即使A未Commit P3，B会主动Commit P3，即C3），所以它不会将P3广播出去。\n\n具体做法是，B在成为Leader后，先判断自身未Commit的消息（本例中即P3）是否存在于大多数服务器中从而决定是否要将其Commit。然后B可得出自身所包含的被Commit过的消息中的最小zxid（记为min_zxid）与最大zxid（记为max_zxid）。C、D和E向B发送自身Commit过的最大消息zxid（记为max_zxid）以及未被Commit过的所有消息（记为zxid_set）。B根据这些信息作出如下操作：\n\n * 如果Follower的max_zxid与Leader的max_zxid相等，说明该Follower与Leader完全同步，无须同步任何数据\n * 如果Follower的max_zxid在Leader的(min_zxid，max_zxid)范围内，Leader会通过TRUNC命令通知Follower将其zxid_set中大于Follower的max_zxid（如果有）的所有消息全部删除\n\n上述操作保证了未被Commit过的消息不会被Commit从而对外不可见。\n\n上述例子中Follower上并不存在未被Commit的消息。但可考虑这种情况，如果将上述例子中的服务器数量从五增加到七，服务器F包含P1、P2、C1、P3，服务器G包含P1、P2。此时服务器F、A和B都包含P3，但是因为票数未过半，因此B作为Leader不会Commit P3，而会通过TRUNC命令通知F删除P3。如下图所示。\n\n\n\n\n# 本节总结\n\n * 由于使用主从复制模式，所有的写操作都要由Leader主导完成，而读操作可通过任意节点完成，因此ZooKeeper读性能远好于写性能，更适合读多写少的场景\n * 虽然使用主从复制模式，同一时间只有一个Leader，但是Failover机制保证了集群不存在单点失败（SPOF）的问题\n * ZAB协议保证了Failover过程中的数据一致性\n * 服务器收到数据后先写本地文件再进行处理，保证了数据的持久性\n\n\n# 基于ZooKeeper的分布式锁与领导选举\n\n本节将结合实例演示了使用ZooKeeper实现分布式锁与领导选举的原理与具体实现方法。\n\n\n# ZooKeeper节点类型\n\nZooKeeper 提供了一个类似于 Linux 文件系统的树形结构。该树形结构中每个节点被称为 znode ，可按如下两个维度分类：\n\n1、Persist vs. Ephemeral\n\n * Persist节点，一旦被创建，便不会意外丢失，即使服务器全部重启也依然存在。每个 Persist 节点即可包含数据，也可包含子节点\n * Ephemeral节点，在创建它的客户端与服务器间的 Session 结束时自动被删除。服务器重启会导致 Session 结束，因此 Ephemeral 类型的 znode 此时也会自动删除\n\n2、Sequence vs. Non-sequence\n\n * Non-sequence节点，多个客户端同时创建同一 Non-sequence 节点时，只有一个可创建成功，其它匀失败。并且创建出的节点名称与创建时指定的节点名完全一样\n * Sequence节点，创建出的节点名在指定的名称之后带有10位10进制数的序号。多个客户端创建同一名称的节点时，都能创建成功，只是序号不同\n\n\n# ZooKeeper语义保证\n\nZooKeeper简单高效，同时提供如下语义保证，从而使得我们可以利用这些特性提供复杂的服务。\n\n * 顺序性：客户端发起的更新会按发送顺序被应用到 ZooKeeper 上\n * 原子性：更新操作要么成功要么失败，不会出现中间状态\n * 单一系统镜像：一个客户端无论连接到哪一个服务器都能看到完全一样的系统镜像（即完全一样的树形结构）。注：根据上文《ZooKeeper架构及FastLeaderElection机制》介绍的 ZAB 协议，写操作并不保证更新被所有的 Follower 立即确认，因此通过部分 Follower 读取数据并不能保证读到最新的数据，而部分 Follwer 及 Leader 可读到最新数据。如果一定要保证单一系统镜像，可在读操作前使用 sync 方法。\n * 可靠性：一个更新操作一旦被接受即不会意外丢失，除非被其它更新操作覆盖\n * 最终一致性：写操作最终（而非立即）会对客户端可见\n\n\n# ZooKeeper Watch机制\n\n所有对 ZooKeeper 的读操作，都可附带一个 Watch 。一旦相应的数据有变化，该 Watch 即被触发。\n\nWatch 有如下特点：\n\n * 主动推送：Watch被触发时，由 ZooKeeper 服务器主动将更新推送给客户端，而不需要客户端轮询。\n * 一次性：数据变化时，Watch 只会被触发一次。如果客户端想得到后续更新的通知，必须要在 Watch 被触发后重新注册一个 Watch。\n * 可见性：如果一个客户端在读请求中附带 Watch，Watch 被触发的同时再次读取数据，客户端在得到 Watch 消息之前肯定不可能看到更新后的数据。换句话说，更新通知先于更新结果。\n * 顺序性：如果多个更新触发了多个 Watch ，那 Watch 被触发的顺序与更新顺序一致。\n\n\n# 分布式锁与领导选举关键点\n\n1、最多一个获取锁 / 成为Leader\n\n对于分布式锁（这里特指排它锁）而言，任意时刻，最多只有一个进程（对于单进程内的锁而言是单线程）可以获得锁。\n\n对于领导选举而言，任意时间，最多只有一个成功当选为Leader。否则即出现脑裂（Split brain）\n\n2、锁重入 / 确认自己是Leader\n\n对于分布式锁，需要保证获得锁的进程在释放锁之前可再次获得锁，即锁的可重入性。\n\n对于领导选举，Leader需要能够确认自己已经获得领导权，即确认自己是Leader。\n\n3、释放锁 / 放弃领导权\n\n锁的获得者应该能够正确释放已经获得的锁，并且当获得锁的进程宕机时，锁应该自动释放，从而使得其它竞争方可以获得该锁，从而避免出现死锁的状态。\n\n领导应该可以主动放弃领导权，并且当领导所在进程宕机时，领导权应该自动释放，从而使得其它参与者可重新竞争领导而避免进入无主状态。\n\n4、感知锁释放 / 领导权的放弃\n\n当获得锁的一方释放锁时，其它对于锁的竞争方需要能够感知到锁的释放，并再次尝试获取锁。\n\n原来的Leader放弃领导权时，其它参与方应该能够感知该事件，并重新发起选举流程。\n\n\n# 非公平领导选举\n\n从上面几个方面可见，分布式锁与领导选举的技术要点非常相似，实际上其实现机制也相近。这里以领导选举为例来说明二者的实现原理，分布式锁的实现原理也几乎一致。\n\n1、选主过程\n\n假设有三个ZooKeeper的客户端，如下图所示，同时竞争Leader。这三个客户端同时向ZooKeeper集群注册Ephemeral且Non-sequence类型的节点，路径都为 /zkroot/leader（工程实践中，路径名可自定义）。\n\n如上图所示，由于是Non-sequence节点，这三个客户端只会有一个创建成功，其它节点均创建失败。此时，创建成功的客户端（即上图中的Client 1）即成功竞选为 Leader 。其它客户端（即上图中的Client 2和Client 3）此时匀为 Follower。\n\n2、放弃领导权\n\n如果 Leader 打算主动放弃领导权，直接删除 /zkroot/leader 节点即可。\n\n如果 Leader 进程意外宕机，其与 ZooKeeper 间的 Session 也结束，该节点由于是Ephemeral类型的节点，因此也会自动被删除。\n\n此时 /zkroot/leader 节点不复存在，对于其它参与竞选的客户端而言，之前的 Leader 已经放弃了领导权。\n\n3、感知领导权的放弃\n\n由上图可见，创建节点失败的节点，除了成为 Follower 以外，还会向 /zkroot/leader 注册一个 Watch ，一旦 Leader 放弃领导权，也即该节点被删除，所有的 Follower 会收到通知。\n\n4、重新选举\n\n感知到旧 Leader 放弃领导权后，所有的 Follower 可以再次发起新一轮的领导选举，如下图所示。\n\n从上图中可见：\n\n * 新一轮的领导选举方法与最初的领导选举方法完全一样，都是发起节点创建请求，创建成功即为 Leader，否则为 Follower ，且 Follower 会 Watch 该节点\n * 新一轮的选举结果，无法预测，与它们在第一轮选举中的顺序无关。这也是该方案被称为非公平模式的原因\n\n小结\n\n 1. 非公平模式实现简单，每一轮选举方法都完全一样\n 2. 竞争参与方不多的情况下，效率高。每个 Follower 通过 Watch 感知到节点被删除的时间不完全一样，只要有一个 Follower 得到通知即发起竞选，即可保证当时有新的 Leader 被选出\n 3. 给ZooKeeper 集群造成的负载大，因此扩展性差。如果有上万个客户端都参与竞选，意味着同时会有上万个写请求发送给 Zookeper。如《ZooKeeper架构》一文所述，ZooKeeper 存在单点写的问题，写性能不高。同时一旦 Leader 放弃领导权，ZooKeeper 需要同时通知上万个 Follower，负载较大。\n\n\n# 公平领导选举\n\n1、选主过程\n\n如下图所示，公平领导选举中，各客户端均创建 /zkroot/leader 节点，且其类型为Ephemeral与Sequence。\n\n由于是Sequence类型节点，故上图中三个客户端均创建成功，只是序号不一样。此时，每个客户端都会判断自己创建成功的节点的序号是不是当前最小的。如果是，则该客户端为 Leader，否则即为 Follower。\n\n在上图中，Client 1创建的节点序号为 1 ，Client 2创建的节点序号为 2，Client 3创建的节点序号为3。由于最小序号为 1 ，且该节点由Client 1创建，故Client 1为 Leader 。\n\n2、放弃领导权\n\nLeader 如果主动放弃领导权，直接删除其创建的节点即可。\n\n如果 Leader 所在进程意外宕机，其与 ZooKeeper 间的 Session 结束，由于其创建的节点为Ephemeral类型，故该节点自动被删除。\n\n3、感知领导权的放弃\n\n与非公平模式不同，每个 Follower 并非都 Watch 由 Leader 创建出来的节点，而是 Watch 序号刚好比自己序号小的节点。\n\n在上图中，总共有 1、2、3 共三个节点，因此Client 2 Watch /zkroot/leader1，Client 3 Watch /zkroot/leader2。（注：序号应该是10位数字，而非一位数字，这里为了方便，以一位数字代替）\n\n一旦 Leader 宕机，/zkroot/leader1 被删除，Client 2可得到通知。此时Client 3由于 Watch 的是 /zkroot/leader2 ，故不会得到通知。\n\n\n# 重新选举\n\n重新选举Client 2得到 /zkroot/leader1 被删除的通知后，不会立即成为新的 Leader 。而是先判断自己的序号 2 是不是当前最小的序号。在该场景下，其序号确为最小。因此Client 2成为新的 Leader 。\n\n这里要注意，如果在Client 1放弃领导权之前，Client 2就宕机了，Client 3会收到通知。此时Client 3不会立即成为Leader，而是要先判断自己的序号 3 是否为当前最小序号。很显然，由于Client 1创建的 /zkroot/leader1 还在，因此Client 3不会成为新的 Leader ，并向Client 2序号 2 前面的序号，也即 1 创建 Watch。该过程如下图所示。\n\n小结\n\n 1. 实现相对复杂；\n 2. 扩展性好，每个客户端都只 Watch 一个节点且每次节点被删除只须通知一个客户端；\n 3. 旧 Leader 放弃领导权时，其它客户端根据竞选的先后顺序（也即节点序号）成为新 Leader，这也是公平模式的由来；\n 4. 延迟相对非公平模式要高，因为它必须等待特定节点得到通知才能选出新的 Leader。\n\n[]: https://mp.weixin.qq.com/s?__biz=MzkwOTIxNDQ3OA==&mid=2247533392&idx=1&sn=8999e64a05cd06dfa63c0c3ecd3a806f&source=41#wechat_redirect",normalizedContent:"作者介绍\n\n**郭俊，**专注于大数据架构，熟悉kafka和flume源码；熟悉hadoop和spark原理；精通数据（仓）库模型设计和sql调优。公众号：大数据架构，博客：http://www.jasongj.com/，\n\n本文经作者授权转载，禁止二次转载。\n\n本节将介绍zookeeper的架构，并结合实例分析原子广播(zab)协议的原理，包括但不限于zookeeper的读写流程，fastleaderelection算法的原理，zab如何保证leader failover过程中的数据一致性。\n\n\n# zookeeper是什么\n\nzookeeper是一个分布式协调服务，可用于服务发现、分布式锁、分布式领导选举、配置管理等。\n\n这一切的基础，都是zookeeper提供了一个类似于linux文件系统的树形结构（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与通知机制。\n\n既然是一个文件系统，就不得不提zookeeper是如何保证数据的一致性的。本节将将介绍zookeeper如何保证数据一致性，如何进行领导选举，以及数据监控/通知机制的语义保证。\n\n\n# zookeeper服务器角色\n\nzookeeper集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种：\n\n * leader 一个zookeeper集群同一时间只会有一个实际工作的leader，它会发起并维护与各follwer及observer间的心跳。所有的写操作必须要通过leader完成再由leader将写操作广播给其它服务器。\n * follower 一个zookeeper集群可能同时存在多个follower，它会响应leader的心跳。follower可直接处理并返回客户端的读请求，同时会将写请求转发给leader处理，并且负责在leader处理写请求时对请求进行投票。\n * observer 角色与follower类似，但是无投票权。\n\n\n# 原子广播（zab）\n\n为了保证写操作的一致性与可用性，zookeeper专门设计了一种名为原子广播（zab）的支持崩溃恢复的一致性协议。基于该协议，zookeeper实现了一种主从模式的系统架构来保持集群中各个副本之间的数据一致性。\n\n根据zab协议，所有的写操作都必须通过leader完成，leader写入本地日志后再复制到所有的follower节点。\n\n一旦leader节点无法工作，zab协议能够自动从follower节点中重新选出一个合适的替代者，即新的leader，该过程即为领导选举。该领导选举过程，是zab协议中最为重要和复杂的过程。\n\n\n# 1、写leader\n\n通过leader进行写操作流程如下图所示：\n\n由上图可见，通过leader进行写操作，主要分为五步：\n\n 1. 客户端向leader发起写请求\n 2. leader将写请求以proposal的形式发给所有follower并等待ack\n 3. follower收到leader的proposal后返回ack\n 4. leader得到过半数的ack（leader对自己默认有一个ack）后向所有的follower和observer发送commit\n 5. leader将处理结果返回给客户端\n\n这里要注意：\n\n * leader并不需要得到observer的ack，即observer无投票权\n * leader不需要得到所有follower的ack，只要收到过半的ack即可，同时leader本身对自己有一个ack。上图中有4个follower，只需其中两个返回ack即可，因为(2+1) / (4+1) > 1/2\n * observer虽然无投票权，但仍须同步leader的数据从而在处理读请求时可以返回尽可能新的数据\n\n\n# 2、写follower/observer\n\n通过follower/observer进行写操作流程如下图所示：\n\n\n\n从上图可见：\n\n * follower/observer均可接受写请求，但不能直接处理，而需要将写请求转发给leader处理\n * 除了多了一步请求转发，其它流程与直接写leader无任何区别\n\n\n# 3、读操作\n\nleader/follower/observer都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。\n\n\n\n由于处理读请求不需要服务器之间的交互，follower/observer越多，整体可处理的读请求量越大，也即读性能越好。\n\n\n# 支持的领导选举算法\n\n可通过electionalg配置项设置zookeeper用于领导选举的算法。\n\n到3.4.10版本为止，可选项有：\n\n * 0 基于udp的leaderelection\n * 1 基于udp的fastleaderelection\n * 2 基于udp和认证的fastleaderelection\n * 3 基于tcp的fastleaderelection\n\n在3.4.10版本中，默认值为3，也即基于tcp的fastleaderelection。另外三种算法已经被弃用，并且有计划在之后的版本中将它们彻底删除而不再支持。\n\n\n# fastleaderelection原理\n\n\n# 1、myid\n\n每个zookeeper服务器，都需要在数据文件夹下创建一个名为myid的文件，该文件包含整个zookeeper集群唯一的id（整数）。例如，某zookeeper集群包含三台服务器，hostname分别为zoo1、zoo2和zoo3，其myid分别为1、2和3，则在配置文件中其id与hostname必须一一对应，如下所示。在该配置文件中，server.后面的数据即为myid\n\nserver.1=zoo1:2888:3888\n\nserver.2=zoo2:2888:3888\n\nserver.3=zoo3:2888:3888\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2、zxid\n\n类似于rdbms中的事务id，用于标识一次更新操作的proposal id。为了保证顺序性，该zkid必须单调递增。因此zookeeper使用一个64位的数来表示，高32位是leader的epoch，从1开始，每次选出新的leader，epoch加一。低32位为该epoch内的序号，每次epoch变化，都将低32位的序号重置。这样保证了zkid的全局递增性。\n\n\n# 3、服务器状态\n\n * looking 不确定leader状态。该状态下的服务器认为当前集群中没有leader，会发起leader选举。\n * following 跟随者状态。表明当前服务器角色是follower，并且它知道leader是谁。\n * leading 领导者状态。表明当前服务器角色是leader，它会维护与follower间的心跳。\n * observing 观察者状态。表明当前服务器角色是observer，与folower唯一的不同在于不参与选举，也不参与集群写操作时的投票。\n\n\n# 4、选票数据结构\n\n每个服务器在进行领导选举时，会发送如下关键信息：\n\n * logicclock 每个服务器会维护一个自增的整数，名为logicclock，它表示这是该服务器发起的第多少轮投票\n * state 当前服务器的状态\n * self_id 当前服务器的myid\n * self_zxid 当前服务器上所保存的数据的最大zxid\n * vote_id 被推举的服务器的myid\n * vote_zxid 被推举的服务器上所保存的数据的最大zxid\n\n\n# 5、投票流程\n\n自增选举轮次\n\nzookeeper规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的logicclock进行自增操作。\n\n初始化选票\n\n每个服务器在广播自己的选票前，会将自己的投票箱清空。该投票箱记录了所收到的选票。例：服务器2投票给服务器3，服务器3投票给服务器1，则服务器1的投票箱为(2, 3), (3, 1), (1, 1)。票箱中只会记录每一投票者的最后一票，如投票者更新自己的选票，则其它服务器收到该新选票后会在自己票箱中更新该服务器的选票。\n\n发送初始化选票\n\n每个服务器最开始都是通过广播把票投给自己。\n\n接收外部投票\n\n服务器会尝试从其它服务器获取投票，并记入自己的投票箱内。如果无法获取任何外部投票，则会确认自己是否与集群中其它服务器保持着有效连接。如果是，则再次发送自己的投票；如果否，则马上与之建立连接。\n\n判断选举轮次\n\n收到外部投票后，首先会根据投票信息中所包含的logicclock来进行不同处理：\n\n * 外部投票的logicclock大于自己的logicclock。说明该服务器的选举轮次落后于其它服务器的选举轮次，立即清空自己的投票箱并将自己的logicclock更新为收到的logicclock，然后再对比自己之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去。\n * 外部投票的logicclock小于自己的logicclock。当前服务器直接忽略该投票，继续处理下一个投票。\n * 外部投票的logickclock与自己的相等。当时进行选票pk。\n\n选票pk\n\n选票pk是基于(self_id, self_zxid)与(vote_id, vote_zxid)的对比：\n\n * 外部投票的logicclock大于自己的logicclock，则将自己的logicclock及自己的选票的logicclock变更为收到的logicclock\n * 若logicclock一致，则对比二者的vote_zxid，若外部投票的vote_zxid比较大，则将自己的票中的vote_zxid与vote_myid更新为收到的票中的vote_zxid与vote_myid并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在(self_myid, self_zxid)相同的选票，则直接覆盖\n * 若二者vote_zxid一致，则比较二者的vote_myid，若外部投票的vote_myid比较大，则将自己的票中的vote_myid更新为收到的票中的vote_myid并广播出去，另外将收到的票及自己更新后的票放入自己的票箱\n\n统计选票\n\n如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票。否则继续接收其它服务器的投票。\n\n更新服务器状态\n\n投票终止后，服务器开始更新自身状态。若过半的票投给了自己，则将自己的服务器状态更新为leading，否则将自己的状态更新为following。\n\n\n# 集群启动领导选举\n\n\n# 1、初始投票给自己\n\n集群刚启动时，所有服务器的logicclock都为1，zxid都为0。各服务器初始化后，都投票给自己，并将自己的一票存入自己的票箱，如下图所示。\n\n在上图中，(1, 1, 0)第一位数代表投出该选票的服务器的logicclock，第二位数代表被推荐的服务器的myid，第三位代表被推荐的服务器的最大的zxid。由于该步骤中所有选票都投给自己，所以第二位的myid即是自己的myid，第三位的zxid即是自己的zxid。\n\n此时各自的票箱中只有自己投给自己的一票。\n\n\n# 2、更新选票\n\n服务器收到外部投票后，进行选票pk，相应更新自己的选票并广播出去，并将合适的选票存入自己的票箱，如下图所示。\n\n服务器1收到服务器2的选票（1, 2, 0）和服务器3的选票（1, 3, 0）后，由于所有的logicclock都相等，所有的zxid都相等，因此根据myid判断应该将自己的选票按照服务器3的选票更新为（1, 3, 0），并将自己的票箱全部清空，再将服务器3的选票与自己的选票存入自己的票箱，接着将自己更新后的选票广播出去。此时服务器1票箱内的选票为(1, 3)，(3, 3)。\n\n同理，服务器2收到服务器3的选票后也将自己的选票更新为（1, 3, 0）并存入票箱然后广播。此时服务器2票箱内的选票为(2, 3)，(3, ,3)。\n\n服务器3根据上述规则，无须更新选票，自身的票箱内选票仍为（3, 3）。\n\n服务器1与服务器2更新后的选票广播出去后，由于三个服务器最新选票都相同，最后三者的票箱内都包含三张投给服务器3的选票。\n\n\n# 3、根据选票确定角色\n\n根据上述选票，三个服务器一致认为此时服务器3应该是leader。因此服务器1和2都进入following状态，而服务器3进入leading状态。之后leader发起并维护与follower间的心跳。\n\n\n# follower重启选举\n\n\n# 1、follower重启投票给自己\n\nfollower重启，或者发生网络分区后找不到leader，会进入looking状态并发起新的一轮投票。\n\n\n# 2、发现已有leader后成为follower\n\n服务器3收到服务器1的投票后，将自己的状态leading以及选票返回给服务器1。服务器2收到服务器1的投票后，将自己的状态following及选票返回给服务器1。此时服务器1知道服务器3是leader，并且通过服务器2与服务器3的选票可以确定服务器3确实得到了超过半数的选票。因此服务器1进入following状态。\n\n\n# leader重启选举\n\n\n# 1、follower发起新投票\n\nleader（服务器3）宕机后，follower（服务器1和2）发现leader不工作了，因此进入looking状态并发起新的一轮投票，并且都将票投给自己。\n\n\n# 2、广播更新选票\n\n服务器1和2根据外部投票确定是否要更新自身的选票。这里有两种情况：\n\n * 服务器1和2的zxid相同。例如在服务器3宕机前服务器1与2完全与之同步。此时选票的更新主要取决于myid的大小\n * 服务器1和2的zxid不同。在旧leader宕机之前，其所主导的写操作，只需过半服务器确认即可，而不需所有服务器确认。换句话说，服务器1和2可能一个与旧leader同步（即zxid与之相同）另一个不同步（即zxid比之小）。此时选票的更新主要取决于谁的zxid较大\n\n在上图中，服务器1的zxid为11，而服务器2的zxid为10，因此服务器2将自身选票更新为（3, 1, 11），如下图所示。\n\n\n# 3、选出新leader\n\n经过上一步选票更新后，服务器1与服务器2均将选票投给服务器1，因此服务器2成为follower，而服务器1成为新的leader并维护与服务器2的心跳。\n\n\n# 4、旧leader恢复后发起选举\n\n旧的leader恢复后，进入looking状态并发起新一轮领导选举，并将选票投给自己。此时服务器1会将自己的leading状态及选票（3, 1, 11）返回给服务器3，而服务器2将自己的following状态及选票（3, 1, 11）返回给服务器3。如下图所示。\n\n\n# 5、旧leader成为follower\n\n服务器3了解到leader为服务器1，且根据选票了解到服务器1确实得到过半服务器的选票，因此自己进入following状态。\n\n\n# commit过的数据不丢失\n\n\n# 1、failover前状态\n\n为更好演示leader failover过程，本例中共使用5个zookeeper服务器。a作为leader，共收到p1、p2、p3三条消息，并且commit了1和2，且总体顺序为p1、p2、c1、p3、c2。根据顺序性原则，其它follower收到的消息的顺序肯定与之相同。其中b与a完全同步，c收到p1、p2、c1，d收到p1、p2，e收到p1，如下图所示。\n\n这里要注意：\n\n * 由于a没有c3，意味着收到p3的服务器的总个数不会超过一半，也即包含a在内最多只有两台服务器收到p3。在这里a和b收到p3，其它服务器均未收到p3\n * 由于a已写入c1、c2，说明它已经commit了p1、p2，因此整个集群有超过一半的服务器，即最少三个服务器收到p1、p2。在这里所有服务器都收到了p1，除e外其它服务器也都收到了p2\n\n\n# 2、选出新leader\n\n旧leader也即a宕机后，其它服务器根据上述fastleaderelection算法选出b作为新的leader。c、d和e成为follower且以b为leader后，会主动将自己最大的zxid发送给b，b会将follower的zxid与自身zxid间的所有被commit过的消息同步给follower，如下图所示。\n\n在上图中：\n\n * p1和p2都被a commit，因此b会通过同步保证p1、p2、c1与c2都存在于c、d和e中\n * p3由于未被a commit，同时幸存的所有服务器中p3未存在于大多数据服务器中，因此它不会被同步到其它follower\n\n\n# 3、通知follower可对外服务\n\n同步完数据后，b会向d、c和e发送newleader命令并等待大多数服务器的ack（下图中d和e已返回ack，加上b自身，已经占集群的大多数），然后向所有服务器广播uptodate命令。收到该命令后的服务器即可对外提供服务。\n\n\n# 未commit过的消息对客户端不可见\n\n在上例中，p3未被a commit过，同时因为没有过半的服务器收到p3，因此b也未commit p3（如果有过半服务器收到p3，即使a未commit p3，b会主动commit p3，即c3），所以它不会将p3广播出去。\n\n具体做法是，b在成为leader后，先判断自身未commit的消息（本例中即p3）是否存在于大多数服务器中从而决定是否要将其commit。然后b可得出自身所包含的被commit过的消息中的最小zxid（记为min_zxid）与最大zxid（记为max_zxid）。c、d和e向b发送自身commit过的最大消息zxid（记为max_zxid）以及未被commit过的所有消息（记为zxid_set）。b根据这些信息作出如下操作：\n\n * 如果follower的max_zxid与leader的max_zxid相等，说明该follower与leader完全同步，无须同步任何数据\n * 如果follower的max_zxid在leader的(min_zxid，max_zxid)范围内，leader会通过trunc命令通知follower将其zxid_set中大于follower的max_zxid（如果有）的所有消息全部删除\n\n上述操作保证了未被commit过的消息不会被commit从而对外不可见。\n\n上述例子中follower上并不存在未被commit的消息。但可考虑这种情况，如果将上述例子中的服务器数量从五增加到七，服务器f包含p1、p2、c1、p3，服务器g包含p1、p2。此时服务器f、a和b都包含p3，但是因为票数未过半，因此b作为leader不会commit p3，而会通过trunc命令通知f删除p3。如下图所示。\n\n\n\n\n# 本节总结\n\n * 由于使用主从复制模式，所有的写操作都要由leader主导完成，而读操作可通过任意节点完成，因此zookeeper读性能远好于写性能，更适合读多写少的场景\n * 虽然使用主从复制模式，同一时间只有一个leader，但是failover机制保证了集群不存在单点失败（spof）的问题\n * zab协议保证了failover过程中的数据一致性\n * 服务器收到数据后先写本地文件再进行处理，保证了数据的持久性\n\n\n# 基于zookeeper的分布式锁与领导选举\n\n本节将结合实例演示了使用zookeeper实现分布式锁与领导选举的原理与具体实现方法。\n\n\n# zookeeper节点类型\n\nzookeeper 提供了一个类似于 linux 文件系统的树形结构。该树形结构中每个节点被称为 znode ，可按如下两个维度分类：\n\n1、persist vs. ephemeral\n\n * persist节点，一旦被创建，便不会意外丢失，即使服务器全部重启也依然存在。每个 persist 节点即可包含数据，也可包含子节点\n * ephemeral节点，在创建它的客户端与服务器间的 session 结束时自动被删除。服务器重启会导致 session 结束，因此 ephemeral 类型的 znode 此时也会自动删除\n\n2、sequence vs. non-sequence\n\n * non-sequence节点，多个客户端同时创建同一 non-sequence 节点时，只有一个可创建成功，其它匀失败。并且创建出的节点名称与创建时指定的节点名完全一样\n * sequence节点，创建出的节点名在指定的名称之后带有10位10进制数的序号。多个客户端创建同一名称的节点时，都能创建成功，只是序号不同\n\n\n# zookeeper语义保证\n\nzookeeper简单高效，同时提供如下语义保证，从而使得我们可以利用这些特性提供复杂的服务。\n\n * 顺序性：客户端发起的更新会按发送顺序被应用到 zookeeper 上\n * 原子性：更新操作要么成功要么失败，不会出现中间状态\n * 单一系统镜像：一个客户端无论连接到哪一个服务器都能看到完全一样的系统镜像（即完全一样的树形结构）。注：根据上文《zookeeper架构及fastleaderelection机制》介绍的 zab 协议，写操作并不保证更新被所有的 follower 立即确认，因此通过部分 follower 读取数据并不能保证读到最新的数据，而部分 follwer 及 leader 可读到最新数据。如果一定要保证单一系统镜像，可在读操作前使用 sync 方法。\n * 可靠性：一个更新操作一旦被接受即不会意外丢失，除非被其它更新操作覆盖\n * 最终一致性：写操作最终（而非立即）会对客户端可见\n\n\n# zookeeper watch机制\n\n所有对 zookeeper 的读操作，都可附带一个 watch 。一旦相应的数据有变化，该 watch 即被触发。\n\nwatch 有如下特点：\n\n * 主动推送：watch被触发时，由 zookeeper 服务器主动将更新推送给客户端，而不需要客户端轮询。\n * 一次性：数据变化时，watch 只会被触发一次。如果客户端想得到后续更新的通知，必须要在 watch 被触发后重新注册一个 watch。\n * 可见性：如果一个客户端在读请求中附带 watch，watch 被触发的同时再次读取数据，客户端在得到 watch 消息之前肯定不可能看到更新后的数据。换句话说，更新通知先于更新结果。\n * 顺序性：如果多个更新触发了多个 watch ，那 watch 被触发的顺序与更新顺序一致。\n\n\n# 分布式锁与领导选举关键点\n\n1、最多一个获取锁 / 成为leader\n\n对于分布式锁（这里特指排它锁）而言，任意时刻，最多只有一个进程（对于单进程内的锁而言是单线程）可以获得锁。\n\n对于领导选举而言，任意时间，最多只有一个成功当选为leader。否则即出现脑裂（split brain）\n\n2、锁重入 / 确认自己是leader\n\n对于分布式锁，需要保证获得锁的进程在释放锁之前可再次获得锁，即锁的可重入性。\n\n对于领导选举，leader需要能够确认自己已经获得领导权，即确认自己是leader。\n\n3、释放锁 / 放弃领导权\n\n锁的获得者应该能够正确释放已经获得的锁，并且当获得锁的进程宕机时，锁应该自动释放，从而使得其它竞争方可以获得该锁，从而避免出现死锁的状态。\n\n领导应该可以主动放弃领导权，并且当领导所在进程宕机时，领导权应该自动释放，从而使得其它参与者可重新竞争领导而避免进入无主状态。\n\n4、感知锁释放 / 领导权的放弃\n\n当获得锁的一方释放锁时，其它对于锁的竞争方需要能够感知到锁的释放，并再次尝试获取锁。\n\n原来的leader放弃领导权时，其它参与方应该能够感知该事件，并重新发起选举流程。\n\n\n# 非公平领导选举\n\n从上面几个方面可见，分布式锁与领导选举的技术要点非常相似，实际上其实现机制也相近。这里以领导选举为例来说明二者的实现原理，分布式锁的实现原理也几乎一致。\n\n1、选主过程\n\n假设有三个zookeeper的客户端，如下图所示，同时竞争leader。这三个客户端同时向zookeeper集群注册ephemeral且non-sequence类型的节点，路径都为 /zkroot/leader（工程实践中，路径名可自定义）。\n\n如上图所示，由于是non-sequence节点，这三个客户端只会有一个创建成功，其它节点均创建失败。此时，创建成功的客户端（即上图中的client 1）即成功竞选为 leader 。其它客户端（即上图中的client 2和client 3）此时匀为 follower。\n\n2、放弃领导权\n\n如果 leader 打算主动放弃领导权，直接删除 /zkroot/leader 节点即可。\n\n如果 leader 进程意外宕机，其与 zookeeper 间的 session 也结束，该节点由于是ephemeral类型的节点，因此也会自动被删除。\n\n此时 /zkroot/leader 节点不复存在，对于其它参与竞选的客户端而言，之前的 leader 已经放弃了领导权。\n\n3、感知领导权的放弃\n\n由上图可见，创建节点失败的节点，除了成为 follower 以外，还会向 /zkroot/leader 注册一个 watch ，一旦 leader 放弃领导权，也即该节点被删除，所有的 follower 会收到通知。\n\n4、重新选举\n\n感知到旧 leader 放弃领导权后，所有的 follower 可以再次发起新一轮的领导选举，如下图所示。\n\n从上图中可见：\n\n * 新一轮的领导选举方法与最初的领导选举方法完全一样，都是发起节点创建请求，创建成功即为 leader，否则为 follower ，且 follower 会 watch 该节点\n * 新一轮的选举结果，无法预测，与它们在第一轮选举中的顺序无关。这也是该方案被称为非公平模式的原因\n\n小结\n\n 1. 非公平模式实现简单，每一轮选举方法都完全一样\n 2. 竞争参与方不多的情况下，效率高。每个 follower 通过 watch 感知到节点被删除的时间不完全一样，只要有一个 follower 得到通知即发起竞选，即可保证当时有新的 leader 被选出\n 3. 给zookeeper 集群造成的负载大，因此扩展性差。如果有上万个客户端都参与竞选，意味着同时会有上万个写请求发送给 zookeper。如《zookeeper架构》一文所述，zookeeper 存在单点写的问题，写性能不高。同时一旦 leader 放弃领导权，zookeeper 需要同时通知上万个 follower，负载较大。\n\n\n# 公平领导选举\n\n1、选主过程\n\n如下图所示，公平领导选举中，各客户端均创建 /zkroot/leader 节点，且其类型为ephemeral与sequence。\n\n由于是sequence类型节点，故上图中三个客户端均创建成功，只是序号不一样。此时，每个客户端都会判断自己创建成功的节点的序号是不是当前最小的。如果是，则该客户端为 leader，否则即为 follower。\n\n在上图中，client 1创建的节点序号为 1 ，client 2创建的节点序号为 2，client 3创建的节点序号为3。由于最小序号为 1 ，且该节点由client 1创建，故client 1为 leader 。\n\n2、放弃领导权\n\nleader 如果主动放弃领导权，直接删除其创建的节点即可。\n\n如果 leader 所在进程意外宕机，其与 zookeeper 间的 session 结束，由于其创建的节点为ephemeral类型，故该节点自动被删除。\n\n3、感知领导权的放弃\n\n与非公平模式不同，每个 follower 并非都 watch 由 leader 创建出来的节点，而是 watch 序号刚好比自己序号小的节点。\n\n在上图中，总共有 1、2、3 共三个节点，因此client 2 watch /zkroot/leader1，client 3 watch /zkroot/leader2。（注：序号应该是10位数字，而非一位数字，这里为了方便，以一位数字代替）\n\n一旦 leader 宕机，/zkroot/leader1 被删除，client 2可得到通知。此时client 3由于 watch 的是 /zkroot/leader2 ，故不会得到通知。\n\n\n# 重新选举\n\n重新选举client 2得到 /zkroot/leader1 被删除的通知后，不会立即成为新的 leader 。而是先判断自己的序号 2 是不是当前最小的序号。在该场景下，其序号确为最小。因此client 2成为新的 leader 。\n\n这里要注意，如果在client 1放弃领导权之前，client 2就宕机了，client 3会收到通知。此时client 3不会立即成为leader，而是要先判断自己的序号 3 是否为当前最小序号。很显然，由于client 1创建的 /zkroot/leader1 还在，因此client 3不会成为新的 leader ，并向client 2序号 2 前面的序号，也即 1 创建 watch。该过程如下图所示。\n\n小结\n\n 1. 实现相对复杂；\n 2. 扩展性好，每个客户端都只 watch 一个节点且每次节点被删除只须通知一个客户端；\n 3. 旧 leader 放弃领导权时，其它客户端根据竞选的先后顺序（也即节点序号）成为新 leader，这也是公平模式的由来；\n 4. 延迟相对非公平模式要高，因为它必须等待特定节点得到通知才能选出新的 leader。\n\n[]: https://mp.weixin.qq.com/s?__biz=mzkwotixndq3oa==&mid=2247533392&idx=1&sn=8999e64a05cd06dfa63c0c3ecd3a806f&source=41#wechat_redirect",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/017da3/"},regularPath:"/10.%E6%A1%86%E6%9E%B6/55.Dubbo/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"10.框架/55.Dubbo/10.Redis高级客户端Lettuce详解.md",key:"v-363cf0bc",path:"/pages/017da3/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Kafka单机版安装",frontmatter:{title:"Kafka单机版安装",date:"2022-02-03T22:43:53.000Z",permalink:"/pages/e5e3af/",categories:["框架","Kafka"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/60.Kafka/01.Kafka%E5%8D%95%E6%9C%BA%E7%89%88%E5%AE%89%E8%A3%85.html",relativePath:"10.框架/60.Kafka/01.Kafka单机版安装.md",key:"v-6756bb32",path:"/pages/e5e3af/",headers:[{level:2,title:"1. 安装JDK",slug:"_1-安装jdk",normalizedTitle:"1. 安装jdk",charIndex:2},{level:2,title:"2. 安装Zookeeper",slug:"_2-安装zookeeper",normalizedTitle:"2. 安装zookeeper",charIndex:332},{level:2,title:"3. 安装Kafka",slug:"_3-安装kafka",normalizedTitle:"3. 安装kafka",charIndex:1546}],headersStr:"1. 安装JDK 2. 安装Zookeeper 3. 安装Kafka",content:"# 1. 安装JDK\n\ncp jdk-8u172-linux-x64.tar.gz /usr/local/\ncd /usr/local/\ntar -zxf jdk-8u172-linux-x64.tar.gz\nmv jdk1.8.0_172/ java\nvi /etc/profile\n    export JAVA_HOME=/usr/local/java\n    export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n    export PATH=$JAVA_HOME/bin:$PATH\nsource /etc/profile\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2. 安装Zookeeper\n\n[root@localhost local]# tar -zxf zookeeper-3.4.6.tar.gz \n[root@localhost local]# mv zookeeper-3.4.6 zookeeper\n[root@localhost local]# cd zookeeper\n[root@localhost zookeeper]# mkdir -p /var/lib/zookeeper\n[root@localhost zookeeper]# cat > /usr/local/zookeeper/conf/zoo.cfg << EOF\n> tickTime=2000\n> dataDir=/var/lib/zookeeper\n> clientPort=2181\n> EOF\n[root@localhost zookeeper]# /usr/local/zookeeper/bin/zkServer.sh start\nJMX enabled by default\nUsing config: /usr/local/zookeeper/bin/../conf/zoo.cfg\nStarting zookeeper ... STARTED\n[root@localhost zookeeper]# telnet localhost 2181\n-bash: telnet: 未找到命令\n[root@localhost zookeeper]# yum -y install telnet\n[root@localhost zookeeper]# telnet localhost 2181\nTrying ::1...\nConnected to localhost.\nEscape character is '^]'.\nsrvr\nZookeeper version: 3.4.6-1569965, built on 02/20/2014 09:09 GMT\nLatency min/avg/max: 0/0/0\nReceived: 1\nSent: 0\nConnections: 1\nOutstanding: 0\nZxid: 0x0\nMode: standalone\nNode count: 4\nConnection closed by foreign host.\n\n# 配置 zookeeper 开机使用 wusc 用户启动：编辑/etc/rc.local 文件，\nsu -wusc -c '/home/wusc/zookeeper-3.4.6/bin/zkServer.sh start'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 3. 安装Kafka\n\n[root@localhost local]# tar -zxf kafka_2.11-0.9.0.1.tgz \n[root@localhost local]# mv kafka_2.11-0.9.0.1 kafka\n[root@localhost local]# mkdir /tmp/kafka-logs\n/usr/local/kafka/bin/kafka-server-start.sh -daemon \\\n/usr/local/kafka/config/server.properties \n[root@localhost local]# jps\n13648 Kafka\n13707 Jps\n13502 QuorumPeerMain\n[root@localhost local]# /usr/local/kafka/bin/kafka-topics.sh --create --zookeeper localhost:2181 \\\n> --replication-factor 1 --partitions 1 --topic test\nCreated topic \"test\".\n[root@localhost local]# /usr/local/kafka/bin/kafka-topics.sh --describe --zookeeper localhost:2181 \\\n> --topic test\nTopic:test\tPartitionCount:1\tReplicationFactor:1\tConfigs:\n\tTopic: test\tPartition: 0\tLeader: 0\tReplicas: 0\tIsr: 0\n[root@localhost local]# /usr/local/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test\nTest message 1\nTest message 2\n[root@localhost local]# /usr/local/kafka/bin/kafka-console-consumer.sh --zookeeper localhost 2181 --topic test --from-beginning\nTest message 1\nTest message 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",normalizedContent:"# 1. 安装jdk\n\ncp jdk-8u172-linux-x64.tar.gz /usr/local/\ncd /usr/local/\ntar -zxf jdk-8u172-linux-x64.tar.gz\nmv jdk1.8.0_172/ java\nvi /etc/profile\n    export java_home=/usr/local/java\n    export classpath=.:$java_home/lib/dt.jar:$java_home/lib/tools.jar\n    export path=$java_home/bin:$path\nsource /etc/profile\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2. 安装zookeeper\n\n[root@localhost local]# tar -zxf zookeeper-3.4.6.tar.gz \n[root@localhost local]# mv zookeeper-3.4.6 zookeeper\n[root@localhost local]# cd zookeeper\n[root@localhost zookeeper]# mkdir -p /var/lib/zookeeper\n[root@localhost zookeeper]# cat > /usr/local/zookeeper/conf/zoo.cfg << eof\n> ticktime=2000\n> datadir=/var/lib/zookeeper\n> clientport=2181\n> eof\n[root@localhost zookeeper]# /usr/local/zookeeper/bin/zkserver.sh start\njmx enabled by default\nusing config: /usr/local/zookeeper/bin/../conf/zoo.cfg\nstarting zookeeper ... started\n[root@localhost zookeeper]# telnet localhost 2181\n-bash: telnet: 未找到命令\n[root@localhost zookeeper]# yum -y install telnet\n[root@localhost zookeeper]# telnet localhost 2181\ntrying ::1...\nconnected to localhost.\nescape character is '^]'.\nsrvr\nzookeeper version: 3.4.6-1569965, built on 02/20/2014 09:09 gmt\nlatency min/avg/max: 0/0/0\nreceived: 1\nsent: 0\nconnections: 1\noutstanding: 0\nzxid: 0x0\nmode: standalone\nnode count: 4\nconnection closed by foreign host.\n\n# 配置 zookeeper 开机使用 wusc 用户启动：编辑/etc/rc.local 文件，\nsu -wusc -c '/home/wusc/zookeeper-3.4.6/bin/zkserver.sh start'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 3. 安装kafka\n\n[root@localhost local]# tar -zxf kafka_2.11-0.9.0.1.tgz \n[root@localhost local]# mv kafka_2.11-0.9.0.1 kafka\n[root@localhost local]# mkdir /tmp/kafka-logs\n/usr/local/kafka/bin/kafka-server-start.sh -daemon \\\n/usr/local/kafka/config/server.properties \n[root@localhost local]# jps\n13648 kafka\n13707 jps\n13502 quorumpeermain\n[root@localhost local]# /usr/local/kafka/bin/kafka-topics.sh --create --zookeeper localhost:2181 \\\n> --replication-factor 1 --partitions 1 --topic test\ncreated topic \"test\".\n[root@localhost local]# /usr/local/kafka/bin/kafka-topics.sh --describe --zookeeper localhost:2181 \\\n> --topic test\ntopic:test\tpartitioncount:1\treplicationfactor:1\tconfigs:\n\ttopic: test\tpartition: 0\tleader: 0\treplicas: 0\tisr: 0\n[root@localhost local]# /usr/local/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test\ntest message 1\ntest message 2\n[root@localhost local]# /usr/local/kafka/bin/kafka-console-consumer.sh --zookeeper localhost 2181 --topic test --from-beginning\ntest message 1\ntest message 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"kafka命令整理",frontmatter:{title:"kafka命令整理",date:"2022-02-03T22:34:25.000Z",permalink:"/pages/bc987c/",categories:["框架","Kafka"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/60.Kafka/10.kafka%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86.html",relativePath:"10.框架/60.Kafka/10.kafka命令整理.md",key:"v-6e63d81a",path:"/pages/bc987c/",headers:[{level:3,title:"0. 启动 Kafka",slug:"_0-启动-kafka",normalizedTitle:"0. 启动 kafka",charIndex:74},{level:3,title:"1. Topic 相关操作",slug:"_1-topic-相关操作",normalizedTitle:"1. topic 相关操作",charIndex:177},{level:3,title:"2. 生产消费消息",slug:"_2-生产消费消息",normalizedTitle:"2. 生产消费消息",charIndex:610},{level:3,title:"3. 其他命令",slug:"_3-其他命令",normalizedTitle:"3. 其他命令",charIndex:1219}],headersStr:"0. 启动 Kafka 1. Topic 相关操作 2. 生产消费消息 3. 其他命令",content:"说明：kafka执行命令非常脆弱，多加个空格啥的就会执行失败，而且报的错看不出来是因为格式有问题，所有在这里严格把命令的格式记录再次！！！\n\n\n# 0. 启动 Kafka\n\ncd kafka_2.11-1.1.0\nbin/kafka-server-start.sh -daemon config/server.properties\n\n\n1\n2\n\n\n\n# 1. Topic 相关操作\n\n查看所有 Topic 列表\n\nbin/kafka-topics.sh --list --zookeeper localhost:2181\n\n\n1\n\n\n删除指定 Topic\n\nbin/kafka-topics.sh --delete --topic test666 --zookeeper localhost:2181\n\n\n1\n\n\n创建 Topic\n\nbin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\n\nbin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic\n\n\n1\n2\n3\n\n\n\n# 2. 生产消费消息\n\n发送消息\n\nbin/kafka-console-producer.sh --broker-list localhost:9092 --topic test\n\n\n1\n\n\n消费消息（从头消费）—— 老版本\n\nbin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning\n\n\n1\n\n\n消费消息（从头消费）—— 新版本\n\nbin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning [--consumer-property group.id=testGroup] [--consumer-property client.id=consumer-1]\n\n# 指定消费者组、以及客户端编号\nbin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning --consumer-property group.id=testGroup --consumer-property client.id=consumer-1\n\n\n1\n2\n3\n4\n\n\n\n# 3. 其他命令\n\n查看消费者组列表\n\nbin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list\n\n\n1\n\n\n查看某一消费者组的消费偏移量（消费偏移量是和消费者组绑定的）\n\nbin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group testGroup\n\n\n1\n\n\n查看 topic 描述 信息\n\nbin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic test\n\n\n1\n\n\n查看启动kafka进程\n\njps\njps -vm\n\n\n1\n2\n",normalizedContent:"说明：kafka执行命令非常脆弱，多加个空格啥的就会执行失败，而且报的错看不出来是因为格式有问题，所有在这里严格把命令的格式记录再次！！！\n\n\n# 0. 启动 kafka\n\ncd kafka_2.11-1.1.0\nbin/kafka-server-start.sh -daemon config/server.properties\n\n\n1\n2\n\n\n\n# 1. topic 相关操作\n\n查看所有 topic 列表\n\nbin/kafka-topics.sh --list --zookeeper localhost:2181\n\n\n1\n\n\n删除指定 topic\n\nbin/kafka-topics.sh --delete --topic test666 --zookeeper localhost:2181\n\n\n1\n\n\n创建 topic\n\nbin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\n\nbin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic\n\n\n1\n2\n3\n\n\n\n# 2. 生产消费消息\n\n发送消息\n\nbin/kafka-console-producer.sh --broker-list localhost:9092 --topic test\n\n\n1\n\n\n消费消息（从头消费）—— 老版本\n\nbin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning\n\n\n1\n\n\n消费消息（从头消费）—— 新版本\n\nbin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning [--consumer-property group.id=testgroup] [--consumer-property client.id=consumer-1]\n\n# 指定消费者组、以及客户端编号\nbin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning --consumer-property group.id=testgroup --consumer-property client.id=consumer-1\n\n\n1\n2\n3\n4\n\n\n\n# 3. 其他命令\n\n查看消费者组列表\n\nbin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list\n\n\n1\n\n\n查看某一消费者组的消费偏移量（消费偏移量是和消费者组绑定的）\n\nbin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group testgroup\n\n\n1\n\n\n查看 topic 描述 信息\n\nbin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic test\n\n\n1\n\n\n查看启动kafka进程\n\njps\njps -vm\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"kafka客户端示例代码",frontmatter:{title:"kafka客户端示例代码",date:"2022-02-03T22:34:32.000Z",permalink:"/pages/4975ea/",categories:["框架","Kafka"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/60.Kafka/20.kafka%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81.html",relativePath:"10.框架/60.Kafka/20.kafka客户端示例代码.md",key:"v-2fe45ff3",path:"/pages/4975ea/",headers:[{level:3,title:"发送端",slug:"发送端",normalizedTitle:"发送端",charIndex:59},{level:3,title:"消费端",slug:"消费端",normalizedTitle:"消费端",charIndex:3004}],headersStr:"发送端 消费端",content:'http://kafka.apache.org/documentation.html#producerapi\n\n\n# 发送端\n\nhttp://kafka.apache.org/23/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html\n\npackage com.ceair.screen.flight.service.impl;\n\nimport org.apache.kafka.clients.producer.*;\n\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\n\n\n/**\n * 代码API发送消息\n */\npublic class KafkaMessageProducer {\n\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n\n        Properties props = new Properties();\n        //props.put("bootstrap.servers", "192.168.229.130:9092,192.168.229.130:9093,192.168.229.130:9094");\n        props.put("bootstrap.servers", "192.168.229.130:9092");\n        //props.put("acks", "all");\n        props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");\n        props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");\n\n        Producer<String, String> producer = new KafkaProducer<>(props);\n        for (int i = 0; i < 5; i++) {\n            // 同步方式发送消息\n            ProducerRecord<String, String> producerRecord = new ProducerRecord<String, String>("code-test-topic", 0, Integer.toString(i), Integer.toString(i));\n\n            // 同步发送消息\n            sendSync(producerRecord, producer);\n            // 异步发送消息\n            //sendAsync(producerRecord, producer);\n        }\n        producer.close();\n    }\n\n    /**\n     * 同步发送消息\n     *\n     * @param producerRecord\n     */\n    private static void sendSync(ProducerRecord<String, String> producerRecord, Producer<String, String> producer) throws ExecutionException, InterruptedException {\n\n        Future<RecordMetadata> result = producer.send(producerRecord);\n        // 等待消息发送成功的同步阻塞方法\n        RecordMetadata metadata = result.get();\n        System.out.println("同步方式发送消息结果：" + "topic-" + metadata.topic() + "|partition-"\n                + metadata.partition() + "|offset-" + metadata.offset());\n    }\n\n    /**\n     * 异步发送消息\n     *\n     * @param producerRecord\n     */\n    private static void sendAsync(ProducerRecord<String, String> producerRecord, Producer<String, String> producer) {\n\n        // 异步方式发送消息\n        producer.send(producerRecord, new Callback() {\n            @Override\n            public void onCompletion(RecordMetadata metadata, Exception exception) {\n                if (exception != null) {\n                    System.err.println("发送消息失败：" + exception.getStackTrace());\n                }\n                if (metadata != null) {\n                    System.out.println("异步方式发送消息结果：" + "topic-" + metadata.topic() + "|partition-"\n                            + metadata.partition() + "|offset-" + metadata.offset());\n                }\n            }\n        });\n    }\n}\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n\n# 消费端\n\nhttp://kafka.apache.org/23/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html\n\npackage com.ceair.screen.flight.service.impl;\n\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\n\nimport java.util.Arrays;\nimport java.util.Properties;\n\npublic class KafkaMessageConsumer {\n\n    public static void main(String[] args) {\n\n        Properties props = new Properties();\n        props.put("bootstrap.servers", "192.168.229.130:9092,192.168.229.130:9093,192.168.229.130:9094");\n        // 消费分组名\n        props.put("group.id", "testGroup");\n\n        props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");\n        props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");\n\n        // 默认自动提交offset\n        //props.put("enable.auto.commit", "false");\n        // 是否自动提交offset\n        //props.put("enable.auto.commit", "true");\n        // 自动提交offset的间隔时间\n        //props.put("auto.commit.interval.ms", "1000");\n\n        KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);\n        // 消费主题\n        consumer.subscribe(Arrays.asList("code-test-topic"));\n        // 消费指定分区\n        //consumer.assign(Arrays.asList(new TopicPartition("topic-replica-zhuge2", 0)));\n        while (true) {\n\t\t\t/*\n\t\t\t * poll() API 是拉取消息的长轮询，主要是判断consumer是否还活着，只要我们持续调用poll()，消费者就会存活在自己所在的group中，\n\t\t\t * 并且持续的消费指定partition的消息。底层是这么做的：消费者向server持续发送心跳，如果一个时间段（session.\n\t\t\t * timeout.ms）consumer挂掉或是不能发送心跳，这个消费者会被认为是挂掉了，\n\t\t\t * 这个Partition也会被重新分配给其他consumer\n\t\t\t */\n            ConsumerRecords<String, String> records = consumer.poll(1000);\n            for (ConsumerRecord<String, String> record : records) {\n                System.out.printf("offset = %d, key = %s, value = %s%n", record.offset(), record.key(), record.value());\n            }\n            if (records.count() > 0) {\n                // 提交offset\n                consumer.commitSync();\n            }\n\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n',normalizedContent:'http://kafka.apache.org/documentation.html#producerapi\n\n\n# 发送端\n\nhttp://kafka.apache.org/23/javadoc/index.html?org/apache/kafka/clients/producer/kafkaproducer.html\n\npackage com.ceair.screen.flight.service.impl;\n\nimport org.apache.kafka.clients.producer.*;\n\nimport java.util.properties;\nimport java.util.concurrent.executionexception;\nimport java.util.concurrent.future;\n\n\n/**\n * 代码api发送消息\n */\npublic class kafkamessageproducer {\n\n    public static void main(string[] args) throws interruptedexception, executionexception {\n\n        properties props = new properties();\n        //props.put("bootstrap.servers", "192.168.229.130:9092,192.168.229.130:9093,192.168.229.130:9094");\n        props.put("bootstrap.servers", "192.168.229.130:9092");\n        //props.put("acks", "all");\n        props.put("key.serializer", "org.apache.kafka.common.serialization.stringserializer");\n        props.put("value.serializer", "org.apache.kafka.common.serialization.stringserializer");\n\n        producer<string, string> producer = new kafkaproducer<>(props);\n        for (int i = 0; i < 5; i++) {\n            // 同步方式发送消息\n            producerrecord<string, string> producerrecord = new producerrecord<string, string>("code-test-topic", 0, integer.tostring(i), integer.tostring(i));\n\n            // 同步发送消息\n            sendsync(producerrecord, producer);\n            // 异步发送消息\n            //sendasync(producerrecord, producer);\n        }\n        producer.close();\n    }\n\n    /**\n     * 同步发送消息\n     *\n     * @param producerrecord\n     */\n    private static void sendsync(producerrecord<string, string> producerrecord, producer<string, string> producer) throws executionexception, interruptedexception {\n\n        future<recordmetadata> result = producer.send(producerrecord);\n        // 等待消息发送成功的同步阻塞方法\n        recordmetadata metadata = result.get();\n        system.out.println("同步方式发送消息结果：" + "topic-" + metadata.topic() + "|partition-"\n                + metadata.partition() + "|offset-" + metadata.offset());\n    }\n\n    /**\n     * 异步发送消息\n     *\n     * @param producerrecord\n     */\n    private static void sendasync(producerrecord<string, string> producerrecord, producer<string, string> producer) {\n\n        // 异步方式发送消息\n        producer.send(producerrecord, new callback() {\n            @override\n            public void oncompletion(recordmetadata metadata, exception exception) {\n                if (exception != null) {\n                    system.err.println("发送消息失败：" + exception.getstacktrace());\n                }\n                if (metadata != null) {\n                    system.out.println("异步方式发送消息结果：" + "topic-" + metadata.topic() + "|partition-"\n                            + metadata.partition() + "|offset-" + metadata.offset());\n                }\n            }\n        });\n    }\n}\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n\n# 消费端\n\nhttp://kafka.apache.org/23/javadoc/index.html?org/apache/kafka/clients/consumer/kafkaconsumer.html\n\npackage com.ceair.screen.flight.service.impl;\n\nimport org.apache.kafka.clients.consumer.consumerrecord;\nimport org.apache.kafka.clients.consumer.consumerrecords;\nimport org.apache.kafka.clients.consumer.kafkaconsumer;\n\nimport java.util.arrays;\nimport java.util.properties;\n\npublic class kafkamessageconsumer {\n\n    public static void main(string[] args) {\n\n        properties props = new properties();\n        props.put("bootstrap.servers", "192.168.229.130:9092,192.168.229.130:9093,192.168.229.130:9094");\n        // 消费分组名\n        props.put("group.id", "testgroup");\n\n        props.put("key.deserializer", "org.apache.kafka.common.serialization.stringdeserializer");\n        props.put("value.deserializer", "org.apache.kafka.common.serialization.stringdeserializer");\n\n        // 默认自动提交offset\n        //props.put("enable.auto.commit", "false");\n        // 是否自动提交offset\n        //props.put("enable.auto.commit", "true");\n        // 自动提交offset的间隔时间\n        //props.put("auto.commit.interval.ms", "1000");\n\n        kafkaconsumer<string, string> consumer = new kafkaconsumer<>(props);\n        // 消费主题\n        consumer.subscribe(arrays.aslist("code-test-topic"));\n        // 消费指定分区\n        //consumer.assign(arrays.aslist(new topicpartition("topic-replica-zhuge2", 0)));\n        while (true) {\n\t\t\t/*\n\t\t\t * poll() api 是拉取消息的长轮询，主要是判断consumer是否还活着，只要我们持续调用poll()，消费者就会存活在自己所在的group中，\n\t\t\t * 并且持续的消费指定partition的消息。底层是这么做的：消费者向server持续发送心跳，如果一个时间段（session.\n\t\t\t * timeout.ms）consumer挂掉或是不能发送心跳，这个消费者会被认为是挂掉了，\n\t\t\t * 这个partition也会被重新分配给其他consumer\n\t\t\t */\n            consumerrecords<string, string> records = consumer.poll(1000);\n            for (consumerrecord<string, string> record : records) {\n                system.out.printf("offset = %d, key = %s, value = %s%n", record.offset(), record.key(), record.value());\n            }\n            if (records.count() > 0) {\n                // 提交offset\n                consumer.commitsync();\n            }\n\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/fb3719/"},regularPath:"/10.%E6%A1%86%E6%9E%B6/65.Apollo/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"10.框架/65.Apollo/10.Redis高级客户端Lettuce详解.md",key:"v-350792bc",path:"/pages/fb3719/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/7f0c55/"},regularPath:"/10.%E6%A1%86%E6%9E%B6/70.%E5%A4%A7%E6%95%B0%E6%8D%AE/05.Hbase/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"10.框架/70.大数据/05.Hbase/10.Redis高级客户端Lettuce详解.md",key:"v-3913f24b",path:"/pages/7f0c55/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"布隆过滤器",frontmatter:{title:"布隆过滤器",date:"2022-02-03T23:04:42.000Z",permalink:"/pages/d09904/",categories:["框架","Redis"],tags:[null]},regularPath:"/10.%E6%A1%86%E6%9E%B6/40.Redis/20.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.html",relativePath:"10.框架/40.Redis/20.布隆过滤器.md",key:"v-fa3822fc",path:"/pages/d09904/",headers:[{level:3,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:29},{level:3,title:"BloomFilterHelper",slug:"bloomfilterhelper",normalizedTitle:"bloomfilterhelper",charIndex:377},{level:3,title:"RedisService",slug:"redisservice",normalizedTitle:"redisservice",charIndex:2299}],headersStr:"前言 BloomFilterHelper RedisService",content:' * 基于Redis的BloomFilter实现\n\n\n# 前言\n\n最近在研究布隆过滤器（如果不了解什么是布隆过滤器的，推荐看这篇如何判断一个元素在亿级数据中是否存在？了解），发现Guava提供了封装好的类，但是只能单机使用，一般现在的应用都是部署在分布式系统的，所以想找个可以在分布式系统下使用的布隆过滤器，找了半天只找到一个基于redis开发的模块项目ReBloom，但是这个是需要额外安装的，而且文档里只说了怎么在docker下运行，没研究过docker所以放弃了。后来找到一篇博客讲怎么利用布隆过滤器统计消息未读数的（博客地址不记得了，是一位淘宝同学写的），博客最后放了一份整合redis和bloomFilter的代码demo，详见BloomFilter.java，看了下实现比较简单，但是使用方式不是我想要的，所以参考着自己整理了一份。\n\n\n# BloomFilterHelper\n\npackage com.doodl6.springmvc.service.cache.redis;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.hash.Funnel;\nimport com.google.common.hash.Hashing;\n\npublic class BloomFilterHelper<T> {\n\n    private int numHashFunctions;\n\n    private int bitSize;\n\n    private Funnel<T> funnel;\n\n    public BloomFilterHelper(Funnel<T> funnel, int expectedInsertions, double fpp) {\n        Preconditions.checkArgument(funnel != null, "funnel不能为空");\n        this.funnel = funnel;\n        bitSize = optimalNumOfBits(expectedInsertions, fpp);\n        numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, bitSize);\n    }\n\n    int[] murmurHashOffset(T value) {\n        int[] offset = new int[numHashFunctions];\n\n        long hash64 = Hashing.murmur3_128().hashObject(value, funnel).asLong();\n        int hash1 = (int) hash64;\n        int hash2 = (int) (hash64 >>> 32);\n        for (int i = 1; i <= numHashFunctions; i++) {\n            int nextHash = hash1 + i * hash2;\n            if (nextHash < 0) {\n                nextHash = ~nextHash;\n            }\n            offset[i - 1] = nextHash % bitSize;\n        }\n\n        return offset;\n    }\n\n    /**\n     * 计算bit数组长度\n     */\n    private int optimalNumOfBits(long n, double p) {\n        if (p == 0) {\n            p = Double.MIN_VALUE;\n        }\n        return (int) (-n * Math.log(p) / (Math.log(2) * Math.log(2)));\n    }\n\n    /**\n     * 计算hash方法执行次数\n     */\n    private int optimalNumOfHashFunctions(long n, long m) {\n        return Math.max(1, (int) Math.round((double) m / n * Math.log(2)));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\nBloomFilterHelper是实现功能的关键，包含了计算bitmap的核心算法，其实大部分代码都是来源于Guava库里面的BloomFilterStrategies类，但是因为这个类是专门为Guava的BloomFilter类使用的，所以没有对外暴露一些重要的算法逻辑。\n\n再来看怎么结合redis一起使用BloomFilterHelper\n\n\n# RedisService\n\npackage com.doodl6.springmvc.service.cache.redis;\n\nimport com.google.common.base.Preconditions;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.Resource;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\n@Service\npublic class RedisService {\n\n    @Resource\n    private RedisTemplate<String, Object> redisTemplate;\n\n    /**\n     * 根据给定的布隆过滤器添加值\n     */\n    public <T> void addByBloomFilter(BloomFilterHelper<T> bloomFilterHelper, String key, T value) {\n        Preconditions.checkArgument(bloomFilterHelper != null, "bloomFilterHelper不能为空");\n        int[] offset = bloomFilterHelper.murmurHashOffset(value);\n        for (int i : offset) {\n            redisTemplate.opsForValue().setBit(key, i, true);\n        }\n    }\n\n    /**\n     * 根据给定的布隆过滤器判断值是否存在\n     */\n    public <T> boolean includeByBloomFilter(BloomFilterHelper<T> bloomFilterHelper, String key, T value) {\n        Preconditions.checkArgument(bloomFilterHelper != null, "bloomFilterHelper不能为空");\n        int[] offset = bloomFilterHelper.murmurHashOffset(value);\n        for (int i : offset) {\n            if (!redisTemplate.opsForValue().getBit(key, i)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\nRedisService很简单，只有两个方法\n\naddByBloomFilter，往redis里面添加元素\n\nincludeByBloomFilter，检查元素是否在redis bloomFilter里面\n\n这里redis的客户端使用的是spring-data-redis封装的，可以在我的项目SpringMVC-Project中查看完整的使用代码。',normalizedContent:' * 基于redis的bloomfilter实现\n\n\n# 前言\n\n最近在研究布隆过滤器（如果不了解什么是布隆过滤器的，推荐看这篇如何判断一个元素在亿级数据中是否存在？了解），发现guava提供了封装好的类，但是只能单机使用，一般现在的应用都是部署在分布式系统的，所以想找个可以在分布式系统下使用的布隆过滤器，找了半天只找到一个基于redis开发的模块项目rebloom，但是这个是需要额外安装的，而且文档里只说了怎么在docker下运行，没研究过docker所以放弃了。后来找到一篇博客讲怎么利用布隆过滤器统计消息未读数的（博客地址不记得了，是一位淘宝同学写的），博客最后放了一份整合redis和bloomfilter的代码demo，详见bloomfilter.java，看了下实现比较简单，但是使用方式不是我想要的，所以参考着自己整理了一份。\n\n\n# bloomfilterhelper\n\npackage com.doodl6.springmvc.service.cache.redis;\n\nimport com.google.common.base.preconditions;\nimport com.google.common.hash.funnel;\nimport com.google.common.hash.hashing;\n\npublic class bloomfilterhelper<t> {\n\n    private int numhashfunctions;\n\n    private int bitsize;\n\n    private funnel<t> funnel;\n\n    public bloomfilterhelper(funnel<t> funnel, int expectedinsertions, double fpp) {\n        preconditions.checkargument(funnel != null, "funnel不能为空");\n        this.funnel = funnel;\n        bitsize = optimalnumofbits(expectedinsertions, fpp);\n        numhashfunctions = optimalnumofhashfunctions(expectedinsertions, bitsize);\n    }\n\n    int[] murmurhashoffset(t value) {\n        int[] offset = new int[numhashfunctions];\n\n        long hash64 = hashing.murmur3_128().hashobject(value, funnel).aslong();\n        int hash1 = (int) hash64;\n        int hash2 = (int) (hash64 >>> 32);\n        for (int i = 1; i <= numhashfunctions; i++) {\n            int nexthash = hash1 + i * hash2;\n            if (nexthash < 0) {\n                nexthash = ~nexthash;\n            }\n            offset[i - 1] = nexthash % bitsize;\n        }\n\n        return offset;\n    }\n\n    /**\n     * 计算bit数组长度\n     */\n    private int optimalnumofbits(long n, double p) {\n        if (p == 0) {\n            p = double.min_value;\n        }\n        return (int) (-n * math.log(p) / (math.log(2) * math.log(2)));\n    }\n\n    /**\n     * 计算hash方法执行次数\n     */\n    private int optimalnumofhashfunctions(long n, long m) {\n        return math.max(1, (int) math.round((double) m / n * math.log(2)));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\nbloomfilterhelper是实现功能的关键，包含了计算bitmap的核心算法，其实大部分代码都是来源于guava库里面的bloomfilterstrategies类，但是因为这个类是专门为guava的bloomfilter类使用的，所以没有对外暴露一些重要的算法逻辑。\n\n再来看怎么结合redis一起使用bloomfilterhelper\n\n\n# redisservice\n\npackage com.doodl6.springmvc.service.cache.redis;\n\nimport com.google.common.base.preconditions;\nimport org.springframework.data.redis.core.redistemplate;\nimport org.springframework.stereotype.service;\n\nimport javax.annotation.resource;\nimport java.util.collection;\nimport java.util.map;\nimport java.util.concurrent.timeunit;\n\n@service\npublic class redisservice {\n\n    @resource\n    private redistemplate<string, object> redistemplate;\n\n    /**\n     * 根据给定的布隆过滤器添加值\n     */\n    public <t> void addbybloomfilter(bloomfilterhelper<t> bloomfilterhelper, string key, t value) {\n        preconditions.checkargument(bloomfilterhelper != null, "bloomfilterhelper不能为空");\n        int[] offset = bloomfilterhelper.murmurhashoffset(value);\n        for (int i : offset) {\n            redistemplate.opsforvalue().setbit(key, i, true);\n        }\n    }\n\n    /**\n     * 根据给定的布隆过滤器判断值是否存在\n     */\n    public <t> boolean includebybloomfilter(bloomfilterhelper<t> bloomfilterhelper, string key, t value) {\n        preconditions.checkargument(bloomfilterhelper != null, "bloomfilterhelper不能为空");\n        int[] offset = bloomfilterhelper.murmurhashoffset(value);\n        for (int i : offset) {\n            if (!redistemplate.opsforvalue().getbit(key, i)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\nredisservice很简单，只有两个方法\n\naddbybloomfilter，往redis里面添加元素\n\nincludebybloomfilter，检查元素是否在redis bloomfilter里面\n\n这里redis的客户端使用的是spring-data-redis封装的，可以在我的项目springmvc-project中查看完整的使用代码。',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/466af9/"},regularPath:"/10.%E6%A1%86%E6%9E%B6/70.%E5%A4%A7%E6%95%B0%E6%8D%AE/10.Spark/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"10.框架/70.大数据/10.Spark/10.Redis高级客户端Lettuce详解.md",key:"v-614b0a72",path:"/pages/466af9/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/d96f04/"},regularPath:"/10.%E6%A1%86%E6%9E%B6/70.%E5%A4%A7%E6%95%B0%E6%8D%AE/15.ClickHouse/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"10.框架/70.大数据/15.ClickHouse/10.Redis高级客户端Lettuce详解.md",key:"v-36fb0f35",path:"/pages/d96f04/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git使用手册",frontmatter:{title:"Git使用手册",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/9a7ee40fc232253e",categories:["技术","技术文档"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/100.%E5%85%B6%E4%BB%96/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/01.Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html",relativePath:"100.其他/01.技术文档/01.Git使用手册.md",key:"v-47148396",path:"/pages/9a7ee40fc232253e/",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:14},{level:2,title:"创建版本库（仓库）",slug:"创建版本库-仓库",normalizedTitle:"创建版本库（仓库）",charIndex:296},{level:2,title:"添加文件到仓库",slug:"添加文件到仓库",normalizedTitle:"添加文件到仓库",charIndex:478},{level:2,title:"版本管理",slug:"版本管理",normalizedTitle:"版本管理",charIndex:819},{level:2,title:"远程仓库",slug:"远程仓库",normalizedTitle:"远程仓库",charIndex:1714},{level:2,title:"分支管理",slug:"分支管理",normalizedTitle:"分支管理",charIndex:2960},{level:2,title:"帮助命令",slug:"帮助命令",normalizedTitle:"帮助命令",charIndex:3360},{level:2,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:7031}],excerpt:'<h1 id="git使用手册"><a class="header-anchor" href="#git使用手册">#</a> Git使用手册</h1>\n<h2 id="安装"><a class="header-anchor" href="#安装">#</a> 安装</h2>\n<p>官网下载：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener noreferrer">https://git-scm.com/downloads<OutboundLink/></a> 下载完成后使用默认进行安装。</p>\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n还需要最后一步设置，在命令行输入：</p>\n\x3c!--beforebegin--\x3e<div class="language-bash line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-bash"><code><span class="token function">git</span> config --global user.name <span class="token string">"Your Name"</span>\n<span class="token function">git</span> config --global user.email <span class="token string">"email@example.com"</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\n',headersStr:"安装 创建版本库（仓库） 添加文件到仓库 版本管理 远程仓库 分支管理 帮助命令 参考文档",content:"# Git使用手册\n\n\n# 安装\n\n官网下载：https://git-scm.com/downloads 下载完成后使用默认进行安装。\n\n安装完成后，在开始菜单里找到 Git -> Git Bash，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 还需要最后一步设置，在命令行输入：\n\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n\n\n1\n2\n\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\n\n\n# 创建版本库（仓库）\n\n# 创建仓库\nmkdir <仓库name> \n\n# 进入仓库\ncd <仓库name>\n\n# 此命令用于显示当前目录\npwd\n\n# 把当前目录初始化成Git仓库\ngit init\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录直接git init也是可以的。\n\n\n# 添加文件到仓库\n\n在仓库目录下放入文件，如新建一个test.txt文件，然后使用git add test.txt命令告诉Git，把文件添加到缓存区，然后使用git commit -m \"提交描述\"告诉Git，把文件提交到仓库。\n\n# 添加指定文件或文件夹到缓存区，文件需添加后缀\ngit add <文件或文件夹name>                   # 单个文件\ngit add <文件或文件夹name> <文件或文件夹name>  # 多个文件\n\n# 或 全部文件同时添加到缓存区\ngit add .\n\n# 把文件从缓存区提交至仓库\ngit commit -m \"提交描述\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 提交描述规范\n\n在提交代码时输入清晰的说明有利于版本管理，建议搭配如下关键字编写提交描述\n\n# 新建(add)\n# 删除(rm)\n# 更新(update)\n# 改动(change)\n# 实现\n# 发布\n# 修复\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 版本管理\n\n# 提交修改\n\n如修改test.txt的内容后，运行git status命令看看被修改的文件，然后再使用git add test.txt、 git commit -m \"修改描述\"把修改后的文件提交到仓库，提交后可再次使用git status查看当前状态。\n\n# 显示 新增/删除/被改动等 的文件\ngit status\n\n\n1\n2\n\n\n# 查看版本记录\n\n# 查看版本记录\ngit log   # 显示版本号、提交时间等信息\n\n\n1\n2\n\n\n> 也可使用可视化工具查看Git版本历史： 在仓库目录右键 > Git BUI Here\n\n# 回退版本\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n# 回退到上一个版本\n$ git reset --hard HEAD^\n\n\n1\n2\n\n\n此时查看git log记录发现，原来最新的版本已经没有了，想回到原来最新的版本怎么办？这就需要知道最新的版本的版本号\n\n# 跳转到指定版本\ngit reset --hard <版本号前几位>\n\n\n1\n2\n\n\n但是不知道版本号怎么办？Git提供了一个命令git reflog用来记录你的每一次命令\n\ngit reflog\n\n\n1\n\n\n# 撤销修改\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/897889638509536\n\n# 删除文件\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/900002180232448\n\n\n# 远程仓库\n\n# SSH验证\n\n使本机能关联远程仓库，首次需要SSH验证\n\n * 第1步：创建SSH Key。在用户主（C:\\Users\\dell）目录下，看看有没有.ssh目录， 如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。 如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n# 创建SSH Key\nssh-keygen -t rsa -C \"邮件地址\"\n\n\n1\n2\n\n * 第2步：登陆GitHub，右上角头像 > settings > SSH and GPG keys >Add SSH Key，在key的文本框里粘贴id_rsa.pub文件的内容\n\n# 关联远程仓库\n\nSSH验证完成后，在github创建仓库，创建仓库时记得取消 Initialize this repository with a README的勾选，然后在本地命令：\n\n# 关联远程仓库，仓库名一般使用origin\ngit remote add <仓库名> <远程仓库地址>\n\n# 示例\ngit remote add origin git@github.com:xugaoyi/test.git\n\n\n1\n2\n3\n4\n5\n\n\n下一步，就可以把本地库的所有内容推送到远程库上\n\n# 把文件推送到远程仓库\ngit push -u <仓库名> <分支名>\n\n# 示例\ngit push -u origin master\n\n\n1\n2\n3\n4\n5\n\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n> 前提是目录已经git init初始化成仓库，并且git status状态是没有改动的，如果有改动则先git add .添加至缓存区，git commit -m '提交描述'提交至仓库，然后执行上面命令。\n> \n> 如创建仓库时勾选了 Initialize this repository with a README 则需先拉取README.md文件到本地仓库git pull\n> \n> 可关联多个远程仓库，注意给不同的远程仓库取不一样的名称，提交是分别按名称提交到不一样的远程仓库。\n\n# 简化的推送命令\ngit push\n\n\n1\n2\n\n\n# 查看远程仓库\n\n# 查看远程仓库\ngit remote -v\n\n\n1\n2\n\n\n# 删除远程仓库\n\n# 删除远程仓库\ngit remote rm <仓库名>\n\n\n1\n2\n\n\n# 从远程库克隆项目\n\n# 从远程库克隆项目\ngit clone <仓库地址>\n\n\n1\n2\n\n\n# 克隆指定分支\n\n# 克隆指定分支\ngit clone -b <分支名> <仓库地址>\n\n\n1\n2\n\n\n\n# 分支管理\n\n# 创建分支\n\n# 创建分支\ngit checkout -b <分支名>\n\n\n1\n2\n\n\n# 查看分支\n\n# 查看分支\ngit branch\n\n\n1\n2\n\n\n查看分支时，在分支前带 * 号的表示当前的分支\n\n# 切换分支\n\n# 切换分支\ngit checkout <分支名>\n\n\n1\n2\n\n\n# 合并分支\n\n# 合并本地的分支\ngit merge <分支名>\n\n# 合并远程的分支\ngit merge <远程仓库名>/<分支名>\n\n\n1\n2\n3\n4\n5\n\n\n注意，是将指定分支合并到当前分支，并非当前分支合并到指定分支。\n\n一般情况下是把当前分支切换到主分支，然后把子分支合并到主分支。\n\n# 删除分支\n\n# 删除分支\ngit branch -d <分支名>\n\n\n1\n2\n\n\n# 修改分支名\n\n# 修改分支名\ngit branch -m <原分支名> <新分支名>\n\n\n1\n2\n\n\n\n# 帮助命令\n\n如对命令不清楚时，可使用git help命令显示出git命令介绍。\n\n# 帮助命令\ngit help\n\n\n1\n2\n\n\n$ git help\nusage: git [--version] [--help] [-C <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\nThese are common Git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone      Clone a repository into a new directory\n   init       Create an empty Git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add        Add file contents to the index\n   mv         Move or rename a file, a directory, or a symlink\n   reset      Reset current HEAD to the specified state\n   rm         Remove files from the working tree and from the index\n\nexamine the history and state (see also: git help revisions)\n   bisect     Use binary search to find the commit that introduced a bug\n   grep       Print lines matching a pattern\n   log        Show commit logs\n   show       Show various types of objects\n   status     Show the working tree status\n\ngrow, mark and tweak your common history\n   branch     List, create, or delete branches\n   checkout   Switch branches or restore working tree files\n   commit     Record changes to the repository\n   diff       Show changes between commits, commit and working tree, etc\n   merge      Join two or more development histories together\n   rebase     Reapply commits on top of another base tip\n   tag        Create, list, delete or verify a tag object signed with GPG\n\ncollaborate (see also: git help workflows)\n   fetch      Download objects and refs from another repository\n   pull       Fetch from and integrate with another repository or a local branch\n   push       Update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. See 'git help <command>' or 'git help <concept>'\nto read about a specific subcommand or concept.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n翻译工具翻译中文\n\n$ git help\n使用：git [--version] [--help] [-C <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\n这些是在各种情况下使用的通用Git命令：\n\nstart a working area (参见命令: git help tutorial)\n   clone      将存储库克隆到新目录中\n   init       创建一个空的Git存储库或重新初始化一个现有的存储库\n\nwork on the current change (参见命令: git help everyday)\n   add        将文件内容添加到索引中\n   mv         移动或重命名文件、目录或符号链接\n   reset      将当前磁头重置为指定状态\n   rm         从工作树和索引中删除文件\n\nexamine the history and state (参见命令: git help revisions)\n   bisect     使用二分查找查找引入错误的提交\n   grep       打印与模式匹配的行\n   log        显示提交日志\n   show       显示各种类型的对象\n   status     显示工作树状态\n\ngrow, mark and tweak your common history\n   branch     列出、创建或删除分支\n   checkout   切换分支或还原工作树文件\n   commit     记录对存储库的更改\n   diff       显示提交、提交和工作树等之间的更改\n   merge      将两个或多个开发历史连接在一起\n   rebase     在另一个基本提示之上重新应用提交\n   tag        创建、列表、删除或验证用GPG签名的标记对象\n\ncollaborate (参见命令: git help workflows)\n   fetch      从另一个存储库下载对象和引用\n   pull       从另一个存储库或本地分支获取并与之集成\n   push       更新远程引用和相关对象\n\n'git help -a' 和 'git help -g' 列出可用的子命令和一些概念指导。\n命令'git help <command>' 或 'git help <concept>' 查看特定子命令或概念.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 参考文档\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600",normalizedContent:"# git使用手册\n\n\n# 安装\n\n官网下载：https://git-scm.com/downloads 下载完成后使用默认进行安装。\n\n安装完成后，在开始菜单里找到 git -> git bash，蹦出一个类似命令行窗口的东西，就说明git安装成功！ 还需要最后一步设置，在命令行输入：\n\ngit config --global user.name \"your name\"\ngit config --global user.email \"email@example.com\"\n\n\n1\n2\n\n\n因为git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和email地址。\n\n\n# 创建版本库（仓库）\n\n# 创建仓库\nmkdir <仓库name> \n\n# 进入仓库\ncd <仓库name>\n\n# 此命令用于显示当前目录\npwd\n\n# 把当前目录初始化成git仓库\ngit init\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 也不一定必须在空目录下创建git仓库，选择一个已经有东西的目录直接git init也是可以的。\n\n\n# 添加文件到仓库\n\n在仓库目录下放入文件，如新建一个test.txt文件，然后使用git add test.txt命令告诉git，把文件添加到缓存区，然后使用git commit -m \"提交描述\"告诉git，把文件提交到仓库。\n\n# 添加指定文件或文件夹到缓存区，文件需添加后缀\ngit add <文件或文件夹name>                   # 单个文件\ngit add <文件或文件夹name> <文件或文件夹name>  # 多个文件\n\n# 或 全部文件同时添加到缓存区\ngit add .\n\n# 把文件从缓存区提交至仓库\ngit commit -m \"提交描述\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 提交描述规范\n\n在提交代码时输入清晰的说明有利于版本管理，建议搭配如下关键字编写提交描述\n\n# 新建(add)\n# 删除(rm)\n# 更新(update)\n# 改动(change)\n# 实现\n# 发布\n# 修复\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 版本管理\n\n# 提交修改\n\n如修改test.txt的内容后，运行git status命令看看被修改的文件，然后再使用git add test.txt、 git commit -m \"修改描述\"把修改后的文件提交到仓库，提交后可再次使用git status查看当前状态。\n\n# 显示 新增/删除/被改动等 的文件\ngit status\n\n\n1\n2\n\n\n# 查看版本记录\n\n# 查看版本记录\ngit log   # 显示版本号、提交时间等信息\n\n\n1\n2\n\n\n> 也可使用可视化工具查看git版本历史： 在仓库目录右键 > git bui here\n\n# 回退版本\n\n首先，git必须知道当前版本是哪个版本，在git中，用head表示当前版本，也就是最新的提交1094adb...（注意我的提交id和你的肯定不一样），上一个版本就是head^，上上一个版本就是head^^，当然往上100个版本写100个^比较容易数不过来，所以写成head~100。\n\n# 回退到上一个版本\n$ git reset --hard head^\n\n\n1\n2\n\n\n此时查看git log记录发现，原来最新的版本已经没有了，想回到原来最新的版本怎么办？这就需要知道最新的版本的版本号\n\n# 跳转到指定版本\ngit reset --hard <版本号前几位>\n\n\n1\n2\n\n\n但是不知道版本号怎么办？git提供了一个命令git reflog用来记录你的每一次命令\n\ngit reflog\n\n\n1\n\n\n# 撤销修改\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/897889638509536\n\n# 删除文件\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/900002180232448\n\n\n# 远程仓库\n\n# ssh验证\n\n使本机能关联远程仓库，首次需要ssh验证\n\n * 第1步：创建ssh key。在用户主（c:\\users\\dell）目录下，看看有没有.ssh目录， 如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。 如果没有，打开shell（windows下打开git bash），创建ssh key：\n\n# 创建ssh key\nssh-keygen -t rsa -c \"邮件地址\"\n\n\n1\n2\n\n * 第2步：登陆github，右上角头像 > settings > ssh and gpg keys >add ssh key，在key的文本框里粘贴id_rsa.pub文件的内容\n\n# 关联远程仓库\n\nssh验证完成后，在github创建仓库，创建仓库时记得取消 initialize this repository with a readme的勾选，然后在本地命令：\n\n# 关联远程仓库，仓库名一般使用origin\ngit remote add <仓库名> <远程仓库地址>\n\n# 示例\ngit remote add origin git@github.com:xugaoyi/test.git\n\n\n1\n2\n3\n4\n5\n\n\n下一步，就可以把本地库的所有内容推送到远程库上\n\n# 把文件推送到远程仓库\ngit push -u <仓库名> <分支名>\n\n# 示例\ngit push -u origin master\n\n\n1\n2\n3\n4\n5\n\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n> 前提是目录已经git init初始化成仓库，并且git status状态是没有改动的，如果有改动则先git add .添加至缓存区，git commit -m '提交描述'提交至仓库，然后执行上面命令。\n> \n> 如创建仓库时勾选了 initialize this repository with a readme 则需先拉取readme.md文件到本地仓库git pull\n> \n> 可关联多个远程仓库，注意给不同的远程仓库取不一样的名称，提交是分别按名称提交到不一样的远程仓库。\n\n# 简化的推送命令\ngit push\n\n\n1\n2\n\n\n# 查看远程仓库\n\n# 查看远程仓库\ngit remote -v\n\n\n1\n2\n\n\n# 删除远程仓库\n\n# 删除远程仓库\ngit remote rm <仓库名>\n\n\n1\n2\n\n\n# 从远程库克隆项目\n\n# 从远程库克隆项目\ngit clone <仓库地址>\n\n\n1\n2\n\n\n# 克隆指定分支\n\n# 克隆指定分支\ngit clone -b <分支名> <仓库地址>\n\n\n1\n2\n\n\n\n# 分支管理\n\n# 创建分支\n\n# 创建分支\ngit checkout -b <分支名>\n\n\n1\n2\n\n\n# 查看分支\n\n# 查看分支\ngit branch\n\n\n1\n2\n\n\n查看分支时，在分支前带 * 号的表示当前的分支\n\n# 切换分支\n\n# 切换分支\ngit checkout <分支名>\n\n\n1\n2\n\n\n# 合并分支\n\n# 合并本地的分支\ngit merge <分支名>\n\n# 合并远程的分支\ngit merge <远程仓库名>/<分支名>\n\n\n1\n2\n3\n4\n5\n\n\n注意，是将指定分支合并到当前分支，并非当前分支合并到指定分支。\n\n一般情况下是把当前分支切换到主分支，然后把子分支合并到主分支。\n\n# 删除分支\n\n# 删除分支\ngit branch -d <分支名>\n\n\n1\n2\n\n\n# 修改分支名\n\n# 修改分支名\ngit branch -m <原分支名> <新分支名>\n\n\n1\n2\n\n\n\n# 帮助命令\n\n如对命令不清楚时，可使用git help命令显示出git命令介绍。\n\n# 帮助命令\ngit help\n\n\n1\n2\n\n\n$ git help\nusage: git [--version] [--help] [-c <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -p | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\nthese are common git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone      clone a repository into a new directory\n   init       create an empty git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add        add file contents to the index\n   mv         move or rename a file, a directory, or a symlink\n   reset      reset current head to the specified state\n   rm         remove files from the working tree and from the index\n\nexamine the history and state (see also: git help revisions)\n   bisect     use binary search to find the commit that introduced a bug\n   grep       print lines matching a pattern\n   log        show commit logs\n   show       show various types of objects\n   status     show the working tree status\n\ngrow, mark and tweak your common history\n   branch     list, create, or delete branches\n   checkout   switch branches or restore working tree files\n   commit     record changes to the repository\n   diff       show changes between commits, commit and working tree, etc\n   merge      join two or more development histories together\n   rebase     reapply commits on top of another base tip\n   tag        create, list, delete or verify a tag object signed with gpg\n\ncollaborate (see also: git help workflows)\n   fetch      download objects and refs from another repository\n   pull       fetch from and integrate with another repository or a local branch\n   push       update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. see 'git help <command>' or 'git help <concept>'\nto read about a specific subcommand or concept.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n翻译工具翻译中文\n\n$ git help\n使用：git [--version] [--help] [-c <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -p | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\n这些是在各种情况下使用的通用git命令：\n\nstart a working area (参见命令: git help tutorial)\n   clone      将存储库克隆到新目录中\n   init       创建一个空的git存储库或重新初始化一个现有的存储库\n\nwork on the current change (参见命令: git help everyday)\n   add        将文件内容添加到索引中\n   mv         移动或重命名文件、目录或符号链接\n   reset      将当前磁头重置为指定状态\n   rm         从工作树和索引中删除文件\n\nexamine the history and state (参见命令: git help revisions)\n   bisect     使用二分查找查找引入错误的提交\n   grep       打印与模式匹配的行\n   log        显示提交日志\n   show       显示各种类型的对象\n   status     显示工作树状态\n\ngrow, mark and tweak your common history\n   branch     列出、创建或删除分支\n   checkout   切换分支或还原工作树文件\n   commit     记录对存储库的更改\n   diff       显示提交、提交和工作树等之间的更改\n   merge      将两个或多个开发历史连接在一起\n   rebase     在另一个基本提示之上重新应用提交\n   tag        创建、列表、删除或验证用gpg签名的标记对象\n\ncollaborate (参见命令: git help workflows)\n   fetch      从另一个存储库下载对象和引用\n   pull       从另一个存储库或本地分支获取并与之集成\n   push       更新远程引用和相关对象\n\n'git help -a' 和 'git help -g' 列出可用的子命令和一些概念指导。\n命令'git help <command>' 或 'git help <concept>' 查看特定子命令或概念.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 参考文档\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Markdown使用教程",frontmatter:{title:"Markdown使用教程",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/ad247c4332211551",categories:["技术","技术文档"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/100.%E5%85%B6%E4%BB%96/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/02.Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html",relativePath:"100.其他/01.技术文档/02.Markdown使用教程.md",key:"v-38b5a542",path:"/pages/ad247c4332211551/",headers:[{level:2,title:"一、Markdown",slug:"一、markdown",normalizedTitle:"一、markdown",charIndex:19},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:34},{level:3,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:87},{level:3,title:"编辑器",slug:"编辑器",normalizedTitle:"编辑器",charIndex:152},{level:2,title:"二、徽章",slug:"二、徽章",normalizedTitle:"二、徽章",charIndex:194},{level:2,title:"三、设置目录",slug:"三、设置目录",normalizedTitle:"三、设置目录",charIndex:579},{level:2,title:"四、标题",slug:"四、标题",normalizedTitle:"四、标题",charIndex:1197},{level:2,title:"二级标题",slug:"二级标题",normalizedTitle:"二级标题",charIndex:1215},{level:3,title:"三级标题",slug:"三级标题",normalizedTitle:"三级标题",charIndex:1227},{level:2,title:"五、文本",slug:"五、文本",normalizedTitle:"五、文本",charIndex:1285},{level:3,title:"段落",slug:"段落",normalizedTitle:"段落",charIndex:1297},{level:3,title:"字体",slug:"字体",normalizedTitle:"字体",charIndex:1307},{level:3,title:"删除线",slug:"删除线",normalizedTitle:"删除线",charIndex:1317},{level:3,title:"下划线",slug:"下划线",normalizedTitle:"下划线",charIndex:1328},{level:3,title:"文字高亮",slug:"文字高亮",normalizedTitle:"文字高亮",charIndex:1339},{level:3,title:"分隔线",slug:"分隔线",normalizedTitle:"分隔线",charIndex:1351},{level:3,title:"脚注",slug:"脚注",normalizedTitle:"脚注",charIndex:1362},{level:2,title:"六、列表",slug:"六、列表",normalizedTitle:"六、列表",charIndex:1370},{level:3,title:"无序列表",slug:"无序列表",normalizedTitle:"无序列表",charIndex:1382},{level:3,title:"有序列表",slug:"有序列表",normalizedTitle:"有序列表",charIndex:1394},{level:3,title:"折叠列表",slug:"折叠列表",normalizedTitle:"折叠列表",charIndex:1406},{level:3,title:"带复选框列表",slug:"带复选框列表",normalizedTitle:"带复选框列表",charIndex:1418},{level:3,title:"列表嵌套",slug:"列表嵌套",normalizedTitle:"列表嵌套",charIndex:1432},{level:2,title:"七、区块引用",slug:"七、区块引用",normalizedTitle:"七、区块引用",charIndex:1442},{level:2,title:"八、代码",slug:"八、代码",normalizedTitle:"八、代码",charIndex:1496},{level:3,title:"代码区块",slug:"代码区块",normalizedTitle:"代码区块",charIndex:1508},{level:2,title:"九、链接",slug:"九、链接",normalizedTitle:"九、链接",charIndex:1518},{level:3,title:"变量链接",slug:"变量链接",normalizedTitle:"变量链接",charIndex:1530},{level:3,title:"Github仓库中使用内部链接",slug:"github仓库中使用内部链接",normalizedTitle:"github仓库中使用内部链接",charIndex:4923},{level:3,title:"锚点链接",slug:"锚点链接",normalizedTitle:"锚点链接",charIndex:1563},{level:2,title:"十、图片",slug:"十、图片",normalizedTitle:"十、图片",charIndex:1573},{level:3,title:"图片宽高",slug:"图片宽高",normalizedTitle:"图片宽高",charIndex:1585},{level:3,title:"相对路径以及Github中使用图片",slug:"相对路径以及github中使用图片",normalizedTitle:"相对路径以及github中使用图片",charIndex:1597},{level:2,title:"十一、表格",slug:"十一、表格",normalizedTitle:"十一、表格",charIndex:1620},{level:2,title:"十二、Emoji表情包",slug:"十二、emoji表情包",normalizedTitle:"十二、emoji表情包",charIndex:1631},{level:2,title:"十三、其他技巧",slug:"十三、其他技巧",normalizedTitle:"十三、其他技巧",charIndex:1648},{level:3,title:"支持的 HTML 元素",slug:"支持的-html-元素",normalizedTitle:"支持的 html 元素",charIndex:1663},{level:3,title:"转义",slug:"转义",normalizedTitle:"转义",charIndex:1682},{level:3,title:"数学公式",slug:"数学公式",normalizedTitle:"数学公式",charIndex:1692},{level:3,title:"图表",slug:"图表",normalizedTitle:"图表",charIndex:1704},{level:3,title:"流程图",slug:"流程图",normalizedTitle:"流程图",charIndex:1714},{level:3,title:"时序图",slug:"时序图",normalizedTitle:"时序图",charIndex:1725},{level:3,title:"甘特图",slug:"甘特图",normalizedTitle:"甘特图",charIndex:1736}],excerpt:'<h1 id="markdown使用教程"><a class="header-anchor" href="#markdown使用教程">#</a> Markdown使用教程</h1>\n<h2 id="一、markdown"><a class="header-anchor" href="#一、markdown">#</a> 一、Markdown</h2>\n<h3 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h3>\n<p><img src="https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png" alt="logo"></p>\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\n',headersStr:"一、Markdown 简介 应用 编辑器 二、徽章 三、设置目录 四、标题 二级标题 三级标题 五、文本 段落 字体 删除线 下划线 文字高亮 分隔线 脚注 六、列表 无序列表 有序列表 折叠列表 带复选框列表 列表嵌套 七、区块引用 八、代码 代码区块 九、链接 变量链接 Github仓库中使用内部链接 锚点链接 十、图片 图片宽高 相对路径以及Github中使用图片 十一、表格 十二、Emoji表情包 十三、其他技巧 支持的 HTML 元素 转义 数学公式 图表 流程图 时序图 甘特图",content:"# Markdown使用教程\n\n\n# 一、Markdown\n\n\n# 简介\n\n\n\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\n\n# 应用\n\n当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\n\n\n# 编辑器\n\n推荐使用Typora，官网：https://typora.io/\n\n\n# 二、徽章\n\n# 什么是徽章\n\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\n\n常见于github项目主页，但其不仅出现于 github 项目主页，凡是能够表现图片的地方都可以出现徽章。\n\n# 徽章的使用\n\n * 在markdown中使用\n\n格式:\n[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片\n\n语法：\n[![github](https://img.shields.io/badge/github-xugaoyi-brightgreen.svg)](https://github.com/xugaoyi)\n\n\n1\n2\n3\n4\n5\n\n\n\n\n徽章生成网站：https://shields.io/\n\n本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 戳我 了解。\n\n\n# 三、设置目录\n\n设置之后会根据分级标题来自动生成目录。\n\n[TOC]\n\n\n1\n\n\n> 注：github暂未支持。\n\n[TOC]\n\n在github生成TOC的方法：https://github.com/ekalinin/github-markdown-toc\n\nwindows系统需要基于golang实现的工具：https://github.com/ekalinin/github-markdown-toc.go\n\n> 如果你有GO语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。\n> \n> 如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）\n> \n> 下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。\n> \n> 使用方法：\n> \n>  1. 首先将.md文档复制到gh-md-toc.exe的根目录下\n>  2. 在该目录下打开系统命令行，输入命令：gh-md-toc.exe README.MD 生成目录\n>  3. 把生成的目录复制到.md文件即可。\n\n这是gh-md-toc生成的目录：\n\n * 一、Markdown\n   * 简介\n   * 应用\n   * 编辑器\n * 二、徽章\n   * 什么是徽章\n   * 徽章的使用\n * 三、设置目录\n * 四、标题\n * 一级标题\n   * 二级标题\n     * 三级标题\n       * 四级标题\n         * 五级标题\n           * 六级标题\n   * 五、文本\n     * 段落\n     * 字体\n     * 删除线\n     * 下划线\n     * 文字高亮\n     * 分隔线\n     * 脚注\n   * 六、列表\n     * 无序列表\n     * 有序列表\n     * 折叠列表\n     * 带复选框列表\n     * 列表嵌套\n   * 七、区块引用\n     * 区块嵌套\n     * 区块中使用列表\n     * 列表中使用区块\n   * 八、代码\n     * 代码区块\n   * 九、链接\n     * 变量链接\n     * Github中使用内部链接\n     * 锚点链接\n   * 十、图片\n     * 图片宽高\n     * 相对路径以及Github中使用图片\n   * 十一、表格\n   * 十二、Emoji表情包\n   * 十三、其他技巧\n     * 支持的 HTML 元素\n     * 转义\n     * 数学公式\n     * 图表\n     * 流程图\n     * 时序图\n     * 甘特图\n\n\n# 四、标题\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 一级标题\n\n\n# 二级标题\n\n\n# 三级标题\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n\n# 五、文本\n\n\n# 段落\n\nMarkdown 段落没有特殊的格式，直接编写文字，需要段落缩进时使用2个Tab\n\n\n# 字体\n\n*斜体文本*\n或 _斜体文本_\n**粗体文本**\n或  __粗体文本__\n***粗斜体文本***\n或 ___粗斜体文本___\n\n\n1\n2\n3\n4\n5\n6\n\n\n斜体文本\n\n斜体文本\n\n粗体文本\n\n粗体文本\n\n粗斜体文本\n\n粗斜体文本\n\n\n# 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\n~~BAIDU.COM~~\n\n\n1\n\n\nBAIDU.COM\n\n\n# 下划线\n\n下划线可以通过 HTML 的<u> 标签来实现：\n\n<u>带下划线的文本</u>\n\n\n1\n\n\n带下划线的文本\n\n\n# 文字高亮\n\n文字高亮能使行内部分文字高亮，使用一对反引号。\n\n`html` `css` `javascript`\n\n\n1\n\n\nhtml css javascript\n\n\n# 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n***\n\n*****\n\n- - -\n\n----------\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 脚注\n\n脚注是对文本的补充说明。\n\n[^变量]\n在文档结尾或其他位置給变量赋值：\n[^变量]: 注明框内显示的内容\n\n鼠标移到这里> [^哈喽]\n[^哈喽]: 注明框内显示的内容\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注：在部分线上预览未支持\n\n鼠标移到这里> ^哈喽\n\n\n# 六、列表\n\n\n# 无序列表\n\n使用星号*、加号+或是减号-作为列表标记：\n\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 第一项\n * 第二项\n\n\n# 有序列表\n\n使用数字并加上. 号来表示\n\n1. 第一项\n2. 第二项\n\n\n1\n2\n\n 1. 第一项\n 2. 第二项\n\n\n# 折叠列表\n\n<details>\n<summary>点我打开关闭折叠</summary>\n 折叠内容\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n </ul>\n</details>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 注意：<details> 标签内写markdown代码无效，可写html代码，如ul>li、table等\n\n点我打开关闭折叠 折叠内容\n * 1\n * 2\n * 3\n\n包含table的折叠\n\n分类        例词\n人称代词-主格   I我，you你，he他，she她，they他们， we我们\n人称代词-宾格   me我， you你， him他， her她， them他们， us我们\n物主代词      my我的， his他的， your你的（your你们的）， their他们的， hers她的\n指示代词      this这， that那， these这些， those 那些\n反身代词      myself我自己， himself他自己， themselves他们自己，\n          yourself你(们)自己，herself她自己\n疑问代词      who谁， what什么， which哪个\n不定代词      some一些， many许多， both两个、两个都， any许多\n关系代词      which……的物， who……的人， that……的人或物， who谁， that引导定语从句\n相互代词      each other 互相， one another互相\n连接代词      who,whom,whose,what,which,whatever,whichever,whoever,whomever\n替代词       one（单数），ones（复数）\n\n\n# 带复选框列表\n\n* [x] 第一项\n* [ ] 第二项\n* [ ] 第三项\n\n\n1\n2\n3\n\n\n> 注：在部分线上预览未支持\n\n * [x] 第一项\n\n * [ ] 第二项\n\n * [ ] 第三项\n\n\n# 列表嵌套\n\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n       - 第三层嵌套\n\n\n1\n2\n3\n4\n5\n6\n\n 1. 第一项\n    * 嵌套1\n    * 嵌套2\n 2. 第二项\n    * 嵌套1\n      * 嵌套2\n\n\n# 七、区块引用\n\n区块引用是在段落开头使用 >符号 ，然后后面紧跟一个空格符号：\n\n> 区块引用\n\n\n1\n\n\n> 区块引用\n> \n> Typora中回车键自动延伸区块\n\n# 区块嵌套\n\n> 第一层\n> > 第二层\n> > > 第三层\n\n\n1\n2\n3\n\n\n> 第一层\n> \n> > 第二层\n> > \n> > > 第三层\n\n# 区块中使用列表\n\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> * 111\n> * 222\n\n\n1\n2\n3\n4\n5\n\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n>     * 111\n>     * 222\n\n# 列表中使用区块\n\n* 第一项\n    > 区块\n* 第二项\n\n\n1\n2\n3\n\n\n * 第一项\n   \n   > 区块\n   > \n   > 区块\n\n * 第二项\n\n\n# 八、代码\n\n如果是段落上的一个代码片段可以用反引号把它包起来（`），示例：\n\n`alert()`\n\n\n1\n\n\nalert()\n\n\n# 代码区块\n\n用三个反引号 ``` 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮\n\n本代码区块为示例说明：\n\n​```javascript\nfunction test() {\n\talert('test')\n}\n​```\n\n\n1\n2\n3\n4\n5\n\n\n效果：\n\nfunction test() {\n\talert('test')\n}\n\n\n1\n2\n3\n\n\n\n# 九、链接\n\n格式：\n\n[链接名称](链接地址)\n\n[链接名称](链接地址,可选的alt)\n\n或\n\n<链接地址>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例：\n\n[百度](http://www.baidu.com,'百度')\n\n\n1\n\n\n百度\n\n直接显示链接地址：\n\n<http://www.baidu.com>\n\n\n1\n\n\nhttp://www.baidu.com\n\n\n# 变量链接\n\n链接可以用变量来代替，文档末尾或其他位置附带变量地址：\n\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 baidu 作为网址变量 [Baidu][baidu]\n\n然后在文档的结尾或其他位置给变量赋值（网址）\n  [1]: http://www.google.com/\n  [baidu]: http://www.baidu.com/\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个链接用 1 作为网址变量 Google\n\n这个链接用 baidu 作为网址变量 Baidu\n\n\n# Github仓库中使用内部链接\n\n可使用相对路径（前提是有该路径下的文件）\n[test](test.md)\n\n\n1\n2\n\n\ntest\n\n\n# 锚点链接\n\n本文件中每一个标题都是一个锚点，和HTML的锚点（#）类似\n\n[Markdown](#Markdown)\n\n\n1\n\n\n> 注： github对含有标点符号的标题进行锚点时会忽略掉标点符号， 本页中，如果这样写则无法跳转：[链接](#九、链接) 正确写法：[链接](#九链接)\n\nMarkdown\n\n链接\n\n流程图\n\n\n# 十、图片\n\n和链接的区别是前面多一个感叹号!\n\n![图片名](图片链接)\n\n\n1\n\n\n当然，你也可以像链接那样对图片地址使用变量:\n\n这里链接用 img 作为图片地址变量\n然后在文档的结尾或其他位置给变量赋值（图片地址）\n![RUNOOB][img]\n[img]: https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 图片宽高\n\n如下想设置图片宽高，可以使用 <img> 标签。\n\n<img src=\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\" width=\"50px\" height=\"30px\">\n\n\n1\n\n\n\n# 相对路径以及Github中使用图片\n\n不管是在本地还是在github同一个仓库中，如果图片存在，可以使用相对路径。\n\n相对路径图片：\n\n![头像图片](./md-img/test.jpg)\n\n\n1\n\n\ngithub上如果引用其他github仓库中的图片则要注意地址格式：仓库地址/raw/分支名/图片路径 或 https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径\n\n![其他仓库的图片1](https://github.com/xugaoyi/vue-music/raw/master/src/common/image/default.png)\n或\n![其他仓库的图片2](https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png)\n\n\n\n1\n2\n3\n4\n\n\n\n\n\n\n\n# 十一、表格\n\n制作表格使用 |来分隔不同的单元格，使用-来分隔表头和其他行。\n\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n\n1\n2\n3\n4\n\n\n表头    表头\n单元格   单元格\n单元格   单元格\n\n对齐方式\n\n * -: 设置内容和标题栏居右对齐\n * :- 设置内容和标题栏居左对齐\n * :-: 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n\n1\n2\n3\n4\n\n\n左对齐   右对齐   居中对齐\n单元格   单元格   单元格\n单元格   单元格   单元格\n\n\n# 十二、Emoji表情包\n\nEmoji表情英文名的前后加冒号，Typore上先输入冒号再输入首字母有表情提示\n\n:smirk:\n\n\n1\n\n\n💋 😸🙈🐴 😏😊😃😄 ☀️\n\n更多表情名称请查看：表情包清单\n\n\n# 十三、其他技巧\n\n\n# 支持的 HTML 元素\n\n不在 Markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n\n目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等等 ，如：\n\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n\n\n1\n\n\n使用 Ctrl+Alt+Del 重启电脑\n\n我是使用b标签的加粗字体\n\n\n# 转义\n\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：\n\n**未转义星号显示加粗**\n\\*\\* 转义显示星号 \\*\\*\n\n\n1\n2\n\n\n未转义星号显示加粗 ** 转义显示星号 **\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n*** 以下部分在Github或其他在线预览中暂未支持 ***\n\n----------------------------------------\n\n\n# 数学公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n\n$$\n\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix}\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\n\\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n$$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n$$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} & \\frac{\\partial Y}{\\partial u} & 0 \\ \\frac{\\partial X}{\\partial v} & \\frac{\\partial Y}{\\partial v} & 0 \\ \\end{vmatrix} $$\n\n\n# 图表\n\n​```chart\n,Budget,Income,Expenses,Debt\nJune,5000,8000,4000,6000\nJuly,3000,1000,4000,3000\nAug,5000,7000,6000,3000\nSep,7000,2000,3000,1000\nOct,6000,5000,4000,2000\nNov,4000,3000,5000,\n\ntype: pie\ntitle: Monthly Revenue\nx.title: Amount\ny.title: Month\ny.suffix: $\n​```\n​```mermaid\nsequenceDiagram\nA->>B: 是否已收到消息？\nB--\x3e>A: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 注：在Typora中未支持\n\n\n# 流程图\n\n语法：\n​```mermaid\ngraph TD\nA[模块A] --\x3e|A1| B(模块B)\nB --\x3e C{判断条件C}\nC --\x3e|条件C1| D[模块D]\nC --\x3e|条件C2| E[模块E]\nC --\x3e|条件C3| F[模块F]\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n流程图相关文章：\n\nhttps://www.jianshu.com/p/b421cc723da5\n\nhttp://www.imooc.com/article/292708\n\n\n# 时序图\n\n​```mermaid\nsequenceDiagram\nA->>B: 是否已收到消息？\nB--\x3e>A: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n\n\n\n# 甘特图\n\n​```mermaid\ngantt\ntitle 甘特图\ndateFormat  YYYY-MM-DD\nsection 项目A\n任务1           :a1, 2018-06-06, 30d\n任务2     :after a1  , 20d\nsection 项目B\n任务3      :2018-06-12  , 12d\n任务4      : 24d\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n回到顶部",normalizedContent:"# markdown使用教程\n\n\n# 一、markdown\n\n\n# 简介\n\n\n\nmarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\n\n# 应用\n\n当前许多网站都广泛使用 markdown 来撰写帮助文档或是用于论坛上发表消息。例如：github、简书、知乎等\n\n\n# 编辑器\n\n推荐使用typora，官网：https://typora.io/\n\n\n# 二、徽章\n\n# 什么是徽章\n\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\n\n常见于github项目主页，但其不仅出现于 github 项目主页，凡是能够表现图片的地方都可以出现徽章。\n\n# 徽章的使用\n\n * 在markdown中使用\n\n格式:\n[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片\n\n语法：\n[![github](https://img.shields.io/badge/github-xugaoyi-brightgreen.svg)](https://github.com/xugaoyi)\n\n\n1\n2\n3\n4\n5\n\n\n\n\n徽章生成网站：https://shields.io/\n\n本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 戳我 了解。\n\n\n# 三、设置目录\n\n设置之后会根据分级标题来自动生成目录。\n\n[toc]\n\n\n1\n\n\n> 注：github暂未支持。\n\n[toc]\n\n在github生成toc的方法：https://github.com/ekalinin/github-markdown-toc\n\nwindows系统需要基于golang实现的工具：https://github.com/ekalinin/github-markdown-toc.go\n\n> 如果你有go语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。\n> \n> 如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）\n> \n> 下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。\n> \n> 使用方法：\n> \n>  1. 首先将.md文档复制到gh-md-toc.exe的根目录下\n>  2. 在该目录下打开系统命令行，输入命令：gh-md-toc.exe readme.md 生成目录\n>  3. 把生成的目录复制到.md文件即可。\n\n这是gh-md-toc生成的目录：\n\n * 一、markdown\n   * 简介\n   * 应用\n   * 编辑器\n * 二、徽章\n   * 什么是徽章\n   * 徽章的使用\n * 三、设置目录\n * 四、标题\n * 一级标题\n   * 二级标题\n     * 三级标题\n       * 四级标题\n         * 五级标题\n           * 六级标题\n   * 五、文本\n     * 段落\n     * 字体\n     * 删除线\n     * 下划线\n     * 文字高亮\n     * 分隔线\n     * 脚注\n   * 六、列表\n     * 无序列表\n     * 有序列表\n     * 折叠列表\n     * 带复选框列表\n     * 列表嵌套\n   * 七、区块引用\n     * 区块嵌套\n     * 区块中使用列表\n     * 列表中使用区块\n   * 八、代码\n     * 代码区块\n   * 九、链接\n     * 变量链接\n     * github中使用内部链接\n     * 锚点链接\n   * 十、图片\n     * 图片宽高\n     * 相对路径以及github中使用图片\n   * 十一、表格\n   * 十二、emoji表情包\n   * 十三、其他技巧\n     * 支持的 html 元素\n     * 转义\n     * 数学公式\n     * 图表\n     * 流程图\n     * 时序图\n     * 甘特图\n\n\n# 四、标题\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 一级标题\n\n\n# 二级标题\n\n\n# 三级标题\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n\n# 五、文本\n\n\n# 段落\n\nmarkdown 段落没有特殊的格式，直接编写文字，需要段落缩进时使用2个tab\n\n\n# 字体\n\n*斜体文本*\n或 _斜体文本_\n**粗体文本**\n或  __粗体文本__\n***粗斜体文本***\n或 ___粗斜体文本___\n\n\n1\n2\n3\n4\n5\n6\n\n\n斜体文本\n\n斜体文本\n\n粗体文本\n\n粗体文本\n\n粗斜体文本\n\n粗斜体文本\n\n\n# 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\n~~baidu.com~~\n\n\n1\n\n\nbaidu.com\n\n\n# 下划线\n\n下划线可以通过 html 的<u> 标签来实现：\n\n<u>带下划线的文本</u>\n\n\n1\n\n\n带下划线的文本\n\n\n# 文字高亮\n\n文字高亮能使行内部分文字高亮，使用一对反引号。\n\n`html` `css` `javascript`\n\n\n1\n\n\nhtml css javascript\n\n\n# 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n***\n\n*****\n\n- - -\n\n----------\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 脚注\n\n脚注是对文本的补充说明。\n\n[^变量]\n在文档结尾或其他位置給变量赋值：\n[^变量]: 注明框内显示的内容\n\n鼠标移到这里> [^哈喽]\n[^哈喽]: 注明框内显示的内容\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注：在部分线上预览未支持\n\n鼠标移到这里> ^哈喽\n\n\n# 六、列表\n\n\n# 无序列表\n\n使用星号*、加号+或是减号-作为列表标记：\n\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 第一项\n * 第二项\n\n\n# 有序列表\n\n使用数字并加上. 号来表示\n\n1. 第一项\n2. 第二项\n\n\n1\n2\n\n 1. 第一项\n 2. 第二项\n\n\n# 折叠列表\n\n<details>\n<summary>点我打开关闭折叠</summary>\n 折叠内容\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n </ul>\n</details>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 注意：<details> 标签内写markdown代码无效，可写html代码，如ul>li、table等\n\n点我打开关闭折叠 折叠内容\n * 1\n * 2\n * 3\n\n包含table的折叠\n\n分类        例词\n人称代词-主格   i我，you你，he他，she她，they他们， we我们\n人称代词-宾格   me我， you你， him他， her她， them他们， us我们\n物主代词      my我的， his他的， your你的（your你们的）， their他们的， hers她的\n指示代词      this这， that那， these这些， those 那些\n反身代词      myself我自己， himself他自己， themselves他们自己，\n          yourself你(们)自己，herself她自己\n疑问代词      who谁， what什么， which哪个\n不定代词      some一些， many许多， both两个、两个都， any许多\n关系代词      which……的物， who……的人， that……的人或物， who谁， that引导定语从句\n相互代词      each other 互相， one another互相\n连接代词      who,whom,whose,what,which,whatever,whichever,whoever,whomever\n替代词       one（单数），ones（复数）\n\n\n# 带复选框列表\n\n* [x] 第一项\n* [ ] 第二项\n* [ ] 第三项\n\n\n1\n2\n3\n\n\n> 注：在部分线上预览未支持\n\n * [x] 第一项\n\n * [ ] 第二项\n\n * [ ] 第三项\n\n\n# 列表嵌套\n\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n       - 第三层嵌套\n\n\n1\n2\n3\n4\n5\n6\n\n 1. 第一项\n    * 嵌套1\n    * 嵌套2\n 2. 第二项\n    * 嵌套1\n      * 嵌套2\n\n\n# 七、区块引用\n\n区块引用是在段落开头使用 >符号 ，然后后面紧跟一个空格符号：\n\n> 区块引用\n\n\n1\n\n\n> 区块引用\n> \n> typora中回车键自动延伸区块\n\n# 区块嵌套\n\n> 第一层\n> > 第二层\n> > > 第三层\n\n\n1\n2\n3\n\n\n> 第一层\n> \n> > 第二层\n> > \n> > > 第三层\n\n# 区块中使用列表\n\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> * 111\n> * 222\n\n\n1\n2\n3\n4\n5\n\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n>     * 111\n>     * 222\n\n# 列表中使用区块\n\n* 第一项\n    > 区块\n* 第二项\n\n\n1\n2\n3\n\n\n * 第一项\n   \n   > 区块\n   > \n   > 区块\n\n * 第二项\n\n\n# 八、代码\n\n如果是段落上的一个代码片段可以用反引号把它包起来（`），示例：\n\n`alert()`\n\n\n1\n\n\nalert()\n\n\n# 代码区块\n\n用三个反引号 ``` 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮\n\n本代码区块为示例说明：\n\n​```javascript\nfunction test() {\n\talert('test')\n}\n​```\n\n\n1\n2\n3\n4\n5\n\n\n效果：\n\nfunction test() {\n\talert('test')\n}\n\n\n1\n2\n3\n\n\n\n# 九、链接\n\n格式：\n\n[链接名称](链接地址)\n\n[链接名称](链接地址,可选的alt)\n\n或\n\n<链接地址>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例：\n\n[百度](http://www.baidu.com,'百度')\n\n\n1\n\n\n百度\n\n直接显示链接地址：\n\n<http://www.baidu.com>\n\n\n1\n\n\nhttp://www.baidu.com\n\n\n# 变量链接\n\n链接可以用变量来代替，文档末尾或其他位置附带变量地址：\n\n这个链接用 1 作为网址变量 [google][1]\n这个链接用 baidu 作为网址变量 [baidu][baidu]\n\n然后在文档的结尾或其他位置给变量赋值（网址）\n  [1]: http://www.google.com/\n  [baidu]: http://www.baidu.com/\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个链接用 1 作为网址变量 google\n\n这个链接用 baidu 作为网址变量 baidu\n\n\n# github仓库中使用内部链接\n\n可使用相对路径（前提是有该路径下的文件）\n[test](test.md)\n\n\n1\n2\n\n\ntest\n\n\n# 锚点链接\n\n本文件中每一个标题都是一个锚点，和html的锚点（#）类似\n\n[markdown](#markdown)\n\n\n1\n\n\n> 注： github对含有标点符号的标题进行锚点时会忽略掉标点符号， 本页中，如果这样写则无法跳转：[链接](#九、链接) 正确写法：[链接](#九链接)\n\nmarkdown\n\n链接\n\n流程图\n\n\n# 十、图片\n\n和链接的区别是前面多一个感叹号!\n\n![图片名](图片链接)\n\n\n1\n\n\n当然，你也可以像链接那样对图片地址使用变量:\n\n这里链接用 img 作为图片地址变量\n然后在文档的结尾或其他位置给变量赋值（图片地址）\n![runoob][img]\n[img]: https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 图片宽高\n\n如下想设置图片宽高，可以使用 <img> 标签。\n\n<img src=\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\" width=\"50px\" height=\"30px\">\n\n\n1\n\n\n\n# 相对路径以及github中使用图片\n\n不管是在本地还是在github同一个仓库中，如果图片存在，可以使用相对路径。\n\n相对路径图片：\n\n![头像图片](./md-img/test.jpg)\n\n\n1\n\n\ngithub上如果引用其他github仓库中的图片则要注意地址格式：仓库地址/raw/分支名/图片路径 或 https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径\n\n![其他仓库的图片1](https://github.com/xugaoyi/vue-music/raw/master/src/common/image/default.png)\n或\n![其他仓库的图片2](https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png)\n\n\n\n1\n2\n3\n4\n\n\n\n\n\n\n\n# 十一、表格\n\n制作表格使用 |来分隔不同的单元格，使用-来分隔表头和其他行。\n\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n\n1\n2\n3\n4\n\n\n表头    表头\n单元格   单元格\n单元格   单元格\n\n对齐方式\n\n * -: 设置内容和标题栏居右对齐\n * :- 设置内容和标题栏居左对齐\n * :-: 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n\n1\n2\n3\n4\n\n\n左对齐   右对齐   居中对齐\n单元格   单元格   单元格\n单元格   单元格   单元格\n\n\n# 十二、emoji表情包\n\nemoji表情英文名的前后加冒号，typore上先输入冒号再输入首字母有表情提示\n\n:smirk:\n\n\n1\n\n\n💋 😸🙈🐴 😏😊😃😄 ☀️\n\n更多表情名称请查看：表情包清单\n\n\n# 十三、其他技巧\n\n\n# 支持的 html 元素\n\n不在 markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 html 撰写。\n\n目前支持的 html 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等等 ，如：\n\n使用 <kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>del</kbd> 重启电脑\n\n\n1\n\n\n使用 ctrl+alt+del 重启电脑\n\n我是使用b标签的加粗字体\n\n\n# 转义\n\nmarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：\n\n**未转义星号显示加粗**\n\\*\\* 转义显示星号 \\*\\*\n\n\n1\n2\n\n\n未转义星号显示加粗 ** 转义显示星号 **\n\nmarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n*** 以下部分在github或其他在线预览中暂未支持 ***\n\n----------------------------------------\n\n\n# 数学公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 tex 或 latex 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 mathjax 对数学公式进行渲染。如：\n\n$$\n\\mathbf{v}_1 \\times \\mathbf{v}_2 =  \\begin{vmatrix}\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial x}{\\partial u} &  \\frac{\\partial y}{\\partial u} & 0 \\\\\n\\frac{\\partial x}{\\partial v} &  \\frac{\\partial y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n$$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n$$ \\mathbf{v}_1 \\times \\mathbf{v}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial x}{\\partial u} & \\frac{\\partial y}{\\partial u} & 0 \\ \\frac{\\partial x}{\\partial v} & \\frac{\\partial y}{\\partial v} & 0 \\ \\end{vmatrix} $$\n\n\n# 图表\n\n​```chart\n,budget,income,expenses,debt\njune,5000,8000,4000,6000\njuly,3000,1000,4000,3000\naug,5000,7000,6000,3000\nsep,7000,2000,3000,1000\noct,6000,5000,4000,2000\nnov,4000,3000,5000,\n\ntype: pie\ntitle: monthly revenue\nx.title: amount\ny.title: month\ny.suffix: $\n​```\n​```mermaid\nsequencediagram\na->>b: 是否已收到消息？\nb--\x3e>a: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 注：在typora中未支持\n\n\n# 流程图\n\n语法：\n​```mermaid\ngraph td\na[模块a] --\x3e|a1| b(模块b)\nb --\x3e c{判断条件c}\nc --\x3e|条件c1| d[模块d]\nc --\x3e|条件c2| e[模块e]\nc --\x3e|条件c3| f[模块f]\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n流程图相关文章：\n\nhttps://www.jianshu.com/p/b421cc723da5\n\nhttp://www.imooc.com/article/292708\n\n\n# 时序图\n\n​```mermaid\nsequencediagram\na->>b: 是否已收到消息？\nb--\x3e>a: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n\n\n\n# 甘特图\n\n​```mermaid\ngantt\ntitle 甘特图\ndateformat  yyyy-mm-dd\nsection 项目a\n任务1           :a1, 2018-06-06, 30d\n任务2     :after a1  , 20d\nsection 项目b\n任务3      :2018-06-12  , 12d\n任务4      : 24d\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n回到顶部",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"npm常用命令",frontmatter:{title:"npm常用命令",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/61f2f95fd7da14fd",categories:["技术","技术文档"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/100.%E5%85%B6%E4%BB%96/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/03.npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"100.其他/01.技术文档/03.npm常用命令.md",key:"v-a5b0f788",path:"/pages/61f2f95fd7da14fd/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:14},{level:2,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:5},{level:2,title:"使用技巧",slug:"使用技巧",normalizedTitle:"使用技巧",charIndex:1761},{level:2,title:"npm发布包教程",slug:"npm发布包教程",normalizedTitle:"npm发布包教程",charIndex:1912},{level:2,title:"nrm的作用与使用",slug:"nrm的作用与使用",normalizedTitle:"nrm的作用与使用",charIndex:1935}],excerpt:'<h1 id="npm常用命令"><a class="header-anchor" href="#npm常用命令">#</a> npm常用命令</h1>\n<h2 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h2>\n<p>npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：</p>\n<ul>\n<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>\n<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>\n<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>\n</ul>\n',headersStr:"简介 常用命令 使用技巧 npm发布包教程 nrm的作用与使用",content:'# npm常用命令\n\n\n# 简介\n\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\n\n * 允许用户从npm服务器下载别人编写的第三方包到本地使用。\n * 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\n * 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\n\n\n# 常用命令\n\n# 检测是否安装及版本\n\nnpm -v # 显示版本号说明已经安装相应的版本\n\n\n1\n\n\n# 生成package.json文件\n\nnpm init\n\n\n1\n\n\n> package.json用来描述项目中用到的模块和其他信息\n\n# 安装模块\n\nnpm install # 安装package.json定义好的模块，简写 npm i\n\n# 安装包指定模块\nnpm i <ModuleName>\n\n# 全局安装\nnpm i <ModuleName> -g \n\n# 安装包的同时，将信息写入到package.json中的 dependencies 配置中\nnpm i <ModuleName> --save\n\n# 安装包的同时，将信息写入到package.json中的 devDependencies 配置中\nnpm i <ModuleName> --save-dev\n\n# 安装多模块\nnpm i <ModuleName1> <ModuleName2>\n\n# 安装方式参数：\n-save # 简写-S，加入到生产依赖中\n-save-dev # 简写-D，加入到开发依赖中\n-g # 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 查看\n\n# 查看所有全局安装的包\nnpm ls -g\n\n# 查看本地项目中安装的包\nnpm ls\n\n# 查看包的 package.json文件\nnpm view <ModuleName>\n\n# 查看包的依赖关系\nnpm view <ModuleName> dependencies\n\n# 查看包的源文件地址\nnpm view <ModuleName> repository.url\n\n# 查看包所依赖的node版本\nnpm view <ModuleName> engines\n\n# 查看帮助\nnpm help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 更新模块\n\n# 更新本地模块\nnpm update <ModuleName>\n\n# 更新全局模块\nnpm update -g <ModuleName> # 更新全局软件包。\nnpm update -g # 更新所有的全局软件包。\nnpm outdated -g --depth=0 # 找出需要更新的包。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 卸载模块\n\n# 卸载本地模块\nnpm uninstall <ModuleName>\n\n# 卸载全局模块\nnpm uninstall -g <ModuleName> # 卸载全局软件包。\n\n\n1\n2\n3\n4\n5\n\n\n# 清空缓存\n\n# 清空npm缓存\nnpm cache clear\n\n\n1\n2\n\n\n# 使用淘宝镜像\n\n# 使用淘宝镜像\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n1\n2\n\n\n# 其他\n\n# 更改包内容后进行重建\nnpm rebuild <ModuleName>\n\n# 检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新\nnpm outdated\n\n# 访问npm的json文件，此命令将会打开一个网页\nnpm help json\n\n# 发布一个包的时候，需要检验某个包名是否存在\nnpm search <ModuleName>\n\n# 撤销自己发布过的某个版本代码\nnpm unpublish <package> <version>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 使用技巧\n\n# 多次安装不成功尝试先清除缓存\n\nnpm cache clean -f\n\n\n1\n\n\n# 查看已安装的依赖包版本号\n\nnpm ls <ModuleName>\n\n\n1\n\n\n> 注意：用此方法才能准确的知道项目使用的版本号，查看package.json时，有“^" 符号表示大于此版本\n\n\n# npm发布包教程\n\nnpm发布包教程\n\n\n# nrm的作用与使用\n\n# nrm是什么？\n\nnrm(npm registry manager )是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换\n\n# nrm的安装\n\nnpm install -g nrm\n\n\n1\n\n\n# nrm命令\n\nnrm ls　#查看可用的源（有*号的表示当前所使用的源,以下<registry>表示源的名称）\nnrm use <registry> # 将npm下载源切换成指定的源\nnrm add <registry> <url> # 添加源，url为源的路径\nnrm del <registry> # 删除源\nnrm test <registry> # 测试源的响应时间，可以作为使用哪个源的参考\n\nnrm help　# 查看nrm帮助\nnrm home <registry>　# 跳转到指定源的官网\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# nrm使用\n\n如果在你的网络不太理想或者受到其他网络限制导致不能使用npm原本的源进行下载时，nrm就非常有用了，你只需要：\n\nnrm ls # 查看可用的源\nnrm use <registry>　# 切换到指定源\n\n\n1\n2\n',normalizedContent:'# npm常用命令\n\n\n# 简介\n\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\n\n * 允许用户从npm服务器下载别人编写的第三方包到本地使用。\n * 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\n * 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\n\n\n# 常用命令\n\n# 检测是否安装及版本\n\nnpm -v # 显示版本号说明已经安装相应的版本\n\n\n1\n\n\n# 生成package.json文件\n\nnpm init\n\n\n1\n\n\n> package.json用来描述项目中用到的模块和其他信息\n\n# 安装模块\n\nnpm install # 安装package.json定义好的模块，简写 npm i\n\n# 安装包指定模块\nnpm i <modulename>\n\n# 全局安装\nnpm i <modulename> -g \n\n# 安装包的同时，将信息写入到package.json中的 dependencies 配置中\nnpm i <modulename> --save\n\n# 安装包的同时，将信息写入到package.json中的 devdependencies 配置中\nnpm i <modulename> --save-dev\n\n# 安装多模块\nnpm i <modulename1> <modulename2>\n\n# 安装方式参数：\n-save # 简写-s，加入到生产依赖中\n-save-dev # 简写-d，加入到开发依赖中\n-g # 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 查看\n\n# 查看所有全局安装的包\nnpm ls -g\n\n# 查看本地项目中安装的包\nnpm ls\n\n# 查看包的 package.json文件\nnpm view <modulename>\n\n# 查看包的依赖关系\nnpm view <modulename> dependencies\n\n# 查看包的源文件地址\nnpm view <modulename> repository.url\n\n# 查看包所依赖的node版本\nnpm view <modulename> engines\n\n# 查看帮助\nnpm help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 更新模块\n\n# 更新本地模块\nnpm update <modulename>\n\n# 更新全局模块\nnpm update -g <modulename> # 更新全局软件包。\nnpm update -g # 更新所有的全局软件包。\nnpm outdated -g --depth=0 # 找出需要更新的包。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 卸载模块\n\n# 卸载本地模块\nnpm uninstall <modulename>\n\n# 卸载全局模块\nnpm uninstall -g <modulename> # 卸载全局软件包。\n\n\n1\n2\n3\n4\n5\n\n\n# 清空缓存\n\n# 清空npm缓存\nnpm cache clear\n\n\n1\n2\n\n\n# 使用淘宝镜像\n\n# 使用淘宝镜像\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n1\n2\n\n\n# 其他\n\n# 更改包内容后进行重建\nnpm rebuild <modulename>\n\n# 检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新\nnpm outdated\n\n# 访问npm的json文件，此命令将会打开一个网页\nnpm help json\n\n# 发布一个包的时候，需要检验某个包名是否存在\nnpm search <modulename>\n\n# 撤销自己发布过的某个版本代码\nnpm unpublish <package> <version>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 使用技巧\n\n# 多次安装不成功尝试先清除缓存\n\nnpm cache clean -f\n\n\n1\n\n\n# 查看已安装的依赖包版本号\n\nnpm ls <modulename>\n\n\n1\n\n\n> 注意：用此方法才能准确的知道项目使用的版本号，查看package.json时，有“^" 符号表示大于此版本\n\n\n# npm发布包教程\n\nnpm发布包教程\n\n\n# nrm的作用与使用\n\n# nrm是什么？\n\nnrm(npm registry manager )是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换\n\n# nrm的安装\n\nnpm install -g nrm\n\n\n1\n\n\n# nrm命令\n\nnrm ls　#查看可用的源（有*号的表示当前所使用的源,以下<registry>表示源的名称）\nnrm use <registry> # 将npm下载源切换成指定的源\nnrm add <registry> <url> # 添加源，url为源的路径\nnrm del <registry> # 删除源\nnrm test <registry> # 测试源的响应时间，可以作为使用哪个源的参考\n\nnrm help　# 查看nrm帮助\nnrm home <registry>　# 跳转到指定源的官网\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# nrm使用\n\n如果在你的网络不太理想或者受到其他网络限制导致不能使用npm原本的源进行下载时，nrm就非常有用了，你只需要：\n\nnrm ls # 查看可用的源\nnrm use <registry>　# 切换到指定源\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"npm packageJson属性详解",frontmatter:{author:{name:"xugaoyi",link:"https://github.com/xugaoyi"},title:"npm packageJson属性详解",date:"2020-04-08T17:16:38.000Z",permalink:"/pages/dec4f3f00e71a312",categories:["技术","技术文档"],tags:[null]},regularPath:"/100.%E5%85%B6%E4%BB%96/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/10.npm%20packageJson%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3.html",relativePath:"100.其他/01.技术文档/10.npm packageJson属性详解.md",key:"v-5746bea6",path:"/pages/dec4f3f00e71a312/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:86},{level:2,title:"name",slug:"name",normalizedTitle:"name",charIndex:160},{level:2,title:"version",slug:"version",normalizedTitle:"version",charIndex:191},{level:2,title:"description",slug:"description",normalizedTitle:"description",charIndex:1036},{level:2,title:"keywords",slug:"keywords",normalizedTitle:"keywords",charIndex:1081},{level:2,title:"homepage",slug:"homepage",normalizedTitle:"homepage",charIndex:1114},{level:2,title:"bugs",slug:"bugs",normalizedTitle:"bugs",charIndex:1266},{level:2,title:"license",slug:"license",normalizedTitle:"license",charIndex:1496},{level:2,title:"和用户相关的属性: author, contributors",slug:"和用户相关的属性-author-contributors",normalizedTitle:"和用户相关的属性: author, contributors",charIndex:1666},{level:2,title:"files",slug:"files",normalizedTitle:"files",charIndex:2037},{level:2,title:"main",slug:"main",normalizedTitle:"main",charIndex:2013},{level:2,title:"bin",slug:"bin",normalizedTitle:"bin",charIndex:2444},{level:2,title:"man",slug:"man",normalizedTitle:"man",charIndex:3180},{level:2,title:"directories",slug:"directories",normalizedTitle:"directories",charIndex:4055},{level:3,title:"directories.lib",slug:"directories-lib",normalizedTitle:"directories.lib",charIndex:4211},{level:3,title:"directories.bin",slug:"directories-bin",normalizedTitle:"directories.bin",charIndex:4282},{level:3,title:"directories.man",slug:"directories-man",normalizedTitle:"directories.man",charIndex:4383},{level:3,title:"directories.doc",slug:"directories-doc",normalizedTitle:"directories.doc",charIndex:4440},{level:3,title:"directories.example",slug:"directories-example",normalizedTitle:"directories.example",charIndex:4514},{level:2,title:"repository",slug:"repository",normalizedTitle:"repository",charIndex:4561},{level:2,title:"scripts",slug:"scripts",normalizedTitle:"scripts",charIndex:5066},{level:2,title:"config",slug:"config",normalizedTitle:"config",charIndex:146},{level:2,title:"dependencies",slug:"dependencies",normalizedTitle:"dependencies",charIndex:1017},{level:2,title:"URLs as Dependencies",slug:"urls-as-dependencies",normalizedTitle:"urls as dependencies",charIndex:6629},{level:2,title:"Git URLs as Dependencies",slug:"git-urls-as-dependencies",normalizedTitle:"git urls as dependencies",charIndex:6706},{level:2,title:"GitHub URLs",slug:"github-urls",normalizedTitle:"github urls",charIndex:7059},{level:2,title:"Local Paths",slug:"local-paths",normalizedTitle:"local paths",charIndex:7300},{level:2,title:"devDependencies",slug:"devdependencies",normalizedTitle:"devdependencies",charIndex:7631},{level:2,title:"peerDependencies",slug:"peerdependencies",normalizedTitle:"peerdependencies",charIndex:8354},{level:2,title:"bundledDependencies",slug:"bundleddependencies",normalizedTitle:"bundleddependencies",charIndex:8793},{level:2,title:"optionalDependencies",slug:"optionaldependencies",normalizedTitle:"optionaldependencies",charIndex:8870},{level:2,title:"engines",slug:"engines",normalizedTitle:"engines",charIndex:594},{level:2,title:"engineStrict",slug:"enginestrict",normalizedTitle:"enginestrict",charIndex:9646},{level:2,title:"os",slug:"os",normalizedTitle:"os",charIndex:1394},{level:2,title:"cpu",slug:"cpu",normalizedTitle:"cpu",charIndex:9846},{level:2,title:"preferGlobal",slug:"preferglobal",normalizedTitle:"preferglobal",charIndex:9962},{level:2,title:"private",slug:"private",normalizedTitle:"private",charIndex:10079},{level:2,title:"publishConfig",slug:"publishconfig",normalizedTitle:"publishconfig",charIndex:10172},{level:2,title:"DEFAULT VALUES",slug:"default-values",normalizedTitle:"default values",charIndex:10286},{level:2,title:"参考文档列表(https://docs.npmjs.com/)",slug:"参考文档列表-https-docs-npmjs-com",normalizedTitle:"参考文档列表(https://docs.npmjs.com/)",charIndex:10599}],excerpt:'<h1 id="npm-package-json属性详解"><a class="header-anchor" href="#npm-package-json属性详解">#</a> npm package.json属性详解</h1>\n<blockquote>\n<p>本文转自<a href="https://www.cnblogs.com/tzyy/p/5193811.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/tzyy/p/5193811.html<OutboundLink/></a>，作者：TZYY</p>\n</blockquote>\n<h2 id="概述"><a class="header-anchor" href="#概述">#</a> 概述</h2>\n<p><code>package.json</code>必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过<code>npm-config</code>来生成</p>\n',headersStr:"概述 name version description keywords homepage bugs license 和用户相关的属性: author, contributors files main bin man directories directories.lib directories.bin directories.man directories.doc directories.example repository scripts config dependencies URLs as Dependencies Git URLs as Dependencies GitHub URLs Local Paths devDependencies peerDependencies bundledDependencies optionalDependencies engines engineStrict os cpu preferGlobal private publishConfig DEFAULT VALUES 参考文档列表(https://docs.npmjs.com/)",content:'# npm package.json属性详解\n\n> 本文转自https://www.cnblogs.com/tzyy/p/5193811.html，作者：TZYY\n\n\n# 概述\n\npackage.json必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过npm-config来生成\n\n\n# name\n\npackage.json中最重要的属性是name和version两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。 name属性就是你的模块名称，下面是一些命名规则:\n\n * name必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\n\n * name不能以"_"或"."开头\n\n * 不能含有大写字母\n\n * name会成为url的一部分，不能含有url非法字符\n   \n   下面是官网文档的一些建议：\n\n * 不要使用和node核心模块一样的名称\n\n * name中不要含有"js"和"node"。 It\'s assumed that it\'s js, since you\'re writing a package.json file, and you can specify the engine using the "engines" field. (See below.)\n\n * name属性会成为模块url、命令行中的一个参数或者一个文件夹名称，任何非url安全的字符在name中都不能使用，也不能以"_"或"."开头\n\n * name属性也许会被写在require()的参数中，所以最好取个简短而语义化的值。\n\n * 创建一个模块前可以先到后边的网址查查name是否已经被占用. https://www.npmjs.com/\n   \n   * # 发布一个包的时候，需要检验某个包名是否存在\n     npm search <ModuleName>\n     \n     \n     1\n     2\n     \n\nname属性可以有一些前缀如 e.g. @myorg/mypackage.在npm-scope(7)的文档中可以看到详细说明\n\n\n# version\n\nversion必须可以被npm依赖的一个node-semver模块解析。具体规则见下面的dependencies模块\n\n\n# description\n\n一个描述，方便别人了解你的模块作用，搜索的时候也有用。\n\n\n# keywords\n\n一个字符串数组，方便别人搜索到本模块\n\n\n# homepage\n\n项目主页url 注意: 这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。 （原文档中用了 spit(吐)这个单词，作者表示他不是在开玩笑:）\n\n\n# bugs\n\n填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽，例如：\n\n{\n    "url" : "https://github.com/owner/project/issues",\n    "email" : "project@hostname.com"\n}\n\n\n1\n2\n3\n4\n\n\nurl和email可以任意填或不填，如果只填一个，可以直接写成一个字符串而不是对象。如果填写了url，npm bugs命令会使用这个url。\n\n\n# license\n\n你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。最简单的，例如你用BSD-3-Clause 或 MIT之类的协议，如下：\n\n{ "license" : "MIT" }\n\n\n1\n\n\n你可以在https://spdx.org/licenses/ 这个地址查阅协议列表 。\n\n\n# 和用户相关的属性: author, contributors\n\nauthor是一个码农， contributors是一个码农数组。 person是一个有一些描述属性的对象，如下 like this:\n\n{\n    "name" : "Barney Rubble",\n    "email" : "b@rubble.com",\n    "url" : "http://barnyrubble.tumblr.com/"\n}\n\n\n1\n2\n3\n4\n5\n\n\n也可以按如下格式缩写，npm会帮着转换:\n\n"Barney Rubble b@rubble.com (http://barnyrubble.tumblr.com/)"\n\n\n1\n\n\nemail和url属性实际上都是可以省略的。描述用户信息的还有一个maintainers（维护者）属性。\n\n\n# files\n\nfiles属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了） 你也可以在模块根目录下创建一个.npmignore文件（windows下无法直接创建以"."开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法".gitignore"类似。\n\n\n# main\n\nmain属性指定了程序的主入口文件。意思是，如果你的模块被命名为foo，用户安装了这个模块并通过require("foo")来使用这个模块，那么require返回的内容就是main属性指定的文件中 module.exports指向的对象。 它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。\n\n\n# bin\n\n很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的） 如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：\n\n{\n    "bin" : { "myapp" : "./cli.js" }\n}\n\n\n1\n2\n3\n\n\n模块安装的时候，若是全局安装，则npm会为bin中配置的文件在bin目录下创建一个软连接（对于windows系统，默认会在C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。 因此，按上面的例子，当你安装myapp的时候，npm就会为cli.js在/usr/local/bin/myapp路径创建一个软链接。 如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：\n\n{ \n    "name": "my-program",\n    "version": "1.2.5", \n    "bin": "./path/to/program"\n}\n\n\n1\n2\n3\n4\n5\n\n\n作用和如下写法相同:\n\n{ \n    "name": "my-program", \n    "version": "1.2.5", \n    "bin" : { \n        "my-program" : "./path/to/program" \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# man\n\n制定一个或通过数组制定一些文件来让linux下的man命令查找文档地址。 如果只有一个文件被指定的话，安装后直接使用man+模块名称，而不管man指定的文件的实际名称。例如:\n\n{\n    "name" : "foo",\n    "version" : "1.2.3", \n    "description" : "A packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : "./man/doc.1"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过man foo命令会得到 ./man/doc.1 文件的内容。 如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：\n\n{ \n    "name" : "foo", \n    "version" : "1.2.3", \n    "description" : "A packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : [ "./man/foo.1", "./man/bar.1" ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n会创建一些文件来作为man foo和man foo-bar命令的结果。 man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。\n\n{ \n    "name" : "foo", \n    "version" : "1.2.3",\n    "description" : "A packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : [ "./man/foo.1", "./man/foo.2" ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n会创建 man foo 和 man 2 foo 两条命令。\n\n\n# directories\n\nCommonJs通过directories来制定一些方法来描述模块的结构，看看npm的package.json文件https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。 目前这个配置没有任何作用，将来可能会整出一些花样来。\n\n\n# directories.lib\n\n告诉用户模块中lib目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。\n\n\n# directories.bin\n\n如果你在这里指定了bin目录，这个配置下面的文件会被加入到bin路径下，如果你已经在package.json中配置了bin目录，那么这里的配置将不起任何作用。\n\n\n# directories.man\n\n指定一个目录，目录里边都是man文件，这是一种配置man文件的语法糖。\n\n\n# directories.doc\n\n在这个目录里边放一些markdown文件，可能最终有一天它们会被友好的展现出来（应该是在npm的网站上）\n\n\n# directories.example\n\n放一些示例脚本，或许某一天会有用 - -！\n\n\n# repository\n\n指定一个代码存放地址，对想要为你的项目贡献代码的人有帮助。像这样：\n\n"repository" :\n  {\n      "type" : "git",\n      "url" : "https://github.com/npm/npm.git"\n  }\n\n"repository" :\n  { \n      "type" : "svn", \n      "url" : "https://v8.googlecode.com/svn/trunk/"\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n若你的模块放在GitHub, GitHub gist, Bitbucket, or GitLab的仓库里，npm install的时候可以使用缩写标记来完成：\n\n"repository": "npm/npm"\n\n"repository": "gist:11081aaa281"\n\n"repository": "bitbucket:example/repo"\n\n"repository": "gitlab:another/repo"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# scripts\n\nscripts属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。key是生命周期中的事件，value是要执行的命令。 具体的内容有 install start stop 等，详见 https://docs.npmjs.com/misc/scripts\n\n\n# config\n\n用来设置一些项目不怎么变化的项目配置，例如port等。 用户用的时候可以使用如下用法：\n\nhttp.createServer(...).listen(process.env.npm_package_config_port)\n\n\n1\n\n\n可以通过npm config set foo:port 80来修改config。详见https://docs.npmjs.com/misc/config\n\n{ \n    "name" : "foo", \n    "config" : { "port" : "8080" }\n}\n\n\n1\n2\n3\n4\n\n\n\n# dependencies\n\ndependencies属性是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围，版本范围是一个字符，可以被一个或多个空格分割。 dependencies也可以被指定为一个git地址或者一个压缩包地址。 不要把测试工具或transpilers写到dependencies中。 下面是一些写法，详见https://docs.npmjs.com/misc/semver\n\n * version 精确匹配版本\n * >version 必须大于某个版本\n * >=version 大于等于\n * <version 小于\n * <=versionversion 小于\n * ~version "约等于"，具体规则详见semver文档\n * ^version "兼容版本"具体规则详见semver文档\n * 1.2.x 仅一点二点几的版本\n * http://... 见下面url作为denpendencies的说明\n * * 任何版本\n * "" 空字符，和*相同\n * version1 - version2 相当于 >=version1 <=version2.\n * range1 || range2 范围1和范围2满足任意一个都行\n * git... 见下面git url作为denpendencies的说明\n * user/repo See 见下面GitHub仓库的说明\n * tag 发布的一个特殊的标签，见npm-tag的文档 https://docs.npmjs.com/getting-started/using-tags\n * path/path/path 见下面本地模块的说明 下面的写法都是可以的:\n\n{ "dependencies" :\n  { "foo" : "1.0.0 - 2.9999.9999"\n  , "bar" : ">=1.0.2 <2.1.2"\n  , "baz" : ">1.0.2 <=2.3.4"\n  , "boo" : "2.0.1"\n  , "qux" : "<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 <3.0.0"\n  , "asd" : "http://asdf.com/asdf.tar.gz"\n  , "til" : "~1.2"\n  , "elf" : "~1.2.3"\n  , "two" : "2.x"\n  , "thr" : "3.3.x"\n  , "lat" : "latest"\n  , "dyl" : "file:../dyl"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# URLs as Dependencies\n\n在版本范围的地方可以写一个url指向一个压缩包，模块安装的时候会把这个压缩包下载下来安装到模块本地。\n\n\n# Git URLs as Dependencies\n\nGit url可以像下面一样:\n\ngit://github.com/user/project.git#commit-ish\ngit+ssh://user@hostname:project.git#commit-ish\ngit+ssh://user@hostname/project.git#commit-ish\ngit+http://user@hostname/project/blah.git#commit-ish\ngit+https://user@hostname/project/blah.git#commit-ish\n\n\n1\n2\n3\n4\n5\n\n\ncommit-ish 可以是任意标签，哈希值，或者可以检出的分支，默认是master分支。\n\n\n# GitHub URLs\n\n支持github的 username/modulename 的写法，#后边可以加后缀写明分支hash或标签：\n\n{\n  "name": "foo",\n  "version": "0.0.0",\n  "dependencies": {\n    "express": "visionmedia/express",\n    "mocha": "visionmedia/mocha#4727d357ea"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Local Paths\n\nnpm2.0.0版本以上可以提供一个本地路径来安装一个本地的模块，通过npm install xxx --save 来安装，格式如下：\n\n../foo/bar\n~/foo/bar\n./foo/bar\n/foo/bar\n\n\n1\n2\n3\n4\n\n\npackage.json 生成的相对路径如下:\n\n{\n  "name": "baz",\n  "dependencies": {\n    "bar": "file:../foo/bar"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这种属性在离线开发或者测试需要用npm install的情况，又不想自己搞一个npm server的时候有用，但是发布模块到公共仓库时不应该使用这种属性。\n\n\n# devDependencies\n\n如果有人想要下载并使用你的模块，也许他们并不希望或需要下载一些你在开发过程中使用的额外的测试或者文档框架。 在这种情况下，最好的方法是把这些依赖添加到devDependencies属性的对象中。 这些模块会在npm link或者npm install的时候被安装，也可以像其他npm配置一样被管理，详见npm的config文档。 对于一些跨平台的构建任务，例如把CoffeeScript编译成JavaScript，就可以通过在package.json的script属性里边配置prepublish脚本来完成这个任务，然后需要依赖的coffee-script模块就写在devDependencies属性种。 例如:\n\n{ "name": "ethopia-waza",\n  "description": "a delightfully fruity coffee varietal",\n  "version": "1.2.3",\n  "devDependencies": {\n    "coffee-script": "~1.6.3"\n  },\n  "scripts": {\n    "prepublish": "coffee -o lib/ -c src/waza.coffee"\n  },\n  "main": "lib/waza.js"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nprepublish脚本会在发布之前运行，因此用户在使用之前就不用再自己去完成编译的过程了。在开发模式下，运行npm install也会执行这个脚本（见npm script文档），因此可以很方便的调试。\n\n\n# peerDependencies\n\n有时候做一些插件开发，比如grunt等工具的插件，它们往往是在grunt的某个版本的基础上开发的，而在他们的代码中并不会出现require("grunt")这样的依赖，dependencies配置里边也不会写上grunt的依赖，为了说明此模块只能作为插件跑在宿主的某个版本范围下，可以配置peerDependencies：\n\n{\n  "name": "tea-latte",\n  "version": "1.3.5",\n  "peerDependencies": {\n    "tea": "2.x"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面这个配置确保再npm install的时候tea-latte会和2.x版本的tea一起安装，而且它们两个的依赖关系是同级的： ├── tea-latte@1.3.5 └── tea@2.2.0 这个配置的目的是让npm知道，如果要使用此插件模块，请确保安装了兼容版本的宿主模块。\n\n\n# bundledDependencies\n\n上面的单词少个d，写成bundleDependencies也可以。 指定发布的时候会被一起打包的模块。\n\n\n# optionalDependencies\n\n如果一个依赖模块可以被使用， 同时你也希望在该模块找不到或无法获取时npm继续运行，你可以把这个模块依赖放到optionalDependencies配置中。这个配置的写法和dependencies的写法一样，不同的是这里边写的模块安装失败不会导致npm install失败。 当然，这种模块就需要你自己在代码中处理模块确实的情况了，例如：\n\ntry {\n  var foo = require(\'foo\')\n  var fooVersion = require(\'foo/package.json\').version\n} catch (er) {\n  foo = null\n}\nif ( notGoodFooVersion(fooVersion) ) {\n  foo = null\n}\n\n// .. then later in your program ..\n\nif (foo) {\n  foo.doFooThings()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\noptionalDependencies 中的配置会覆盖dependencies中的配置，最好只在一个地方写。\n\n\n# engines\n\n你可以指定项目运行的node版本范围，如下： { "engines" : { "node" : ">=0.10.3 <0.12" } } 和dependencies一样，如果你不指定版本范围或者指定为*，任何版本的node都可以。 也可以指定一些npm版本可以正确的安装你的模块，例如： { "engines" : { "npm" : "~1.0.20" } } 要注意的是，除非你设置了engine-strict属性，engines属性是仅供参考的。\n\n\n# engineStrict\n\n注意：这个属性已经弃用，将在npm 3.0.0 版本干掉。\n\n\n# os\n\n可以指定你的模块只能在哪个操作系统上跑： "os" : [ "darwin", "linux" ] 也可以指定黑名单而不是白名单： "os" : [ "!win32" ] 服务的操作系统是由process.platform来判断的，这个属性允许黑白名单同时存在，虽然没啥必要这样搞...\n\n\n# cpu\n\n限制模块只能在某某cpu架构下运行 "cpu" : [ "x64", "ia32" ] 同样可以设置黑名单: "cpu" : [ "!arm", "!mips" ] cpu架构通过 process.arch 判断\n\n\n# preferGlobal\n\n如果您的软件包主要用于安装到全局的命令行应用程序，那么该值设置为true ，如果它被安装在本地，则提供一个警告。实际上该配置并没有阻止用户把模块安装到本地，只是防止该模块被错误的使用引起一些问题。\n\n\n# private\n\n如果这个属性被设置为true，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。如果你只想让模块被发布到一个特定的npm仓库，如一个内部的仓库，可与在下面的publishConfig中配置仓库参数。\n\n\n# publishConfig\n\n这个配置是会在模块发布时用到的一些值的集合。如果你不想模块被默认被标记为最新的，或者默认发布到公共仓库，可以在这里配置tag或仓库地址。\n\n\n# DEFAULT VALUES\n\nnpm设置了一些默认参数，如： "scripts": {"start": "node server.js"} 如果模块根目录下有一个server.js文件，那么npm start会默认运行这个文件。 "scripts":{"preinstall": "node-gyp rebuild"} 如果模块根目录下有binding.gyp, npm将默认用node-gyp来编译preinstall的脚本 "contributors": [...] 若模块根目录下有AUTHORS 文件，则npm会按Name (url)格式解析每一行的数据添加到contributors中，可以用#添加行注释\n\n\n# 参考文档列表(https://docs.npmjs.com/)\n\nsemver(7) npm-init(1) npm-version(1) npm-config(1) npm-config(7) npm-help(1) npm-faq(7) npm-install(1) npm-publish(1) npm-rm(1)',normalizedContent:'# npm package.json属性详解\n\n> 本文转自https://www.cnblogs.com/tzyy/p/5193811.html，作者：tzyy\n\n\n# 概述\n\npackage.json必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过npm-config来生成\n\n\n# name\n\npackage.json中最重要的属性是name和version两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。 name属性就是你的模块名称，下面是一些命名规则:\n\n * name必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\n\n * name不能以"_"或"."开头\n\n * 不能含有大写字母\n\n * name会成为url的一部分，不能含有url非法字符\n   \n   下面是官网文档的一些建议：\n\n * 不要使用和node核心模块一样的名称\n\n * name中不要含有"js"和"node"。 it\'s assumed that it\'s js, since you\'re writing a package.json file, and you can specify the engine using the "engines" field. (see below.)\n\n * name属性会成为模块url、命令行中的一个参数或者一个文件夹名称，任何非url安全的字符在name中都不能使用，也不能以"_"或"."开头\n\n * name属性也许会被写在require()的参数中，所以最好取个简短而语义化的值。\n\n * 创建一个模块前可以先到后边的网址查查name是否已经被占用. https://www.npmjs.com/\n   \n   * # 发布一个包的时候，需要检验某个包名是否存在\n     npm search <modulename>\n     \n     \n     1\n     2\n     \n\nname属性可以有一些前缀如 e.g. @myorg/mypackage.在npm-scope(7)的文档中可以看到详细说明\n\n\n# version\n\nversion必须可以被npm依赖的一个node-semver模块解析。具体规则见下面的dependencies模块\n\n\n# description\n\n一个描述，方便别人了解你的模块作用，搜索的时候也有用。\n\n\n# keywords\n\n一个字符串数组，方便别人搜索到本模块\n\n\n# homepage\n\n项目主页url 注意: 这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。 （原文档中用了 spit(吐)这个单词，作者表示他不是在开玩笑:）\n\n\n# bugs\n\n填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽，例如：\n\n{\n    "url" : "https://github.com/owner/project/issues",\n    "email" : "project@hostname.com"\n}\n\n\n1\n2\n3\n4\n\n\nurl和email可以任意填或不填，如果只填一个，可以直接写成一个字符串而不是对象。如果填写了url，npm bugs命令会使用这个url。\n\n\n# license\n\n你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。最简单的，例如你用bsd-3-clause 或 mit之类的协议，如下：\n\n{ "license" : "mit" }\n\n\n1\n\n\n你可以在https://spdx.org/licenses/ 这个地址查阅协议列表 。\n\n\n# 和用户相关的属性: author, contributors\n\nauthor是一个码农， contributors是一个码农数组。 person是一个有一些描述属性的对象，如下 like this:\n\n{\n    "name" : "barney rubble",\n    "email" : "b@rubble.com",\n    "url" : "http://barnyrubble.tumblr.com/"\n}\n\n\n1\n2\n3\n4\n5\n\n\n也可以按如下格式缩写，npm会帮着转换:\n\n"barney rubble b@rubble.com (http://barnyrubble.tumblr.com/)"\n\n\n1\n\n\nemail和url属性实际上都是可以省略的。描述用户信息的还有一个maintainers（维护者）属性。\n\n\n# files\n\nfiles属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了） 你也可以在模块根目录下创建一个.npmignore文件（windows下无法直接创建以"."开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法".gitignore"类似。\n\n\n# main\n\nmain属性指定了程序的主入口文件。意思是，如果你的模块被命名为foo，用户安装了这个模块并通过require("foo")来使用这个模块，那么require返回的内容就是main属性指定的文件中 module.exports指向的对象。 它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。\n\n\n# bin\n\n很多模块有一个或多个需要配置到path路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的） 如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：\n\n{\n    "bin" : { "myapp" : "./cli.js" }\n}\n\n\n1\n2\n3\n\n\n模块安装的时候，若是全局安装，则npm会为bin中配置的文件在bin目录下创建一个软连接（对于windows系统，默认会在c:\\users\\username\\appdata\\roaming\\npm目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。 因此，按上面的例子，当你安装myapp的时候，npm就会为cli.js在/usr/local/bin/myapp路径创建一个软链接。 如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：\n\n{ \n    "name": "my-program",\n    "version": "1.2.5", \n    "bin": "./path/to/program"\n}\n\n\n1\n2\n3\n4\n5\n\n\n作用和如下写法相同:\n\n{ \n    "name": "my-program", \n    "version": "1.2.5", \n    "bin" : { \n        "my-program" : "./path/to/program" \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# man\n\n制定一个或通过数组制定一些文件来让linux下的man命令查找文档地址。 如果只有一个文件被指定的话，安装后直接使用man+模块名称，而不管man指定的文件的实际名称。例如:\n\n{\n    "name" : "foo",\n    "version" : "1.2.3", \n    "description" : "a packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : "./man/doc.1"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过man foo命令会得到 ./man/doc.1 文件的内容。 如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：\n\n{ \n    "name" : "foo", \n    "version" : "1.2.3", \n    "description" : "a packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : [ "./man/foo.1", "./man/bar.1" ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n会创建一些文件来作为man foo和man foo-bar命令的结果。 man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。\n\n{ \n    "name" : "foo", \n    "version" : "1.2.3",\n    "description" : "a packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : [ "./man/foo.1", "./man/foo.2" ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n会创建 man foo 和 man 2 foo 两条命令。\n\n\n# directories\n\ncommonjs通过directories来制定一些方法来描述模块的结构，看看npm的package.json文件https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。 目前这个配置没有任何作用，将来可能会整出一些花样来。\n\n\n# directories.lib\n\n告诉用户模块中lib目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。\n\n\n# directories.bin\n\n如果你在这里指定了bin目录，这个配置下面的文件会被加入到bin路径下，如果你已经在package.json中配置了bin目录，那么这里的配置将不起任何作用。\n\n\n# directories.man\n\n指定一个目录，目录里边都是man文件，这是一种配置man文件的语法糖。\n\n\n# directories.doc\n\n在这个目录里边放一些markdown文件，可能最终有一天它们会被友好的展现出来（应该是在npm的网站上）\n\n\n# directories.example\n\n放一些示例脚本，或许某一天会有用 - -！\n\n\n# repository\n\n指定一个代码存放地址，对想要为你的项目贡献代码的人有帮助。像这样：\n\n"repository" :\n  {\n      "type" : "git",\n      "url" : "https://github.com/npm/npm.git"\n  }\n\n"repository" :\n  { \n      "type" : "svn", \n      "url" : "https://v8.googlecode.com/svn/trunk/"\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n若你的模块放在github, github gist, bitbucket, or gitlab的仓库里，npm install的时候可以使用缩写标记来完成：\n\n"repository": "npm/npm"\n\n"repository": "gist:11081aaa281"\n\n"repository": "bitbucket:example/repo"\n\n"repository": "gitlab:another/repo"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# scripts\n\nscripts属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。key是生命周期中的事件，value是要执行的命令。 具体的内容有 install start stop 等，详见 https://docs.npmjs.com/misc/scripts\n\n\n# config\n\n用来设置一些项目不怎么变化的项目配置，例如port等。 用户用的时候可以使用如下用法：\n\nhttp.createserver(...).listen(process.env.npm_package_config_port)\n\n\n1\n\n\n可以通过npm config set foo:port 80来修改config。详见https://docs.npmjs.com/misc/config\n\n{ \n    "name" : "foo", \n    "config" : { "port" : "8080" }\n}\n\n\n1\n2\n3\n4\n\n\n\n# dependencies\n\ndependencies属性是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围，版本范围是一个字符，可以被一个或多个空格分割。 dependencies也可以被指定为一个git地址或者一个压缩包地址。 不要把测试工具或transpilers写到dependencies中。 下面是一些写法，详见https://docs.npmjs.com/misc/semver\n\n * version 精确匹配版本\n * >version 必须大于某个版本\n * >=version 大于等于\n * <version 小于\n * <=versionversion 小于\n * ~version "约等于"，具体规则详见semver文档\n * ^version "兼容版本"具体规则详见semver文档\n * 1.2.x 仅一点二点几的版本\n * http://... 见下面url作为denpendencies的说明\n * * 任何版本\n * "" 空字符，和*相同\n * version1 - version2 相当于 >=version1 <=version2.\n * range1 || range2 范围1和范围2满足任意一个都行\n * git... 见下面git url作为denpendencies的说明\n * user/repo see 见下面github仓库的说明\n * tag 发布的一个特殊的标签，见npm-tag的文档 https://docs.npmjs.com/getting-started/using-tags\n * path/path/path 见下面本地模块的说明 下面的写法都是可以的:\n\n{ "dependencies" :\n  { "foo" : "1.0.0 - 2.9999.9999"\n  , "bar" : ">=1.0.2 <2.1.2"\n  , "baz" : ">1.0.2 <=2.3.4"\n  , "boo" : "2.0.1"\n  , "qux" : "<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 <3.0.0"\n  , "asd" : "http://asdf.com/asdf.tar.gz"\n  , "til" : "~1.2"\n  , "elf" : "~1.2.3"\n  , "two" : "2.x"\n  , "thr" : "3.3.x"\n  , "lat" : "latest"\n  , "dyl" : "file:../dyl"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# urls as dependencies\n\n在版本范围的地方可以写一个url指向一个压缩包，模块安装的时候会把这个压缩包下载下来安装到模块本地。\n\n\n# git urls as dependencies\n\ngit url可以像下面一样:\n\ngit://github.com/user/project.git#commit-ish\ngit+ssh://user@hostname:project.git#commit-ish\ngit+ssh://user@hostname/project.git#commit-ish\ngit+http://user@hostname/project/blah.git#commit-ish\ngit+https://user@hostname/project/blah.git#commit-ish\n\n\n1\n2\n3\n4\n5\n\n\ncommit-ish 可以是任意标签，哈希值，或者可以检出的分支，默认是master分支。\n\n\n# github urls\n\n支持github的 username/modulename 的写法，#后边可以加后缀写明分支hash或标签：\n\n{\n  "name": "foo",\n  "version": "0.0.0",\n  "dependencies": {\n    "express": "visionmedia/express",\n    "mocha": "visionmedia/mocha#4727d357ea"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# local paths\n\nnpm2.0.0版本以上可以提供一个本地路径来安装一个本地的模块，通过npm install xxx --save 来安装，格式如下：\n\n../foo/bar\n~/foo/bar\n./foo/bar\n/foo/bar\n\n\n1\n2\n3\n4\n\n\npackage.json 生成的相对路径如下:\n\n{\n  "name": "baz",\n  "dependencies": {\n    "bar": "file:../foo/bar"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这种属性在离线开发或者测试需要用npm install的情况，又不想自己搞一个npm server的时候有用，但是发布模块到公共仓库时不应该使用这种属性。\n\n\n# devdependencies\n\n如果有人想要下载并使用你的模块，也许他们并不希望或需要下载一些你在开发过程中使用的额外的测试或者文档框架。 在这种情况下，最好的方法是把这些依赖添加到devdependencies属性的对象中。 这些模块会在npm link或者npm install的时候被安装，也可以像其他npm配置一样被管理，详见npm的config文档。 对于一些跨平台的构建任务，例如把coffeescript编译成javascript，就可以通过在package.json的script属性里边配置prepublish脚本来完成这个任务，然后需要依赖的coffee-script模块就写在devdependencies属性种。 例如:\n\n{ "name": "ethopia-waza",\n  "description": "a delightfully fruity coffee varietal",\n  "version": "1.2.3",\n  "devdependencies": {\n    "coffee-script": "~1.6.3"\n  },\n  "scripts": {\n    "prepublish": "coffee -o lib/ -c src/waza.coffee"\n  },\n  "main": "lib/waza.js"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nprepublish脚本会在发布之前运行，因此用户在使用之前就不用再自己去完成编译的过程了。在开发模式下，运行npm install也会执行这个脚本（见npm script文档），因此可以很方便的调试。\n\n\n# peerdependencies\n\n有时候做一些插件开发，比如grunt等工具的插件，它们往往是在grunt的某个版本的基础上开发的，而在他们的代码中并不会出现require("grunt")这样的依赖，dependencies配置里边也不会写上grunt的依赖，为了说明此模块只能作为插件跑在宿主的某个版本范围下，可以配置peerdependencies：\n\n{\n  "name": "tea-latte",\n  "version": "1.3.5",\n  "peerdependencies": {\n    "tea": "2.x"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面这个配置确保再npm install的时候tea-latte会和2.x版本的tea一起安装，而且它们两个的依赖关系是同级的： ├── tea-latte@1.3.5 └── tea@2.2.0 这个配置的目的是让npm知道，如果要使用此插件模块，请确保安装了兼容版本的宿主模块。\n\n\n# bundleddependencies\n\n上面的单词少个d，写成bundledependencies也可以。 指定发布的时候会被一起打包的模块。\n\n\n# optionaldependencies\n\n如果一个依赖模块可以被使用， 同时你也希望在该模块找不到或无法获取时npm继续运行，你可以把这个模块依赖放到optionaldependencies配置中。这个配置的写法和dependencies的写法一样，不同的是这里边写的模块安装失败不会导致npm install失败。 当然，这种模块就需要你自己在代码中处理模块确实的情况了，例如：\n\ntry {\n  var foo = require(\'foo\')\n  var fooversion = require(\'foo/package.json\').version\n} catch (er) {\n  foo = null\n}\nif ( notgoodfooversion(fooversion) ) {\n  foo = null\n}\n\n// .. then later in your program ..\n\nif (foo) {\n  foo.dofoothings()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\noptionaldependencies 中的配置会覆盖dependencies中的配置，最好只在一个地方写。\n\n\n# engines\n\n你可以指定项目运行的node版本范围，如下： { "engines" : { "node" : ">=0.10.3 <0.12" } } 和dependencies一样，如果你不指定版本范围或者指定为*，任何版本的node都可以。 也可以指定一些npm版本可以正确的安装你的模块，例如： { "engines" : { "npm" : "~1.0.20" } } 要注意的是，除非你设置了engine-strict属性，engines属性是仅供参考的。\n\n\n# enginestrict\n\n注意：这个属性已经弃用，将在npm 3.0.0 版本干掉。\n\n\n# os\n\n可以指定你的模块只能在哪个操作系统上跑： "os" : [ "darwin", "linux" ] 也可以指定黑名单而不是白名单： "os" : [ "!win32" ] 服务的操作系统是由process.platform来判断的，这个属性允许黑白名单同时存在，虽然没啥必要这样搞...\n\n\n# cpu\n\n限制模块只能在某某cpu架构下运行 "cpu" : [ "x64", "ia32" ] 同样可以设置黑名单: "cpu" : [ "!arm", "!mips" ] cpu架构通过 process.arch 判断\n\n\n# preferglobal\n\n如果您的软件包主要用于安装到全局的命令行应用程序，那么该值设置为true ，如果它被安装在本地，则提供一个警告。实际上该配置并没有阻止用户把模块安装到本地，只是防止该模块被错误的使用引起一些问题。\n\n\n# private\n\n如果这个属性被设置为true，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。如果你只想让模块被发布到一个特定的npm仓库，如一个内部的仓库，可与在下面的publishconfig中配置仓库参数。\n\n\n# publishconfig\n\n这个配置是会在模块发布时用到的一些值的集合。如果你不想模块被默认被标记为最新的，或者默认发布到公共仓库，可以在这里配置tag或仓库地址。\n\n\n# default values\n\nnpm设置了一些默认参数，如： "scripts": {"start": "node server.js"} 如果模块根目录下有一个server.js文件，那么npm start会默认运行这个文件。 "scripts":{"preinstall": "node-gyp rebuild"} 如果模块根目录下有binding.gyp, npm将默认用node-gyp来编译preinstall的脚本 "contributors": [...] 若模块根目录下有authors 文件，则npm会按name (url)格式解析每一行的数据添加到contributors中，可以用#添加行注释\n\n\n# 参考文档列表(https://docs.npmjs.com/)\n\nsemver(7) npm-init(1) npm-version(1) npm-config(1) npm-config(7) npm-help(1) npm-faq(7) npm-install(1) npm-publish(1) npm-rm(1)',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"yaml语言教程",frontmatter:{title:"yaml语言教程",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/4e8444e2d534d14f",categories:["技术","技术文档"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/100.%E5%85%B6%E4%BB%96/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/15.yaml%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B.html",relativePath:"100.其他/01.技术文档/15.yaml语言教程.md",key:"v-0e65177a",path:"/pages/4e8444e2d534d14f/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:15},{level:2,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:326},{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:422},{level:2,title:"YAML 对象",slug:"yaml-对象",normalizedTitle:"yaml 对象",charIndex:576},{level:2,title:"YAML 数组",slug:"yaml-数组",normalizedTitle:"yaml 数组",charIndex:1086},{level:2,title:"复合结构（对象和数组组合）",slug:"复合结构-对象和数组组合",normalizedTitle:"复合结构（对象和数组组合）",charIndex:1594},{level:2,title:"纯量",slug:"纯量",normalizedTitle:"纯量",charIndex:549},{level:2,title:"转换数据格式",slug:"转换数据格式",normalizedTitle:"转换数据格式",charIndex:3050},{level:2,title:"锚点引用",slug:"锚点引用",normalizedTitle:"锚点引用",charIndex:3157}],excerpt:'<h1 id="yaml语言教程"><a class="header-anchor" href="#yaml语言教程">#</a> yaml语言教程</h1>\n<h2 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h2>\n<p>YAML 是 &quot;YAML Ain\'t a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。</p>\n',headersStr:"简介 基本语法 数据类型 YAML 对象 YAML 数组 复合结构（对象和数组组合） 纯量 转换数据格式 锚点引用",content:"# yaml语言教程\n\n\n# 简介\n\nYAML 是 \"YAML Ain't a Markup Language\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\"Yet Another Markup Language\"（仍是一种标记语言）。\n\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\n\nYAML 的配置文件后缀为 .yml，如：runoob.yml 。\n\n> yaml常用来用作配置文件，和json类似\n\n\n# 基本语法\n\n * 大小写敏感\n\n * 使用缩进表示层级关系\n\n * 缩进不允许使用tab，只允许空格\n\n * 缩进的空格数不重要，只要相同层级的元素左对齐即可\n\n * '#'表示注释\n\n\n# 数据类型\n\nYAML 支持以下几种数据类型：\n\n * 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n * 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n * 纯量（scalars）：单个的、不可再分的值\n\n\n# YAML 对象\n\n对象的几种表示形式：\n\n1、对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。\n\nkey: value\n\n\n1\n\n\n2、也可以使用 key:{key1: value1, key2: value2, ...}。\n\nkey:{child-key1:value1,child-key2:value2}\n\n\n1\n\n\n3、还可以使用缩进表示层级关系；\n\nkey: \n    child-key1: value1\n    child-key2: value2\n\n\n1\n2\n3\n\n\n同2，只是表示形式不同。\n\n4、较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：\n\n?  \n    - complexkey1\n    - complexkey2\n:\n    - complexvalue1\n    - complexvalue2\n\n\n1\n2\n3\n4\n5\n6\n\n\n意思即对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]\n\n\n# YAML 数组\n\n以 - 开头的行表示构成一个数组：\n\n- A\n- B\n- C\n\n\n1\n2\n3\n\n\nYAML 支持多维数组，可以使用行内表示：\n\nkey: [value1, value2, ...]\n\n\n1\n\n\n数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。\n\n-\n - A\n - B\n - C\n\n\n1\n2\n3\n4\n\n\n一个相对复杂的例子：\n\ncompanies:\n    -\n        id: 1\n        name: company1\n        price: 200W\n    -\n        id: 2\n        name: company2\n        price: 500W\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。\n\n数组也可以使用流式(flow)的方式表示：\n\ncompanies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]\n\n\n1\n\n\n\n# 复合结构（对象和数组组合）\n\n数组和对象可以构成复合结构，例：\n\nlanguages:\n  - Ruby\n  - Perl\n  - Python \nwebsites:\n  YAML: yaml.org \n  Ruby: ruby-lang.org \n  Python: python.org \n  Perl: use.perl.org\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转换为 js 为：\n\n{ \n  languages: [ 'Ruby', 'Perl', 'Python'],\n  websites: {\n    YAML: 'yaml.org',\n    Ruby: 'ruby-lang.org',\n    Python: 'python.org',\n    Perl: 'use.perl.org' \n  } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 纯量\n\n纯量是最基本的，不可再分的值，包括：\n\n * 字符串\n * 布尔值\n * 整数\n * 浮点数\n * Null\n * 时间\n * 日期\n\n使用一个例子来快速了解纯量的基本使用：\n\nboolean: # 布尔值\n    - TRUE  #true,True都可以\n    - FALSE  #false，False都可以\nfloat: # 浮点数\n    - 3.14\n    - 6.8523015e+5  #可以使用科学计数法\nint: # 整数\n    - 123\n    - 0b1010_0111_0100_1010_1110    #二进制表示\nnull: # Null\n    nodeName: 'node'\n    parent: ~  #使用~表示null\nstring: # 字符串\n    - 哈哈 # 字符串默认不使用引号表示\n    - 'Hello world'  #可以使用双引号或者单引号包裹特殊字符\n    - newline\n      newline2    #字符串可以拆成多行，每一行会被转化成一个空格\ndate:\n    - 2018-02-17    #日期必须使用ISO 8601格式，即yyyy-MM-dd\ndatetime: \n    -  2018-02-17T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n多行字符串可以使用|保留换行符，也可以使用>折叠换行。\n\nthis: |\n  Foo\n  Bar\nthat: >\n  Foo\n  Bar\n\n\n1\n2\n3\n4\n5\n6\n\n\n转为js代码如下。\n\n{ this: 'Foo\\nBar\\n', that: 'Foo Bar\\n' }\n\n\n1\n\n\n+表示保留文字块末尾的换行，-表示删除字符串末尾的换行。\n\ns1: |\n  Foo\n \ns2: |+\n  Foo\n \n \ns3: |-\n  Foo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转为json代码如下\n\n{ s1: 'Foo\\n', s2: 'Foo\\n\\n\\n', s3: 'Foo' }\n\n\n1\n\n\n字符串之中可以插入 HTML 标记。\n\nmessage: |\n  <p style=\"color: red\">\n    段落\n  </p>\n\n\n1\n2\n3\n4\n\n\n\n# 转换数据格式\n\n允许使用两个感叹号，强制转换数据类型。\n\ne: !!str 123\nf: !!str true\n\n\n1\n2\n\n\n转换js结果同：\n\n{ e: '123', f: 'true' }\n\n\n1\n\n\n\n# 锚点引用\n\n& 锚点和< span class=\"marked\">* 别名，可以用来引用:\n\ndefaults: &defaults # 添加锚点\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  <<: *defaults # <<表示合并，*引用锚点\n\ntest:\n  database: myapp_test\n  <<: *defaults # <<表示合并，*引用锚点\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n相当于:\n\ndefaults:\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  adapter:  postgres\n  host:     localhost\n\ntest:\n  database: myapp_test\n  adapter:  postgres\n  host:     localhost\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n& 用来建立锚点（defaults），<< 表示合并到当前数据，***** 用来引用锚点。\n\n下面是另一个例子:\n\n- &showell Steve \n- Clark \n- Brian \n- Oren \n- *showell \n\n\n1\n2\n3\n4\n5\n\n\n转为js代码如下:\n\n[ 'Steve', 'Clark', 'Brian', 'Oren', 'Steve' ]\n\n\n1\n\n\n> 参考：\n> \n>  * yaml官网：https://yaml.org/\n>  * yaml与js的转换demo：http://nodeca.github.io/js-yaml/\n>  * 菜鸟教程：https://www.ruanyifeng.com/blog/2016/07/yaml.html",normalizedContent:"# yaml语言教程\n\n\n# 简介\n\nyaml 是 \"yaml ain't a markup language\"（yaml 不是一种标记语言）的递归缩写。在开发的这种语言时，yaml 的意思其实是：\"yet another markup language\"（仍是一种标记语言）。\n\nyaml 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和yaml非常接近）。\n\nyaml 的配置文件后缀为 .yml，如：runoob.yml 。\n\n> yaml常用来用作配置文件，和json类似\n\n\n# 基本语法\n\n * 大小写敏感\n\n * 使用缩进表示层级关系\n\n * 缩进不允许使用tab，只允许空格\n\n * 缩进的空格数不重要，只要相同层级的元素左对齐即可\n\n * '#'表示注释\n\n\n# 数据类型\n\nyaml 支持以下几种数据类型：\n\n * 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n * 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n * 纯量（scalars）：单个的、不可再分的值\n\n\n# yaml 对象\n\n对象的几种表示形式：\n\n1、对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。\n\nkey: value\n\n\n1\n\n\n2、也可以使用 key:{key1: value1, key2: value2, ...}。\n\nkey:{child-key1:value1,child-key2:value2}\n\n\n1\n\n\n3、还可以使用缩进表示层级关系；\n\nkey: \n    child-key1: value1\n    child-key2: value2\n\n\n1\n2\n3\n\n\n同2，只是表示形式不同。\n\n4、较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：\n\n?  \n    - complexkey1\n    - complexkey2\n:\n    - complexvalue1\n    - complexvalue2\n\n\n1\n2\n3\n4\n5\n6\n\n\n意思即对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]\n\n\n# yaml 数组\n\n以 - 开头的行表示构成一个数组：\n\n- a\n- b\n- c\n\n\n1\n2\n3\n\n\nyaml 支持多维数组，可以使用行内表示：\n\nkey: [value1, value2, ...]\n\n\n1\n\n\n数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。\n\n-\n - a\n - b\n - c\n\n\n1\n2\n3\n4\n\n\n一个相对复杂的例子：\n\ncompanies:\n    -\n        id: 1\n        name: company1\n        price: 200w\n    -\n        id: 2\n        name: company2\n        price: 500w\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。\n\n数组也可以使用流式(flow)的方式表示：\n\ncompanies: [{id: 1,name: company1,price: 200w},{id: 2,name: company2,price: 500w}]\n\n\n1\n\n\n\n# 复合结构（对象和数组组合）\n\n数组和对象可以构成复合结构，例：\n\nlanguages:\n  - ruby\n  - perl\n  - python \nwebsites:\n  yaml: yaml.org \n  ruby: ruby-lang.org \n  python: python.org \n  perl: use.perl.org\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转换为 js 为：\n\n{ \n  languages: [ 'ruby', 'perl', 'python'],\n  websites: {\n    yaml: 'yaml.org',\n    ruby: 'ruby-lang.org',\n    python: 'python.org',\n    perl: 'use.perl.org' \n  } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 纯量\n\n纯量是最基本的，不可再分的值，包括：\n\n * 字符串\n * 布尔值\n * 整数\n * 浮点数\n * null\n * 时间\n * 日期\n\n使用一个例子来快速了解纯量的基本使用：\n\nboolean: # 布尔值\n    - true  #true,true都可以\n    - false  #false，false都可以\nfloat: # 浮点数\n    - 3.14\n    - 6.8523015e+5  #可以使用科学计数法\nint: # 整数\n    - 123\n    - 0b1010_0111_0100_1010_1110    #二进制表示\nnull: # null\n    nodename: 'node'\n    parent: ~  #使用~表示null\nstring: # 字符串\n    - 哈哈 # 字符串默认不使用引号表示\n    - 'hello world'  #可以使用双引号或者单引号包裹特殊字符\n    - newline\n      newline2    #字符串可以拆成多行，每一行会被转化成一个空格\ndate:\n    - 2018-02-17    #日期必须使用iso 8601格式，即yyyy-mm-dd\ndatetime: \n    -  2018-02-17t15:02:31+08:00    #时间使用iso 8601格式，时间和日期之间使用t连接，最后使用+代表时区\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n多行字符串可以使用|保留换行符，也可以使用>折叠换行。\n\nthis: |\n  foo\n  bar\nthat: >\n  foo\n  bar\n\n\n1\n2\n3\n4\n5\n6\n\n\n转为js代码如下。\n\n{ this: 'foo\\nbar\\n', that: 'foo bar\\n' }\n\n\n1\n\n\n+表示保留文字块末尾的换行，-表示删除字符串末尾的换行。\n\ns1: |\n  foo\n \ns2: |+\n  foo\n \n \ns3: |-\n  foo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转为json代码如下\n\n{ s1: 'foo\\n', s2: 'foo\\n\\n\\n', s3: 'foo' }\n\n\n1\n\n\n字符串之中可以插入 html 标记。\n\nmessage: |\n  <p style=\"color: red\">\n    段落\n  </p>\n\n\n1\n2\n3\n4\n\n\n\n# 转换数据格式\n\n允许使用两个感叹号，强制转换数据类型。\n\ne: !!str 123\nf: !!str true\n\n\n1\n2\n\n\n转换js结果同：\n\n{ e: '123', f: 'true' }\n\n\n1\n\n\n\n# 锚点引用\n\n& 锚点和< span class=\"marked\">* 别名，可以用来引用:\n\ndefaults: &defaults # 添加锚点\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  <<: *defaults # <<表示合并，*引用锚点\n\ntest:\n  database: myapp_test\n  <<: *defaults # <<表示合并，*引用锚点\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n相当于:\n\ndefaults:\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  adapter:  postgres\n  host:     localhost\n\ntest:\n  database: myapp_test\n  adapter:  postgres\n  host:     localhost\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n& 用来建立锚点（defaults），<< 表示合并到当前数据，***** 用来引用锚点。\n\n下面是另一个例子:\n\n- &showell steve \n- clark \n- brian \n- oren \n- *showell \n\n\n1\n2\n3\n4\n5\n\n\n转为js代码如下:\n\n[ 'steve', 'clark', 'brian', 'oren', 'steve' ]\n\n\n1\n\n\n> 参考：\n> \n>  * yaml官网：https://yaml.org/\n>  * yaml与js的转换demo：http://nodeca.github.io/js-yaml/\n>  * 菜鸟教程：https://www.ruanyifeng.com/blog/2016/07/yaml.html",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"GitHub高级搜索技巧",frontmatter:{title:"GitHub高级搜索技巧",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/4c778760be26d8b3",categories:["技术","GitHub技巧"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/100.%E5%85%B6%E4%BB%96/02.GitHub%E6%8A%80%E5%B7%A7/01.GitHub%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html",relativePath:"100.其他/02.GitHub技巧/01.GitHub高级搜索技巧.md",key:"v-936eed32",path:"/pages/4c778760be26d8b3/",excerpt:'<h1 id="github高级搜索技巧"><a class="header-anchor" href="#github高级搜索技巧">#</a> GitHub高级搜索技巧</h1>\n<p><code>in:name &lt;关键字&gt;</code>\n仓库名称带关键字查询</p>\n<p><code>in:description &lt;关键字&gt;</code>\n仓库描述带关键字查询</p>\n<p><code>in:readme &lt;关键字&gt;</code>\nREADME文件带关键字查询</p>\n',headersStr:null,content:'# GitHub高级搜索技巧\n\nin:name <关键字> 仓库名称带关键字查询\n\nin:description <关键字> 仓库描述带关键字查询\n\nin:readme <关键字> README文件带关键字查询\n\nstars(fork): >(=) <数字> <关键字> star或fork数大于(或等于)指定数字的带关键字查询\n\nstars(fork): 10..20 <关键词> star或fork数在10到20之间的带关键字查询\n\nsize:>=5000 <关键词> 限定仓库大于等于5000K的带关键字查询\n\npushed(created):>2019-11-15 <关键字> 更新 或 创建 日期在2019年11月16日之后的带关键字查询\n\nlicense:apache-2.0 <关键字> LICENSE为apache-2.0的带关键字查询\n\nlanguage:java <关键词> 仓库语言为Java的带关键字查询\n\nuser:<用户名> 查询某个用户的项目\n\norg:<组织名> 查询某个组织的项目\n\n*以上查询条件可组合使用，空格隔开\n\n# 示例1：搜索仓库名包含javascript，并且stars数大于1000的项目\nin:name javascript stars:>1000\n\n# 示例2：搜索描述中包含"小程序"，并且fork大于100，并且最近更新时间在2019-11-15之后的，并且使用开发语言为vue的项目\nin:description 小程序 fork:>100 pushed:>2019-11-15 language:vue\n\n\n1\n2\n3\n4\n5\n\n\n*或使用高级搜索页搜索：\n\nhttps://github.com/search/advanced',normalizedContent:'# github高级搜索技巧\n\nin:name <关键字> 仓库名称带关键字查询\n\nin:description <关键字> 仓库描述带关键字查询\n\nin:readme <关键字> readme文件带关键字查询\n\nstars(fork): >(=) <数字> <关键字> star或fork数大于(或等于)指定数字的带关键字查询\n\nstars(fork): 10..20 <关键词> star或fork数在10到20之间的带关键字查询\n\nsize:>=5000 <关键词> 限定仓库大于等于5000k的带关键字查询\n\npushed(created):>2019-11-15 <关键字> 更新 或 创建 日期在2019年11月16日之后的带关键字查询\n\nlicense:apache-2.0 <关键字> license为apache-2.0的带关键字查询\n\nlanguage:java <关键词> 仓库语言为java的带关键字查询\n\nuser:<用户名> 查询某个用户的项目\n\norg:<组织名> 查询某个组织的项目\n\n*以上查询条件可组合使用，空格隔开\n\n# 示例1：搜索仓库名包含javascript，并且stars数大于1000的项目\nin:name javascript stars:>1000\n\n# 示例2：搜索描述中包含"小程序"，并且fork大于100，并且最近更新时间在2019-11-15之后的，并且使用开发语言为vue的项目\nin:description 小程序 fork:>100 pushed:>2019-11-15 language:vue\n\n\n1\n2\n3\n4\n5\n\n\n*或使用高级搜索页搜索：\n\nhttps://github.com/search/advanced',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"GitHub Actions 实现自动部署静态博客",frontmatter:{title:"GitHub Actions 实现自动部署静态博客",date:"2019-12-27T11:44:41.000Z",permalink:"/pages/6b9d359ec5aa5019",categories:["技术","GitHub技巧"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/100.%E5%85%B6%E4%BB%96/02.GitHub%E6%8A%80%E5%B7%A7/02.GitHub%20Actions%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2.html",relativePath:"100.其他/02.GitHub技巧/02.GitHub Actions 实现自动部署静态博客.md",key:"v-0944f7ee",path:"/pages/6b9d359ec5aa5019/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:32},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:17},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:3449}],excerpt:'<h1 id="github-actions-实现自动部署静态博客"><a class="header-anchor" href="#github-actions-实现自动部署静态博客">#</a> GitHub Actions 实现自动部署静态博客</h1>\n<h2 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h2>\n<p>我使用vuepress搭建了一个静态博客，挂在了Github pages和<a href="https://dev.tencent.com/" target="_blank" rel="noopener noreferrer">Coding pages<OutboundLink/></a>上面。</p>\n<p>coding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。</p>\n',headersStr:"前言 实现 相关文章",content:'# GitHub Actions 实现自动部署静态博客\n\n\n# 前言\n\n我使用vuepress搭建了一个静态博客，挂在了Github pages和Coding pages上面。\n\ncoding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。\n\n一开始的部署方式是使用sh部署脚本把代码提交到这两个平台的仓库分支，虽然已经很方便了，但是我还想把博客未打包的源码提交到Github主分支上。这就需要我操作两次命令，我就想能不能只需要一次操作就可以同时把源码、部署代码一次性提交到两个平台呢？\n\n\n# 实现\n\n在了解GitHub Actions最近（2019.12）刚正式发布了之后，尝试使用它发现能够满足我的需求。GitHub Actions 入门教程\n\n首先，需要获取token，后面会用到。获取方法：github获取token官方文档、coding获取token官方文档。\n\n然后，将这两个token同时储存到github仓库的Settings/Secrets里面。变量名可以随便取，但是注意要和后面的ci.yml文件内的变量名一致，这里取的是ACCESS_TOKEN和CODING_TOKEN。\n\n\n\nGitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。\n\nworkflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如ci.yml。一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。\n\n我的ci.yml文件：\n\nname: CI\n\n# 在master分支发生push事件时触发。\non: \n  push:\n    branches:\n      - master\njobs: # 工作流\n  build:\n    runs-on: ubuntu-latest #运行在虚拟机环境ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [10.x]\n\n    steps: \n      - name: Checkout # 步骤1\n        uses: actions/checkout@v1 # 使用的动作。格式：userName/repoName。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n      - name: Use Node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n      - name: run deploy.sh # 步骤3 （同时部署到github和coding）\n        env: # 设置环境变量\n          GITHUB_TOKEN: ${{ secrets.ACCESS_TOKEN }} # toKen私密变量\n          CODING_TOKEN: ${{ secrets.CODING_TOKEN }} # 腾讯云开发者平台（coding）私密token\n        run: npm install && npm run deploy # 执行的命令  \n        # package.json 中添加 "deploy": "bash deploy.sh"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n这个配置文件会在我push提交代码到主分支时触发工作，运行环境是ubuntu-latest，工作步骤：\n\n * 一，获取仓库源码\n\n * 二，安装nodejs，打包项目有用到nodejs\n\n * 三，把token设置到环境变量，安装项目依赖，并运行deploy.sh文件，\n\n> ACCESS_TOKE 和 CODING_TOKEN 都是保存在github仓库的Settings/Secrets位置的私密变量，仓库代码中可以通过<secrets.变量名>来获取，保证了token的私密性。\n\n再来看看将要被运行的deploy.sh部署代码：\n\n#!/usr/bin/env sh\n# 确保脚本抛出遇到的错误\nset -e\nnpm run build # 生成静态文件\ncd docs/.vuepress/dist # 进入生成的文件夹\n\n# deploy to github\necho \'blog.xugaoyi.com\' > CNAME\nif [ -z "$GITHUB_TOKEN" ]; then\n  msg=\'deploy\'\n  githubUrl=git@github.com:xugaoyi/blog.git\nelse\n  msg=\'来自github action的自动部署\'\n  githubUrl=https://xugaoyi:${GITHUB_TOKEN}@github.com/xugaoyi/blog.git\n  git config --global user.name "xugaoyi"\n  git config --global user.email "894072666@qq.com"\nfi\ngit init\ngit add -A\ngit commit -m "${msg}"\ngit push -f $githubUrl master:gh-pages # 推送到github\n\n# deploy to coding\necho \'www.xugaoyi.com\\nxugaoyi.com\' > CNAME  # 自定义域名\nif [ -z "$CODING_TOKEN" ]; then  # -z 字符串 长度为0则为true；$CODING_TOKEN来自于github仓库`Settings/Secrets`设置的私密环境变量\n  codingUrl=git@git.dev.tencent.com:xugaoyi/xugaoyi.git\nelse\n  codingUrl=https://xugaoyi:${CODING_TOKEN}@git.dev.tencent.com/xugaoyi/xugaoyi.git\nfi\ngit add -A\ngit commit -m "${msg}"\ngit push -f $codingUrl master # 推送到coding\n\ncd -\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这个文件使用Shell命令写的，它会先运行打包命令，进入打包好的文件，创建一个自定义域名的CNAME文件（如果你没有自定义域名可去掉这个命令），判断是否有token环境变量，如果没有说明是在本地自己的电脑上运行的部署，使用ssh代码仓库地址，如果有token环境变量，说明是GitHub Actions自动触发的部署，此时使用的是可以通过toKen来获取代码提交权限的提交地址。最后通过git命令提交到各自的仓库，完成部署。\n\n> 提示：\n> \n>  * Shell 可以获取到环境变量。\n> \n>  * 我想给两个平台上部署的博客不一样的自定义域名，因此做了分开创建CNAME文件，分开提交。\n\n至此，我前面提到的需求就实现啦，只需要把源码push到github仓库这一个步骤，后面的博客打包、部署到github和coding等工作都由GitHub Actions来自动完成。\n\n如下你想查看部署日志，你可以到github仓库的Actions这一项查看。\n\n\n\n\n# 相关文章\n\n《GitHub Actions 定时运行代码：每天定时百度链接推送》',normalizedContent:'# github actions 实现自动部署静态博客\n\n\n# 前言\n\n我使用vuepress搭建了一个静态博客，挂在了github pages和coding pages上面。\n\ncoding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。\n\n一开始的部署方式是使用sh部署脚本把代码提交到这两个平台的仓库分支，虽然已经很方便了，但是我还想把博客未打包的源码提交到github主分支上。这就需要我操作两次命令，我就想能不能只需要一次操作就可以同时把源码、部署代码一次性提交到两个平台呢？\n\n\n# 实现\n\n在了解github actions最近（2019.12）刚正式发布了之后，尝试使用它发现能够满足我的需求。github actions 入门教程\n\n首先，需要获取token，后面会用到。获取方法：github获取token官方文档、coding获取token官方文档。\n\n然后，将这两个token同时储存到github仓库的settings/secrets里面。变量名可以随便取，但是注意要和后面的ci.yml文件内的变量名一致，这里取的是access_token和coding_token。\n\n\n\ngithub actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。\n\nworkflow 文件采用 yaml 格式，文件名可以任意取，但是后缀名统一为.yml，比如ci.yml。一个库可以有多个 workflow 文件。github 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。\n\n我的ci.yml文件：\n\nname: ci\n\n# 在master分支发生push事件时触发。\non: \n  push:\n    branches:\n      - master\njobs: # 工作流\n  build:\n    runs-on: ubuntu-latest #运行在虚拟机环境ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [10.x]\n\n    steps: \n      - name: checkout # 步骤1\n        uses: actions/checkout@v1 # 使用的动作。格式：username/reponame。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n      - name: use node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n      - name: run deploy.sh # 步骤3 （同时部署到github和coding）\n        env: # 设置环境变量\n          github_token: ${{ secrets.access_token }} # token私密变量\n          coding_token: ${{ secrets.coding_token }} # 腾讯云开发者平台（coding）私密token\n        run: npm install && npm run deploy # 执行的命令  \n        # package.json 中添加 "deploy": "bash deploy.sh"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n这个配置文件会在我push提交代码到主分支时触发工作，运行环境是ubuntu-latest，工作步骤：\n\n * 一，获取仓库源码\n\n * 二，安装nodejs，打包项目有用到nodejs\n\n * 三，把token设置到环境变量，安装项目依赖，并运行deploy.sh文件，\n\n> access_toke 和 coding_token 都是保存在github仓库的settings/secrets位置的私密变量，仓库代码中可以通过<secrets.变量名>来获取，保证了token的私密性。\n\n再来看看将要被运行的deploy.sh部署代码：\n\n#!/usr/bin/env sh\n# 确保脚本抛出遇到的错误\nset -e\nnpm run build # 生成静态文件\ncd docs/.vuepress/dist # 进入生成的文件夹\n\n# deploy to github\necho \'blog.xugaoyi.com\' > cname\nif [ -z "$github_token" ]; then\n  msg=\'deploy\'\n  githuburl=git@github.com:xugaoyi/blog.git\nelse\n  msg=\'来自github action的自动部署\'\n  githuburl=https://xugaoyi:${github_token}@github.com/xugaoyi/blog.git\n  git config --global user.name "xugaoyi"\n  git config --global user.email "894072666@qq.com"\nfi\ngit init\ngit add -a\ngit commit -m "${msg}"\ngit push -f $githuburl master:gh-pages # 推送到github\n\n# deploy to coding\necho \'www.xugaoyi.com\\nxugaoyi.com\' > cname  # 自定义域名\nif [ -z "$coding_token" ]; then  # -z 字符串 长度为0则为true；$coding_token来自于github仓库`settings/secrets`设置的私密环境变量\n  codingurl=git@git.dev.tencent.com:xugaoyi/xugaoyi.git\nelse\n  codingurl=https://xugaoyi:${coding_token}@git.dev.tencent.com/xugaoyi/xugaoyi.git\nfi\ngit add -a\ngit commit -m "${msg}"\ngit push -f $codingurl master # 推送到coding\n\ncd -\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这个文件使用shell命令写的，它会先运行打包命令，进入打包好的文件，创建一个自定义域名的cname文件（如果你没有自定义域名可去掉这个命令），判断是否有token环境变量，如果没有说明是在本地自己的电脑上运行的部署，使用ssh代码仓库地址，如果有token环境变量，说明是github actions自动触发的部署，此时使用的是可以通过token来获取代码提交权限的提交地址。最后通过git命令提交到各自的仓库，完成部署。\n\n> 提示：\n> \n>  * shell 可以获取到环境变量。\n> \n>  * 我想给两个平台上部署的博客不一样的自定义域名，因此做了分开创建cname文件，分开提交。\n\n至此，我前面提到的需求就实现啦，只需要把源码push到github仓库这一个步骤，后面的博客打包、部署到github和coding等工作都由github actions来自动完成。\n\n如下你想查看部署日志，你可以到github仓库的actions这一项查看。\n\n\n\n\n# 相关文章\n\n《github actions 定时运行代码：每天定时百度链接推送》',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"GitHub Actions 定时运行代码：每天定时百度链接推送",frontmatter:{title:"GitHub Actions 定时运行代码：每天定时百度链接推送",date:"2019-12-30T21:23:00.000Z",permalink:"/pages/f44d2f9ad04ab8d3",categories:["技术","GitHub技巧"],tags:["github","博客"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/100.%E5%85%B6%E4%BB%96/02.GitHub%E6%8A%80%E5%B7%A7/03.GitHub%20Actions%20%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%AF%8F%E5%A4%A9%E5%AE%9A%E6%97%B6%E7%99%BE%E5%BA%A6%E9%93%BE%E6%8E%A5%E6%8E%A8%E9%80%81.html",relativePath:"100.其他/02.GitHub技巧/03.GitHub Actions 定时运行代码：每天定时百度链接推送.md",key:"v-638f70fb",path:"/pages/f44d2f9ad04ab8d3/",headers:[{level:2,title:"百度主动链接推送",slug:"百度主动链接推送",normalizedTitle:"百度主动链接推送",charIndex:246},{level:2,title:"自动生成urls.txt",slug:"自动生成urls-txt",normalizedTitle:"自动生成urls.txt",charIndex:603},{level:2,title:"GitHub Actions 定时运行代码",slug:"github-actions-定时运行代码",normalizedTitle:"github actions 定时运行代码",charIndex:2},{level:3,title:"配置 GitHub Actions",slug:"配置-github-actions",normalizedTitle:"配置 github actions",charIndex:2071},{level:3,title:"baiduPush命令在package.json配置",slug:"baidupush命令在package-json配置",normalizedTitle:"baidupush命令在package.json配置",charIndex:2824},{level:3,title:"baiduPush.sh执行百度推送命令",slug:"baidupush-sh执行百度推送命令",normalizedTitle:"baidupush.sh执行百度推送命令",charIndex:3175},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:3659}],excerpt:'<h1 id="github-actions-定时运行代码-每天定时百度链接推送"><a class="header-anchor" href="#github-actions-定时运行代码-每天定时百度链接推送">#</a> GitHub Actions 定时运行代码：每天定时百度链接推送</h1>\n<p>博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。</p>\n<p>最近刚好了解到GitHub Actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。</p>\n<p>GitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。<strong>功能非常强大，能够玩出许多花样。</strong></p>\n',headersStr:"百度主动链接推送 自动生成urls.txt GitHub Actions 定时运行代码 配置 GitHub Actions baiduPush命令在package.json配置 baiduPush.sh执行百度推送命令 相关文章",content:"# GitHub Actions 定时运行代码：每天定时百度链接推送\n\n博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。\n\n最近刚好了解到GitHub Actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。\n\nGitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 百度主动链接推送\n\n链接主动推送在百度站长中有介绍，如图。\n\n\n\n具体使用方法就是创建一个文件urls.txt，文件内每行一条链接的格式写入提交的多个链接，如图。\n\n\n\n运行命令\n\ncurl -H 'Content-Type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=xugaoyi.com&token=T5PEAzhG*****\"\n\n\n1\n\n\n上面命令的地址和参数由百度站长提供。运行完命令会返回推送结果，不出意外的话就会把urls.txt内的所有链接一次性推送给百度。\n\n这个方法虽然比嵌入网站头部的自动推送更高效，但是也有它的麻烦之处，就是得自己填入链接到urls.txt文件，然后手动运行命令。\n\n\n# 自动生成urls.txt\n\n没关系，技术的本质就是让人\"偷懒\"的。于是，我写了一个nodejs工具，用于把所有的博客页面链接生成到urls.txt\n\n// baiduPush.js\n\n/**\n * 生成百度链接推送文件\n */\nconst fs = require('fs');\nconst path = require('path');\nconst logger = require('tracer').colorConsole();\nconst matter = require('gray-matter'); // FrontMatter解析器 https://github.com/jonschlinkert/gray-matter\nconst readFileList = require('./modules/readFileList');\nconst urlsRoot = path.join(__dirname, '..', 'urls.txt'); // 百度链接推送文件\nconst DOMAIN = process.argv.splice(2)[0]; // 获取命令行传入的参数\n\nif (!DOMAIN) {\n  logger.error('请在运行此文件时指定一个你要进行百度推送的域名参数，例：node utils/baiduPush.js https://xugaoyi.com')\n  return\n}\n\nmain();\nfunction main() {\n  fs.writeFileSync(urlsRoot, DOMAIN)\n  const files = readFileList(); // 读取所有md文件数据\n\n  files.forEach( file => {\n    const { data } = matter(fs.readFileSync(file.filePath, 'utf8')); \n\n    if (data.permalink) {\n      const link = `\\r\\n${DOMAIN}${data.permalink}/`;\n      console.log(link)\n      fs.appendFileSync(urlsRoot, link);\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上面代码仅是针对我个人的博客生成链接到urls.txt文件。更多代码在 这里。\n\n运行如下命令就可以生产一个包含博客所有链接的urls.txt文件：\n\nnode utils/baiduPush.js https://xugaoyi.com\n\n\n1\n\n\n哈哈，第一个麻烦解决了😏，接下来是解决第二个需要手动运行推送命令的问题。\n\n> 如果你没办法自动生成，你也可以自己手动创建一个urls.txt文件，放到github仓库。\n\n\n# GitHub Actions 定时运行代码\n\n今天的主角GitHub Actions 要登场了。（相关：GitHub Actions 入门教程、GitHub Actions 实现自动部署静态博客）\n\nGitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 配置 GitHub Actions\n\n触发 GitHub Actions 需要在项目仓库新建一个.github/workflows子目录，里面是 YAML 格式配置文件，文件名可以随便取。GitHub 只要发现配置文件，就会运行 Actions。\n\n配置文件的第一部分是触发条件。\n\n## baiduPush.yml\nname: 'baiduPush'\n \non:\n  push:\n  schedule:\n    - cron: '0 23 * * *'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，name字段是配置文件的描述，on字段是触发条件。我们指定两种情况下触发，第一种是代码 Push 进仓库，第二种是定时任务，每天在国际标准时间23点（北京时间+8，即早上7点）运行。\n\n> 定时设置看这里\n\n接着，就是运行流程。\n\njobs:\n  bot:\n    runs-on: ubuntu-latest # 运行环境为最新版的Ubuntu\n    steps:\n      - name: 'Checkout codes' # 步骤一，获取仓库代码\n        uses: actions/checkout@v1\n      - name: 'Run baiduPush.sh' # 步骤二，执行sh命令文件\n        run: npm install && npm run baiduPush # 运行命令。（注意，运行目录是仓库根目录）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，指定运行环境是最新的ubuntu，流程的第一步是从代码仓库获取代码，第二步运行两个命令，先安装项目依赖，再运行写在package.json的baiduPush命令。完整代码看 这里\n\n\n# baiduPush命令在package.json配置\n\n// package.json\n\"scripts\": {\n\t\"baiduPush\": \"node utils/baiduPush.js https://xugaoyi.com && bash baiduPush.sh\"\n}\n\n\n1\n2\n3\n4\n\n\n上面脚本中在node utils/baiduPush.js的后面加入你的域名参数。运行此命令生成urls.txt文件，然后执行baiduPush.sh文件。\n\n注意，在使用window系统时，请使用git bash命令窗运行上面的脚本。\n\n> baiduPush命令之所以没有放在baiduPush.yml的 run 里面是因为我想在本地也可以执行npm run baiduPush命令。\n\n\n# baiduPush.sh执行百度推送命令\n\nbaiduPush.sh文件：\n\n#!/usr/bin/env sh\n\nset -e\n\n# 百度链接推送\ncurl -H 'Content-Type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=https://xugaoyi.com&token=T5PEAzhGa*****\"\n\nrm -rf urls.txt # 灭迹\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，把urls.txt文件中的所有链接一次性推送。\n\n> baiduPush.sh内的命令之所以没有写在package.json是因为我觉得命令太长了，不方便阅读。\n\n写好配置，推送到仓库，就会在每天的早上7点钟，自动运行命令生成一个包含博客所有页面链接的urls.txt文件，并把所有链接一次性推送到百度。麻麻再也不用担心我的网站不被收录~~😘 😘 😘\n\n在这个基础上可以扩展，使用GitHub Actions满足你自己的各种定时需求。\n\n\n# 相关文章\n\n《 GitHub Actions 实现自动部署静态博客》\n\n《解决百度无法收录搭建在GitHub上的静态博客的问题》",normalizedContent:"# github actions 定时运行代码：每天定时百度链接推送\n\n博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。\n\n最近刚好了解到github actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。\n\ngithub actions 是一个 ci/cd（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 百度主动链接推送\n\n链接主动推送在百度站长中有介绍，如图。\n\n\n\n具体使用方法就是创建一个文件urls.txt，文件内每行一条链接的格式写入提交的多个链接，如图。\n\n\n\n运行命令\n\ncurl -h 'content-type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=xugaoyi.com&token=t5peazhg*****\"\n\n\n1\n\n\n上面命令的地址和参数由百度站长提供。运行完命令会返回推送结果，不出意外的话就会把urls.txt内的所有链接一次性推送给百度。\n\n这个方法虽然比嵌入网站头部的自动推送更高效，但是也有它的麻烦之处，就是得自己填入链接到urls.txt文件，然后手动运行命令。\n\n\n# 自动生成urls.txt\n\n没关系，技术的本质就是让人\"偷懒\"的。于是，我写了一个nodejs工具，用于把所有的博客页面链接生成到urls.txt\n\n// baidupush.js\n\n/**\n * 生成百度链接推送文件\n */\nconst fs = require('fs');\nconst path = require('path');\nconst logger = require('tracer').colorconsole();\nconst matter = require('gray-matter'); // frontmatter解析器 https://github.com/jonschlinkert/gray-matter\nconst readfilelist = require('./modules/readfilelist');\nconst urlsroot = path.join(__dirname, '..', 'urls.txt'); // 百度链接推送文件\nconst domain = process.argv.splice(2)[0]; // 获取命令行传入的参数\n\nif (!domain) {\n  logger.error('请在运行此文件时指定一个你要进行百度推送的域名参数，例：node utils/baidupush.js https://xugaoyi.com')\n  return\n}\n\nmain();\nfunction main() {\n  fs.writefilesync(urlsroot, domain)\n  const files = readfilelist(); // 读取所有md文件数据\n\n  files.foreach( file => {\n    const { data } = matter(fs.readfilesync(file.filepath, 'utf8')); \n\n    if (data.permalink) {\n      const link = `\\r\\n${domain}${data.permalink}/`;\n      console.log(link)\n      fs.appendfilesync(urlsroot, link);\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上面代码仅是针对我个人的博客生成链接到urls.txt文件。更多代码在 这里。\n\n运行如下命令就可以生产一个包含博客所有链接的urls.txt文件：\n\nnode utils/baidupush.js https://xugaoyi.com\n\n\n1\n\n\n哈哈，第一个麻烦解决了😏，接下来是解决第二个需要手动运行推送命令的问题。\n\n> 如果你没办法自动生成，你也可以自己手动创建一个urls.txt文件，放到github仓库。\n\n\n# github actions 定时运行代码\n\n今天的主角github actions 要登场了。（相关：github actions 入门教程、github actions 实现自动部署静态博客）\n\ngithub actions 是一个 ci/cd（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 配置 github actions\n\n触发 github actions 需要在项目仓库新建一个.github/workflows子目录，里面是 yaml 格式配置文件，文件名可以随便取。github 只要发现配置文件，就会运行 actions。\n\n配置文件的第一部分是触发条件。\n\n## baidupush.yml\nname: 'baidupush'\n \non:\n  push:\n  schedule:\n    - cron: '0 23 * * *'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，name字段是配置文件的描述，on字段是触发条件。我们指定两种情况下触发，第一种是代码 push 进仓库，第二种是定时任务，每天在国际标准时间23点（北京时间+8，即早上7点）运行。\n\n> 定时设置看这里\n\n接着，就是运行流程。\n\njobs:\n  bot:\n    runs-on: ubuntu-latest # 运行环境为最新版的ubuntu\n    steps:\n      - name: 'checkout codes' # 步骤一，获取仓库代码\n        uses: actions/checkout@v1\n      - name: 'run baidupush.sh' # 步骤二，执行sh命令文件\n        run: npm install && npm run baidupush # 运行命令。（注意，运行目录是仓库根目录）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，指定运行环境是最新的ubuntu，流程的第一步是从代码仓库获取代码，第二步运行两个命令，先安装项目依赖，再运行写在package.json的baidupush命令。完整代码看 这里\n\n\n# baidupush命令在package.json配置\n\n// package.json\n\"scripts\": {\n\t\"baidupush\": \"node utils/baidupush.js https://xugaoyi.com && bash baidupush.sh\"\n}\n\n\n1\n2\n3\n4\n\n\n上面脚本中在node utils/baidupush.js的后面加入你的域名参数。运行此命令生成urls.txt文件，然后执行baidupush.sh文件。\n\n注意，在使用window系统时，请使用git bash命令窗运行上面的脚本。\n\n> baidupush命令之所以没有放在baidupush.yml的 run 里面是因为我想在本地也可以执行npm run baidupush命令。\n\n\n# baidupush.sh执行百度推送命令\n\nbaidupush.sh文件：\n\n#!/usr/bin/env sh\n\nset -e\n\n# 百度链接推送\ncurl -h 'content-type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=https://xugaoyi.com&token=t5peazhga*****\"\n\nrm -rf urls.txt # 灭迹\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，把urls.txt文件中的所有链接一次性推送。\n\n> baidupush.sh内的命令之所以没有写在package.json是因为我觉得命令太长了，不方便阅读。\n\n写好配置，推送到仓库，就会在每天的早上7点钟，自动运行命令生成一个包含博客所有页面链接的urls.txt文件，并把所有链接一次性推送到百度。麻麻再也不用担心我的网站不被收录~~😘 😘 😘\n\n在这个基础上可以扩展，使用github actions满足你自己的各种定时需求。\n\n\n# 相关文章\n\n《 github actions 实现自动部署静态博客》\n\n《解决百度无法收录搭建在github上的静态博客的问题》",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"GitHub加速下载项目的方法",frontmatter:{title:"GitHub加速下载项目的方法",date:"2020-03-09T10:28:09.000Z",permalink:"/pages/95331c6a9613faf8",categories:["技术","GitHub技巧"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/100.%E5%85%B6%E4%BB%96/02.GitHub%E6%8A%80%E5%B7%A7/10.GitHub%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%B9%E6%B3%95.html",relativePath:"100.其他/02.GitHub技巧/10.GitHub加速下载项目的方法.md",key:"v-6d7302f2",path:"/pages/95331c6a9613faf8/",headers:[{level:2,title:"利用码云来转接做下载加速",slug:"利用码云来转接做下载加速",normalizedTitle:"利用码云来转接做下载加速",charIndex:109}],excerpt:'<h1 id="github加速下载项目的方法"><a class="header-anchor" href="#github加速下载项目的方法">#</a> GitHub加速下载项目的方法</h1>\n<p>国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。</p>\n',headersStr:"利用码云来转接做下载加速",content:'# GitHub加速下载项目的方法\n\n国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。\n\n\n\n\n# 利用码云来转接做下载加速\n\n 1. 首先你得有一个 码云 的账号\n\n 2. 登录码云之后在页面右上角的加号选择从GitHub/GitLab导入项目\n    \n    \n\n 3. 选择从URL导入，粘贴从GitHub复制来的仓库地址，然后导入，这个导入过程一般是很快的。\n    \n    \n\n 4. 从码云克隆刚导入的这个项目，克隆速度会快很多，网速好的能达到几兆每秒（具体速度就看你的网速了，吐槽一下我家网速，总在关键时刻显示"视频加载中"....）\n    \n    \n\n 5. 另外要注意的一点，克隆下来的项目关联的是码云的仓库，如果你需要关联github仓库需要更改远程仓库。\n    \n    git remote -v # 查看关联的远程仓库\n    git remote rm <仓库名> # 删除远程仓库\n    git remote add <仓库名> <远程仓库地址> # 关联远程仓库，仓库名一般使用origin\n    \n    \n    1\n    2\n    3\n    \n\n这个方法适合用于克隆比较大的项目，如果克隆小项目，20k/s的速度好像还能将就~~',normalizedContent:'# github加速下载项目的方法\n\n国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。\n\n\n\n\n# 利用码云来转接做下载加速\n\n 1. 首先你得有一个 码云 的账号\n\n 2. 登录码云之后在页面右上角的加号选择从github/gitlab导入项目\n    \n    \n\n 3. 选择从url导入，粘贴从github复制来的仓库地址，然后导入，这个导入过程一般是很快的。\n    \n    \n\n 4. 从码云克隆刚导入的这个项目，克隆速度会快很多，网速好的能达到几兆每秒（具体速度就看你的网速了，吐槽一下我家网速，总在关键时刻显示"视频加载中"....）\n    \n    \n\n 5. 另外要注意的一点，克隆下来的项目关联的是码云的仓库，如果你需要关联github仓库需要更改远程仓库。\n    \n    git remote -v # 查看关联的远程仓库\n    git remote rm <仓库名> # 删除远程仓库\n    git remote add <仓库名> <远程仓库地址> # 关联远程仓库，仓库名一般使用origin\n    \n    \n    1\n    2\n    3\n    \n\n这个方法适合用于克隆比较大的项目，如果克隆小项目，20k/s的速度好像还能将就~~',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"解决百度无法收录搭建在GitHub上的个人博客的问题",frontmatter:{title:"解决百度无法收录搭建在GitHub上的个人博客的问题",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/41f87d890d0a02af",categories:["技术","博客搭建"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/100.%E5%85%B6%E4%BB%96/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/01.%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E6%97%A0%E6%B3%95%E6%94%B6%E5%BD%95%E6%90%AD%E5%BB%BA%E5%9C%A8GitHub%E4%B8%8A%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98.html",relativePath:"100.其他/04.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.md",key:"v-1de1c18a",path:"/pages/41f87d890d0a02af/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:74},{level:2,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:172},{level:3,title:"如何知道百度有没有收录？",slug:"如何知道百度有没有收录",normalizedTitle:"如何知道百度有没有收录？",charIndex:1221},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:1286}],excerpt:'<h1 id="解决百度无法收录搭建在github上的静态博客的问题"><a class="header-anchor" href="#解决百度无法收录搭建在github上的静态博客的问题">#</a> 解决百度无法收录搭建在GitHub上的静态博客的问题</h1>\n<div class="custom-block warning"><p class="custom-block-title">注意</p>\n<p>如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的<a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer">README<OutboundLink/></a>。</p>\n</div>\n<h2 id="背景"><a class="header-anchor" href="#背景">#</a> 背景</h2>\n<p>由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的<code>抓取诊断</code>再现，每次都是403 Forbidden的错误。</p>\n',headersStr:"背景 解决方案 如何知道百度有没有收录？ 相关文章",content:"# 解决百度无法收录搭建在GitHub上的静态博客的问题\n\n注意\n\n如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\n\n\n# 背景\n\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的抓取诊断再现，每次都是403 Forbidden的错误。\n\n\n# 解决方案\n\n同时将博客同时同步托管到GitHub Pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\n\n步骤：\n\n1、注册coding账号，创建仓库，把代码推送到coding仓库，并开启pages服务。\n\n> git 操作部分和使用github的差不多，不了解git操作的可以看我的另一篇文章：Git使用手册\n\n2、我的博客项目使用vuepress搭建的，使用的是如下自动部署脚本，同时将代码推送到github和conding。\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# github\necho 'b.xugaoyi.com' > CNAME\ngit init\ngit add -A\ngit commit -m 'deploy'\ngit push -f git@github.com:xugaoyi/blog.git master:gh-pages # 发布到github\n\n# coding\necho 'xugaoyi.com' > CNAME\ngit add -A\ngit commit -m 'deploy'\ngit push -f git@git.dev.tencent.com:xugaoyi/xugaoyi.git master # 发布到coding\n\ncd - # 退回开始所在目录\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 因为我想给两个平台上绑定不同的自定义域名，因此我分开创建了CNAME文件。\n\n3、有自定义域名的，也可以在coding pages绑定自定义域名，域名DNS解析中添加CNAME记录指向coding pages的站点地址即可。（没有自定义域名的可忽略，同时把自动部署脚本中的创建CNAME文件的脚本去掉）\n\n最后，使用百度站长的抓取诊断，发现抓取成功啦，再使用百度站长的链接提交功能，把链接提交给百度，过一段时间就可能在百度搜索中搜索到啦。\n\n\n# 如何知道百度有没有收录？\n\n在百度搜索框中使用site:<链接地址>，如：\n\nsite:xugaoyi.com\n\n\n1\n\n\n\n# 相关文章\n\n《GitHub Actions 定时运行代码：每天定时百度链接推送》",normalizedContent:"# 解决百度无法收录搭建在github上的静态博客的问题\n\n注意\n\n如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的readme。\n\n\n# 背景\n\n由于github禁止百度爬虫访问，造成托管在github pages上的博客无法被百度收录。相关问题可以通过百度站长平台的抓取诊断再现，每次都是403 forbidden的错误。\n\n\n# 解决方案\n\n同时将博客同时同步托管到github pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\n\n步骤：\n\n1、注册coding账号，创建仓库，把代码推送到coding仓库，并开启pages服务。\n\n> git 操作部分和使用github的差不多，不了解git操作的可以看我的另一篇文章：git使用手册\n\n2、我的博客项目使用vuepress搭建的，使用的是如下自动部署脚本，同时将代码推送到github和conding。\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# github\necho 'b.xugaoyi.com' > cname\ngit init\ngit add -a\ngit commit -m 'deploy'\ngit push -f git@github.com:xugaoyi/blog.git master:gh-pages # 发布到github\n\n# coding\necho 'xugaoyi.com' > cname\ngit add -a\ngit commit -m 'deploy'\ngit push -f git@git.dev.tencent.com:xugaoyi/xugaoyi.git master # 发布到coding\n\ncd - # 退回开始所在目录\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 因为我想给两个平台上绑定不同的自定义域名，因此我分开创建了cname文件。\n\n3、有自定义域名的，也可以在coding pages绑定自定义域名，域名dns解析中添加cname记录指向coding pages的站点地址即可。（没有自定义域名的可忽略，同时把自动部署脚本中的创建cname文件的脚本去掉）\n\n最后，使用百度站长的抓取诊断，发现抓取成功啦，再使用百度站长的链接提交功能，把链接提交给百度，过一段时间就可能在百度搜索中搜索到啦。\n\n\n# 如何知道百度有没有收录？\n\n在百度搜索框中使用site:<链接地址>，如：\n\nsite:xugaoyi.com\n\n\n1\n\n\n\n# 相关文章\n\n《github actions 定时运行代码：每天定时百度链接推送》",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"使用Gitalk实现静态博客无后台评论系统",frontmatter:{title:"使用Gitalk实现静态博客无后台评论系统",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/1da0bf9a988eafe5",categories:["技术","博客搭建"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/100.%E5%85%B6%E4%BB%96/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/02.%E4%BD%BF%E7%94%A8Gitalk%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%97%A0%E5%90%8E%E5%8F%B0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html",relativePath:"100.其他/04.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.md",key:"v-f465e8f0",path:"/pages/1da0bf9a988eafe5/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:28},{level:2,title:"准备",slug:"准备",normalizedTitle:"准备",charIndex:109},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:10},{level:3,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:338},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:2},{level:3,title:"BUG修复",slug:"bug修复",normalizedTitle:"bug修复",charIndex:1603}],excerpt:'<h1 id="使用gitalk实现静态博客无后台评论系统"><a class="header-anchor" href="#使用gitalk实现静态博客无后台评论系统">#</a> 使用Gitalk实现静态博客无后台评论系统</h1>\n<h2 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h2>\n<p>Gitalk，一个基于 Github Issue 和 Preact 开发的评论插件。</p>\n<p>下面我们来用它在vuepress搭建的博客中搭建评论区吧</p>\n',headersStr:"前言 准备 实现 安装 使用 BUG修复",content:"# 使用Gitalk实现静态博客无后台评论系统\n\n\n# 前言\n\nGitalk，一个基于 Github Issue 和 Preact 开发的评论插件。\n\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\n\n\n# 准备\n\n使用一个新的东西首先当然是要了解它\n\nGitalk demo：https://gitalk.github.io/\n\nGitalk github：https://github.com/gitalk/gitalk\n\n\n# 实现\n\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\n\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把Gitalk应用到vuepress搭建的静态博客。\n\n\n# 安装\n\nnpm install --save vuepress-plugin-comment\n\n\n1\n\n\n\n# 使用\n\noptions的配置和Gitalk的配置相同\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientID: 'GitHub Application Client ID',\n          clientSecret: 'GitHub Application Client Secret',\n          repo: 'GitHub repo',\n          owner: 'GitHub repo owner',\n          admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'],\n          distractionFreeMode: false \n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n需要 GitHub Application，如果没有 点击这里申请，Authorization callback URL 填写当前使用插件页面的域名。\n\n\n\n申请完成就会得 Client ID 和 Client Secret。然后把对应参数填写到配置中，例：\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientID: 'a6e*******4709b88b',\n          clientSecret: 'f0e***************beb8b2d54d7241',\n          repo: 'blog', // GitHub 仓库\n          owner: 'xugaoyi', // GitHub仓库所有者\n          admin: ['xugaoyi'], // 对仓库有写权限的人\n          distractionFreeMode: false \n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n配置好之后重启项目就发现页面上多了一个评论区，说明评论功能实现啦。但还是有一些bug，继续完善它~\n\n\n# BUG修复\n\n评论区与博客样式不匹配\n\n解决办法：新增全局样式文件.vuepress/styles/index.styl，写入样式\n\n#vuepress-plugin-comment\n  max-width $contentWidth\n  margin 0 auto\n  padding 2rem 2.5rem\n  @media (max-width: $MQNarrow)\n    padding 2rem\n  @media (max-width: $MQMobileNarrow)\n    padding 1.5rem\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n评论区出现 Error: Validation Failed.\n\n问题分析：当页面 链接过长 或 存在中文链接，导致整个链接字符串长度超过50时，会造成请求issues接口失败，出现422状态码。（中文链接会自动转码，变得很长，id参数默认取的是链接，长度不能超过50）\n\n解决办法：手动设置id取值，限制长度不超过50。\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // GitHub issue 的标题\n   labels: [\"Gitalk\", \"Comment\"], // GitHub issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // GitHub issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 访问变量时，如 $frontmatter 或 window等，请使用 EJS 语法。因为在配置中不能使用回调函数，会被vuepress过滤，因此使用 EJS 语法。 ——插件作者文档说明\n\n切换页面后评论区内容还是上一个页面的评论\n\n解决：id在获取path时使用 frontmatter.to.path，插件内置了 ``frontmatter.from、frontmatter.to`。\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // GitHub issue 的标题\n   labels: [\"Gitalk\", \"Comment\"], // GitHub issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // GitHub issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"# 使用gitalk实现静态博客无后台评论系统\n\n\n# 前言\n\ngitalk，一个基于 github issue 和 preact 开发的评论插件。\n\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\n\n\n# 准备\n\n使用一个新的东西首先当然是要了解它\n\ngitalk demo：https://gitalk.github.io/\n\ngitalk github：https://github.com/gitalk/gitalk\n\n\n# 实现\n\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\n\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把gitalk应用到vuepress搭建的静态博客。\n\n\n# 安装\n\nnpm install --save vuepress-plugin-comment\n\n\n1\n\n\n\n# 使用\n\noptions的配置和gitalk的配置相同\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientid: 'github application client id',\n          clientsecret: 'github application client secret',\n          repo: 'github repo',\n          owner: 'github repo owner',\n          admin: ['github repo owner and collaborators, only these guys can initialize github issues'],\n          distractionfreemode: false \n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n需要 github application，如果没有 点击这里申请，authorization callback url 填写当前使用插件页面的域名。\n\n\n\n申请完成就会得 client id 和 client secret。然后把对应参数填写到配置中，例：\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientid: 'a6e*******4709b88b',\n          clientsecret: 'f0e***************beb8b2d54d7241',\n          repo: 'blog', // github 仓库\n          owner: 'xugaoyi', // github仓库所有者\n          admin: ['xugaoyi'], // 对仓库有写权限的人\n          distractionfreemode: false \n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n配置好之后重启项目就发现页面上多了一个评论区，说明评论功能实现啦。但还是有一些bug，继续完善它~\n\n\n# bug修复\n\n评论区与博客样式不匹配\n\n解决办法：新增全局样式文件.vuepress/styles/index.styl，写入样式\n\n#vuepress-plugin-comment\n  max-width $contentwidth\n  margin 0 auto\n  padding 2rem 2.5rem\n  @media (max-width: $mqnarrow)\n    padding 2rem\n  @media (max-width: $mqmobilenarrow)\n    padding 1.5rem\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n评论区出现 error: validation failed.\n\n问题分析：当页面 链接过长 或 存在中文链接，导致整个链接字符串长度超过50时，会造成请求issues接口失败，出现422状态码。（中文链接会自动转码，变得很长，id参数默认取的是链接，长度不能超过50）\n\n解决办法：手动设置id取值，限制长度不超过50。\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // github issue 的标题\n   labels: [\"gitalk\", \"comment\"], // github issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // github issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 访问变量时，如 $frontmatter 或 window等，请使用 ejs 语法。因为在配置中不能使用回调函数，会被vuepress过滤，因此使用 ejs 语法。 ——插件作者文档说明\n\n切换页面后评论区内容还是上一个页面的评论\n\n解决：id在获取path时使用 frontmatter.to.path，插件内置了 ``frontmatter.from、frontmatter.to`。\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // github issue 的标题\n   labels: [\"gitalk\", \"comment\"], // github issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // github issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床",frontmatter:{title:"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床",date:"2020-01-03T12:55:43.000Z",permalink:"/pages/a5f73af5185fdf0a",categories:["技术","博客搭建"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/100.%E5%85%B6%E4%BB%96/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/03.GitHub%20+%20jsDelivr%20+%20TinyPNG+%20PicGo%20%E6%89%93%E9%80%A0%E7%A8%B3%E5%AE%9A%E5%BF%AB%E9%80%9F%E3%80%81%E9%AB%98%E6%95%88%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A.html",relativePath:"100.其他/04.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.md",key:"v-1a36efce",path:"/pages/a5f73af5185fdf0a/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:55},{level:2,title:"图床打造",slug:"图床打造",normalizedTitle:"图床打造",charIndex:590}],excerpt:'<h1 id="github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床"><a class="header-anchor" href="#github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床">#</a> GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床</h1>\n<h2 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h2>\n<p><strong>Q：为什么要使用图床呢？什么是图床？</strong></p>\n<p>A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用<code>markdown+图片url</code>的方式写作文章，一次编写，到处使用~</p>\n',headersStr:"前言 图床打造",content:"# GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\n\n\n# 前言\n\nQ：为什么要使用图床呢？什么是图床？\n\nA：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用markdown+图片url的方式写作文章，一次编写，到处使用~\n\n更好的选择...\n\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：https://picx.xpoet.cn/ 使用方法看一下他网站的使用教程就行。 撒由那拉~~\n\n2021.07.04\n\nQ：图床的选择\n\nA：推荐使用GitHub作为图床，特点是免费、稳定，有一个小缺点是国内访问速度慢，不过没关系，可以使用jsDelivr免费CDN加速。\n\nQ：jsDelivr是什么？\n\nA：jsDelivr是国外的一家优秀的公共 CDN 服务提供商，该平台是首个「打通中国大陆与海外的免费CDN服务」，无须担心中国防火墙问题而影响使用。官网：http://www.jsdelivr.com/\n\n\n# 图床打造\n\n 1. 新建GitHub仓库，注意仓库要设置成公开\n\n 2. 参照 官方文档 生成一个token密钥\n\n 3. 在 这里 下载PicGo，安装完成后打开，图床设置 选 GitHub图床，并填写相应的信息\n    \n    * 仓库名：前面新建的仓库，格式：<用户名>/<仓库名>\n    * 分支名：填写主分支master即可\n    * Token：前面生成的token密钥\n    * 存储路径：按你自己的需求填写\n    * 自定义域名：图片上传后，PicGo 会按照 自定义域名+上传的图片名 的方式生成访问链接，此处我们填写jsDelivr的CDN加速地址，格式：https://cdn.jsdelivr.net/gh/<用户名>/<仓库名>\n\n\n\n 4. 使用https://tinypng.cn/压缩你要上传的图片（如图片已经很小或你有更好的压缩工具可省略这一步）\n 5. 在PigGo的上传区上传你的图片，到相册一键复制刚刚上传的图片URL，至此，你就可以在你的文章当中愉快的插入图片啦~， 更多功能自己去探索吧~~\n\n",normalizedContent:"# github + jsdelivr + tinypng+ picgo 打造稳定快速、高效免费图床\n\n\n# 前言\n\nq：为什么要使用图床呢？什么是图床？\n\na：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的url，使用markdown+图片url的方式写作文章，一次编写，到处使用~\n\n更好的选择...\n\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：https://picx.xpoet.cn/ 使用方法看一下他网站的使用教程就行。 撒由那拉~~\n\n2021.07.04\n\nq：图床的选择\n\na：推荐使用github作为图床，特点是免费、稳定，有一个小缺点是国内访问速度慢，不过没关系，可以使用jsdelivr免费cdn加速。\n\nq：jsdelivr是什么？\n\na：jsdelivr是国外的一家优秀的公共 cdn 服务提供商，该平台是首个「打通中国大陆与海外的免费cdn服务」，无须担心中国防火墙问题而影响使用。官网：http://www.jsdelivr.com/\n\n\n# 图床打造\n\n 1. 新建github仓库，注意仓库要设置成公开\n\n 2. 参照 官方文档 生成一个token密钥\n\n 3. 在 这里 下载picgo，安装完成后打开，图床设置 选 github图床，并填写相应的信息\n    \n    * 仓库名：前面新建的仓库，格式：<用户名>/<仓库名>\n    * 分支名：填写主分支master即可\n    * token：前面生成的token密钥\n    * 存储路径：按你自己的需求填写\n    * 自定义域名：图片上传后，picgo 会按照 自定义域名+上传的图片名 的方式生成访问链接，此处我们填写jsdelivr的cdn加速地址，格式：https://cdn.jsdelivr.net/gh/<用户名>/<仓库名>\n\n\n\n 4. 使用https://tinypng.cn/压缩你要上传的图片（如图片已经很小或你有更好的压缩工具可省略这一步）\n 5. 在piggo的上传区上传你的图片，到相册一键复制刚刚上传的图片url，至此，你就可以在你的文章当中愉快的插入图片啦~， 更多功能自己去探索吧~~\n\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"vdoing主题效果图",frontmatter:{title:"vdoing主题效果图",date:"2020-04-08T11:27:22.000Z",permalink:"/pages/d557b9a89a215d2e",article:!1,author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/100.%E5%85%B6%E4%BB%96/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/10.vdoing%E4%B8%BB%E9%A2%98%E6%95%88%E6%9E%9C%E5%9B%BE.html",relativePath:"100.其他/04.博客搭建/10.vdoing主题效果图.md",key:"v-1426c78e",path:"/pages/d557b9a89a215d2e/",headers:[{level:2,title:"PC端",slug:"pc端",normalizedTitle:"pc端",charIndex:18},{level:2,title:"首页个性化大图",slug:"首页个性化大图",normalizedTitle:"首页个性化大图",charIndex:53},{level:2,title:"深色模式和阅读模式",slug:"深色模式和阅读模式",normalizedTitle:"深色模式和阅读模式",charIndex:76},{level:2,title:"移动端",slug:"移动端",normalizedTitle:"移动端",charIndex:105}],headersStr:"PC端 首页个性化大图 深色模式和阅读模式 移动端",content:"# vdoing主题效果图\n\n\n# PC端\n\n\n首页 & 目录页△\n\n文章详情页 & 时间轴页△\n\n\n# 首页个性化大图\n\n\n首页个性化大图△\n\n\n# 深色模式和阅读模式\n\n\n深色模式△\n\n阅读模式△\n\n\n# 移动端\n\n\n移动端效果△",normalizedContent:"# vdoing主题效果图\n\n\n# pc端\n\n\n首页 & 目录页△\n\n文章详情页 & 时间轴页△\n\n\n# 首页个性化大图\n\n\n首页个性化大图△\n\n\n# 深色模式和阅读模式\n\n\n深色模式△\n\n阅读模式△\n\n\n# 移动端\n\n\n移动端效果△",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/f1cf70/"},regularPath:"/15.%E5%89%8D%E7%AB%AF/05.HTML/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"15.前端/05.HTML/10.Redis高级客户端Lettuce详解.md",key:"v-8b61ee12",path:"/pages/f1cf70/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/b0cbfe/"},regularPath:"/15.%E5%89%8D%E7%AB%AF/10.JavaScript/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"15.前端/10.JavaScript/10.Redis高级客户端Lettuce详解.md",key:"v-01eb52f2",path:"/pages/b0cbfe/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/1b9d03/"},regularPath:"/15.%E5%89%8D%E7%AB%AF/15.CSS/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"15.前端/15.CSS/10.Redis高级客户端Lettuce详解.md",key:"v-0832524d",path:"/pages/1b9d03/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"nodejs递归读取所有文件",frontmatter:{title:"nodejs递归读取所有文件",date:"2019-12-26T15:57:32.000Z",permalink:"/pages/117708e0af7f0bd9",categories:["技术","Nodejs"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/100.%E5%85%B6%E4%BB%96/03.Nodejs/01.nodejs%E9%80%92%E5%BD%92%E8%AF%BB%E5%8F%96%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6.html",relativePath:"100.其他/03.Nodejs/01.nodejs递归读取所有文件.md",key:"v-3e241928",path:"/pages/117708e0af7f0bd9/",headersStr:null,content:"# nodejs递归读取所有文件\n\n\nvar fs = require('fs');\nvar path = require('path');\n \nfunction readFileList(dir, filesList = []) {\n    const files = fs.readdirSync(dir);\n    console.log(files);\n    files.forEach((item, index) => {\n        var fullPath = path.join(dir, item);\n        const stat = fs.statSync(fullPath);\n        if (stat.isDirectory()) {      \n            readFileList(path.join(dir, item), filesList);  //递归读取文件\n        } else {                \n            filesList.push(fullPath);                     \n        }        \n    });\n    return filesList;\n}\n \nvar filesList = [];\nreadFileList(__dirname,filesList);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# nodejs递归读取所有文件\n\n\nvar fs = require('fs');\nvar path = require('path');\n \nfunction readfilelist(dir, fileslist = []) {\n    const files = fs.readdirsync(dir);\n    console.log(files);\n    files.foreach((item, index) => {\n        var fullpath = path.join(dir, item);\n        const stat = fs.statsync(fullpath);\n        if (stat.isdirectory()) {      \n            readfilelist(path.join(dir, item), fileslist);  //递归读取文件\n        } else {                \n            fileslist.push(fullpath);                     \n        }        \n    });\n    return fileslist;\n}\n \nvar fileslist = [];\nreadfilelist(__dirname,fileslist);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/f94942/"},regularPath:"/15.%E5%89%8D%E7%AB%AF/20.ES6/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"15.前端/20.ES6/10.Redis高级客户端Lettuce详解.md",key:"v-85694126",path:"/pages/f94942/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/3a3093/"},regularPath:"/15.%E5%89%8D%E7%AB%AF/30.Webpack/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"15.前端/30.Webpack/10.Redis高级客户端Lettuce详解.md",key:"v-7db0be6d",path:"/pages/3a3093/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/6397c2/"},regularPath:"/15.%E5%89%8D%E7%AB%AF/25.Nodejs/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"15.前端/25.Nodejs/10.Redis高级客户端Lettuce详解.md",key:"v-0033648a",path:"/pages/6397c2/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/45f613/"},regularPath:"/15.%E5%89%8D%E7%AB%AF/35.Vue/05.Vue%20Router/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"15.前端/35.Vue/05.Vue Router/10.Redis高级客户端Lettuce详解.md",key:"v-315c4010",path:"/pages/45f613/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"《ES6 教程》笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"《ES6 教程》笔记",imgUrl:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200112160453.png",description:"本章内容为博主在原教程基础上添加学习笔记，教程版权归原作者所有。来源：<a href='https://es6.ruanyifeng.com/' target='_blank'>ES6教程</a>"}},title:"《ES6 教程》笔记",date:"2020-01-12T15:49:22.000Z",permalink:"/note/es6/",article:!1,comment:!1,editLink:!1,author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/15.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0.html",relativePath:"15.前端/40.学习笔记/10.《ES6 教程》笔记.md",key:"v-50864176",path:"/note/es6/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/8b11e8/"},regularPath:"/15.%E5%89%8D%E7%AB%AF/35.Vue/10.Vuex/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"15.前端/35.Vue/10.Vuex/10.Redis高级客户端Lettuce详解.md",key:"v-520c0bed",path:"/pages/8b11e8/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/be47c5/"},regularPath:"/25.%E8%BF%90%E7%BB%B4/05.Linux/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"25.运维/05.Linux/10.Redis高级客户端Lettuce详解.md",key:"v-7284126c",path:"/pages/be47c5/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/1cbc1f/"},regularPath:"/20.%E6%9E%B6%E6%9E%84/05.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"20.架构/05.设计模式/10.Redis高级客户端Lettuce详解.md",key:"v-462b4ed7",path:"/pages/1cbc1f/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/48ee28/"},regularPath:"/25.%E8%BF%90%E7%BB%B4/10.Shell%E8%84%9A%E6%9C%AC/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"25.运维/10.Shell脚本/10.Redis高级客户端Lettuce详解.md",key:"v-64279124",path:"/pages/48ee28/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/c0a158/"},regularPath:"/25.%E8%BF%90%E7%BB%B4/40.Tomcat/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"25.运维/40.Tomcat/10.Redis高级客户端Lettuce详解.md",key:"v-10cc5422",path:"/pages/c0a158/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/22279f/"},regularPath:"/25.%E8%BF%90%E7%BB%B4/45.Nginx/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"25.运维/45.Nginx/10.Redis高级客户端Lettuce详解.md",key:"v-61d376a8",path:"/pages/22279f/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Docker 初级篇",frontmatter:{title:"Docker 初级篇",date:"2022-02-03T00:03:52.000Z",permalink:"/pages/261b24/",categories:["后端","Docker"],tags:[null]},regularPath:"/25.%E8%BF%90%E7%BB%B4/50.Docker/01.Docker%20%E5%88%9D%E7%BA%A7%E7%AF%87.html",relativePath:"25.运维/50.Docker/01.Docker 初级篇.md",key:"v-529de428",path:"/pages/261b24/",headers:[{level:2,title:"Docker和传统虚拟化方式对比",slug:"docker和传统虚拟化方式对比",normalizedTitle:"docker和传统虚拟化方式对比",charIndex:236},{level:2,title:"镜像",slug:"镜像",normalizedTitle:"镜像",charIndex:227},{level:2,title:"容器",slug:"容器",normalizedTitle:"容器",charIndex:162},{level:2,title:"仓库",slug:"仓库",normalizedTitle:"仓库",charIndex:229},{level:3,title:"Docker Registry 公开服务",slug:"docker-registry-公开服务",normalizedTitle:"docker registry 公开服务",charIndex:2190},{level:3,title:"私有 Docker Registry",slug:"私有-docker-registry",normalizedTitle:"私有 docker registry",charIndex:2526},{level:2,title:"底层原理",slug:"底层原理",normalizedTitle:"底层原理",charIndex:2747},{level:2,title:"准备工作",slug:"准备工作",normalizedTitle:"准备工作",charIndex:3377},{level:3,title:"系统要求",slug:"系统要求",normalizedTitle:"系统要求",charIndex:3386},{level:3,title:"卸载旧版本",slug:"卸载旧版本",normalizedTitle:"卸载旧版本",charIndex:3513},{level:2,title:"使用 yum 安装",slug:"使用-yum-安装",normalizedTitle:"使用 yum 安装",charIndex:3961},{level:2,title:"安装 Docker",slug:"安装-docker",normalizedTitle:"安装 docker",charIndex:4428},{level:2,title:"CentOS8 额外设置",slug:"centos8-额外设置",normalizedTitle:"centos8 额外设置",charIndex:4534},{level:2,title:"启动 Docker",slug:"启动-docker",normalizedTitle:"启动 docker",charIndex:4832},{level:2,title:"建立 docker 用户组",slug:"建立-docker-用户组",normalizedTitle:"建立 docker 用户组",charIndex:4915},{level:2,title:"测试 Docker 是否安装正确",slug:"测试-docker-是否安装正确",normalizedTitle:"测试 docker 是否安装正确",charIndex:5206},{level:2,title:"镜像加速器",slug:"镜像加速器",normalizedTitle:"镜像加速器",charIndex:6417},{level:3,title:"CentOS 7+",slug:"centos-7",normalizedTitle:"centos 7+",charIndex:6707},{level:2,title:"添加内核参数",slug:"添加内核参数",normalizedTitle:"添加内核参数",charIndex:7648},{level:2,title:"获取镜像",slug:"获取镜像",normalizedTitle:"获取镜像",charIndex:7954},{level:2,title:"列出镜像",slug:"列出镜像",normalizedTitle:"列出镜像",charIndex:9466},{level:3,title:"镜像体积",slug:"镜像体积",normalizedTitle:"镜像体积",charIndex:10281},{level:3,title:"虚悬镜像",slug:"虚悬镜像",normalizedTitle:"虚悬镜像",charIndex:11286},{level:3,title:"中间层镜像",slug:"中间层镜像",normalizedTitle:"中间层镜像",charIndex:11509},{level:3,title:"列出部分镜像",slug:"列出部分镜像",normalizedTitle:"列出部分镜像",charIndex:11892},{level:3,title:"其他用法",slug:"其他用法",normalizedTitle:"其他用法",charIndex:13078},{level:2,title:"删除本地镜像",slug:"删除本地镜像",normalizedTitle:"删除本地镜像",charIndex:13578},{level:3,title:"用 ID、镜像名、摘要删除镜像",slug:"用-id、镜像名、摘要删除镜像",normalizedTitle:"用 id、镜像名、摘要删除镜像",charIndex:13728},{level:3,title:"用 docker image ls 命令来配合",slug:"用-docker-image-ls-命令来配合",normalizedTitle:"用 docker image ls 命令来配合",charIndex:13926},{level:2,title:"提交本地镜像",slug:"提交本地镜像",normalizedTitle:"提交本地镜像",charIndex:14126},{level:3,title:"慎用 docker commit",slug:"慎用-docker-commit",normalizedTitle:"慎用 docker commit",charIndex:15448},{level:2,title:"启动（docker run）",slug:"启动-docker-run",normalizedTitle:"启动（docker run）",charIndex:15792},{level:2,title:"守护态运行（-d）",slug:"守护态运行-d",normalizedTitle:"守护态运行（-d）",charIndex:15928},{level:2,title:"终止（docker stop）",slug:"终止-docker-stop",normalizedTitle:"终止（docker stop）",charIndex:16818},{level:2,title:"进入容器",slug:"进入容器",normalizedTitle:"进入容器",charIndex:17073},{level:3,title:"attach 命令",slug:"attach-命令",normalizedTitle:"attach 命令",charIndex:17106},{level:3,title:"exec 命令",slug:"exec-命令",normalizedTitle:"exec 命令",charIndex:17124},{level:2,title:"导出和导入",slug:"导出和导入",normalizedTitle:"导出和导入",charIndex:18413},{level:3,title:"导出容器",slug:"导出容器",normalizedTitle:"导出容器",charIndex:18423},{level:3,title:"导入容器快照",slug:"导入容器快照",normalizedTitle:"导入容器快照",charIndex:18817},{level:3,title:"删除",slug:"删除",normalizedTitle:"删除",charIndex:984},{level:2,title:"帮助命令",slug:"帮助命令",normalizedTitle:"帮助命令",charIndex:19693},{level:2,title:"镜像命令",slug:"镜像命令",normalizedTitle:"镜像命令",charIndex:19822},{level:2,title:"容器命令",slug:"容器命令",normalizedTitle:"容器命令",charIndex:20762},{level:2,title:"常用的其他命令",slug:"常用的其他命令",normalizedTitle:"常用的其他命令",charIndex:22738}],headersStr:"Docker和传统虚拟化方式对比 镜像 容器 仓库 Docker Registry 公开服务 私有 Docker Registry 底层原理 准备工作 系统要求 卸载旧版本 使用 yum 安装 安装 Docker CentOS8 额外设置 启动 Docker 建立 docker 用户组 测试 Docker 是否安装正确 镜像加速器 CentOS 7+ 添加内核参数 获取镜像 列出镜像 镜像体积 虚悬镜像 中间层镜像 列出部分镜像 其他用法 删除本地镜像 用 ID、镜像名、摘要删除镜像 用 docker image ls 命令来配合 提交本地镜像 慎用 docker commit 启动（docker run） 守护态运行（-d） 终止（docker stop） 进入容器 attach 命令 exec 命令 导出和导入 导出容器 导入容器快照 删除 帮助命令 镜像命令 容器命令 常用的其他命令",content:'# Docker 简介\n\nDocker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n\n\n\n * B站狂神Docker视频教程\n\n * Docker官网\n\n * Docker官方文档\n\n * Docker官方镜像仓库\n\n\n# Docker和传统虚拟化方式对比\n\n传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。\n\n下面的图片比较了 Docker 和传统虚拟化方式的不同之处。\n\n\n\n\n\n对比总结\n\n特性      容器          虚拟机\n启动      秒级          分钟级\n硬盘使用    一般为 MB      一般为 GB\n性能      接近原生        弱于\n系统支持量   单机支持上千个容器   一般几十个\n\n\n# Docker基本概念\n\nDocker 包括三个基本概念\n\n * 镜像（Image）\n * 容器（Container）\n * 仓库（Repository）\n\n\n# 镜像\n\n我们都知道，操作系统分为 内核 和 用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。\n\nDocker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。\n\n分层存储\n\n因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。\n\n镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。\n\n分层存储的特征还使得镜像的复用、定制变的更为容易。比如可以用之前构建好的镜像作为基础层，然后进一步添加新的层，构建新的镜像。\n\n\n# 容器\n\n镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n\n容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。\n\n容器也采用分层存储。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。\n\n容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\n\n按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。\n\n数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。\n\n\n# 仓库\n\n一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。\n\n通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <仓库名>:<标签> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。\n\n以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:16.04，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。\n\n仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。\n\n\n# Docker Registry 公开服务\n\n最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的 官方镜像。\n\n由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为 加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。\n\n国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库 等。\n\n\n# 私有 Docker Registry\n\n除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。\n\n除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，Harbor 和 Sonatype Nexus。\n\n\n# 底层原理\n\n\n\n * HelloWorld镜像\n\n\n\n * 底层原理 Docker Engine是一个客户端-服务器应用程序，具有以下主要组件:\n\n * * 一个服务器，它是一种长期运行的程序，称为守护进程(dockerd命令)\n   * 一个REST API，它指定程序可以用来与守护进程对话并指示它做什么的接口。\n\nDocker是一个Client Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户 端访问，守护进程从客户端接受命令并管理运行在主机上的容器。容器，是一个运行时环境就是我们所说的集装箱。\n\n * 为什么Docker比Vm快\n\n * * docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,*运行在docker容器上的程序直接使用的都是实际物理机的硬件资源*。因此在CPU、内存利用率上docker将会在效率上有明显优势。\n   * docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个 容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载GuestOS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。\n\n\n\n\n# Docker安装\n\n\n# 准备工作\n\n\n# 系统要求\n\nDocker 支持 64 位版本 CentOS 7/8，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。\n\n\n# 卸载旧版本\n\n旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：\n\n$ sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-selinux \\\n                  docker-engine-selinux \\\n                  docker-engine\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 使用 yum 安装\n\n执行以下命令安装依赖包：\n\n$ sudo yum install -y yum-utils\n\n\n1\n\n\n鉴于国内网络问题，强烈建议使用国内源。\n\n执行下面的命令添加 yum 软件源：\n\n$ sudo yum-config-manager \\\n    --add-repo \\\n    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n$ sudo sed -i \'s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g\' /etc/yum.repos.d/docker-ce.repo\n\n# 官方源\n# $ sudo yum-config-manager \\\n#     --add-repo \\\n#     https://download.docker.com/linux/centos/docker-ce.repo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 安装 Docker\n\n更新 yum 软件源缓存，并安装 docker-ce。\n\n$ sudo yum install docker-ce docker-ce-cli containerd.io\n\n\n1\n\n\n\n# CentOS8 额外设置\n\n由于 CentOS8 防火墙使用了 nftables，但 Docker 尚未支持 nftables， 我们可以使用如下设置使用 iptables：\n\n更改 /etc/firewalld/firewalld.conf\n\n# FirewallBackend=nftables\nFirewallBackend=iptables\n\n\n1\n2\n\n\n或者执行如下命令：\n\n$ firewall-cmd --permanent --zone=trusted --add-interface=docker0\n\n$ firewall-cmd --reload\n\n\n1\n2\n3\n\n\n\n# 启动 Docker\n\n$ sudo systemctl enable docker\n$ sudo systemctl start docker\n\n\n1\n2\n\n\n\n# 建立 docker 用户组\n\n默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。\n\n建立 docker 组：\n\n$ sudo groupadd docker\n\n\n1\n\n\n将当前用户加入 docker 组：\n\n$ sudo usermod -aG docker $USER\n\n\n1\n\n\n\n# 测试 Docker 是否安装正确\n\n$ docker run --rm hello-world\n\nUnable to find image \'hello-world:latest\' locally\nlatest: Pulling from library/hello-world\nb8dfde127a29: Pull complete\nDigest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n若能正常输出以上信息，则说明安装成功。\n\n\n# 镜像加速器\n\n国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如：\n\n * 阿里云加速器(点击管理控制台 -> 登录账号(淘宝账号) -> 右侧镜像工具 -> 镜像加速器 -> 复制加速器地址)\n * 网易云加速器 https://hub-mirror.c.163.com\n * 百度云加速器 https://mirror.baidubce.com\n\n由于镜像服务可能出现宕机，建议同时配置多个镜像。\n\n以 网易云 镜像服务 https://hub-mirror.c.163.com 为例进行介绍。\n\n\n# CentOS 7+\n\n目前主流 Linux 发行版均已使用 systemd 进行服务管理，这里介绍如何在使用 systemd 的 Linux 发行版中配置镜像加速器。\n\n请首先执行以下命令，查看是否在 docker.service 文件中配置过镜像地址。\n\n$ systemctl cat docker | grep \'\\-\\-registry\\-mirror\'\n\n\n1\n\n\n如果该命令有输出，那么请执行 $ systemctl cat docker 查看 ExecStart= 出现的位置，修改对应的文件内容去掉 --registry-mirror 参数及其值，并按接下来的步骤进行配置。\n\n如果以上命令没有任何输出，那么就可以在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）：\n\n{\n  "registry-mirrors": [\n    "https://hub-mirror.c.163.com",\n    "https://mirror.baidubce.com"\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。\n\n之后重新启动服务。\n\n$ sudo systemctl daemon-reload\n$ sudo systemctl restart docker\t\t\t\n\n\n1\n2\n\n\n阿里云镜像加速配置\n\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\n{\n  "registry-mirrors": ["https://hub-mirror.c.163.com/", \t\t\t\t\t\t\t        \t\t\t\t\t"https://docker.mirrors.ustc.edu.cn/", \n   \t\t\t\t\t   "https://reg-mirror.qiniu.com"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 添加内核参数\n\n如果在 CentOS 使用 Docker 看到下面的这些警告信息：\n\nWARNING: bridge-nf-call-iptables is disabled\nWARNING: bridge-nf-call-ip6tables is disabled\n\n\n1\n2\n\n\n请添加内核配置参数以启用这些功能。\n\n$ sudo tee -a /etc/sysctl.conf <<-EOF\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nEOF\n\n\n1\n2\n3\n4\n\n\n\n# 使用镜像\n\n\n# 获取镜像\n\n从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：\n\n$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\t\t\t\t\t\n\n\n1\n\n\n具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。\n\n * Docker 镜像仓库地址：地址的格式一般是 <域名/IP>[:端口号]。默认地址是 Docker Hub(docker.io)。\n * 仓库名：如之前所说，这里的仓库名是两段式名称，即 <用户名>/<软件名>。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。\n\n比如：\n\n$ docker pull ubuntu:18.04\n18.04: Pulling from library/ubuntu\n92dc2a97ff99: Pull complete\nbe13a9d27eb8: Pull complete\nc8299583700a: Pull complete\nDigest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26\nStatus: Downloaded newer image for ubuntu:18.04\ndocker.io/library/ubuntu:18.04\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （docker.io）获取镜像。而镜像名称是 ubuntu:18.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像。docker pull 命令的输出结果最后一行给出了镜像的完整名称，即： docker.io/library/ubuntu:18.04。\n\n运行\n\n$ docker run -it --rm ubuntu:18.04 bash\n\nroot@e7009c6ce357:/# cat /etc/os-release\nNAME="Ubuntu"\nVERSION="18.04.1 LTS (Bionic Beaver)"\nID=ubuntu\nID_LIKE=debian\nPRETTY_NAME="Ubuntu 18.04.1 LTS"\nVERSION_ID="18.04"\nHOME_URL="https://www.ubuntu.com/"\nSUPPORT_URL="https://help.ubuntu.com/"\nBUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"\nPRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"\nVERSION_CODENAME=bionic\nUBUNTU_CODENAME=bionic\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。\n * --rm：这个参数是说容器退出后随之将其删除。\n * bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。\n\n\n# 列出镜像\n\n$ docker image ls | docker images\nREPOSITORY           TAG                 IMAGE ID            CREATED             SIZE\nredis                latest              5f515359c7f8        5 days ago          183 MB\nnginx                latest              05a60462f8ba        5 days ago          181 MB\nmongo                3.2                 fe9198c04d62        5 days ago          342 MB\n<none>               <none>              00285df0df87        5 days ago          342 MB\nubuntu               18.04               329ed837d508        3 days ago          63.3MB\nubuntu               bionic              329ed837d508        3 days ago          63.3MB\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。\n\n镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个 标签。因此，在上面的例子中，我们可以看到 ubuntu:18.04 和 ubuntu:bionic 拥有相同的 ID，因为它们对应的是同一个镜像。\n\n\n# 镜像体积\n\n如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，ubuntu:18.04 镜像大小，在这里是 63.3MB，但是在 Docker Hub 显示的却是 25.47 MB。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 docker image ls 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。\n\n另外一个需要注意的问题是，docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。\n\n你可以通过 docker system df 命令来便捷的查看镜像、容器、数据卷所占用的空间。\n\n$ docker system df\n\nTYPE                TOTAL               ACTIVE              SIZE           RECLAIMABLE\nImages              24                  0                   1.992GB        1.992GB (100%)\nContainers          1                   0                   62.82MB        62.82MB (100%)\nLocal Volumes       9                   0                   652.2MB        652.2MB (100%)\nBuild Cache                                                 0B             0B\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 虚悬镜像\n\n上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <none>。\n\n<none>               <none>              00285df0df87        5 days ago          342 MB\n\n\n1\n\n\n一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。\n\n$ docker image prune\n\n\n1\n\n\n\n# 中间层镜像\n\n为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。\n\n$ docker image ls -a | docker images -a\n\n\n1\n\n\n这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。\n\n\n# 列出部分镜像\n\n不加任何参数的情况下，docker image ls 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。\n\n根据仓库名列出镜像\n\n$ docker image ls ubuntu\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nubuntu              18.04               329ed837d508        3 days ago          63.3MB\nubuntu              bionic              329ed837d508        3 days ago          63.3MB\n\n\n1\n2\n3\n4\n\n\n列出特定的某个镜像，也就是说指定仓库名和标签\n\n$ docker image ls ubuntu:18.04\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nubuntu              18.04               329ed837d508        3 days ago          63.3MB\n\n\n1\n2\n3\n\n\n除此以外，docker image ls 还支持强大的过滤器参数 --filter，或者简写 -f。比如，我们希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令：\n\n$ docker image ls -f since=mongo:3.2\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nredis               latest              5f515359c7f8        5 days ago          183 MB\nnginx               latest              05a60462f8ba        5 days ago          181 MB\n\n\n1\n2\n3\n4\n\n\n想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。\n\n此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。\n\n$ docker image ls -f label=com.example.version=0.1\n...\n\n\n1\n2\n\n\n\n# 其他用法\n\n[root@localhost ~]# docker images ls --help\n\nUsage:  docker images [OPTIONS] [REPOSITORY[:TAG]]\n\nList images\n\nOptions:\n  -a, --all             Show all images (default hides intermediate images)\n      --digests         Show digests\n  -f, --filter filter   Filter output based on conditions provided\n      --format string   Pretty-print images using a Go template\n      --no-trunc        Don\'t truncate output\n  -q, --quiet           Only show image IDs\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 删除本地镜像\n\n如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：\n\n$ docker image rm [选项] <镜像1> [<镜像2> ...] (用法1)\n$ docker rmi [选项] <镜像1> [<镜像2> ...] （用法2）\n\n\n1\n2\n\n\n\n# 用 ID、镜像名、摘要删除镜像\n\n其中，<镜像> 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。\n\n我们可以用镜像的完整 ID，也称为 长 ID，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 短 ID 来删除镜像。docker image ls 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。\n\n\n# 用 docker image ls 命令来配合\n\n比如，我们需要删除所有仓库名为 redis 的镜像：\n\n$ docker image rm $(docker image ls -q redis)\n\n\n1\n\n\n或者删除所有在 mongo:3.2 之前的镜像：\n\n$ docker image rm $(docker image ls -q -f before=mongo:3.2)\n\n\n1\n\n\n\n# 提交本地镜像\n\n当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器存储层构成新的镜像。\n\ndocker commit 的语法格式为：\n\ndocker commit [选项] <容器ID或容器名> [<仓库名>[:<标签>]]\n\n\n1\n\n\n现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。\n\n$ docker run --name webserver -d -p 80:80 nginx\n$ docker exec -it webserver bash\nroot@3729b97e8226:/# echo \'<h1>Hello, Docker!</h1>\' > /usr/share/nginx/html/index.html\nroot@3729b97e8226:/# exit\nexit\n\n# 通过 docker diff 命令查看容器存储层的文件改动\n$ docker diff webserver\nC /root\nA /root/.bash_history\nC /run\nC /usr\nC /usr/share\nC /usr/share/nginx\nC /usr/share/nginx/html\nC /usr/share/nginx/html/index.html\nC /var\nC /var/cache\nC /var/cache/nginx\nA /var/cache/nginx/client_temp\nA /var/cache/nginx/fastcgi_temp\nA /var/cache/nginx/proxy_temp\nA /var/cache/nginx/scgi_temp\nA /var/cache/nginx/uwsgi_temp\n\n$ docker commit \\\n    --author "Tao Wang <twang2218@gmail.com>" \\\n    --message "修改了默认网页" \\\n    webserver \\\n    nginx:v2\nsha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214\n\n# 用 docker history 查看镜像构建历史\n# 比较nginx:v2和nginx:latest 的镜像构建历史，发现nginx:v2新增了我们刚刚提交的这一层。\n$ docker history nginx:v2\n\n# 新的镜像定制好后，我们可以来运行这个镜像。\n$ docker run --name web2 -d -p 81:80 nginx:v2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 慎用 docker commit\n\n首先，如果仔细观察之前的 docker diff webserver 的结果，你会发现除了真正想要修改的 /usr/share/nginx/html/index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，将会导致镜像极为臃肿。\n\n此外，使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。\n\n\n# 操作容器\n\n\n# 启动（docker run）\n\n# -t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上\n# -i 则让容器的标准输入保持打开\n$ docker run -t -i ubuntu:18.04 /bin/bash\n\n\n1\n2\n3\n\n\n\n# 守护态运行（-d）\n\n如果不使用 -d 参数运行容器。\n\n$ docker run ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"\nhello world\nhello world\nhello world\nhello world\n\n\n1\n2\n3\n4\n5\n\n\n容器会把输出的结果 (STDOUT) 打印到宿主机上面\n\n如果使用了 -d 参数运行容器。\n\n$ docker run -d ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"\n77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a\n\n\n1\n2\n\n\n此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。\n\n注： 容器是否会长久运行，是和 docker run 指定的命令（或者Dockfile中CMD指令指定的默认启动命令）有关，和 -d 参数无关。\n\n通过 docker ps 命令来查看容器信息\n\n$ docker ps\nCONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES\n77b2dc01fe0f  ubuntu:18.04  /bin/sh -c \'while tr  2 minutes ago  Up 1 minute        agitated_wright\n\n\n1\n2\n3\n\n\n要获取容器的输出信息，可以通过 docker logs 命令。\n\n$ docker logs [container ID or NAMES]\nhello world\nhello world\nhello world\n. . .\n\n\n1\n2\n3\n4\n5\n\n\n\n# 终止（docker stop）\n\n可以使用 docker stop 来终止一个运行中的容器。\n\n此外，当 Docker 容器中指定的应用终结时，容器也自动终止。\n\n例如对于只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。\n\n终止状态的容器可以用 docker ls -a 命令看到。\n\n处于终止状态的容器，可以通过 docker start 命令来重新启动。\n\n此外，docker restart 命令会将一个运行态的容器终止，然后再重新启动它。\n\n\n# 进入容器\n\n某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。\n\n\n# attach 命令\n\n下面示例如何使用 docker attach 命令。\n\n$ docker run -dit ubuntu\n243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550\n\n$ docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n243c32535da7        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           nostalgic_hypatia\n\n$ docker attach 243c\nroot@243c32535da7:/#\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意： 如果从这个 stdin 中 exit，会导致容器的停止。\n\n\n# exec 命令\n\n-i -t 参数\n\ndocker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。\n\n只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。\n\n当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。\n\n$ docker run -dit ubuntu\n69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6\n\n$ docker container ls\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n69d137adef7a        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           zealous_swirles\n\n$ docker exec -i 69d1 bash\nls\nbin\nboot\ndev\n...\n\n$ docker exec -it 69d1 bash\nroot@69d137adef7a:/#\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。\n\n\n# 导出和导入\n\n\n# 导出容器\n\n如果要导出本地某个容器，可以使用 docker export 命令。\n\n$ docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES\n7691a814370e        ubuntu:18.04        "/bin/bash"         36 hours ago        Exited (0) 21 hours ago                       test\n$ docker export 7691a814370e > ubuntu.tar\n\n\n1\n2\n3\n4\n\n\n这样将导出容器快照到本地文件。\n\n\n# 导入容器快照\n\n可以使用 docker import 从容器快照文件中再导入为镜像，例如\n\n$ cat ubuntu.tar | docker import - test/ubuntu:v1.0\n$ docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE\ntest/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB\n\n\n1\n2\n3\n4\n\n\n此外，也可以通过指定 URL 或者某个目录来导入，例如\n\n$ docker import http://example.com/exampleimage.tgz example/imagerepo\n\n\n1\n\n\n注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。\n\n\n# 删除\n\n可以使用 docker rm 来删除一个处于终止状态的容器。\n\n$ docker rm trusting_newton\ntrusting_newton\n\n\n1\n2\n\n\n如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。\n\n用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。\n\n$ docker container prune\n\n\n1\n\n\n\n# Docker其他常用命令补充\n\n\n\n\n# 帮助命令\n\ndocker version\t# docker版本信息\ndocker info\t\t# 系统级别的信息，包括镜像和容器的数量\ndocker --help\ndocker 命令 --help\n\n\n1\n2\n3\n4\n\n\ndocker 命令帮助文档\n\n\n# 镜像命令\n\n * docker images\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nhello-world         latest              bf756fb1ae65        7 months ago        13.3kB\n\n# 可选项\n--all , -a\t\t# 列出所有镜像\n--quiet , -q\t# 只显示镜像的id\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * docker search\n\n--filter=STARS=3000\t\t# 搜素出来的镜像就是STARS大于3000的\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker search mysql --filter=STARS=3000\nNAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\nmysql               MySQL is a widely used, open-source relation…   9822                [OK]                \nmariadb             MariaDB is a community-developed fork of MyS…   3586                [OK]\n\n\n1\n2\n3\n4\n5\n6\n\n * docker rmi\n\ndocker rmi -f imageId# 删除指定镜像\ndocker rmi -f imageId1 imageId2 imageId3\t# 删除多个镜像\ndocker rmi -f $(docker images -aq)\t\t\t# 删除所有镜像\n\n\n1\n2\n3\n\n\n\n# 容器命令\n\n运行容器\n\ndocker run [可选参数] image\n\n# 参数说明\n--name=“Name”\t容器名字\ttomcat01 tomcat02\t用来区分容器\n-d\t\t后台方式运行\n-it\t\t使用交互方式运行，进入容器查看内容\n-p\t\tPublish a container\'s port(s) to the host\t-p 8080:8080\n\t-p\tip:主机端口:容器端口\n\t-p\t主机端口:容器端口（常用）\n\t-P\tPublish all exposed ports to random ports\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n列出所有的运行的容器\n\n# docker ps 命令\n\t\t# 列出当前正在运行的容器\n-a\t\t# 列出正在运行的容器包括历史容器\n-n=?\t# 显示最近创建的容器\n-q\t\t# 只显示当前容器的编号\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES\n77969f5dcbf9        centos              "/bin/bash"         5 minutes ago       Exited (0) 5 minutes ago                       xenodochial_bose\n74e82b7980e7        centos              "/bin/bash"         16 minutes ago      Exited (0) 6 minutes ago                       silly_cori\na57250395804        bf756fb1ae65        "/hello"            7 hours ago         Exited (0) 7 hours ago                         elated_nash\n392d674f4f18        bf756fb1ae65        "/hello"            8 hours ago         Exited (0) 8 hours ago                         distracted_mcnulty\n571d1bc0e8e8        bf756fb1ae65        "/hello"            23 hours ago        Exited (0) 23 hours ago                        magical_burnell\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker ps -qa\n77969f5dcbf9\n74e82b7980e7\na57250395804\n392d674f4f18\n571d1bc0e8e8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n退出容器\n\nexit \t\t\t# 直接退出容器并关闭\nCtrl + P + Q\t# 容器不关闭退出\n\n\n1\n2\n\n\n删除容器docker\n\ndocker rm -f 容器id                  # 删除指定容器\ndocker rm -f $(docker ps -aq)\t\t# 删除所有容器\ndocker ps -aq | xargs docker rm -f\t# 删除所有容器\n\n\n1\n2\n3\n\n\n启动和停止容器的操作\n\ndocker start 容器id\t\t\t# 启动容器\ndocker restart 容器id\t\t\t# 重启容器\ndocker stop 容器id\t\t\t# 停止当前正在运行的容器\ndocker kill 容器id\t\t\t# 强制停止当前的容器\n\n\n1\n2\n3\n4\n\n\n\n# 常用的其他命令\n\n查看日志\n\ndocker logs -tf --tail number 容器id\n\n[root@localhost ~]# docker logs --help\n\nUsage:  docker logs [OPTIONS] CONTAINER\n\nFetch the logs of a container\n\nOptions:\n      --details        Show extra details provided to logs\n  -f, --follow         Follow log output\n      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)\n  -n, --tail string    Number of lines to show from the end of the logs (default "all")\n  -t, --timestamps     Show timestamps\n      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n查看容器中进程信息ps\n\n# 命令 docker top 容器id\n[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker top df358bc06b17              ?\n\n\n1\n2\n\n\n查看镜像的元数据\n\n# 命令\ndocker inspect 容器id\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker inspect df358bc06b17\n[\n    {\n        "Id": "df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3",\n        "Created": "2020-08-11T11:38:34.935048603Z",\n        "Path": "/bin/bash",\n        "Args": [],\n        "State": {\n            "Status": "running",\n            "Running": true,\n            "Paused": false,\n            "Restarting": false,\n            "OOMKilled": false,\n            "Dead": false,\n            "Pid": 28498,\n            "ExitCode": 0,\n            "Error": "",\n            "StartedAt": "2020-08-11T11:38:35.216616071Z",\n            "FinishedAt": "0001-01-01T00:00:00Z"\n        },\n        "Image": "sha256:0d120b6ccaa8c5e149176798b3501d4dd1885f961922497cd0abef155c869566",\n        "ResolvConfPath": "/var/lib/docker/containers/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3/resolv.conf",\n        "HostnamePath": "/var/lib/docker/containers/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3/hostname",\n        "HostsPath": "/var/lib/docker/containers/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3/hosts",\n        "LogPath": "/var/lib/docker/containers/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3-json.log",\n        "Name": "/hungry_heisenberg",\n        "RestartCount": 0,\n        "Driver": "overlay2",\n        "Platform": "linux",\n        "MountLabel": "",\n        "ProcessLabel": "",\n        "AppArmorProfile": "",\n        "ExecIDs": null,\n        "HostConfig": {\n            "Binds": null,\n            "ContainerIDFile": "",\n            "LogConfig": {\n                "Type": "json-file",\n                "Config": {}\n            },\n            "NetworkMode": "default",\n            "PortBindings": {},\n            "RestartPolicy": {\n                "Name": "no",\n                "MaximumRetryCount": 0\n            },\n            "AutoRemove": false,\n            "VolumeDriver": "",\n            "VolumesFrom": null,\n            "CapAdd": null,\n            "CapDrop": null,\n            "Capabilities": null,\n            "Dns": [],\n            "DnsOptions": [],\n            "DnsSearch": [],\n            "ExtraHosts": null,\n            "GroupAdd": null,\n            "IpcMode": "private",\n            "Cgroup": "",\n            "Links": null,\n            "OomScoreAdj": 0,\n            "PidMode": "",\n            "Privileged": false,\n            "PublishAllPorts": false,\n            "ReadonlyRootfs": false,\n            "SecurityOpt": null,\n            "UTSMode": "",\n            "UsernsMode": "",\n            "ShmSize": 67108864,\n            "Runtime": "runc",\n            "ConsoleSize": [\n                0,\n                0\n            ],\n            "Isolation": "",\n            "CpuShares": 0,\n            "Memory": 0,\n            "NanoCpus": 0,\n            "CgroupParent": "",\n            "BlkioWeight": 0,\n            "BlkioWeightDevice": [],\n            "BlkioDeviceReadBps": null,\n            "BlkioDeviceWriteBps": null,\n            "BlkioDeviceReadIOps": null,\n            "BlkioDeviceWriteIOps": null,\n            "CpuPeriod": 0,\n            "CpuQuota": 0,\n            "CpuRealtimePeriod": 0,\n            "CpuRealtimeRuntime": 0,\n            "CpusetCpus": "",\n            "CpusetMems": "",\n            "Devices": [],\n            "DeviceCgroupRules": null,\n            "DeviceRequests": null,\n            "KernelMemory": 0,\n            "KernelMemoryTCP": 0,\n            "MemoryReservation": 0,\n            "MemorySwap": 0,\n            "MemorySwappiness": null,\n            "OomKillDisable": false,\n            "PidsLimit": null,\n            "Ulimits": null,\n            "CpuCount": 0,\n            "CpuPercent": 0,\n            "IOMaximumIOps": 0,\n            "IOMaximumBandwidth": 0,\n            "MaskedPaths": [\n                "/proc/asound",\n                "/proc/acpi",\n                "/proc/kcore",\n                "/proc/keys",\n                "/proc/latency_stats",\n                "/proc/timer_list",\n                "/proc/timer_stats",\n                "/proc/sched_debug",\n                "/proc/scsi",\n                "/sys/firmware"\n            ],\n            "ReadonlyPaths": [\n                "/proc/bus",\n                "/proc/fs",\n                "/proc/irq",\n                "/proc/sys",\n                "/proc/sysrq-trigger"\n            ]\n        },\n        "GraphDriver": {\n            "Data": {\n                "LowerDir": "/var/lib/docker/overlay2/5af8a2aadbdba9e1e066331ff4bce56398617710a22ef906f9ce4d58bde2d360-init/diff:/var/lib/docker/overlay2/62926d498bd9d1a6684bb2f9920fb77a2f88896098e66ef93c4b74fcb19f29b6/diff",\n                "MergedDir": "/var/lib/docker/overlay2/5af8a2aadbdba9e1e066331ff4bce56398617710a22ef906f9ce4d58bde2d360/merged",\n                "UpperDir": "/var/lib/docker/overlay2/5af8a2aadbdba9e1e066331ff4bce56398617710a22ef906f9ce4d58bde2d360/diff",\n                "WorkDir": "/var/lib/docker/overlay2/5af8a2aadbdba9e1e066331ff4bce56398617710a22ef906f9ce4d58bde2d360/work"\n            },\n            "Name": "overlay2"\n        },\n        "Mounts": [],\n        "Config": {\n            "Hostname": "df358bc06b17",\n            "Domainname": "",\n            "User": "",\n            "AttachStdin": true,\n            "AttachStdout": true,\n            "AttachStderr": true,\n            "Tty": true,\n            "OpenStdin": true,\n            "StdinOnce": true,\n            "Env": [\n                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"\n            ],\n            "Cmd": [\n                "/bin/bash"\n            ],\n            "Image": "centos",\n            "Volumes": null,\n            "WorkingDir": "",\n            "Entrypoint": null,\n            "OnBuild": null,\n            "Labels": {\n                "org.label-schema.build-date": "20200809",\n                "org.label-schema.license": "GPLv2",\n                "org.label-schema.name": "CentOS Base Image",\n                "org.label-schema.schema-version": "1.0",\n                "org.label-schema.vendor": "CentOS"\n            }\n        },\n        "NetworkSettings": {\n            "Bridge": "",\n            "SandboxID": "4822f9ac2058e8415ebefbfa73f05424fe20cc8280a5720ad3708fa6e80cdb08",\n            "HairpinMode": false,\n            "LinkLocalIPv6Address": "",\n            "LinkLocalIPv6PrefixLen": 0,\n            "Ports": {},\n            "SandboxKey": "/var/run/docker/netns/4822f9ac2058",\n            "SecondaryIPAddresses": null,\n            "SecondaryIPv6Addresses": null,\n            "EndpointID": "5fd269c0a28227241e40cd30658e3ffe8ad6cc3e6514917c867d89d36a31d605",\n            "Gateway": "172.17.0.1",\n            "GlobalIPv6Address": "",\n            "GlobalIPv6PrefixLen": 0,\n            "IPAddress": "172.17.0.2",\n            "IPPrefixLen": 16,\n            "IPv6Gateway": "",\n            "MacAddress": "02:42:ac:11:00:02",\n            "Networks": {\n                "bridge": {\n                    "IPAMConfig": null,\n                    "Links": null,\n                    "Aliases": null,\n                    "NetworkID": "30d6017888627cb565618b1639fecf8fc97e1ae4df5a9fd5ddb046d8fb02b565",\n                    "EndpointID": "5fd269c0a28227241e40cd30658e3ffe8ad6cc3e6514917c867d89d36a31d605",\n                    "Gateway": "172.17.0.1",\n                    "IPAddress": "172.17.0.2",\n                    "IPPrefixLen": 16,\n                    "IPv6Gateway": "",\n                    "GlobalIPv6Address": "",\n                    "GlobalIPv6PrefixLen": 0,\n                    "MacAddress": "02:42:ac:11:00:02",\n                    "DriverOpts": null\n                }\n            }\n        }\n    }\n]\n[root@iZ2zeg4ytp0whqtmxbsqiiZ /]#\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n\n\n在容器和主机间相互拷贝文件\n\nUsage:  \ndocker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-\ndocker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker cp 7af535f807e0:/home/Test.java /home\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'# docker 简介\n\ndocker 使用 google 公司推出的 go 语言 进行开发实现，基于 linux 内核的 cgroup，namespace，以及 overlayfs 类的 union fs 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。\n\n\n\n * b站狂神docker视频教程\n\n * docker官网\n\n * docker官方文档\n\n * docker官方镜像仓库\n\n\n# docker和传统虚拟化方式对比\n\n传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。\n\n下面的图片比较了 docker 和传统虚拟化方式的不同之处。\n\n\n\n\n\n对比总结\n\n特性      容器          虚拟机\n启动      秒级          分钟级\n硬盘使用    一般为 mb      一般为 gb\n性能      接近原生        弱于\n系统支持量   单机支持上千个容器   一般几十个\n\n\n# docker基本概念\n\ndocker 包括三个基本概念\n\n * 镜像（image）\n * 容器（container）\n * 仓库（repository）\n\n\n# 镜像\n\n我们都知道，操作系统分为 内核 和 用户空间。对于 linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 docker 镜像（image），就相当于是一个 root 文件系统。\n\ndocker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。\n\n分层存储\n\n因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 docker 设计时，就充分利用 union fs 的技术，将其设计为分层存储的架构。\n\n镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。\n\n分层存储的特征还使得镜像的复用、定制变的更为容易。比如可以用之前构建好的镜像作为基础层，然后进一步添加新的层，构建新的镜像。\n\n\n# 容器\n\n镜像（image）和容器（container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n\n容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 id 空间。\n\n容器也采用分层存储。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。\n\n容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\n\n按照 docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（volume）、或者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。\n\n数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。\n\n\n# 仓库\n\n一个 docker registry 中可以包含多个 仓库（repository）；每个仓库可以包含多个 标签（tag）；每个标签对应一个镜像。\n\n通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <仓库名>:<标签> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。\n\n以 ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:16.04，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。\n\n仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 docker registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 docker registry 的软件或服务。\n\n\n# docker registry 公开服务\n\n最常使用的 registry 公开服务是官方的 docker hub，这也是默认的 registry，并拥有大量的高质量的 官方镜像。\n\n由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 docker hub 的镜像服务（registry mirror），这些镜像服务被称为 加速器。常见的有 阿里云加速器、daocloud 加速器 等。使用加速器会直接从国内的地址下载 docker hub 的镜像，比直接从 docker hub 下载速度会提高很多。\n\n国内也有一些云服务商提供类似于 docker hub 的公开服务。比如 网易云镜像服务、daocloud 镜像市场、阿里云镜像库 等。\n\n\n# 私有 docker registry\n\n除了使用公开服务外，用户还可以在本地搭建私有 docker registry。docker 官方提供了 docker registry 镜像，可以直接使用做为私有 registry 服务。\n\n除了官方的 docker registry 外，还有第三方软件实现了 docker registry api，甚至提供了用户界面以及一些高级功能。比如，harbor 和 sonatype nexus。\n\n\n# 底层原理\n\n\n\n * helloworld镜像\n\n\n\n * 底层原理 docker engine是一个客户端-服务器应用程序，具有以下主要组件:\n\n * * 一个服务器，它是一种长期运行的程序，称为守护进程(dockerd命令)\n   * 一个rest api，它指定程序可以用来与守护进程对话并指示它做什么的接口。\n\ndocker是一个client server结构的系统，docker守护进程运行在主机上，然后通过socket连接从客户 端访问，守护进程从客户端接受命令并管理运行在主机上的容器。容器，是一个运行时环境就是我们所说的集装箱。\n\n * 为什么docker比vm快\n\n * * docker有着比虚拟机更少的抽象层。由于docker不需要hypervisor实现硬件资源虚拟化,*运行在docker容器上的程序直接使用的都是实际物理机的硬件资源*。因此在cpu、内存利用率上docker将会在效率上有明显优势。\n   * docker利用的是宿主机的内核,而不需要guest os。因此,当新建一个 容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载guestos,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。\n\n\n\n\n# docker安装\n\n\n# 准备工作\n\n\n# 系统要求\n\ndocker 支持 64 位版本 centos 7/8，并且要求内核版本不低于 3.10。 centos 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。\n\n\n# 卸载旧版本\n\n旧版本的 docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：\n\n$ sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-selinux \\\n                  docker-engine-selinux \\\n                  docker-engine\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 使用 yum 安装\n\n执行以下命令安装依赖包：\n\n$ sudo yum install -y yum-utils\n\n\n1\n\n\n鉴于国内网络问题，强烈建议使用国内源。\n\n执行下面的命令添加 yum 软件源：\n\n$ sudo yum-config-manager \\\n    --add-repo \\\n    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n$ sudo sed -i \'s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g\' /etc/yum.repos.d/docker-ce.repo\n\n# 官方源\n# $ sudo yum-config-manager \\\n#     --add-repo \\\n#     https://download.docker.com/linux/centos/docker-ce.repo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 安装 docker\n\n更新 yum 软件源缓存，并安装 docker-ce。\n\n$ sudo yum install docker-ce docker-ce-cli containerd.io\n\n\n1\n\n\n\n# centos8 额外设置\n\n由于 centos8 防火墙使用了 nftables，但 docker 尚未支持 nftables， 我们可以使用如下设置使用 iptables：\n\n更改 /etc/firewalld/firewalld.conf\n\n# firewallbackend=nftables\nfirewallbackend=iptables\n\n\n1\n2\n\n\n或者执行如下命令：\n\n$ firewall-cmd --permanent --zone=trusted --add-interface=docker0\n\n$ firewall-cmd --reload\n\n\n1\n2\n3\n\n\n\n# 启动 docker\n\n$ sudo systemctl enable docker\n$ sudo systemctl start docker\n\n\n1\n2\n\n\n\n# 建立 docker 用户组\n\n默认情况下，docker 命令会使用 unix socket 与 docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 docker 引擎的 unix socket。出于安全考虑，一般 linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。\n\n建立 docker 组：\n\n$ sudo groupadd docker\n\n\n1\n\n\n将当前用户加入 docker 组：\n\n$ sudo usermod -ag docker $user\n\n\n1\n\n\n\n# 测试 docker 是否安装正确\n\n$ docker run --rm hello-world\n\nunable to find image \'hello-world:latest\' locally\nlatest: pulling from library/hello-world\nb8dfde127a29: pull complete\ndigest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24\nstatus: downloaded newer image for hello-world:latest\n\nhello from docker!\nthis message shows that your installation appears to be working correctly.\n\nto generate this message, docker took the following steps:\n 1. the docker client contacted the docker daemon.\n 2. the docker daemon pulled the "hello-world" image from the docker hub.\n    (amd64)\n 3. the docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. the docker daemon streamed that output to the docker client, which sent it\n    to your terminal.\n\nto try something more ambitious, you can run an ubuntu container with:\n $ docker run -it ubuntu bash\n\nshare images, automate workflows, and more with a free docker id:\n https://hub.docker.com/\n\nfor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n若能正常输出以上信息，则说明安装成功。\n\n\n# 镜像加速器\n\n国内从 docker hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如：\n\n * 阿里云加速器(点击管理控制台 -> 登录账号(淘宝账号) -> 右侧镜像工具 -> 镜像加速器 -> 复制加速器地址)\n * 网易云加速器 https://hub-mirror.c.163.com\n * 百度云加速器 https://mirror.baidubce.com\n\n由于镜像服务可能出现宕机，建议同时配置多个镜像。\n\n以 网易云 镜像服务 https://hub-mirror.c.163.com 为例进行介绍。\n\n\n# centos 7+\n\n目前主流 linux 发行版均已使用 systemd 进行服务管理，这里介绍如何在使用 systemd 的 linux 发行版中配置镜像加速器。\n\n请首先执行以下命令，查看是否在 docker.service 文件中配置过镜像地址。\n\n$ systemctl cat docker | grep \'\\-\\-registry\\-mirror\'\n\n\n1\n\n\n如果该命令有输出，那么请执行 $ systemctl cat docker 查看 execstart= 出现的位置，修改对应的文件内容去掉 --registry-mirror 参数及其值，并按接下来的步骤进行配置。\n\n如果以上命令没有任何输出，那么就可以在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）：\n\n{\n  "registry-mirrors": [\n    "https://hub-mirror.c.163.com",\n    "https://mirror.baidubce.com"\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注意，一定要保证该文件符合 json 规范，否则 docker 将不能启动。\n\n之后重新启动服务。\n\n$ sudo systemctl daemon-reload\n$ sudo systemctl restart docker\t\t\t\n\n\n1\n2\n\n\n阿里云镜像加速配置\n\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'eof\'\n{\n  "registry-mirrors": ["https://hub-mirror.c.163.com/", \t\t\t\t\t\t\t        \t\t\t\t\t"https://docker.mirrors.ustc.edu.cn/", \n   \t\t\t\t\t   "https://reg-mirror.qiniu.com"]\n}\neof\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 添加内核参数\n\n如果在 centos 使用 docker 看到下面的这些警告信息：\n\nwarning: bridge-nf-call-iptables is disabled\nwarning: bridge-nf-call-ip6tables is disabled\n\n\n1\n2\n\n\n请添加内核配置参数以启用这些功能。\n\n$ sudo tee -a /etc/sysctl.conf <<-eof\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\neof\n\n\n1\n2\n3\n4\n\n\n\n# 使用镜像\n\n\n# 获取镜像\n\n从 docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：\n\n$ docker pull [选项] [docker registry 地址[:端口号]/]仓库名[:标签]\t\t\t\t\t\n\n\n1\n\n\n具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。\n\n * docker 镜像仓库地址：地址的格式一般是 <域名/ip>[:端口号]。默认地址是 docker hub(docker.io)。\n * 仓库名：如之前所说，这里的仓库名是两段式名称，即 <用户名>/<软件名>。对于 docker hub，如果不给出用户名，则默认为 library，也就是官方镜像。\n\n比如：\n\n$ docker pull ubuntu:18.04\n18.04: pulling from library/ubuntu\n92dc2a97ff99: pull complete\nbe13a9d27eb8: pull complete\nc8299583700a: pull complete\ndigest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26\nstatus: downloaded newer image for ubuntu:18.04\ndocker.io/library/ubuntu:18.04\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面的命令中没有给出 docker 镜像仓库地址，因此将会从 docker hub （docker.io）获取镜像。而镜像名称是 ubuntu:18.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像。docker pull 命令的输出结果最后一行给出了镜像的完整名称，即： docker.io/library/ubuntu:18.04。\n\n运行\n\n$ docker run -it --rm ubuntu:18.04 bash\n\nroot@e7009c6ce357:/# cat /etc/os-release\nname="ubuntu"\nversion="18.04.1 lts (bionic beaver)"\nid=ubuntu\nid_like=debian\npretty_name="ubuntu 18.04.1 lts"\nversion_id="18.04"\nhome_url="https://www.ubuntu.com/"\nsupport_url="https://help.ubuntu.com/"\nbug_report_url="https://bugs.launchpad.net/ubuntu/"\nprivacy_policy_url="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"\nversion_codename=bionic\nubuntu_codename=bionic\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。\n * --rm：这个参数是说容器退出后随之将其删除。\n * bash：放在镜像名后的是 命令，这里我们希望有个交互式 shell，因此用的是 bash。\n\n\n# 列出镜像\n\n$ docker image ls | docker images\nrepository           tag                 image id            created             size\nredis                latest              5f515359c7f8        5 days ago          183 mb\nnginx                latest              05a60462f8ba        5 days ago          181 mb\nmongo                3.2                 fe9198c04d62        5 days ago          342 mb\n<none>               <none>              00285df0df87        5 days ago          342 mb\nubuntu               18.04               329ed837d508        3 days ago          63.3mb\nubuntu               bionic              329ed837d508        3 days ago          63.3mb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n列表包含了 仓库名、标签、镜像 id、创建时间 以及 所占用的空间。\n\n镜像 id 则是镜像的唯一标识，一个镜像可以对应多个 标签。因此，在上面的例子中，我们可以看到 ubuntu:18.04 和 ubuntu:bionic 拥有相同的 id，因为它们对应的是同一个镜像。\n\n\n# 镜像体积\n\n如果仔细观察，会注意到，这里标识的所占用空间和在 docker hub 上看到的镜像大小不同。比如，ubuntu:18.04 镜像大小，在这里是 63.3mb，但是在 docker hub 显示的却是 25.47 mb。这是因为 docker hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 docker hub 所显示的大小是网络传输中更关心的流量大小。而 docker image ls 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。\n\n另外一个需要注意的问题是，docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 docker 使用 union fs，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。\n\n你可以通过 docker system df 命令来便捷的查看镜像、容器、数据卷所占用的空间。\n\n$ docker system df\n\ntype                total               active              size           reclaimable\nimages              24                  0                   1.992gb        1.992gb (100%)\ncontainers          1                   0                   62.82mb        62.82mb (100%)\nlocal volumes       9                   0                   652.2mb        652.2mb (100%)\nbuild cache                                                 0b             0b\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 虚悬镜像\n\n上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <none>。\n\n<none>               <none>              00285df0df87        5 days ago          342 mb\n\n\n1\n\n\n一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。\n\n$ docker image prune\n\n\n1\n\n\n\n# 中间层镜像\n\n为了加速镜像构建、重复利用资源，docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。\n\n$ docker image ls -a | docker images -a\n\n\n1\n\n\n这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。\n\n\n# 列出部分镜像\n\n不加任何参数的情况下，docker image ls 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。\n\n根据仓库名列出镜像\n\n$ docker image ls ubuntu\nrepository          tag                 image id            created             size\nubuntu              18.04               329ed837d508        3 days ago          63.3mb\nubuntu              bionic              329ed837d508        3 days ago          63.3mb\n\n\n1\n2\n3\n4\n\n\n列出特定的某个镜像，也就是说指定仓库名和标签\n\n$ docker image ls ubuntu:18.04\nrepository          tag                 image id            created             size\nubuntu              18.04               329ed837d508        3 days ago          63.3mb\n\n\n1\n2\n3\n\n\n除此以外，docker image ls 还支持强大的过滤器参数 --filter，或者简写 -f。比如，我们希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令：\n\n$ docker image ls -f since=mongo:3.2\nrepository          tag                 image id            created             size\nredis               latest              5f515359c7f8        5 days ago          183 mb\nnginx               latest              05a60462f8ba        5 days ago          181 mb\n\n\n1\n2\n3\n4\n\n\n想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。\n\n此外，如果镜像构建时，定义了 label，还可以通过 label 来过滤。\n\n$ docker image ls -f label=com.example.version=0.1\n...\n\n\n1\n2\n\n\n\n# 其他用法\n\n[root@localhost ~]# docker images ls --help\n\nusage:  docker images [options] [repository[:tag]]\n\nlist images\n\noptions:\n  -a, --all             show all images (default hides intermediate images)\n      --digests         show digests\n  -f, --filter filter   filter output based on conditions provided\n      --format string   pretty-print images using a go template\n      --no-trunc        don\'t truncate output\n  -q, --quiet           only show image ids\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 删除本地镜像\n\n如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：\n\n$ docker image rm [选项] <镜像1> [<镜像2> ...] (用法1)\n$ docker rmi [选项] <镜像1> [<镜像2> ...] （用法2）\n\n\n1\n2\n\n\n\n# 用 id、镜像名、摘要删除镜像\n\n其中，<镜像> 可以是 镜像短 id、镜像长 id、镜像名 或者 镜像摘要。\n\n我们可以用镜像的完整 id，也称为 长 id，来删除镜像。使用脚本的时候可能会用长 id，但是人工输入就太累了，所以更多的时候是用 短 id 来删除镜像。docker image ls 默认列出的就已经是短 id 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。\n\n\n# 用 docker image ls 命令来配合\n\n比如，我们需要删除所有仓库名为 redis 的镜像：\n\n$ docker image rm $(docker image ls -q redis)\n\n\n1\n\n\n或者删除所有在 mongo:3.2 之前的镜像：\n\n$ docker image rm $(docker image ls -q -f before=mongo:3.2)\n\n\n1\n\n\n\n# 提交本地镜像\n\n当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器存储层构成新的镜像。\n\ndocker commit 的语法格式为：\n\ndocker commit [选项] <容器id或容器名> [<仓库名>[:<标签>]]\n\n\n1\n\n\n现在让我们以定制一个 web 服务器为例子，来讲解镜像是如何构建的。\n\n$ docker run --name webserver -d -p 80:80 nginx\n$ docker exec -it webserver bash\nroot@3729b97e8226:/# echo \'<h1>hello, docker!</h1>\' > /usr/share/nginx/html/index.html\nroot@3729b97e8226:/# exit\nexit\n\n# 通过 docker diff 命令查看容器存储层的文件改动\n$ docker diff webserver\nc /root\na /root/.bash_history\nc /run\nc /usr\nc /usr/share\nc /usr/share/nginx\nc /usr/share/nginx/html\nc /usr/share/nginx/html/index.html\nc /var\nc /var/cache\nc /var/cache/nginx\na /var/cache/nginx/client_temp\na /var/cache/nginx/fastcgi_temp\na /var/cache/nginx/proxy_temp\na /var/cache/nginx/scgi_temp\na /var/cache/nginx/uwsgi_temp\n\n$ docker commit \\\n    --author "tao wang <twang2218@gmail.com>" \\\n    --message "修改了默认网页" \\\n    webserver \\\n    nginx:v2\nsha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214\n\n# 用 docker history 查看镜像构建历史\n# 比较nginx:v2和nginx:latest 的镜像构建历史，发现nginx:v2新增了我们刚刚提交的这一层。\n$ docker history nginx:v2\n\n# 新的镜像定制好后，我们可以来运行这个镜像。\n$ docker run --name web2 -d -p 81:80 nginx:v2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 慎用 docker commit\n\n首先，如果仔细观察之前的 docker diff webserver 的结果，你会发现除了真正想要修改的 /usr/share/nginx/html/index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，将会导致镜像极为臃肿。\n\n此外，使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。\n\n\n# 操作容器\n\n\n# 启动（docker run）\n\n# -t 选项让docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上\n# -i 则让容器的标准输入保持打开\n$ docker run -t -i ubuntu:18.04 /bin/bash\n\n\n1\n2\n3\n\n\n\n# 守护态运行（-d）\n\n如果不使用 -d 参数运行容器。\n\n$ docker run ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"\nhello world\nhello world\nhello world\nhello world\n\n\n1\n2\n3\n4\n5\n\n\n容器会把输出的结果 (stdout) 打印到宿主机上面\n\n如果使用了 -d 参数运行容器。\n\n$ docker run -d ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"\n77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a\n\n\n1\n2\n\n\n此时容器会在后台运行并不会把输出的结果 (stdout) 打印到宿主机上面(输出结果可以用 docker logs 查看)。\n\n注： 容器是否会长久运行，是和 docker run 指定的命令（或者dockfile中cmd指令指定的默认启动命令）有关，和 -d 参数无关。\n\n通过 docker ps 命令来查看容器信息\n\n$ docker ps\ncontainer id  image         command               created        status       ports names\n77b2dc01fe0f  ubuntu:18.04  /bin/sh -c \'while tr  2 minutes ago  up 1 minute        agitated_wright\n\n\n1\n2\n3\n\n\n要获取容器的输出信息，可以通过 docker logs 命令。\n\n$ docker logs [container id or names]\nhello world\nhello world\nhello world\n. . .\n\n\n1\n2\n3\n4\n5\n\n\n\n# 终止（docker stop）\n\n可以使用 docker stop 来终止一个运行中的容器。\n\n此外，当 docker 容器中指定的应用终结时，容器也自动终止。\n\n例如对于只启动了一个终端的容器，用户通过 exit 命令或 ctrl+d 来退出终端时，所创建的容器立刻终止。\n\n终止状态的容器可以用 docker ls -a 命令看到。\n\n处于终止状态的容器，可以通过 docker start 命令来重新启动。\n\n此外，docker restart 命令会将一个运行态的容器终止，然后再重新启动它。\n\n\n# 进入容器\n\n某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。\n\n\n# attach 命令\n\n下面示例如何使用 docker attach 命令。\n\n$ docker run -dit ubuntu\n243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550\n\n$ docker ps\ncontainer id        image               command             created             status              ports               names\n243c32535da7        ubuntu:latest       "/bin/bash"         18 seconds ago      up 17 seconds                           nostalgic_hypatia\n\n$ docker attach 243c\nroot@243c32535da7:/#\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意： 如果从这个 stdin 中 exit，会导致容器的停止。\n\n\n# exec 命令\n\n-i -t 参数\n\ndocker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。\n\n只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 linux 命令提示符，但命令执行结果仍然可以返回。\n\n当 -i -t 参数一起使用时，则可以看到我们熟悉的 linux 命令提示符。\n\n$ docker run -dit ubuntu\n69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6\n\n$ docker container ls\ncontainer id        image               command             created             status              ports               names\n69d137adef7a        ubuntu:latest       "/bin/bash"         18 seconds ago      up 17 seconds                           zealous_swirles\n\n$ docker exec -i 69d1 bash\nls\nbin\nboot\ndev\n...\n\n$ docker exec -it 69d1 bash\nroot@69d137adef7a:/#\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。\n\n\n# 导出和导入\n\n\n# 导出容器\n\n如果要导出本地某个容器，可以使用 docker export 命令。\n\n$ docker ps -a\ncontainer id        image               command             created             status                    ports               names\n7691a814370e        ubuntu:18.04        "/bin/bash"         36 hours ago        exited (0) 21 hours ago                       test\n$ docker export 7691a814370e > ubuntu.tar\n\n\n1\n2\n3\n4\n\n\n这样将导出容器快照到本地文件。\n\n\n# 导入容器快照\n\n可以使用 docker import 从容器快照文件中再导入为镜像，例如\n\n$ cat ubuntu.tar | docker import - test/ubuntu:v1.0\n$ docker images\nrepository          tag                 image id            created              virtual size\ntest/ubuntu         v1.0                9d37a6082e97        about a minute ago   171.3 mb\n\n\n1\n2\n3\n4\n\n\n此外，也可以通过指定 url 或者某个目录来导入，例如\n\n$ docker import http://example.com/exampleimage.tgz example/imagerepo\n\n\n1\n\n\n注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。\n\n\n# 删除\n\n可以使用 docker rm 来删除一个处于终止状态的容器。\n\n$ docker rm trusting_newton\ntrusting_newton\n\n\n1\n2\n\n\n如果要删除一个运行中的容器，可以添加 -f 参数。docker 会发送 sigkill 信号给容器。\n\n用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。\n\n$ docker container prune\n\n\n1\n\n\n\n# docker其他常用命令补充\n\n\n\n\n# 帮助命令\n\ndocker version\t# docker版本信息\ndocker info\t\t# 系统级别的信息，包括镜像和容器的数量\ndocker --help\ndocker 命令 --help\n\n\n1\n2\n3\n4\n\n\ndocker 命令帮助文档\n\n\n# 镜像命令\n\n * docker images\n\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker images\nrepository          tag                 image id            created             size\nhello-world         latest              bf756fb1ae65        7 months ago        13.3kb\n\n# 可选项\n--all , -a\t\t# 列出所有镜像\n--quiet , -q\t# 只显示镜像的id\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * docker search\n\n--filter=stars=3000\t\t# 搜素出来的镜像就是stars大于3000的\n\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker search mysql --filter=stars=3000\nname                description                                     stars               official            automated\nmysql               mysql is a widely used, open-source relation…   9822                [ok]                \nmariadb             mariadb is a community-developed fork of mys…   3586                [ok]\n\n\n1\n2\n3\n4\n5\n6\n\n * docker rmi\n\ndocker rmi -f imageid# 删除指定镜像\ndocker rmi -f imageid1 imageid2 imageid3\t# 删除多个镜像\ndocker rmi -f $(docker images -aq)\t\t\t# 删除所有镜像\n\n\n1\n2\n3\n\n\n\n# 容器命令\n\n运行容器\n\ndocker run [可选参数] image\n\n# 参数说明\n--name=“name”\t容器名字\ttomcat01 tomcat02\t用来区分容器\n-d\t\t后台方式运行\n-it\t\t使用交互方式运行，进入容器查看内容\n-p\t\tpublish a container\'s port(s) to the host\t-p 8080:8080\n\t-p\tip:主机端口:容器端口\n\t-p\t主机端口:容器端口（常用）\n\t-p\tpublish all exposed ports to random ports\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n列出所有的运行的容器\n\n# docker ps 命令\n\t\t# 列出当前正在运行的容器\n-a\t\t# 列出正在运行的容器包括历史容器\n-n=?\t# 显示最近创建的容器\n-q\t\t# 只显示当前容器的编号\n\n[root@iz2zeg4ytp0whqtmxbsqiiz /]# docker ps\ncontainer id        image               command             created             status              ports               names\n[root@iz2zeg4ytp0whqtmxbsqiiz /]# docker ps -a\ncontainer id        image               command             created             status                     ports               names\n77969f5dcbf9        centos              "/bin/bash"         5 minutes ago       exited (0) 5 minutes ago                       xenodochial_bose\n74e82b7980e7        centos              "/bin/bash"         16 minutes ago      exited (0) 6 minutes ago                       silly_cori\na57250395804        bf756fb1ae65        "/hello"            7 hours ago         exited (0) 7 hours ago                         elated_nash\n392d674f4f18        bf756fb1ae65        "/hello"            8 hours ago         exited (0) 8 hours ago                         distracted_mcnulty\n571d1bc0e8e8        bf756fb1ae65        "/hello"            23 hours ago        exited (0) 23 hours ago                        magical_burnell\n\n[root@iz2zeg4ytp0whqtmxbsqiiz /]# docker ps -qa\n77969f5dcbf9\n74e82b7980e7\na57250395804\n392d674f4f18\n571d1bc0e8e8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n退出容器\n\nexit \t\t\t# 直接退出容器并关闭\nctrl + p + q\t# 容器不关闭退出\n\n\n1\n2\n\n\n删除容器docker\n\ndocker rm -f 容器id                  # 删除指定容器\ndocker rm -f $(docker ps -aq)\t\t# 删除所有容器\ndocker ps -aq | xargs docker rm -f\t# 删除所有容器\n\n\n1\n2\n3\n\n\n启动和停止容器的操作\n\ndocker start 容器id\t\t\t# 启动容器\ndocker restart 容器id\t\t\t# 重启容器\ndocker stop 容器id\t\t\t# 停止当前正在运行的容器\ndocker kill 容器id\t\t\t# 强制停止当前的容器\n\n\n1\n2\n3\n4\n\n\n\n# 常用的其他命令\n\n查看日志\n\ndocker logs -tf --tail number 容器id\n\n[root@localhost ~]# docker logs --help\n\nusage:  docker logs [options] container\n\nfetch the logs of a container\n\noptions:\n      --details        show extra details provided to logs\n  -f, --follow         follow log output\n      --since string   show logs since timestamp (e.g. 2013-01-02t13:23:37z) or relative (e.g. 42m for 42 minutes)\n  -n, --tail string    number of lines to show from the end of the logs (default "all")\n  -t, --timestamps     show timestamps\n      --until string   show logs before a timestamp (e.g. 2013-01-02t13:23:37z) or relative (e.g. 42m for 42 minutes)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n查看容器中进程信息ps\n\n# 命令 docker top 容器id\n[root@iz2zeg4ytp0whqtmxbsqiiz /]# docker top df358bc06b17              ?\n\n\n1\n2\n\n\n查看镜像的元数据\n\n# 命令\ndocker inspect 容器id\n\n[root@iz2zeg4ytp0whqtmxbsqiiz /]# docker inspect df358bc06b17\n[\n    {\n        "id": "df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3",\n        "created": "2020-08-11t11:38:34.935048603z",\n        "path": "/bin/bash",\n        "args": [],\n        "state": {\n            "status": "running",\n            "running": true,\n            "paused": false,\n            "restarting": false,\n            "oomkilled": false,\n            "dead": false,\n            "pid": 28498,\n            "exitcode": 0,\n            "error": "",\n            "startedat": "2020-08-11t11:38:35.216616071z",\n            "finishedat": "0001-01-01t00:00:00z"\n        },\n        "image": "sha256:0d120b6ccaa8c5e149176798b3501d4dd1885f961922497cd0abef155c869566",\n        "resolvconfpath": "/var/lib/docker/containers/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3/resolv.conf",\n        "hostnamepath": "/var/lib/docker/containers/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3/hostname",\n        "hostspath": "/var/lib/docker/containers/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3/hosts",\n        "logpath": "/var/lib/docker/containers/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3-json.log",\n        "name": "/hungry_heisenberg",\n        "restartcount": 0,\n        "driver": "overlay2",\n        "platform": "linux",\n        "mountlabel": "",\n        "processlabel": "",\n        "apparmorprofile": "",\n        "execids": null,\n        "hostconfig": {\n            "binds": null,\n            "containeridfile": "",\n            "logconfig": {\n                "type": "json-file",\n                "config": {}\n            },\n            "networkmode": "default",\n            "portbindings": {},\n            "restartpolicy": {\n                "name": "no",\n                "maximumretrycount": 0\n            },\n            "autoremove": false,\n            "volumedriver": "",\n            "volumesfrom": null,\n            "capadd": null,\n            "capdrop": null,\n            "capabilities": null,\n            "dns": [],\n            "dnsoptions": [],\n            "dnssearch": [],\n            "extrahosts": null,\n            "groupadd": null,\n            "ipcmode": "private",\n            "cgroup": "",\n            "links": null,\n            "oomscoreadj": 0,\n            "pidmode": "",\n            "privileged": false,\n            "publishallports": false,\n            "readonlyrootfs": false,\n            "securityopt": null,\n            "utsmode": "",\n            "usernsmode": "",\n            "shmsize": 67108864,\n            "runtime": "runc",\n            "consolesize": [\n                0,\n                0\n            ],\n            "isolation": "",\n            "cpushares": 0,\n            "memory": 0,\n            "nanocpus": 0,\n            "cgroupparent": "",\n            "blkioweight": 0,\n            "blkioweightdevice": [],\n            "blkiodevicereadbps": null,\n            "blkiodevicewritebps": null,\n            "blkiodevicereadiops": null,\n            "blkiodevicewriteiops": null,\n            "cpuperiod": 0,\n            "cpuquota": 0,\n            "cpurealtimeperiod": 0,\n            "cpurealtimeruntime": 0,\n            "cpusetcpus": "",\n            "cpusetmems": "",\n            "devices": [],\n            "devicecgrouprules": null,\n            "devicerequests": null,\n            "kernelmemory": 0,\n            "kernelmemorytcp": 0,\n            "memoryreservation": 0,\n            "memoryswap": 0,\n            "memoryswappiness": null,\n            "oomkilldisable": false,\n            "pidslimit": null,\n            "ulimits": null,\n            "cpucount": 0,\n            "cpupercent": 0,\n            "iomaximumiops": 0,\n            "iomaximumbandwidth": 0,\n            "maskedpaths": [\n                "/proc/asound",\n                "/proc/acpi",\n                "/proc/kcore",\n                "/proc/keys",\n                "/proc/latency_stats",\n                "/proc/timer_list",\n                "/proc/timer_stats",\n                "/proc/sched_debug",\n                "/proc/scsi",\n                "/sys/firmware"\n            ],\n            "readonlypaths": [\n                "/proc/bus",\n                "/proc/fs",\n                "/proc/irq",\n                "/proc/sys",\n                "/proc/sysrq-trigger"\n            ]\n        },\n        "graphdriver": {\n            "data": {\n                "lowerdir": "/var/lib/docker/overlay2/5af8a2aadbdba9e1e066331ff4bce56398617710a22ef906f9ce4d58bde2d360-init/diff:/var/lib/docker/overlay2/62926d498bd9d1a6684bb2f9920fb77a2f88896098e66ef93c4b74fcb19f29b6/diff",\n                "mergeddir": "/var/lib/docker/overlay2/5af8a2aadbdba9e1e066331ff4bce56398617710a22ef906f9ce4d58bde2d360/merged",\n                "upperdir": "/var/lib/docker/overlay2/5af8a2aadbdba9e1e066331ff4bce56398617710a22ef906f9ce4d58bde2d360/diff",\n                "workdir": "/var/lib/docker/overlay2/5af8a2aadbdba9e1e066331ff4bce56398617710a22ef906f9ce4d58bde2d360/work"\n            },\n            "name": "overlay2"\n        },\n        "mounts": [],\n        "config": {\n            "hostname": "df358bc06b17",\n            "domainname": "",\n            "user": "",\n            "attachstdin": true,\n            "attachstdout": true,\n            "attachstderr": true,\n            "tty": true,\n            "openstdin": true,\n            "stdinonce": true,\n            "env": [\n                "path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"\n            ],\n            "cmd": [\n                "/bin/bash"\n            ],\n            "image": "centos",\n            "volumes": null,\n            "workingdir": "",\n            "entrypoint": null,\n            "onbuild": null,\n            "labels": {\n                "org.label-schema.build-date": "20200809",\n                "org.label-schema.license": "gplv2",\n                "org.label-schema.name": "centos base image",\n                "org.label-schema.schema-version": "1.0",\n                "org.label-schema.vendor": "centos"\n            }\n        },\n        "networksettings": {\n            "bridge": "",\n            "sandboxid": "4822f9ac2058e8415ebefbfa73f05424fe20cc8280a5720ad3708fa6e80cdb08",\n            "hairpinmode": false,\n            "linklocalipv6address": "",\n            "linklocalipv6prefixlen": 0,\n            "ports": {},\n            "sandboxkey": "/var/run/docker/netns/4822f9ac2058",\n            "secondaryipaddresses": null,\n            "secondaryipv6addresses": null,\n            "endpointid": "5fd269c0a28227241e40cd30658e3ffe8ad6cc3e6514917c867d89d36a31d605",\n            "gateway": "172.17.0.1",\n            "globalipv6address": "",\n            "globalipv6prefixlen": 0,\n            "ipaddress": "172.17.0.2",\n            "ipprefixlen": 16,\n            "ipv6gateway": "",\n            "macaddress": "02:42:ac:11:00:02",\n            "networks": {\n                "bridge": {\n                    "ipamconfig": null,\n                    "links": null,\n                    "aliases": null,\n                    "networkid": "30d6017888627cb565618b1639fecf8fc97e1ae4df5a9fd5ddb046d8fb02b565",\n                    "endpointid": "5fd269c0a28227241e40cd30658e3ffe8ad6cc3e6514917c867d89d36a31d605",\n                    "gateway": "172.17.0.1",\n                    "ipaddress": "172.17.0.2",\n                    "ipprefixlen": 16,\n                    "ipv6gateway": "",\n                    "globalipv6address": "",\n                    "globalipv6prefixlen": 0,\n                    "macaddress": "02:42:ac:11:00:02",\n                    "driveropts": null\n                }\n            }\n        }\n    }\n]\n[root@iz2zeg4ytp0whqtmxbsqiiz /]#\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n\n\n在容器和主机间相互拷贝文件\n\nusage:  \ndocker cp [options] container:src_path dest_path|-\ndocker cp [options] src_path|- container:dest_path\n\n[root@iz2zeg4ytp0whqtmxbsqiiz /]# docker cp 7af535f807e0:/home/test.java /home\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Docker 高级实践篇",frontmatter:{title:"Docker 高级实践篇",date:"2022-02-03T00:03:52.000Z",permalink:"/pages/a24e91/",categories:["后端","Docker"],tags:[null]},regularPath:"/25.%E8%BF%90%E7%BB%B4/50.Docker/03.Docker%20%E9%AB%98%E7%BA%A7%E5%AE%9E%E8%B7%B5%E7%AF%87.html",relativePath:"25.运维/50.Docker/03.Docker 高级实践篇.md",key:"v-69bafd4e",path:"/pages/a24e91/",headers:[{level:2,title:"Docker安装Nginx",slug:"docker安装nginx",normalizedTitle:"docker安装nginx",charIndex:19},{level:2,title:"Docker安装Tomcat",slug:"docker安装tomcat",normalizedTitle:"docker安装tomcat",charIndex:1455},{level:2,title:"Docker部署es + kibana·",slug:"docker部署es-kibana·",normalizedTitle:"docker部署es + kibana·",charIndex:1699},{level:2,title:"可视化",slug:"可视化",normalizedTitle:"可视化",charIndex:3089},{level:2,title:"Docker的理解回顾",slug:"docker的理解回顾",normalizedTitle:"docker的理解回顾",charIndex:3420},{level:2,title:"使用数据卷",slug:"使用数据卷",normalizedTitle:"使用数据卷",charIndex:3620},{level:2,title:"实战：安装MySQL",slug:"实战-安装mysql",normalizedTitle:"实战：安装mysql",charIndex:3970},{level:2,title:"匿名和具名挂载（容器卷）",slug:"匿名和具名挂载-容器卷",normalizedTitle:"匿名和具名挂载（容器卷）",charIndex:4703},{level:2,title:"数据卷容器",slug:"数据卷容器",normalizedTitle:"数据卷容器",charIndex:7045},{level:2,title:"DockerFile",slug:"dockerfile",normalizedTitle:"dockerfile",charIndex:9863},{level:2,title:"DockerFile的构建过程",slug:"dockerfile的构建过程",normalizedTitle:"dockerfile的构建过程",charIndex:9878},{level:2,title:"DockerFile指令说明",slug:"dockerfile指令说明",normalizedTitle:"dockerfile指令说明",charIndex:10051},{level:2,title:"创建一个自己的Centos",slug:"创建一个自己的centos",normalizedTitle:"创建一个自己的centos",charIndex:10072},{level:3,title:"CMD 和ENTRYPOINT区别",slug:"cmd-和entrypoint区别",normalizedTitle:"cmd 和entrypoint区别",charIndex:10695},{level:2,title:"制作Tomcat镜像",slug:"制作tomcat镜像",normalizedTitle:"制作tomcat镜像",charIndex:15472},{level:2,title:"发布自己的镜像到Docker Hub",slug:"发布自己的镜像到docker-hub",normalizedTitle:"发布自己的镜像到docker hub",charIndex:17336},{level:2,title:"发布到阿里云镜像服务上",slug:"发布到阿里云镜像服务上",normalizedTitle:"发布到阿里云镜像服务上",charIndex:17981},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:3586},{level:2,title:"连接 Docker0",slug:"连接-docker0",normalizedTitle:"连接 docker0",charIndex:18095},{level:2,title:"-- link",slug:"link",normalizedTitle:"-- link",charIndex:19853},{level:2,title:"自定义网络",slug:"自定义网络",normalizedTitle:"自定义网络",charIndex:21881},{level:2,title:"网络连通（不同网络之间）",slug:"网络连通-不同网络之间",normalizedTitle:"网络连通（不同网络之间）",charIndex:26061},{level:2,title:"实战：部署redis",slug:"实战-部署redis",normalizedTitle:"实战：部署redis",charIndex:26938},{level:3,title:"实战一（bridge网络 + docker）",slug:"实战一-bridge网络-docker",normalizedTitle:"实战一（bridge网络 + docker）",charIndex:26955},{level:3,title:"实战二（host网络 + docker-compose）",slug:"实战二-host网络-docker-compose",normalizedTitle:"实战二（host网络 + docker-compose）",charIndex:31934},{level:2,title:"SpringBoot微服务打包Docker镜像",slug:"springboot微服务打包docker镜像",normalizedTitle:"springboot微服务打包docker镜像",charIndex:31989},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:25},{level:2,title:"yaml规则",slug:"yaml规则",normalizedTitle:"yaml规则",charIndex:35136},{level:2,title:"实战：自己编写微服务上线",slug:"实战-自己编写微服务上线",normalizedTitle:"实战：自己编写微服务上线",charIndex:35230}],headersStr:"Docker安装Nginx Docker安装Tomcat Docker部署es + kibana· 可视化 Docker的理解回顾 使用数据卷 实战：安装MySQL 匿名和具名挂载（容器卷） 数据卷容器 DockerFile DockerFile的构建过程 DockerFile指令说明 创建一个自己的Centos CMD 和ENTRYPOINT区别 制作Tomcat镜像 发布自己的镜像到Docker Hub 发布到阿里云镜像服务上 总结 连接 Docker0 -- link 自定义网络 网络连通（不同网络之间） 实战：部署redis 实战一（bridge网络 + docker） 实战二（host网络 + docker-compose） SpringBoot微服务打包Docker镜像 安装 yaml规则 实战：自己编写微服务上线",content:'# Docker部署软件实战\n\n\n# Docker安装Nginx\n\n# 1. 搜索镜像 docker search, 建议去docker hub搜索，可以看到帮助文档\n# 2. 下载镜像 docker pull\n# 3. 运行测试\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              0d120b6ccaa8        32 hours ago        215MB\nnginx               latest              08393e824c32        7 days ago          132MB\n\n# -d 后台运行\n# -name 给容器命名\n# -p 宿主机端口：容器内部端口\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d --name nginx01 -p 3344:80 nginx\t# 后台方式启动启动镜像\nfe9dc33a83294b1b240b1ebb0db9cb16bda880737db2c8a5c0a512fc819850e0\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES\nfe9dc33a8329        nginx               "/docker-entrypoint.…"   4 seconds ago       Up 4 seconds        0.0.0.0:3344->80/tcp   nginx01\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# curl localhost:3344\t# 本地访问测试\n# 进入容器\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker exec -it nginx01 /bin/bash\nroot@fe9dc33a8329:/# whereis nginx\nnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx\nroot@fe9dc33a8329:/# cd /etc/nginx/\nroot@fe9dc33a8329:/etc/nginx# ls\nconf.d\t\tkoi-utf  mime.types  nginx.conf   uwsgi_params\nfastcgi_params\tkoi-win  modules     scgi_params  win-utf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n端口暴露原理图\n\n\n\n\n# Docker安装Tomcat\n\n# 官方的使用\n# docker run -it --rm 一般用来测试，用完就删\ndocker run -it --rm tomcat:9.0\n\n# 下载再启动\ndocker pull tomcat\n# 启动运行\ndocker run -d -p 3344:8080 --name tomcat01 tomcat\n# 进入容器\ndocker exec -it tomcat01 /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Docker部署es + kibana·\n\n# es 暴露的端口很多\n# es 十分的耗内存\n# es 的数据一般需要放置到安全目录！ 挂载\n# --net somenetwork\t网络配置\n\n# 启动elasticsearch， docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2\na920894a940b354d3c867079efada13d96cf9138712c76c8dea58fabd9c7e96f\n\n# 启动了linux就卡主了，docker stats 查看cpu状态\n\n# 测试一下es成功了\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# curl localhost:9200\n{\n  "name" : "a920894a940b",\n  "cluster_name" : "docker-cluster",\n  "cluster_uuid" : "bxE1TJMEThKgwmk7Aa3fHQ",\n  "version" : {\n    "number" : "7.6.2",\n    "build_flavor" : "default",\n    "build_type" : "docker",\n    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",\n    "build_date" : "2020-03-26T06:34:37.794943Z",\n    "build_snapshot" : false,\n    "lucene_version" : "8.4.0",\n    "minimum_wire_compatibility_version" : "6.8.0",\n    "minimum_index_compatibility_version" : "6.0.0-beta1"\n  },\n  "tagline" : "You Know, for Search"\n}\n\n\n# 增加内存限制，修改配置文件 -e 环境配置修改\ndocker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 可视化\n\n * portainer\n\ndocker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer\n# 测试\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# curl localhost:8088\n<!DOCTYPE html><html lang="en" ng-app="portainer">\n# 外网访问 http://ip:8088\n\n\n1\n2\n3\n4\n5\n\n\n\n\n * Rancher(CI/CD再用)\n\n\n# 容器数据卷\n\n\n# Docker的理解回顾\n\n数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化\n\nMySQL，容器删了，删库跑路！需求：MySQL数据可以存储在本地！\n\n容器之间可以有一个数据共享技术！Docker容器中产生的数据，同步到本地！\n\n这就是卷技术，目录的挂载，将我们容器内的目录挂载到Linux目录上面！\n\n总结： 容器的持久化和同步操作！容器间数据也是可以共享的！\n\n\n# 使用数据卷\n\n直接使用命令来挂载 -v\n\n# 匿名挂载和具名挂载的目录都默认在/var/lib/docker/volumn目录下\n1. docker run -it -v 容器目录   # 匿名挂载\n2. docker run -it -v 卷名:容器目录  # 匿名挂载\n3. docker run -it -v 主机目录:容器目录 # 指定路径挂载\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -it -v /home/ceshi:/home centos /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n测试文件的同步（在主机上改动，观察容器变化）\n\n\n\n注意：设置容器数据卷挂载后，容器目录和挂载的主机目录保持实时同步！\n\n\n# 实战：安装MySQL\n\n思考：MySQL的数据持久化的问题！\n\n# 获取镜像\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker pull mysql:5.7\n\n# 运行容器， 需要做数据挂载！ \n# 安装启动mysql，需要配置密码（注意）\n# 官方测试， docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag\n\n# 启动我们的\n-d\t\t# 后台运行\n-p\t\t# 端口映射\n-v\t\t# 卷挂载\n-e\t\t# 环境配置\n--name\t# 容器的名字\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d -p 3344:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7\n9552bf4eb2b69a2ccd344b5ba5965da4d97b19f2e1a78626ac1f2f8d276fc2ba\n\n# 启动成功之后，我们在本地使用navicat链接测试一下\n# navicat链接到服务器的3344 --- 3344 和 容器的3306映射，这个时候我们就可以连接上mysql喽！\n\n# 在本地测试创建一个数据库，查看下我们的路径是否ok！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n\n\n# 匿名和具名挂载（容器卷）\n\n# 匿名挂载\n-v 容器内路径\ndocker run -d -P --name nginx01 -v /etc/nginx nginx\t\t# -P 随机指定端口\n\n# 查看所有volume的情况\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker volume ls\nDRIVER              VOLUME NAME\nlocal               561b81a03506f31d45ada3f9fb7bd8d7c9b5e0f826c877221a17e45d4c80e096\nlocal               36083fb6ca083005094cbd49572a0bffeec6daadfbc5ce772909bb00be760882\n\n# 这里发现，这种情况就是匿名挂载，我们在-v 后面只写了容器内的路径，没有写容器外的路径！\n\n# 具名挂载\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx\n26da1ec7d4994c76e80134d24d82403a254a4e1d84ec65d5f286000105c3da17\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES\n26da1ec7d499        nginx               "/docker-entrypoint.…"   3 seconds ago       Up 2 seconds        0.0.0.0:32769->80/tcp   nginx02\n486de1da03cb        nginx               "/docker-entrypoint.…"   3 minutes ago       Up 3 minutes        0.0.0.0:32768->80/tcp   nginx01\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker volume ls\nDRIVER              VOLUME NAME\nlocal               561b81a03506f31d45ada3f9fb7bd8d7c9b5e0f826c877221a17e45d4c80e096\nlocal               36083fb6ca083005094cbd49572a0bffeec6daadfbc5ce772909bb00be760882\nlocal               juming-nginx\n\n# 通过 -v 卷名:容器内的路径\n# 查看一下这个卷\n# docker volume inspect juming-nginx\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker volume inspect juming-nginx\n[\n  {\n      "CreatedAt": "2020-08-12T18:15:21+08:00",\n      "Driver": "local",\n      "Labels": null,\n      "Mountpoint": "/var/lib/docker/volumes/juming-nginx/_data",\n      "Name": "juming-nginx",\n      "Options": null,\n      "Scope": "local"\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n拓展\n\n# 通过 -v 容器内路径[:ro|:rw] 改变读写权限 \n# ro readonly 只读\t\n# rw readwrite 可读可写\ndocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx\ndocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx\n# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内容无法操作\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 初始Dockerfile\n\n# 创建一个dockerfile文件， 名字可以随机\n# 文件的内容 指定（大写）参数\n\nFROM centos\n\n# 匿名挂载\nVOLUME ["volume01", "volume02"]\n\nCMD echo "----end----"\nCMD /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n启动自己的容器\n\n\n\ndocker inspect 容器id\n\n\n\n假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名:容器内路径！\n\n\n# 数据卷容器\n\n多个mysql同步数据！\n\n\n\n# 启动3个容器，通过我们刚才自己写的镜像启动\n\n\n1\n\n\n\n\n\n\n多个mysql实现数据共享\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d -p 3344:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d -p 3344:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7\n[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d -p 3344:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql03 --volumes-from mysql01 mysql:5.7\n\n\n1\n2\n3\n\n\n\n\ndocker inspect centos01\n[{\n\t"Type": "volume",\n\t"Name": "7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca",\n\t"Source": "/var/lib/docker/volumes/7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca/_data",\n\t"Destination": "volume02",\n\t"Driver": "local",\n\t"Mode": "",\n\t"RW": true,\n\t"Propagation": ""\n}, {\n\t"Type": "volume",\n\t"Name": "27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4",\n\t"Source": "/var/lib/docker/volumes/27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4/_data",\n\t"Destination": "volume01",\n\t"Driver": "local",\n\t"Mode": "",\n\t"RW": true,\n\t"Propagation": ""\n}]\n\ndocker inspect centos02 \n"Mounts": [{\n\t"Type": "volume",\n\t"Name": "27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4",\n\t"Source": "/var/lib/docker/volumes/27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4/_data",\n\t"Destination": "volume01",\n\t"Driver": "local",\n\t"Mode": "",\n\t"RW": true,\n\t"Propagation": ""\n}, {\n\t"Type": "volume",\n\t"Name": "7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca",\n\t"Source": "/var/lib/docker/volumes/7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca/_data",\n\t"Destination": "volume02",\n\t"Driver": "local",\n\t"Mode": "",\n\t"RW": true,\n\t"Propagation": ""\n}]\n\ndocker inspect centos03 \n"Mounts": [{\n\t"Type": "volume",\n\t"Name": "7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca",\n\t"Source": "/var/lib/docker/volumes/7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca/_data",\n\t"Destination": "volume02",\n\t"Driver": "local",\n\t"Mode": "",\n\t"RW": true,\n\t"Propagation": ""\n}, {\n\t"Type": "volume",\n\t"Name": "27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4",\n\t"Source": "/var/lib/docker/volumes/27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4/_data",\n\t"Destination": "volume01",\n\t"Driver": "local",\n\t"Mode": "",\n\t"RW": true,\n\t"Propagation": ""\n}]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n通过查看centos01、02、03的数据卷挂载情况，可以发现，数据卷容器的实现原理其实就是把其他继承数据卷容器的数据卷映射到相同的外部挂载点，这样这个外部挂载点有目录文件变更，就会同步到数据卷容器以及其他继承关系的容器中\n\n\n# DockerFile\n\n\n# DockerFile的构建过程\n\n基础知识：\n\n 1. 每个保留关键字（指令）都是必须大写字母\n\n 2. 执行从上到下顺序执行\n\n 3. # 表示注释\n\n 4. 每个指令都会创建提交一个新的镜像层，并提交！\n\n\n\ndockerFile是面向开发的， 我们以后要发布项目， 做镜像， 就需要编写dockefile文件， 这个文件十分简单！\n\n\n# DockerFile指令说明\n\n\n\n\n# 创建一个自己的Centos\n\n# 1. 编写Dockerfile的文件\n[root@localhost dockfile]# cat mydockerfile-centos \nFROM centos\nMAINTAINER xiaofan<594042358@qq.com>\n\nENV MYPATH /usr/local\nWORKDIR $MYPATH\t\t# 镜像的工作目录\n\nRUN yum -y install vim \\\n\t&& yum -y install net-tools\n\nEXPOSE 80\n\nCMD echo $MYPATH\nCMD echo "---end---"\nCMD /bin/bash\n\n# 2. 通过这个文件构建镜像\n# 命令 docker build -f <Dockerfile文件路径> -t 镜像名:[tag] <构建上下文路径>\n\n[root@localhost dockfile]# docker build -f mydockerfile-centos -t mycentos:0.1 .\n\nSuccessfully built d2d9f0ea8cb2\nSuccessfully tagged mycentos:0.1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\n我们可以列出本地进行的变更历史\n\n\n\n\n# CMD 和ENTRYPOINT区别\n\nCMD\n\n * 指定这个容器启动的时候要运行的命令\n * 当同时存在ENTRYPOINT时，会被当作ENTRYPOINT声明command的参数（可变参数）\n * 会被docker run 后指定的command覆盖\n\nENTRYPOINT\n\n * 指定这个容器启动的时候要运行的命令\n * 当同时存在CMD时，会把CMD声明command当作参数（可变参数）\n * 会被docker run --entrypoint 后指定的command覆盖\n\n# 只包含CMD\n\n[root@localhost dockfile]# cat dockfile\nFROM centos\nCMD ["ls", "-a"]\n\n[root@localhost dockfile]# docker build -f dockerfile -t centos:v1 .\n\n# 3. run运行， 发现我们的ls -a 命令生效\n[root@localhost dockfile]# docker run ebe6a52bb125\n.\n..\n.dockerenv\nbin\ndev\netc\nhome\nlib\nlib64\n\n# 想追加一个命令 -l 变成 ls -al\n[root@localhost dockfile]# docker run ebe6a52bb125 -l\ndocker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused "exec: \\"-l\\": executable file not found in $PATH": unknown.\n[root@localhost dockfile]# docker run ebe6a52bb125 ls -l\n\n# cmd的情况下 -l替换了CMD["ls", "-a"]命令， -l不是命令，所以报错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 只包含ENTRYPOINT\n\n[root@localhost dockfile]# cat dockerfile \nFROM centos\nENTRYPOINT ["ls", "-a"]\n\n\n[root@localhost dockfile]# docker build -f dockerfile -t centos:v1 .\n\n# 3. run运行 发现我们的ls -a 命令同样生效\n[root@localhost dockfile]# docker run centos:v1\n.\n..\n.dockerenv\nbin\ndev\netc\nhome\nlib\n\n# 4. 我们的追加命令， 是直接拼接到ENTRYPOINT命令的后面的！\n[root@localhost dockfile]# docker run centos:v1 -l\ntotal 56\ndrwxr-xr-x  1 root root 4096 Aug 13 07:52 .\ndrwxr-xr-x  1 root root 4096 Aug 13 07:52 ..\n-rwxr-xr-x  1 root root    0 Aug 13 07:52 .dockerenv\nlrwxrwxrwx  1 root root    7 May 11  2019 bin -> usr/bin\ndrwxr-xr-x  5 root root  340 Aug 13 07:52 dev\ndrwxr-xr-x  1 root root 4096 Aug 13 07:52 etc\ndrwxr-xr-x  2 root root 4096 May 11  2019 home\nlrwxrwxrwx  1 root root    7 May 11  2019 lib -> usr/lib\nlrwxrwxrwx  1 root root    9 May 11  2019 lib64 -> usr/lib64\ndrwx------  2 root root 4096 Aug  9 21:40 lost+found\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 同时包含CMD和ENTRYPOINT\n\n[root@localhost dockfile]# cat dockerfile \nFROM centos:latest\nMAINTAINER ZHAOXING<779292642@qq.com>\n\nENV MYPATH /usr/local\nWORKDIR $MYPATH\n\nCMD ["-a"]\nENTRYPOINT ["ls"]\n\n[root@localhost dockfile]# docker build -f dockerfile -t centos:v1 .\n\n# 执行命令：ls -a\n# CMD声明的command会当作ENTRYPOINT声明的command的参数\n[root@localhost dockfile]# docker run centos:v1\n.\n..\nbin\netc\ngames\ninclude\nlib\nlib64\nlibexec\nsbin\nshare\nsrc\n\n# 覆盖CMD声明的command\n[root@localhost dockfile]# docker run centos:v1 -l\ntotal 0\ndrwxr-xr-x. 2 root root  6 Nov  3  2020 bin\ndrwxr-xr-x. 2 root root  6 Nov  3  2020 etc\ndrwxr-xr-x. 2 root root  6 Nov  3  2020 games\ndrwxr-xr-x. 2 root root  6 Nov  3  2020 include\ndrwxr-xr-x. 2 root root  6 Nov  3  2020 lib\ndrwxr-xr-x. 3 root root 16 Sep 15 14:17 lib64\ndrwxr-xr-x. 2 root root  6 Nov  3  2020 libexec\ndrwxr-xr-x. 2 root root  6 Nov  3  2020 sbin\ndrwxr-xr-x. 5 root root 46 Sep 15 14:17 share\ndrwxr-xr-x. 2 root root  6 Nov  3  2020 src\n[root@localhost dockfile]# docker run centos:v1 -al\ntotal 8\ndrwxr-xr-x. 12 root root 4096 Sep 15 14:17 .\ndrwxr-xr-x. 12 root root 4096 Sep 15 14:17 ..\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 bin\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 etc\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 games\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 include\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 lib\ndrwxr-xr-x.  3 root root   16 Sep 15 14:17 lib64\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 libexec\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 sbin\ndrwxr-xr-x.  5 root root   46 Sep 15 14:17 share\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 src\n\n\n# 覆盖ENTRYPOINT声明的command（此时CMD声明的command失效）\n[root@localhost dockfile]# docker run --entrypoint ls 3a\nbin\netc\ngames\ninclude\nlib\nlib64\nlibexec\nsbin\nshare\nsrc\n\n# 同时覆盖ENTRYPOINT和CMD声明的command\n[root@localhost dockfile]# docker run --entrypoint ls 3a -a\n.\n..\nbin\netc\ngames\ninclude\nlib\nlib64\nlibexec\nsbin\nshare\nsrc\n[root@localhost dockfile]# docker run --entrypoint ls 3a -al\ntotal 8\ndrwxr-xr-x. 12 root root 4096 Sep 15 14:17 .\ndrwxr-xr-x. 12 root root 4096 Sep 15 14:17 ..\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 bin\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 etc\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 games\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 include\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 lib\ndrwxr-xr-x.  3 root root   16 Sep 15 14:17 lib64\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 libexec\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 sbin\ndrwxr-xr-x.  5 root root   46 Sep 15 14:17 share\ndrwxr-xr-x.  2 root root    6 Nov  3  2020 src\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n\n# Dockerfile制作Tomcat镜像\n\n\n# 制作Tomcat镜像\n\n 1. 准备镜像文件 tomcat压缩包，jdk的压缩包！\n\n\n\n 2. 编写Dockerfile文件, build默认在构建上下文寻找名称为Dockfile的文件，就不需要-f 指定了！\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ tomcat]# cat Dockerfile \nFROM centos\nMAINTAINER xiaofan<594042358@qq.com>\nCOPY readme.txt /usr/local/readme.txt\n# ADD 会自动解压\nADD jdk-8u73-linux-x64.tar.gz /usr/local/\nADD apache-tomcat-9.0.37.tar.gz /usr/local/\nRUN yum -y install vim\nENV MYPATH /usr/local\nWORKDIR $MYPATH\nENV JAVA_HOME /usr/local/jdk1.8.0_73\nENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nENV CATALINA_HOME /usr/local/apache-tomcat-9.0.37\nENV CATALINA_BASH /usr/local/apache-tomcat-9.0.37\nENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin\nEXPOSE 8080\nCMD /usr/local/apache-tomcat-9.0.37/bin/startup.sh && tail -F /usr/local/apache-tomcat-9.0.37/bin/logs/catalina.out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 3. 构建镜像\n\n# docker build -t diytomcat .\n\n\n1\n\n 4. 启动镜像\n\ndocker run -d -p 3344:8080 \\\n--name xiaofantomcat1 \\\n-v /home/xiaofan/build/tomcat/test:/usr/local/apache-tomcat-9.0.37/webapps/test \\\n-v /home/xiaofan/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.37/logs \ndiytomcat\n\n\n1\n2\n3\n4\n5\n\n 5. 访问测试\n\n在本地编写web.xml和index.jsp进行测试\n\n\n\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app version="2.4" \n    xmlns="http://java.sun.com/xml/ns/j2ee" \n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee \n        http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">\n        \n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n<%@ page language="java" contentType="text/html; charset=UTF-8"\n    pageEncoding="UTF-8"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset="utf-8">\n<title>hello. xiaofan</title>\n</head>\n<body>\nHello World!<br/>\n<%\nSystem.out.println("-----my test web logs------");\n%>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n发现：项目部署成功， 可以直接访问ok！\n\n\n\n\n# 发布自己的镜像到Docker Hub\n\n 1. Dockker Hub 注册自己的账号！\n 2. 确定这个账号可以登录\n\n\n\n 3. 在我们的服务器上提交自己的镜像\n\n# push到我们的服务器上\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker push diytomcat\nThe push refers to repository [docker.io/library/diytomcat]\n2eaca873a720: Preparing \n1b38cc4085a8: Preparing \n088ebb58d264: Preparing \nc06785a2723d: Preparing \n291f6e44771a: Preparing \ndenied: requested access to the resource is denied\t# 拒绝\n\n# push镜像的问题？\nThe push refers to repository [docker.io/1314520007/diytomcat]\nAn image does not exist locally with the tag: 1314520007/diytomcat\n\n# 解决，增加一个tag\ndocker tag diytomcat 1314520007/tomcat:1.0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n\n# 发布到阿里云镜像服务上\n\n 1. 登录阿里云\n\n 2. 找到容器镜像服务\n\n 3. 创建命名空间\n\n\n\n 4. 创建镜像仓库\n\n\n\n 5. 点击仓库名称，参考官方文档即可\n\n\n\n\n# 总结\n\n\n\n\n# Docker网络\n\n\n# 连接 Docker0\n\n测试\n\n\n\n三个网络\n\n# 问题： docker是如何处理容器网络访问的？\n\n# [root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P --name tomcat01 tomcat\n\n# 查看容器内部的网络地址 ip addr\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat01 ip addr， 发现容器启动的时候得到一个eth0@if115 ip地址，docker分配的！\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n114: eth0@if115: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default \n    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0\n       valid_lft forever preferred_lft forever\n\n# 思考： linux 能不能ping通容器？\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# ping 172.17.0.2\nPING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.\n64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.077 ms\n64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.069 ms\n64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.075 ms\n\n# linux 可以 ping 通docker容器内部！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n原理\n\n> 我们每启动一个docker容器， docker就会给docker容器分配一个ip， 我们只要安装了docker，就会有一个网卡 docker0桥接模式，使用的技术是veth-pair技术！\n\n再次测试 ip addr\n\n\n\n再启动一个容器测试， 发现又多了一对网卡\n\n\n\n# 我们发现这个容器带来网卡，都是一对对的\n# veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连\n# 正因为有这个特性，veth-pair充当一个桥梁， 连接各种虚拟网络设备\n# OpenStac， Docker容器之间的链接，OVS的链接， 都是使用veth-pair技术\n\n\n1\n2\n3\n4\n\n\n我们测试一下tomcat01和tomcat02之间是否可以ping通！\n\n结论：容器与容器之间是可以相互ping通的！\n\n绘制一个网络模型图\n\n\n\n结论：tomcat01和tomcat02是共用的一个路由器，docker0\n\n所有容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用IP\n\n小结\n\nDocker使用的是Linux的桥接，宿主机中是一个Docker容器的网桥docker0.\n\n\n\nDocker中的所有的网络接口都是虚拟的，虚拟的转发效率高！（内网传递文件！）\n\n只要容器删除，对应的网桥一对就没有了！\n\n\n\n\n# -- link\n\n解决通过docker0联通时通过容器名访问\n\n思考一个场景，我们编写了一个微服务，database url =ip； 项目不重启，数据ip换掉了，我们希望可以处理这个问题，可以按名字来进行访问容器\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat02 ping tomcat01\nping: tomcat01: Name or service not known\n\n# 如何可以解决呢？\n# 通过--link即可以解决网络连通问题\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P  --name tomcat03 --link tomcat02 tomcat\n3a2bcaba804c5980d94d168457c436fbd139820be2ee77246888f1744e6bb473\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES\n3a2bcaba804c        tomcat              "catalina.sh run"   4 seconds ago       Up 3 seconds        0.0.0.0:32772->8080/tcp   tomcat03\nf22ed47ed1be        tomcat              "catalina.sh run"   57 minutes ago      Up 57 minutes       0.0.0.0:32771->8080/tcp   tomcat02\n9d97f93401a0        tomcat              "catalina.sh run"   About an hour ago   Up About an hour    0.0.0.0:32770->8080/tcp   tomcat01\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat03 ping tomcat02\nPING tomcat02 (172.17.0.3) 56(84) bytes of data.\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.129 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.100 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.110 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.107 ms\n\n# 反向可以ping通吗？\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat02 ping tomcat03\nping: tomcat03: Name or service not known\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n探究：inspect！\n\n\n\n其实这个tomcat03就是在本地配置了tomcat02的配置？\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat03 cat /etc/hosts\n127.0.0.1\tlocalhost\n::1\tlocalhost ip6-localhost ip6-loopback\nfe00::0\tip6-localnet\nff00::0\tip6-mcastprefix\nff02::1\tip6-allnodes\nff02::2\tip6-allrouters\n172.17.0.3\ttomcat02 f22ed47ed1be\n172.17.0.4\t3a2bcaba804c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n本质探究：--link 就是我们在hosts配置中增加了一个172.17.0.3 tomcat02 f22ed47ed1be\n\n我们现在玩Docker已经不建议使用--link了！\n\n自定义网络！不使用Docker0！\n\nDocker0的问题：它不支持容器名链接访问！\n\n\n# 自定义网络\n\n查看所有的docker网络\n\n\n\n网络模式\n\n * bridge： 桥接模式，桥接 docker 默认，自己创建的也是用brdge模式\n\n * none： 不配置网络\n\n * host： 和宿主机共享网络\n\n * container：容器网络连通！（用的少， 局限很大）\n\n测试\n\n# 我们直接启动的命令默认有一个 --net bridge，而这个就是我们的docker0\ndocker run -d -P --name tomcat01 tomcat\ndocker run -d -P --name tomcat01 --net bridge tomcat\n\n# docker0特点，默认，容器名不能访问， --link可以打通连接！\n# 我们可以自定义一个网络！\n# --driver bridge\n# --subnet 192.168.0.0/16 可以支持255*255个网络 192.168.0.2 ~ 192.168.255.254\n# --gateway 192.168.0.1\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet\n26a5afdf4805d7ee0a660b82244929a4226470d99a179355558dca35a2b983ec\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n30d601788862        bridge              bridge              local\n226019b14d91        host                host                local\n26a5afdf4805        mynet               bridge              local\n7496c014f74b        none                null                local\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n我们自己创建的网络就ok了！\n\n\n\n在自己创建的网络里面启动两个容器\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P --name tomcat-net-01 --net mynet tomcat\n0e85ebe6279fd23379d39b27b5f47c1e18f23ba7838637802973bf6449e22f5c\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P --name tomcat-net-02 --net mynet tomcat\nc6e462809ccdcebb51a4078b1ac8fdec33f1112e9e416406b606d0c9fb6f21b5\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network inspect mynet\n[\n    {\n        "Name": "mynet",\n        "Id": "26a5afdf4805d7ee0a660b82244929a4226470d99a179355558dca35a2b983ec",\n        "Created": "2020-08-14T11:12:40.553433163+08:00",\n        "Scope": "local",\n        "Driver": "bridge",\n        "EnableIPv6": false,\n        "IPAM": {\n            "Driver": "default",\n            "Options": {},\n            "Config": [\n                {\n                    "Subnet": "192.168.0.0/16",\n                    "Gateway": "192.168.0.1"\n                }\n            ]\n        },\n        "Internal": false,\n        "Attachable": false,\n        "Ingress": false,\n        "ConfigFrom": {\n            "Network": ""\n        },\n        "ConfigOnly": false,\n        "Containers": {\n            "0e85ebe6279fd23379d39b27b5f47c1e18f23ba7838637802973bf6449e22f5c": {\n                "Name": "tomcat-net-01",\n                "EndpointID": "576ce5c0f5860a5aab5e487a805da9d72f41a409c460f983c0bd341dd75d83ac",\n                "MacAddress": "02:42:c0:a8:00:02",\n                "IPv4Address": "192.168.0.2/16",\n                "IPv6Address": ""\n            },\n            "c6e462809ccdcebb51a4078b1ac8fdec33f1112e9e416406b606d0c9fb6f21b5": {\n                "Name": "tomcat-net-02",\n                "EndpointID": "81ecbc4fe26e49855fe374f2d7c00d517b11107cc91a174d383ff6be37d25a30",\n                "MacAddress": "02:42:c0:a8:00:03",\n                "IPv4Address": "192.168.0.3/16",\n                "IPv6Address": ""\n            }\n        },\n        "Options": {},\n        "Labels": {}\n    }\n]\n\n# 再次ping连接\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat-net-01 ping 192.168.0.3\nPING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.\n64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.113 ms\n64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.093 ms\n^C\n--- 192.168.0.3 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 999ms\nrtt min/avg/max/mdev = 0.093/0.103/0.113/0.010 ms\n# 现在不使用 --link也可以ping名字了！\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat-net-01 ping tomcat-net-02\nPING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.\n64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.068 ms\n64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.096 ms\n64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.094 ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络\n\n好处：\n\n> redis - 不同的集群使用不同的网络，保证集群是安全和健康的\n> \n> mysql - 不同的集群使用不同的网络，保证集群是安全和健康的\n\n\n# 网络连通（不同网络之间）\n\n\n\n测试打通tomcat01 和mynet\n\n\n\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network connect  mynet tomcat01\n\n# 连通之后就是讲tomcat01放到了mynet网络下\n# 一个容器两个ip地址：\n# 阿里云服务器，公网ip，私网ip\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\n\n# 连通ok\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat01 ping tomcat-net-01\nPING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.\n64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.100 ms\n64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.085 ms\n^C\n--- tomcat-net-01 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1000ms\nrtt min/avg/max/mdev = 0.085/0.092/0.100/0.012 ms\n# 依旧无法连通，没有connect\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat02 ping tomcat-net-01\nping: tomcat-net-01: Name or service not known\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n结论：假设要跨网络操作别人，就要使用docker network connect连通.....!\n\n\n# 实战：部署redis\n\n\n\n\n# 实战一（bridge网络 + docker）\n\n> 这种方案 spring boot 项目连接redis集群时有问题：redis节点之间通信有问题，还是使用的自定义网段分配的地址\n\n# 创建网卡\ndocker network create redis --subnet 172.38.0.0/16\n\n# 通过脚本创建六个redis配置\nfor port in $(seq 1 6); \\\ndo \\\nmkdir -p /home/software/redis/node-${port}/conf\ntouch /home/software/redis/node-${port}/conf/redis.conf\ncat << EOF >/home/software/redis/node-${port}/conf/redis.conf\nport 6379\nbind 0.0.0.0\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 5000\ncluster-announce-ip 172.38.0.1${port}\ncluster-announce-port 6379\ncluster-announce-bus-port 16379\nappendonly yes\nEOF\ndone\n# 创建结点1\ndocker run -p 6371:6379 -p 16371:16379 --name redis-1 \\\n-v /home/software/redis/node-1/data:/data \\\n-v /home/software/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n#创建结点2\ndocker run -p 6372:6379 -p 16372:16379 --name redis-2 \\\n-v /home/software/redis/node-2/data:/data \\\n-v /home/software/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n#创建结点3\ndocker run -p 6373:6379 -p 16373:16379 --name redis-3 \\\n-v /home/software/redis/node-3/data:/data \\\n-v /home/software/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n#创建结点4\ndocker run -p 6374:6379 -p 16374:16379 --name redis-4 \\\n-v /home/software/redis/node-4/data:/data \\\n-v /home/software/redis/node-4/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n#创建结点5\ndocker run -p 6375:6379 -p 16375:16379 --name redis-5 \\\n-v /home/software/redis/node-5/data:/data \\\n-v /home/software/redis/node-5/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n#创建结点6\ndocker run -p 6376:6379 -p 16376:16379 --name redis-6 \\\n-v /home/software/redis/node-6/data:/data \\\n-v /home/software/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n# 创建集群\n[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it redis-1 /bin/sh\n/data # ls\nappendonly.aof  nodes.conf\n/data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1\n>>> Performing hash slots allocation on 6 nodes...\nMaster[0] -> Slots 0 - 5460\nMaster[1] -> Slots 5461 - 10922\nMaster[2] -> Slots 10923 - 16383\nAdding replica 172.38.0.15:6379 to 172.38.0.11:6379\nAdding replica 172.38.0.16:6379 to 172.38.0.12:6379\nAdding replica 172.38.0.14:6379 to 172.38.0.13:6379\nM: 541b7d237b641ac2ffc94d17c6ab96b18b26a638 172.38.0.11:6379\n   slots:[0-5460] (5461 slots) master\nM: a89c1f1245b264e4a402a3cf99766bcb6138dbca 172.38.0.12:6379\n   slots:[5461-10922] (5462 slots) master\nM: 259e804d6df74e67a72e4206d7db691a300c775e 172.38.0.13:6379\n   slots:[10923-16383] (5461 slots) master\nS: 9b19170eea3ea1b92c58ad18c0b5522633a9e271 172.38.0.14:6379\n   replicates 259e804d6df74e67a72e4206d7db691a300c775e\nS: 061a9d38f22910aaf0ba1dbd21bf1d8f57bcb7d5 172.38.0.15:6379\n   replicates 541b7d237b641ac2ffc94d17c6ab96b18b26a638\nS: 7a16b9bbb0615ec95fc978fa62fc054df60536f0 172.38.0.16:6379\n   replicates a89c1f1245b264e4a402a3cf99766bcb6138dbca\nCan I set the above configuration? (type \'yes\' to accept): yes\n>>> Nodes configuration updated\n>>> Assign a different config epoch to each node\n>>> Sending CLUSTER MEET messages to join the cluster\nWaiting for the cluster to join\n...\n>>> Performing Cluster Check (using node 172.38.0.11:6379)\nM: 541b7d237b641ac2ffc94d17c6ab96b18b26a638 172.38.0.11:6379\n   slots:[0-5460] (5461 slots) master\n   1 additional replica(s)\nM: a89c1f1245b264e4a402a3cf99766bcb6138dbca 172.38.0.12:6379\n   slots:[5461-10922] (5462 slots) master\n   1 additional replica(s)\nS: 7a16b9bbb0615ec95fc978fa62fc054df60536f0 172.38.0.16:6379\n   slots: (0 slots) slave\n   replicates a89c1f1245b264e4a402a3cf99766bcb6138dbca\nS: 061a9d38f22910aaf0ba1dbd21bf1d8f57bcb7d5 172.38.0.15:6379\n   slots: (0 slots) slave\n   replicates 541b7d237b641ac2ffc94d17c6ab96b18b26a638\nM: 259e804d6df74e67a72e4206d7db691a300c775e 172.38.0.13:6379\n   slots:[10923-16383] (5461 slots) master\n   1 additional replica(s)\nS: 9b19170eea3ea1b92c58ad18c0b5522633a9e271 172.38.0.14:6379\n   slots: (0 slots) slave\n   replicates 259e804d6df74e67a72e4206d7db691a300c775e\n[OK] All nodes agree about slots configuration.\n>>> Check for open slots...\n>>> Check slots coverage...\n[OK] All 16384 slots covered.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n\n\n\n# 实战二（host网络 + docker-compose）\n\ndocker搭建redis集群完成！\n\n\n\n\n# SpringBoot微服务打包Docker镜像\n\n * 打包应用\n * 编写Dockerfile\n\nFROM java:8\n\nCOPY *.jar /app.jar\n\nCMD ["--server.port=8080"]\n\nEXPOSE 8080\n\nENTRYPOINT ["java", "-jar", "/app.jar"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 构建镜像\n\n# 上传jar包和Dockerfile到Linux\n[root@iZ2zeg4ytp0whqtmxbsqiiZ idea]# ll\ntotal 16140\n-rw-r--r-- 1 root root 16519871 Aug 14 17:38 demo-0.0.1-SNAPSHOT.jar\n-rw-r--r-- 1 root root      122 Aug 14 17:38 Dockerfile\n\n# 构建镜像\n[root@iZ2zeg4ytp0whqtmxbsqiiZ idea]# docker build -t myapp:V1 .\nSending build context to Docker daemon  16.52MB\nStep 1/5 : FROM java:8\n8: Pulling from library/java\n5040bd298390: Pull complete \nfce5728aad85: Pull complete \n76610ec20bf5: Pull complete \n60170fec2151: Pull complete \ne98f73de8f0d: Pull complete \n11f7af24ed9c: Pull complete \n49e2d6393f32: Pull complete \nbb9cdec9c7f3: Pull complete \nDigest: sha256:c1ff613e8ba25833d2e1940da0940c3824f03f802c449f3d1815a66b7f8c0e9d\nStatus: Downloaded newer image for java:8\n ---\x3e d23bdf5b1b1b\nStep 2/5 : COPY *.jar /app.jar\n ---\x3e d4de8837ebf9\nStep 3/5 : CMD ["--server.port=8080"]\n ---\x3e Running in e3abc66303f0\nRemoving intermediate container e3abc66303f0\n ---\x3e 131bb3917fea\nStep 4/5 : EXPOSE 8080\n ---\x3e Running in fa2f25977db7\nRemoving intermediate container fa2f25977db7\n ---\x3e d98147377951\nStep 5/5 : ENTRYPOINT ["java", "-jar", "/app.jar"]\n ---\x3e Running in e1885e23773b\nRemoving intermediate container e1885e23773b\n ---\x3e afb6b5f28a32\nSuccessfully built afb6b5f28a32\nSuccessfully tagged xiaofan666:latest\n\n# 查看镜像\n[root@iZ2zeg4ytp0whqtmxbsqiiZ idea]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nmyapp               v1                  afb6b5f28a32        14 seconds ago      660MB\ntomcat              latest              2ae23eb477aa        8 days ago          647MB\nredis               5.0.9-alpine3.11    3661c84ee9d0        3 months ago        29.8MB\njava                8                   d23bdf5b1b1b        3 years ago         643MB\n\n# 运行容器\n[root@iZ2zeg4ytp0whqtmxbsqiiZ idea]# docker run -d -P --name my-springboot-web myapp:v1\nfd9a353a80bfd61f6930c16cd92204532bfd734e003f3f9983b5128a27b0375e\n# 查看运行起来的容器端口（因为我们启动的时候没有指定）\n[root@iZ2zeg4ytp0whqtmxbsqiiZ idea]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                     NAMES\nfd9a353a80bf        xiaofan666          "java -jar /app.jar …"   9 seconds ago       Up 8 seconds        0.0.0.0:32779->8080/tcp   xiaofan-springboot-web\n# 本地访问1\n[root@iZ2zeg4ytp0whqtmxbsqiiZ idea]# curl localhost:32779/hello\nhello, world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# Docker Compose\n\n\n# 安装\n\n下载docker-compose命令\n\n# 官网提供 （没有下载成功）\ncurl -L "https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose\n# 国内地址\ncurl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n\n\n1\n2\n3\n4\n\n\n分配可执行权限\n\nchmod +x /usr/local/bin/docker-compose\n\n\n1\n\n\n\n\n\n# yaml规则\n\nhttps://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples\n\n\n# 实战：自己编写微服务上线\n\n * 编写项目微服务\n * Dockerfile构建镜像\n\nFROM java:8\n\nCOPY *.jar /app.jar\n\nCMD ["--server.port=8080"]\n\nEXPOSE 8080\n\nENTRYPOINT ["java", "-jar", "/app.jar"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * docker-compose.yml编排项目\n\nversion \'3.8\'\nservices:\n  myapp:\n    build: .\n    image: myapp:v1\n    depends_on:\n      - redis\n    ports:\n      - "8080:8080"\n\n  redis:\n    image: "library/redis:alpine"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 丢到服务器运行 docker-compose up\n\ndocker-compose down\t\t\t# 关闭容器\ndocker-compose up --build \t# 重新构建\n\n\n1\n2\n\n\n\n\n',normalizedContent:'# docker部署软件实战\n\n\n# docker安装nginx\n\n# 1. 搜索镜像 docker search, 建议去docker hub搜索，可以看到帮助文档\n# 2. 下载镜像 docker pull\n# 3. 运行测试\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# docker images\nrepository          tag                 image id            created             size\ncentos              latest              0d120b6ccaa8        32 hours ago        215mb\nnginx               latest              08393e824c32        7 days ago          132mb\n\n# -d 后台运行\n# -name 给容器命名\n# -p 宿主机端口：容器内部端口\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# docker run -d --name nginx01 -p 3344:80 nginx\t# 后台方式启动启动镜像\nfe9dc33a83294b1b240b1ebb0db9cb16bda880737db2c8a5c0a512fc819850e0\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# docker ps\ncontainer id        image               command                  created             status              ports                  names\nfe9dc33a8329        nginx               "/docker-entrypoint.…"   4 seconds ago       up 4 seconds        0.0.0.0:3344->80/tcp   nginx01\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# curl localhost:3344\t# 本地访问测试\n# 进入容器\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# docker exec -it nginx01 /bin/bash\nroot@fe9dc33a8329:/# whereis nginx\nnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx\nroot@fe9dc33a8329:/# cd /etc/nginx/\nroot@fe9dc33a8329:/etc/nginx# ls\nconf.d\t\tkoi-utf  mime.types  nginx.conf   uwsgi_params\nfastcgi_params\tkoi-win  modules     scgi_params  win-utf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n端口暴露原理图\n\n\n\n\n# docker安装tomcat\n\n# 官方的使用\n# docker run -it --rm 一般用来测试，用完就删\ndocker run -it --rm tomcat:9.0\n\n# 下载再启动\ndocker pull tomcat\n# 启动运行\ndocker run -d -p 3344:8080 --name tomcat01 tomcat\n# 进入容器\ndocker exec -it tomcat01 /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# docker部署es + kibana·\n\n# es 暴露的端口很多\n# es 十分的耗内存\n# es 的数据一般需要放置到安全目录！ 挂载\n# --net somenetwork\t网络配置\n\n# 启动elasticsearch， docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2\n\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2\na920894a940b354d3c867079efada13d96cf9138712c76c8dea58fabd9c7e96f\n\n# 启动了linux就卡主了，docker stats 查看cpu状态\n\n# 测试一下es成功了\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# curl localhost:9200\n{\n  "name" : "a920894a940b",\n  "cluster_name" : "docker-cluster",\n  "cluster_uuid" : "bxe1tjmethkgwmk7aa3fhq",\n  "version" : {\n    "number" : "7.6.2",\n    "build_flavor" : "default",\n    "build_type" : "docker",\n    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",\n    "build_date" : "2020-03-26t06:34:37.794943z",\n    "build_snapshot" : false,\n    "lucene_version" : "8.4.0",\n    "minimum_wire_compatibility_version" : "6.8.0",\n    "minimum_index_compatibility_version" : "6.0.0-beta1"\n  },\n  "tagline" : "you know, for search"\n}\n\n\n# 增加内存限制，修改配置文件 -e 环境配置修改\ndocker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e es_java_opts="-xms64m -xmx512m" elasticsearch:7.6.2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 可视化\n\n * portainer\n\ndocker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer\n# 测试\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# curl localhost:8088\n<!doctype html><html lang="en" ng-app="portainer">\n# 外网访问 http://ip:8088\n\n\n1\n2\n3\n4\n5\n\n\n\n\n * rancher(ci/cd再用)\n\n\n# 容器数据卷\n\n\n# docker的理解回顾\n\n数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化\n\nmysql，容器删了，删库跑路！需求：mysql数据可以存储在本地！\n\n容器之间可以有一个数据共享技术！docker容器中产生的数据，同步到本地！\n\n这就是卷技术，目录的挂载，将我们容器内的目录挂载到linux目录上面！\n\n总结： 容器的持久化和同步操作！容器间数据也是可以共享的！\n\n\n# 使用数据卷\n\n直接使用命令来挂载 -v\n\n# 匿名挂载和具名挂载的目录都默认在/var/lib/docker/volumn目录下\n1. docker run -it -v 容器目录   # 匿名挂载\n2. docker run -it -v 卷名:容器目录  # 匿名挂载\n3. docker run -it -v 主机目录:容器目录 # 指定路径挂载\n\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# docker run -it -v /home/ceshi:/home centos /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n测试文件的同步（在主机上改动，观察容器变化）\n\n\n\n注意：设置容器数据卷挂载后，容器目录和挂载的主机目录保持实时同步！\n\n\n# 实战：安装mysql\n\n思考：mysql的数据持久化的问题！\n\n# 获取镜像\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# docker pull mysql:5.7\n\n# 运行容器， 需要做数据挂载！ \n# 安装启动mysql，需要配置密码（注意）\n# 官方测试， docker run --name some-mysql -e mysql_root_password=my-secret-pw -d mysql:tag\n\n# 启动我们的\n-d\t\t# 后台运行\n-p\t\t# 端口映射\n-v\t\t# 卷挂载\n-e\t\t# 环境配置\n--name\t# 容器的名字\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# docker run -d -p 3344:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e mysql_root_password=123456 --name mysql01 mysql:5.7\n9552bf4eb2b69a2ccd344b5ba5965da4d97b19f2e1a78626ac1f2f8d276fc2ba\n\n# 启动成功之后，我们在本地使用navicat链接测试一下\n# navicat链接到服务器的3344 --- 3344 和 容器的3306映射，这个时候我们就可以连接上mysql喽！\n\n# 在本地测试创建一个数据库，查看下我们的路径是否ok！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n\n\n# 匿名和具名挂载（容器卷）\n\n# 匿名挂载\n-v 容器内路径\ndocker run -d -p --name nginx01 -v /etc/nginx nginx\t\t# -p 随机指定端口\n\n# 查看所有volume的情况\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker volume ls\ndriver              volume name\nlocal               561b81a03506f31d45ada3f9fb7bd8d7c9b5e0f826c877221a17e45d4c80e096\nlocal               36083fb6ca083005094cbd49572a0bffeec6daadfbc5ce772909bb00be760882\n\n# 这里发现，这种情况就是匿名挂载，我们在-v 后面只写了容器内的路径，没有写容器外的路径！\n\n# 具名挂载\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker run -d -p --name nginx02 -v juming-nginx:/etc/nginx nginx\n26da1ec7d4994c76e80134d24d82403a254a4e1d84ec65d5f286000105c3da17\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker ps\ncontainer id        image               command                  created             status              ports                   names\n26da1ec7d499        nginx               "/docker-entrypoint.…"   3 seconds ago       up 2 seconds        0.0.0.0:32769->80/tcp   nginx02\n486de1da03cb        nginx               "/docker-entrypoint.…"   3 minutes ago       up 3 minutes        0.0.0.0:32768->80/tcp   nginx01\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker volume ls\ndriver              volume name\nlocal               561b81a03506f31d45ada3f9fb7bd8d7c9b5e0f826c877221a17e45d4c80e096\nlocal               36083fb6ca083005094cbd49572a0bffeec6daadfbc5ce772909bb00be760882\nlocal               juming-nginx\n\n# 通过 -v 卷名:容器内的路径\n# 查看一下这个卷\n# docker volume inspect juming-nginx\n\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker volume inspect juming-nginx\n[\n  {\n      "createdat": "2020-08-12t18:15:21+08:00",\n      "driver": "local",\n      "labels": null,\n      "mountpoint": "/var/lib/docker/volumes/juming-nginx/_data",\n      "name": "juming-nginx",\n      "options": null,\n      "scope": "local"\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n拓展\n\n# 通过 -v 容器内路径[:ro|:rw] 改变读写权限 \n# ro readonly 只读\t\n# rw readwrite 可读可写\ndocker run -d -p --name nginx02 -v juming-nginx:/etc/nginx:ro nginx\ndocker run -d -p --name nginx02 -v juming-nginx:/etc/nginx:rw nginx\n# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内容无法操作\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 初始dockerfile\n\n# 创建一个dockerfile文件， 名字可以随机\n# 文件的内容 指定（大写）参数\n\nfrom centos\n\n# 匿名挂载\nvolume ["volume01", "volume02"]\n\ncmd echo "----end----"\ncmd /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n启动自己的容器\n\n\n\ndocker inspect 容器id\n\n\n\n假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名:容器内路径！\n\n\n# 数据卷容器\n\n多个mysql同步数据！\n\n\n\n# 启动3个容器，通过我们刚才自己写的镜像启动\n\n\n1\n\n\n\n\n\n\n多个mysql实现数据共享\n\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# docker run -d -p 3344:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e mysql_root_password=123456 --name mysql01 mysql:5.7\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# docker run -d -p 3344:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e mysql_root_password=123456 --name mysql02 --volumes-from mysql01 mysql:5.7\n[root@iz2zeg4ytp0whqtmxbsqiiz home]# docker run -d -p 3344:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e mysql_root_password=123456 --name mysql03 --volumes-from mysql01 mysql:5.7\n\n\n1\n2\n3\n\n\n\n\ndocker inspect centos01\n[{\n\t"type": "volume",\n\t"name": "7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca",\n\t"source": "/var/lib/docker/volumes/7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca/_data",\n\t"destination": "volume02",\n\t"driver": "local",\n\t"mode": "",\n\t"rw": true,\n\t"propagation": ""\n}, {\n\t"type": "volume",\n\t"name": "27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4",\n\t"source": "/var/lib/docker/volumes/27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4/_data",\n\t"destination": "volume01",\n\t"driver": "local",\n\t"mode": "",\n\t"rw": true,\n\t"propagation": ""\n}]\n\ndocker inspect centos02 \n"mounts": [{\n\t"type": "volume",\n\t"name": "27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4",\n\t"source": "/var/lib/docker/volumes/27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4/_data",\n\t"destination": "volume01",\n\t"driver": "local",\n\t"mode": "",\n\t"rw": true,\n\t"propagation": ""\n}, {\n\t"type": "volume",\n\t"name": "7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca",\n\t"source": "/var/lib/docker/volumes/7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca/_data",\n\t"destination": "volume02",\n\t"driver": "local",\n\t"mode": "",\n\t"rw": true,\n\t"propagation": ""\n}]\n\ndocker inspect centos03 \n"mounts": [{\n\t"type": "volume",\n\t"name": "7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca",\n\t"source": "/var/lib/docker/volumes/7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca/_data",\n\t"destination": "volume02",\n\t"driver": "local",\n\t"mode": "",\n\t"rw": true,\n\t"propagation": ""\n}, {\n\t"type": "volume",\n\t"name": "27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4",\n\t"source": "/var/lib/docker/volumes/27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4/_data",\n\t"destination": "volume01",\n\t"driver": "local",\n\t"mode": "",\n\t"rw": true,\n\t"propagation": ""\n}]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n通过查看centos01、02、03的数据卷挂载情况，可以发现，数据卷容器的实现原理其实就是把其他继承数据卷容器的数据卷映射到相同的外部挂载点，这样这个外部挂载点有目录文件变更，就会同步到数据卷容器以及其他继承关系的容器中\n\n\n# dockerfile\n\n\n# dockerfile的构建过程\n\n基础知识：\n\n 1. 每个保留关键字（指令）都是必须大写字母\n\n 2. 执行从上到下顺序执行\n\n 3. # 表示注释\n\n 4. 每个指令都会创建提交一个新的镜像层，并提交！\n\n\n\ndockerfile是面向开发的， 我们以后要发布项目， 做镜像， 就需要编写dockefile文件， 这个文件十分简单！\n\n\n# dockerfile指令说明\n\n\n\n\n# 创建一个自己的centos\n\n# 1. 编写dockerfile的文件\n[root@localhost dockfile]# cat mydockerfile-centos \nfrom centos\nmaintainer xiaofan<594042358@qq.com>\n\nenv mypath /usr/local\nworkdir $mypath\t\t# 镜像的工作目录\n\nrun yum -y install vim \\\n\t&& yum -y install net-tools\n\nexpose 80\n\ncmd echo $mypath\ncmd echo "---end---"\ncmd /bin/bash\n\n# 2. 通过这个文件构建镜像\n# 命令 docker build -f <dockerfile文件路径> -t 镜像名:[tag] <构建上下文路径>\n\n[root@localhost dockfile]# docker build -f mydockerfile-centos -t mycentos:0.1 .\n\nsuccessfully built d2d9f0ea8cb2\nsuccessfully tagged mycentos:0.1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\n我们可以列出本地进行的变更历史\n\n\n\n\n# cmd 和entrypoint区别\n\ncmd\n\n * 指定这个容器启动的时候要运行的命令\n * 当同时存在entrypoint时，会被当作entrypoint声明command的参数（可变参数）\n * 会被docker run 后指定的command覆盖\n\nentrypoint\n\n * 指定这个容器启动的时候要运行的命令\n * 当同时存在cmd时，会把cmd声明command当作参数（可变参数）\n * 会被docker run --entrypoint 后指定的command覆盖\n\n# 只包含cmd\n\n[root@localhost dockfile]# cat dockfile\nfrom centos\ncmd ["ls", "-a"]\n\n[root@localhost dockfile]# docker build -f dockerfile -t centos:v1 .\n\n# 3. run运行， 发现我们的ls -a 命令生效\n[root@localhost dockfile]# docker run ebe6a52bb125\n.\n..\n.dockerenv\nbin\ndev\netc\nhome\nlib\nlib64\n\n# 想追加一个命令 -l 变成 ls -al\n[root@localhost dockfile]# docker run ebe6a52bb125 -l\ndocker: error response from daemon: oci runtime create failed: container_linux.go:349: starting container process caused "exec: \\"-l\\": executable file not found in $path": unknown.\n[root@localhost dockfile]# docker run ebe6a52bb125 ls -l\n\n# cmd的情况下 -l替换了cmd["ls", "-a"]命令， -l不是命令，所以报错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 只包含entrypoint\n\n[root@localhost dockfile]# cat dockerfile \nfrom centos\nentrypoint ["ls", "-a"]\n\n\n[root@localhost dockfile]# docker build -f dockerfile -t centos:v1 .\n\n# 3. run运行 发现我们的ls -a 命令同样生效\n[root@localhost dockfile]# docker run centos:v1\n.\n..\n.dockerenv\nbin\ndev\netc\nhome\nlib\n\n# 4. 我们的追加命令， 是直接拼接到entrypoint命令的后面的！\n[root@localhost dockfile]# docker run centos:v1 -l\ntotal 56\ndrwxr-xr-x  1 root root 4096 aug 13 07:52 .\ndrwxr-xr-x  1 root root 4096 aug 13 07:52 ..\n-rwxr-xr-x  1 root root    0 aug 13 07:52 .dockerenv\nlrwxrwxrwx  1 root root    7 may 11  2019 bin -> usr/bin\ndrwxr-xr-x  5 root root  340 aug 13 07:52 dev\ndrwxr-xr-x  1 root root 4096 aug 13 07:52 etc\ndrwxr-xr-x  2 root root 4096 may 11  2019 home\nlrwxrwxrwx  1 root root    7 may 11  2019 lib -> usr/lib\nlrwxrwxrwx  1 root root    9 may 11  2019 lib64 -> usr/lib64\ndrwx------  2 root root 4096 aug  9 21:40 lost+found\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 同时包含cmd和entrypoint\n\n[root@localhost dockfile]# cat dockerfile \nfrom centos:latest\nmaintainer zhaoxing<779292642@qq.com>\n\nenv mypath /usr/local\nworkdir $mypath\n\ncmd ["-a"]\nentrypoint ["ls"]\n\n[root@localhost dockfile]# docker build -f dockerfile -t centos:v1 .\n\n# 执行命令：ls -a\n# cmd声明的command会当作entrypoint声明的command的参数\n[root@localhost dockfile]# docker run centos:v1\n.\n..\nbin\netc\ngames\ninclude\nlib\nlib64\nlibexec\nsbin\nshare\nsrc\n\n# 覆盖cmd声明的command\n[root@localhost dockfile]# docker run centos:v1 -l\ntotal 0\ndrwxr-xr-x. 2 root root  6 nov  3  2020 bin\ndrwxr-xr-x. 2 root root  6 nov  3  2020 etc\ndrwxr-xr-x. 2 root root  6 nov  3  2020 games\ndrwxr-xr-x. 2 root root  6 nov  3  2020 include\ndrwxr-xr-x. 2 root root  6 nov  3  2020 lib\ndrwxr-xr-x. 3 root root 16 sep 15 14:17 lib64\ndrwxr-xr-x. 2 root root  6 nov  3  2020 libexec\ndrwxr-xr-x. 2 root root  6 nov  3  2020 sbin\ndrwxr-xr-x. 5 root root 46 sep 15 14:17 share\ndrwxr-xr-x. 2 root root  6 nov  3  2020 src\n[root@localhost dockfile]# docker run centos:v1 -al\ntotal 8\ndrwxr-xr-x. 12 root root 4096 sep 15 14:17 .\ndrwxr-xr-x. 12 root root 4096 sep 15 14:17 ..\ndrwxr-xr-x.  2 root root    6 nov  3  2020 bin\ndrwxr-xr-x.  2 root root    6 nov  3  2020 etc\ndrwxr-xr-x.  2 root root    6 nov  3  2020 games\ndrwxr-xr-x.  2 root root    6 nov  3  2020 include\ndrwxr-xr-x.  2 root root    6 nov  3  2020 lib\ndrwxr-xr-x.  3 root root   16 sep 15 14:17 lib64\ndrwxr-xr-x.  2 root root    6 nov  3  2020 libexec\ndrwxr-xr-x.  2 root root    6 nov  3  2020 sbin\ndrwxr-xr-x.  5 root root   46 sep 15 14:17 share\ndrwxr-xr-x.  2 root root    6 nov  3  2020 src\n\n\n# 覆盖entrypoint声明的command（此时cmd声明的command失效）\n[root@localhost dockfile]# docker run --entrypoint ls 3a\nbin\netc\ngames\ninclude\nlib\nlib64\nlibexec\nsbin\nshare\nsrc\n\n# 同时覆盖entrypoint和cmd声明的command\n[root@localhost dockfile]# docker run --entrypoint ls 3a -a\n.\n..\nbin\netc\ngames\ninclude\nlib\nlib64\nlibexec\nsbin\nshare\nsrc\n[root@localhost dockfile]# docker run --entrypoint ls 3a -al\ntotal 8\ndrwxr-xr-x. 12 root root 4096 sep 15 14:17 .\ndrwxr-xr-x. 12 root root 4096 sep 15 14:17 ..\ndrwxr-xr-x.  2 root root    6 nov  3  2020 bin\ndrwxr-xr-x.  2 root root    6 nov  3  2020 etc\ndrwxr-xr-x.  2 root root    6 nov  3  2020 games\ndrwxr-xr-x.  2 root root    6 nov  3  2020 include\ndrwxr-xr-x.  2 root root    6 nov  3  2020 lib\ndrwxr-xr-x.  3 root root   16 sep 15 14:17 lib64\ndrwxr-xr-x.  2 root root    6 nov  3  2020 libexec\ndrwxr-xr-x.  2 root root    6 nov  3  2020 sbin\ndrwxr-xr-x.  5 root root   46 sep 15 14:17 share\ndrwxr-xr-x.  2 root root    6 nov  3  2020 src\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n\n# dockerfile制作tomcat镜像\n\n\n# 制作tomcat镜像\n\n 1. 准备镜像文件 tomcat压缩包，jdk的压缩包！\n\n\n\n 2. 编写dockerfile文件, build默认在构建上下文寻找名称为dockfile的文件，就不需要-f 指定了！\n\n[root@iz2zeg4ytp0whqtmxbsqiiz tomcat]# cat dockerfile \nfrom centos\nmaintainer xiaofan<594042358@qq.com>\ncopy readme.txt /usr/local/readme.txt\n# add 会自动解压\nadd jdk-8u73-linux-x64.tar.gz /usr/local/\nadd apache-tomcat-9.0.37.tar.gz /usr/local/\nrun yum -y install vim\nenv mypath /usr/local\nworkdir $mypath\nenv java_home /usr/local/jdk1.8.0_73\nenv classpath $java_home/lib/dt.jar:$java_home/lib/tools.jar\nenv catalina_home /usr/local/apache-tomcat-9.0.37\nenv catalina_bash /usr/local/apache-tomcat-9.0.37\nenv path $path:$java_home/bin:$catalina_home/lib:$catalina_home/bin\nexpose 8080\ncmd /usr/local/apache-tomcat-9.0.37/bin/startup.sh && tail -f /usr/local/apache-tomcat-9.0.37/bin/logs/catalina.out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 3. 构建镜像\n\n# docker build -t diytomcat .\n\n\n1\n\n 4. 启动镜像\n\ndocker run -d -p 3344:8080 \\\n--name xiaofantomcat1 \\\n-v /home/xiaofan/build/tomcat/test:/usr/local/apache-tomcat-9.0.37/webapps/test \\\n-v /home/xiaofan/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.37/logs \ndiytomcat\n\n\n1\n2\n3\n4\n5\n\n 5. 访问测试\n\n在本地编写web.xml和index.jsp进行测试\n\n\n\n<?xml version="1.0" encoding="utf-8"?>\n<web-app version="2.4" \n    xmlns="http://java.sun.com/xml/ns/j2ee" \n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xsi:schemalocation="http://java.sun.com/xml/ns/j2ee \n        http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">\n        \n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n<%@ page language="java" contenttype="text/html; charset=utf-8"\n    pageencoding="utf-8"%>\n<!doctype html>\n<html>\n<head>\n<meta charset="utf-8">\n<title>hello. xiaofan</title>\n</head>\n<body>\nhello world!<br/>\n<%\nsystem.out.println("-----my test web logs------");\n%>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n发现：项目部署成功， 可以直接访问ok！\n\n\n\n\n# 发布自己的镜像到docker hub\n\n 1. dockker hub 注册自己的账号！\n 2. 确定这个账号可以登录\n\n\n\n 3. 在我们的服务器上提交自己的镜像\n\n# push到我们的服务器上\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker push diytomcat\nthe push refers to repository [docker.io/library/diytomcat]\n2eaca873a720: preparing \n1b38cc4085a8: preparing \n088ebb58d264: preparing \nc06785a2723d: preparing \n291f6e44771a: preparing \ndenied: requested access to the resource is denied\t# 拒绝\n\n# push镜像的问题？\nthe push refers to repository [docker.io/1314520007/diytomcat]\nan image does not exist locally with the tag: 1314520007/diytomcat\n\n# 解决，增加一个tag\ndocker tag diytomcat 1314520007/tomcat:1.0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n\n# 发布到阿里云镜像服务上\n\n 1. 登录阿里云\n\n 2. 找到容器镜像服务\n\n 3. 创建命名空间\n\n\n\n 4. 创建镜像仓库\n\n\n\n 5. 点击仓库名称，参考官方文档即可\n\n\n\n\n# 总结\n\n\n\n\n# docker网络\n\n\n# 连接 docker0\n\n测试\n\n\n\n三个网络\n\n# 问题： docker是如何处理容器网络访问的？\n\n# [root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker run -d -p --name tomcat01 tomcat\n\n# 查看容器内部的网络地址 ip addr\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker exec -it tomcat01 ip addr， 发现容器启动的时候得到一个eth0@if115 ip地址，docker分配的！\n1: lo: <loopback,up,lower_up> mtu 65536 qdisc noqueue state unknown group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n114: eth0@if115: <broadcast,multicast,up,lower_up> mtu 1500 qdisc noqueue state up group default \n    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0\n       valid_lft forever preferred_lft forever\n\n# 思考： linux 能不能ping通容器？\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# ping 172.17.0.2\nping 172.17.0.2 (172.17.0.2) 56(84) bytes of data.\n64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.077 ms\n64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.069 ms\n64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.075 ms\n\n# linux 可以 ping 通docker容器内部！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n原理\n\n> 我们每启动一个docker容器， docker就会给docker容器分配一个ip， 我们只要安装了docker，就会有一个网卡 docker0桥接模式，使用的技术是veth-pair技术！\n\n再次测试 ip addr\n\n\n\n再启动一个容器测试， 发现又多了一对网卡\n\n\n\n# 我们发现这个容器带来网卡，都是一对对的\n# veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连\n# 正因为有这个特性，veth-pair充当一个桥梁， 连接各种虚拟网络设备\n# openstac， docker容器之间的链接，ovs的链接， 都是使用veth-pair技术\n\n\n1\n2\n3\n4\n\n\n我们测试一下tomcat01和tomcat02之间是否可以ping通！\n\n结论：容器与容器之间是可以相互ping通的！\n\n绘制一个网络模型图\n\n\n\n结论：tomcat01和tomcat02是共用的一个路由器，docker0\n\n所有容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip\n\n小结\n\ndocker使用的是linux的桥接，宿主机中是一个docker容器的网桥docker0.\n\n\n\ndocker中的所有的网络接口都是虚拟的，虚拟的转发效率高！（内网传递文件！）\n\n只要容器删除，对应的网桥一对就没有了！\n\n\n\n\n# -- link\n\n解决通过docker0联通时通过容器名访问\n\n思考一个场景，我们编写了一个微服务，database url =ip； 项目不重启，数据ip换掉了，我们希望可以处理这个问题，可以按名字来进行访问容器\n\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker exec -it tomcat02 ping tomcat01\nping: tomcat01: name or service not known\n\n# 如何可以解决呢？\n# 通过--link即可以解决网络连通问题\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker run -d -p  --name tomcat03 --link tomcat02 tomcat\n3a2bcaba804c5980d94d168457c436fbd139820be2ee77246888f1744e6bb473\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker ps\ncontainer id        image               command             created             status              ports                     names\n3a2bcaba804c        tomcat              "catalina.sh run"   4 seconds ago       up 3 seconds        0.0.0.0:32772->8080/tcp   tomcat03\nf22ed47ed1be        tomcat              "catalina.sh run"   57 minutes ago      up 57 minutes       0.0.0.0:32771->8080/tcp   tomcat02\n9d97f93401a0        tomcat              "catalina.sh run"   about an hour ago   up about an hour    0.0.0.0:32770->8080/tcp   tomcat01\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker exec -it tomcat03 ping tomcat02\nping tomcat02 (172.17.0.3) 56(84) bytes of data.\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.129 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.100 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.110 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.107 ms\n\n# 反向可以ping通吗？\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker exec -it tomcat02 ping tomcat03\nping: tomcat03: name or service not known\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n探究：inspect！\n\n\n\n其实这个tomcat03就是在本地配置了tomcat02的配置？\n\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker exec -it tomcat03 cat /etc/hosts\n127.0.0.1\tlocalhost\n::1\tlocalhost ip6-localhost ip6-loopback\nfe00::0\tip6-localnet\nff00::0\tip6-mcastprefix\nff02::1\tip6-allnodes\nff02::2\tip6-allrouters\n172.17.0.3\ttomcat02 f22ed47ed1be\n172.17.0.4\t3a2bcaba804c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n本质探究：--link 就是我们在hosts配置中增加了一个172.17.0.3 tomcat02 f22ed47ed1be\n\n我们现在玩docker已经不建议使用--link了！\n\n自定义网络！不使用docker0！\n\ndocker0的问题：它不支持容器名链接访问！\n\n\n# 自定义网络\n\n查看所有的docker网络\n\n\n\n网络模式\n\n * bridge： 桥接模式，桥接 docker 默认，自己创建的也是用brdge模式\n\n * none： 不配置网络\n\n * host： 和宿主机共享网络\n\n * container：容器网络连通！（用的少， 局限很大）\n\n测试\n\n# 我们直接启动的命令默认有一个 --net bridge，而这个就是我们的docker0\ndocker run -d -p --name tomcat01 tomcat\ndocker run -d -p --name tomcat01 --net bridge tomcat\n\n# docker0特点，默认，容器名不能访问， --link可以打通连接！\n# 我们可以自定义一个网络！\n# --driver bridge\n# --subnet 192.168.0.0/16 可以支持255*255个网络 192.168.0.2 ~ 192.168.255.254\n# --gateway 192.168.0.1\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet\n26a5afdf4805d7ee0a660b82244929a4226470d99a179355558dca35a2b983ec\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker network ls\nnetwork id          name                driver              scope\n30d601788862        bridge              bridge              local\n226019b14d91        host                host                local\n26a5afdf4805        mynet               bridge              local\n7496c014f74b        none                null                local\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n我们自己创建的网络就ok了！\n\n\n\n在自己创建的网络里面启动两个容器\n\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker run -d -p --name tomcat-net-01 --net mynet tomcat\n0e85ebe6279fd23379d39b27b5f47c1e18f23ba7838637802973bf6449e22f5c\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker run -d -p --name tomcat-net-02 --net mynet tomcat\nc6e462809ccdcebb51a4078b1ac8fdec33f1112e9e416406b606d0c9fb6f21b5\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker network inspect mynet\n[\n    {\n        "name": "mynet",\n        "id": "26a5afdf4805d7ee0a660b82244929a4226470d99a179355558dca35a2b983ec",\n        "created": "2020-08-14t11:12:40.553433163+08:00",\n        "scope": "local",\n        "driver": "bridge",\n        "enableipv6": false,\n        "ipam": {\n            "driver": "default",\n            "options": {},\n            "config": [\n                {\n                    "subnet": "192.168.0.0/16",\n                    "gateway": "192.168.0.1"\n                }\n            ]\n        },\n        "internal": false,\n        "attachable": false,\n        "ingress": false,\n        "configfrom": {\n            "network": ""\n        },\n        "configonly": false,\n        "containers": {\n            "0e85ebe6279fd23379d39b27b5f47c1e18f23ba7838637802973bf6449e22f5c": {\n                "name": "tomcat-net-01",\n                "endpointid": "576ce5c0f5860a5aab5e487a805da9d72f41a409c460f983c0bd341dd75d83ac",\n                "macaddress": "02:42:c0:a8:00:02",\n                "ipv4address": "192.168.0.2/16",\n                "ipv6address": ""\n            },\n            "c6e462809ccdcebb51a4078b1ac8fdec33f1112e9e416406b606d0c9fb6f21b5": {\n                "name": "tomcat-net-02",\n                "endpointid": "81ecbc4fe26e49855fe374f2d7c00d517b11107cc91a174d383ff6be37d25a30",\n                "macaddress": "02:42:c0:a8:00:03",\n                "ipv4address": "192.168.0.3/16",\n                "ipv6address": ""\n            }\n        },\n        "options": {},\n        "labels": {}\n    }\n]\n\n# 再次ping连接\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker exec -it tomcat-net-01 ping 192.168.0.3\nping 192.168.0.3 (192.168.0.3) 56(84) bytes of data.\n64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.113 ms\n64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.093 ms\n^c\n--- 192.168.0.3 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 999ms\nrtt min/avg/max/mdev = 0.093/0.103/0.113/0.010 ms\n# 现在不使用 --link也可以ping名字了！\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker exec -it tomcat-net-01 ping tomcat-net-02\nping tomcat-net-02 (192.168.0.3) 56(84) bytes of data.\n64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.068 ms\n64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.096 ms\n64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.094 ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络\n\n好处：\n\n> redis - 不同的集群使用不同的网络，保证集群是安全和健康的\n> \n> mysql - 不同的集群使用不同的网络，保证集群是安全和健康的\n\n\n# 网络连通（不同网络之间）\n\n\n\n测试打通tomcat01 和mynet\n\n\n\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker network connect  mynet tomcat01\n\n# 连通之后就是讲tomcat01放到了mynet网络下\n# 一个容器两个ip地址：\n# 阿里云服务器，公网ip，私网ip\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\n\n# 连通ok\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker exec -it tomcat01 ping tomcat-net-01\nping tomcat-net-01 (192.168.0.2) 56(84) bytes of data.\n64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.100 ms\n64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.085 ms\n^c\n--- tomcat-net-01 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1000ms\nrtt min/avg/max/mdev = 0.085/0.092/0.100/0.012 ms\n# 依旧无法连通，没有connect\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker exec -it tomcat02 ping tomcat-net-01\nping: tomcat-net-01: name or service not known\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n结论：假设要跨网络操作别人，就要使用docker network connect连通.....!\n\n\n# 实战：部署redis\n\n\n\n\n# 实战一（bridge网络 + docker）\n\n> 这种方案 spring boot 项目连接redis集群时有问题：redis节点之间通信有问题，还是使用的自定义网段分配的地址\n\n# 创建网卡\ndocker network create redis --subnet 172.38.0.0/16\n\n# 通过脚本创建六个redis配置\nfor port in $(seq 1 6); \\\ndo \\\nmkdir -p /home/software/redis/node-${port}/conf\ntouch /home/software/redis/node-${port}/conf/redis.conf\ncat << eof >/home/software/redis/node-${port}/conf/redis.conf\nport 6379\nbind 0.0.0.0\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 5000\ncluster-announce-ip 172.38.0.1${port}\ncluster-announce-port 6379\ncluster-announce-bus-port 16379\nappendonly yes\neof\ndone\n# 创建结点1\ndocker run -p 6371:6379 -p 16371:16379 --name redis-1 \\\n-v /home/software/redis/node-1/data:/data \\\n-v /home/software/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n#创建结点2\ndocker run -p 6372:6379 -p 16372:16379 --name redis-2 \\\n-v /home/software/redis/node-2/data:/data \\\n-v /home/software/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n#创建结点3\ndocker run -p 6373:6379 -p 16373:16379 --name redis-3 \\\n-v /home/software/redis/node-3/data:/data \\\n-v /home/software/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n#创建结点4\ndocker run -p 6374:6379 -p 16374:16379 --name redis-4 \\\n-v /home/software/redis/node-4/data:/data \\\n-v /home/software/redis/node-4/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n#创建结点5\ndocker run -p 6375:6379 -p 16375:16379 --name redis-5 \\\n-v /home/software/redis/node-5/data:/data \\\n-v /home/software/redis/node-5/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n#创建结点6\ndocker run -p 6376:6379 -p 16376:16379 --name redis-6 \\\n-v /home/software/redis/node-6/data:/data \\\n-v /home/software/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n# 创建集群\n[root@iz2zeg4ytp0whqtmxbsqiiz ~]# docker exec -it redis-1 /bin/sh\n/data # ls\nappendonly.aof  nodes.conf\n/data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1\n>>> performing hash slots allocation on 6 nodes...\nmaster[0] -> slots 0 - 5460\nmaster[1] -> slots 5461 - 10922\nmaster[2] -> slots 10923 - 16383\nadding replica 172.38.0.15:6379 to 172.38.0.11:6379\nadding replica 172.38.0.16:6379 to 172.38.0.12:6379\nadding replica 172.38.0.14:6379 to 172.38.0.13:6379\nm: 541b7d237b641ac2ffc94d17c6ab96b18b26a638 172.38.0.11:6379\n   slots:[0-5460] (5461 slots) master\nm: a89c1f1245b264e4a402a3cf99766bcb6138dbca 172.38.0.12:6379\n   slots:[5461-10922] (5462 slots) master\nm: 259e804d6df74e67a72e4206d7db691a300c775e 172.38.0.13:6379\n   slots:[10923-16383] (5461 slots) master\ns: 9b19170eea3ea1b92c58ad18c0b5522633a9e271 172.38.0.14:6379\n   replicates 259e804d6df74e67a72e4206d7db691a300c775e\ns: 061a9d38f22910aaf0ba1dbd21bf1d8f57bcb7d5 172.38.0.15:6379\n   replicates 541b7d237b641ac2ffc94d17c6ab96b18b26a638\ns: 7a16b9bbb0615ec95fc978fa62fc054df60536f0 172.38.0.16:6379\n   replicates a89c1f1245b264e4a402a3cf99766bcb6138dbca\ncan i set the above configuration? (type \'yes\' to accept): yes\n>>> nodes configuration updated\n>>> assign a different config epoch to each node\n>>> sending cluster meet messages to join the cluster\nwaiting for the cluster to join\n...\n>>> performing cluster check (using node 172.38.0.11:6379)\nm: 541b7d237b641ac2ffc94d17c6ab96b18b26a638 172.38.0.11:6379\n   slots:[0-5460] (5461 slots) master\n   1 additional replica(s)\nm: a89c1f1245b264e4a402a3cf99766bcb6138dbca 172.38.0.12:6379\n   slots:[5461-10922] (5462 slots) master\n   1 additional replica(s)\ns: 7a16b9bbb0615ec95fc978fa62fc054df60536f0 172.38.0.16:6379\n   slots: (0 slots) slave\n   replicates a89c1f1245b264e4a402a3cf99766bcb6138dbca\ns: 061a9d38f22910aaf0ba1dbd21bf1d8f57bcb7d5 172.38.0.15:6379\n   slots: (0 slots) slave\n   replicates 541b7d237b641ac2ffc94d17c6ab96b18b26a638\nm: 259e804d6df74e67a72e4206d7db691a300c775e 172.38.0.13:6379\n   slots:[10923-16383] (5461 slots) master\n   1 additional replica(s)\ns: 9b19170eea3ea1b92c58ad18c0b5522633a9e271 172.38.0.14:6379\n   slots: (0 slots) slave\n   replicates 259e804d6df74e67a72e4206d7db691a300c775e\n[ok] all nodes agree about slots configuration.\n>>> check for open slots...\n>>> check slots coverage...\n[ok] all 16384 slots covered.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n\n\n\n# 实战二（host网络 + docker-compose）\n\ndocker搭建redis集群完成！\n\n\n\n\n# springboot微服务打包docker镜像\n\n * 打包应用\n * 编写dockerfile\n\nfrom java:8\n\ncopy *.jar /app.jar\n\ncmd ["--server.port=8080"]\n\nexpose 8080\n\nentrypoint ["java", "-jar", "/app.jar"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 构建镜像\n\n# 上传jar包和dockerfile到linux\n[root@iz2zeg4ytp0whqtmxbsqiiz idea]# ll\ntotal 16140\n-rw-r--r-- 1 root root 16519871 aug 14 17:38 demo-0.0.1-snapshot.jar\n-rw-r--r-- 1 root root      122 aug 14 17:38 dockerfile\n\n# 构建镜像\n[root@iz2zeg4ytp0whqtmxbsqiiz idea]# docker build -t myapp:v1 .\nsending build context to docker daemon  16.52mb\nstep 1/5 : from java:8\n8: pulling from library/java\n5040bd298390: pull complete \nfce5728aad85: pull complete \n76610ec20bf5: pull complete \n60170fec2151: pull complete \ne98f73de8f0d: pull complete \n11f7af24ed9c: pull complete \n49e2d6393f32: pull complete \nbb9cdec9c7f3: pull complete \ndigest: sha256:c1ff613e8ba25833d2e1940da0940c3824f03f802c449f3d1815a66b7f8c0e9d\nstatus: downloaded newer image for java:8\n ---\x3e d23bdf5b1b1b\nstep 2/5 : copy *.jar /app.jar\n ---\x3e d4de8837ebf9\nstep 3/5 : cmd ["--server.port=8080"]\n ---\x3e running in e3abc66303f0\nremoving intermediate container e3abc66303f0\n ---\x3e 131bb3917fea\nstep 4/5 : expose 8080\n ---\x3e running in fa2f25977db7\nremoving intermediate container fa2f25977db7\n ---\x3e d98147377951\nstep 5/5 : entrypoint ["java", "-jar", "/app.jar"]\n ---\x3e running in e1885e23773b\nremoving intermediate container e1885e23773b\n ---\x3e afb6b5f28a32\nsuccessfully built afb6b5f28a32\nsuccessfully tagged xiaofan666:latest\n\n# 查看镜像\n[root@iz2zeg4ytp0whqtmxbsqiiz idea]# docker images\nrepository          tag                 image id            created             size\nmyapp               v1                  afb6b5f28a32        14 seconds ago      660mb\ntomcat              latest              2ae23eb477aa        8 days ago          647mb\nredis               5.0.9-alpine3.11    3661c84ee9d0        3 months ago        29.8mb\njava                8                   d23bdf5b1b1b        3 years ago         643mb\n\n# 运行容器\n[root@iz2zeg4ytp0whqtmxbsqiiz idea]# docker run -d -p --name my-springboot-web myapp:v1\nfd9a353a80bfd61f6930c16cd92204532bfd734e003f3f9983b5128a27b0375e\n# 查看运行起来的容器端口（因为我们启动的时候没有指定）\n[root@iz2zeg4ytp0whqtmxbsqiiz idea]# docker ps\ncontainer id        image               command                  created             status              ports                     names\nfd9a353a80bf        xiaofan666          "java -jar /app.jar …"   9 seconds ago       up 8 seconds        0.0.0.0:32779->8080/tcp   xiaofan-springboot-web\n# 本地访问1\n[root@iz2zeg4ytp0whqtmxbsqiiz idea]# curl localhost:32779/hello\nhello, world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# docker compose\n\n\n# 安装\n\n下载docker-compose命令\n\n# 官网提供 （没有下载成功）\ncurl -l "https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose\n# 国内地址\ncurl -l https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n\n\n1\n2\n3\n4\n\n\n分配可执行权限\n\nchmod +x /usr/local/bin/docker-compose\n\n\n1\n\n\n\n\n\n# yaml规则\n\nhttps://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples\n\n\n# 实战：自己编写微服务上线\n\n * 编写项目微服务\n * dockerfile构建镜像\n\nfrom java:8\n\ncopy *.jar /app.jar\n\ncmd ["--server.port=8080"]\n\nexpose 8080\n\nentrypoint ["java", "-jar", "/app.jar"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * docker-compose.yml编排项目\n\nversion \'3.8\'\nservices:\n  myapp:\n    build: .\n    image: myapp:v1\n    depends_on:\n      - redis\n    ports:\n      - "8080:8080"\n\n  redis:\n    image: "library/redis:alpine"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 丢到服务器运行 docker-compose up\n\ndocker-compose down\t\t\t# 关闭容器\ndocker-compose up --build \t# 重新构建\n\n\n1\n2\n\n\n\n\n',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Docker 中级篇",frontmatter:{title:"Docker 中级篇",date:"2022-02-03T00:03:52.000Z",permalink:"/pages/5ca863/",categories:["后端","Docker"],tags:[null]},regularPath:"/25.%E8%BF%90%E7%BB%B4/50.Docker/02.Docker%20%E4%B8%AD%E7%BA%A7%E7%AF%87.html",relativePath:"25.运维/50.Docker/02.Docker 中级篇.md",key:"v-485c8077",path:"/pages/5ca863/",headers:[{level:2,title:"FROM 指定基础镜像",slug:"from-指定基础镜像",normalizedTitle:"from 指定基础镜像",charIndex:106},{level:2,title:"RUN 执行命令",slug:"run-执行命令",normalizedTitle:"run 执行命令",charIndex:539},{level:2,title:"构建镜像",slug:"构建镜像",normalizedTitle:"构建镜像",charIndex:2376},{level:2,title:"镜像构建上下文（Context）",slug:"镜像构建上下文-context",normalizedTitle:"镜像构建上下文（context）",charIndex:2983},{level:2,title:"Dockerfile 指令详解",slug:"dockerfile-指令详解",normalizedTitle:"dockerfile 指令详解",charIndex:4827},{level:3,title:"COPY 复制文件",slug:"copy-复制文件",normalizedTitle:"copy 复制文件",charIndex:4847},{level:3,title:"ADD 更高级的复制文件",slug:"add-更高级的复制文件",normalizedTitle:"add 更高级的复制文件",charIndex:5413},{level:3,title:"CMD 容器启动命令",slug:"cmd-容器启动命令",normalizedTitle:"cmd 容器启动命令",charIndex:5792},{level:3,title:"ENTRYPOINT 入口点",slug:"entrypoint-入口点",normalizedTitle:"entrypoint 入口点",charIndex:7211},{level:3,title:"ENV 设置环境变量",slug:"env-设置环境变量",normalizedTitle:"env 设置环境变量",charIndex:9829},{level:3,title:"ARG 构建参数",slug:"arg-构建参数",normalizedTitle:"arg 构建参数",charIndex:10232},{level:3,title:"VOLUME 定义匿名卷",slug:"volume-定义匿名卷",normalizedTitle:"volume 定义匿名卷",charIndex:10532},{level:3,title:"EXPOSE 暴露端口",slug:"expose-暴露端口",normalizedTitle:"expose 暴露端口",charIndex:11006},{level:3,title:"WORKDIR 指定工作目录",slug:"workdir-指定工作目录",normalizedTitle:"workdir 指定工作目录",charIndex:11360},{level:3,title:"USER 指定当前用户",slug:"user-指定当前用户",normalizedTitle:"user 指定当前用户",charIndex:12057},{level:3,title:"LABEL 为镜像添加元数据",slug:"label-为镜像添加元数据",normalizedTitle:"label 为镜像添加元数据",charIndex:12338},{level:2,title:"数据卷",slug:"数据卷",normalizedTitle:"数据卷",charIndex:12484},{level:3,title:"创建一个数据卷（具名数据卷）",slug:"创建一个数据卷-具名数据卷",normalizedTitle:"创建一个数据卷（具名数据卷）",charIndex:12694},{level:3,title:"启动一个挂载数据卷的容器",slug:"启动一个挂载数据卷的容器",normalizedTitle:"启动一个挂载数据卷的容器",charIndex:13137},{level:3,title:"查看数据卷的具体信息",slug:"查看数据卷的具体信息",normalizedTitle:"查看数据卷的具体信息",charIndex:13547},{level:3,title:"删除数据卷",slug:"删除数据卷",normalizedTitle:"删除数据卷",charIndex:13949},{level:2,title:"挂载主机目录",slug:"挂载主机目录",normalizedTitle:"挂载主机目录",charIndex:12500},{level:3,title:"挂载一个主机目录作为数据卷",slug:"挂载一个主机目录作为数据卷",normalizedTitle:"挂载一个主机目录作为数据卷",charIndex:14163},{level:3,title:"查看数据卷的具体信息",slug:"查看数据卷的具体信息-2",normalizedTitle:"查看数据卷的具体信息",charIndex:13547}],headersStr:"FROM 指定基础镜像 RUN 执行命令 构建镜像 镜像构建上下文（Context） Dockerfile 指令详解 COPY 复制文件 ADD 更高级的复制文件 CMD 容器启动命令 ENTRYPOINT 入口点 ENV 设置环境变量 ARG 构建参数 VOLUME 定义匿名卷 EXPOSE 暴露端口 WORKDIR 指定工作目录 USER 指定当前用户 LABEL 为镜像添加元数据 数据卷 创建一个数据卷（具名数据卷） 启动一个挂载数据卷的容器 查看数据卷的具体信息 删除数据卷 挂载主机目录 挂载一个主机目录作为数据卷 查看数据卷的具体信息",content:'# 使用 Dockerfile 定制镜像\n\nDockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。\n\n\n# FROM 指定基础镜像\n\n所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。\n\n在 Docker Hub 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。\n\n如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。\n\n\n# RUN 执行命令\n\nRUN 指令是用来执行命令行命令的。\n\n其格式有两种：\n\n * shell 格式：RUN <命令>，就像直接在命令行中输入的命令一样。\n\nRUN echo \'<h1>Hello, Docker!</h1>\' > /usr/share/nginx/html/index.html\n\n\n1\n\n * exec 格式：RUN ["可执行文件", "参数1", "参数2"]，这更像是函数调用中的格式。\n\n之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。\n\n * 错误示例\n\nFROM debian:stretch\n\nRUN apt-get update\nRUN apt-get install -y gcc libc6-dev make wget\nRUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"\nRUN mkdir -p /usr/src/redis\nRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1\nRUN make -C /usr/src/redis\nRUN make -C /usr/src/redis install\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。\n\nUnion FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。\n\n * 最佳实践\n\nFROM debian:stretch\n\nRUN set -x; buildDeps=\'gcc libc6-dev make wget\' \\\n    && apt-get update \\\n    && apt-get install -y $buildDeps \\\n    && wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \\\n    && mkdir -p /usr/src/redis \\\n    && tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\\n    && make -C /usr/src/redis \\\n    && make -C /usr/src/redis install \\\n    && rm -rf /var/lib/apt/lists/* \\\n    && rm redis.tar.gz \\\n    && rm -r /usr/src/redis \\\n    && apt-get purge -y --auto-remove $buildDeps\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。\n\n并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。\n\n此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。\n\n很多人 Docker 初学者制作出很臃肿的镜像的原因之一，就是忘记了在每一层构建的最后一定要清理掉无关文件。\n\n\n# 构建镜像\n\n在 Dockerfile 文件所在目录执行：\n\n$ docker build -t nginx:v3 .\nSending build context to Docker daemon 2.048 kB\nStep 1 : FROM nginx\n ---\x3e e43d811ce2f4\nStep 2 : RUN echo \'<h1>Hello, Docker!</h1>\' > /usr/share/nginx/html/index.html\n ---\x3e Running in 9cdc27646c7b\n ---\x3e 44aa4490ce2c\nRemoving intermediate container 9cdc27646c7b\nSuccessfully built 44aa4490ce2c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。\n\n这里我们使用了 docker build 命令进行镜像构建。其格式为：\n\ndocker build [选项] <上下文路径/URL/->\n\n\n1\n\n\n在这里我们指定了最终镜像的名称 -t nginx:v3\n\n\n# 镜像构建上下文（Context）\n\n如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 上下文路径。那么什么是上下文呢？\n\n首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。\n\n当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？\n\n这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。\n\n如果在 Dockerfile 中这么写：\n\nCOPY ./package.json /app/\n\n\n1\n\n\n就表示复制 上下文（context） 目录下的 package.json。\n\n因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。\n\n现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。\n\n如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：\n\n$ docker build -t nginx:v3 .\nSending build context to Docker daemon 2.048 kB\n...\n\n\n1\n2\n3\n\n\n理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。\n\n一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。\n\n在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。\n\n当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。\n\n\n# Dockerfile 指令详解\n\n\n# COPY 复制文件\n\n格式：\n\n * COPY [--chown=<user>:<group>] <源路径>... <目标路径>\n * COPY [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]\n\n和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。\n\nCOPY 指令将从构建上下文目录中 <源路径> 的文件/目录复制到新的一层的镜像内的 <目标路径> 位置。比如：\n\nCOPY package.json /usr/src/app/\n\n\n1\n\n\n<源路径> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：\n\nCOPY hom* /mydir/\nCOPY hom?.txt /mydir/\n\n\n1\n2\n\n\n<目标路径> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。\n\n此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。\n\n如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。\n\n\n# ADD 更高级的复制文件\n\nADD 指令和 COPY 的格式和性质基本一致。\n\n如果 <源路径> 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 <目标路径> 去。\n\n在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。\n\n另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。\n\n因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。\n\n\n# CMD 容器启动命令\n\nCMD 指令用于指定容器主进程的默认启动命令。\n\n类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:\n\n * CMD 在docker run 时运行。\n * RUN 是在 docker build。\n\nCMD 指令的格式和 RUN 相似，也是两种格式：\n\n * shell 格式：CMD <命令>\n * exec 格式：CMD ["可执行文件", "参数1", "参数2"...]\n * 参数列表格式：CMD ["参数1", "参数2"...]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。\n\n注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。\n\nCMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。\n\n在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 "，而不要使用单引号。\n\n如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：\n\nCMD echo $HOME\n\n\n1\n\n\n在实际执行中，会将其变更为：\n\nCMD [ "sh", "-c", "echo $HOME" ]\n\n\n1\n\n\n这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。\n\n> 提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。\n> \n> Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。\n> \n> 一些初学者将 CMD 写为：\n> \n> CMD service nginx start\n> \n> \n> 1\n> \n> \n> 然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。\n> \n> 对于容器而言，容器就是为了容器内的应用主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。\n> \n> 例如CMD service nginx start 会被理解为 CMD [ "sh", "-c", "service nginx start"]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。\n> \n> 正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：\n> \n> CMD ["nginx", "-g", "daemon off;"]\n> \n> \n> 1\n\n\n# ENTRYPOINT 入口点\n\nENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。\n\nENTRYPOINT 的目的和 CMD 一样，都是在指定容器主进程启动命令及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。\n\n当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：\n\n<ENTRYPOINT> "<CMD>"\n\n\n1\n\n\n那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 <ENTRYPOINT> "<CMD>" 有什么好处么？让我们来看下面的场景。\n\n# 场景：让镜像变成像命令一样使用\n\n假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现：\n\nFROM ubuntu:18.04\nRUN apt-get update \\\n    && apt-get install -y curl \\\n    && rm -rf /var/lib/apt/lists/*\nCMD [ "curl", "-s", "http://myip.ipip.net" ]\n\n\n1\n2\n3\n4\n5\n\n\n假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：\n\n$ docker run myip\n当前 IP：61.148.226.66 来自：北京市 联通\n\n\n1\n2\n\n\n嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？\n\n$ docker run myip -i\ndocker: Error response from daemon: invalid header field value "oci runtime error: container_linux.go:247: starting container process caused \\"exec: \\\\\\"-i\\\\\\": executable file not found in $PATH\\"\\n".\n\n\n1\n2\n\n\n我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s http://myip.ipip.net 后面。而 -i 根本不是命令，所以自然找不到。\n\n那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：\n\n$ docker run myip curl -s http://myip.ipip.net -i\n\n\n1\n\n\n这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像：\n\nFROM ubuntu:18.04\nRUN apt-get update \\\n    && apt-get install -y curl \\\n    && rm -rf /var/lib/apt/lists/*\nENTRYPOINT [ "curl", "-s", "http://myip.ipip.net" ]\n\n\n1\n2\n3\n4\n5\n\n\n这次我们再来尝试直接使用 docker run myip -i：\n\n$ docker run myip\n当前 IP：61.148.226.66 来自：北京市 联通\n\n$ docker run myip -i\nHTTP/1.1 200 OK\nServer: nginx/1.8.0\nDate: Tue, 22 Nov 2016 05:12:40 GMT\nContent-Type: text/html; charset=UTF-8\nVary: Accept-Encoding\nX-Powered-By: PHP/5.6.24-1~dotdeb+7.1\nX-Cache: MISS from cache-2\nX-Cache-Lookup: MISS from cache-2:80\nX-Cache: MISS from proxy-2_6\nTransfer-Encoding: chunked\nVia: 1.1 cache-2:80, 1.1 proxy-2_6:8006\nConnection: keep-alive\n\n当前 IP：61.148.226.66 来自：北京市 联通\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果。\n\n总结\n\n>  * Dockfile中的 CMD 指令 和 ENTRYPOINT 指令 作用一样，都是用于定义容器主进程的启动命令\n>  * Dockfile中可以定义多条 CMD 指令 ，仅最后一个生效，ENTRYPOINT 指令也一样\n>  * CMD 指令和ENTRYPOINT 指令同时存在时，CMD指令指定的命令会被当做ENTRYPOINT 指令指定命令的参数，即 <ENTRYPOINT> "<CMD>"\n>  * docker run 命令后追加的 command 可以覆盖CMD指令指定的命令（如果不存在CMD 指令就是新定义一个）\n>  * dockker run 命令后追加的 command 也可以覆盖 ENTRYPOINT 指令指定的命令，不过要加 --entrypoint选项（如果不存在ENTRYPOINT 指令就是新定义一个）\n\n\n# ENV 设置环境变量\n\n格式有两种：\n\n * ENV <key> <value>\n * ENV <key1>=<value1> <key2>=<value2>...\n\n这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。\n\nENV VERSION=1.0 DEBUG=on \\\n    NAME="Happy Feet"\n\n\n1\n2\n\n\n这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。\n\n下列指令可以支持环境变量展开： ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。\n\n通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。\n\n\n# ARG 构建参数\n\n格式：ARG <参数名>[=<默认值>]\n\n构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。\n\nDockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 --build-arg <参数名>=<值> 来覆盖。\n\n灵活的使用 ARG 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。\n\n\n# VOLUME 定义匿名卷\n\n格式为：\n\n * VOLUME ["<路径1>", "<路径2>"...]\n * VOLUME <路径>\n\n之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。\n\nVOLUME /data\n\n\n1\n\n\n这里的 /data 目录就会在容器运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：\n\n$ docker run -d -v mydata:/data xxxx\n\n\n1\n\n\n在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。\n\n\n# EXPOSE 暴露端口\n\n格式为 EXPOSE <端口1> [<端口2>...]。\n\nEXPOSE 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。\n\n要将 EXPOSE 和在运行时使用 -p <宿主端口>:<容器端口> 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。\n\n\n# WORKDIR 指定工作目录\n\n格式为 WORKDIR <工作目录路径>。\n\n使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如果该目录不存在，WORKDIR 会帮你建立目录。\n\n之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：\n\nRUN cd /app\nRUN echo "hello" > world.txt\n\n\n1\n2\n\n\n如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。\n\n之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。\n\n因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。\n\nWORKDIR /app\n\nRUN echo "hello" > world.txt\n\n\n1\n2\n3\n\n\n\n# USER 指定当前用户\n\n格式：USER <用户名>[:<用户组>]\n\nUSER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。\n\n注意，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。\n\nRUN groupadd -r redis && useradd -r -g redis redis\nUSER redis\nRUN [ "redis-server" ]\n\n\n1\n2\n3\n\n\n\n# LABEL 为镜像添加元数据\n\nLABEL 指令用来给镜像以键值对的形式添加一些元数据（metadata）。\n\nLABEL <key>=<value> <key>=<value> <key>=<value> ...\n\n\n1\n\n\n\n# 数据管理\n\n\n\n在容器中管理数据主要有两种方式：\n\n * 数据卷（Volumes）\n * 挂载主机目录 (Bind mounts)\n\n\n# 数据卷\n\n数据卷（Volumes） ：Docker在宿主机文件系统默认开辟的一片空间，默认位于 /var/lib/docker/volumes 目录中；\n\n\n\n由上图可以知道，目前所有Container的数据都保存在了这个目录下边，由于没有在创建时指定卷，所以Docker帮我们默认创建许多匿名（就上面这一堆很长ID的名字）卷。\n\n\n# 创建一个数据卷（具名数据卷）\n\n$ docker volume create my-vol\n\n\n1\n\n\n查看所有的 数据卷\n\n$ docker volume ls\n\nDRIVER              VOLUME NAME\nlocal               my-vol\n\n\n1\n2\n3\n4\n\n\n在主机里使用以下命令可以查看指定 数据卷 的信息\n\n$ docker volume inspect my-vol\n[\n    {\n        "Driver": "local",\n        "Labels": {},\n        "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",\n        "Name": "my-vol",\n        "Options": {},\n        "Scope": "local"\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 启动一个挂载数据卷的容器\n\n在用 docker run 命令的时候，使用 --mount 标记来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。\n\n下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /usr/share/nginx/html 目录。\n\n$ docker run -d -P \\\n    --name web \\\n    # -v my-vol:/usr/share/nginx/html \\\n    --mount source=my-vol,target=/usr/share/nginx/html \\\n    nginx:alpine\n\n\n1\n2\n3\n4\n5\n\n\n注意：如果挂载数据卷时直接指定容器中目录，不指定挂载数据卷名，那么就会挂在一个匿名数据卷，不管是具名数据卷还是匿名数据卷，默认都位于/var/lib/docker/volume/中\n\n\n# 查看数据卷的具体信息\n\n在主机里使用以下命令可以查看 web 容器的信息\n\n$ docker inspect web\n\n\n1\n\n\n数据卷 信息在 "Mounts" Key 下面\n\n"Mounts": [\n    {\n        "Type": "volume",\n        "Name": "my-vol",\n        "Source": "/var/lib/docker/volumes/my-vol/_data",\n        "Destination": "/usr/share/nginx/html",\n        "Driver": "local",\n        "Mode": "",\n        "RW": true,\n        "Propagation": ""\n    }\n],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 删除数据卷\n\n$ docker volume rm my-vol\n\n\n1\n\n\n数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。\n\n无主的数据卷可能会占据很多空间，要清理请使用以下命令\n\n$ docker volume prune\n\n\n1\n\n\n\n# 挂载主机目录\n\n\n# 挂载一个主机目录作为数据卷\n\n使用 --mount 标记可以指定挂载一个本地主机的目录到容器中去。\n\n$ docker run -d -P \\\n    --name web \\\n    # -v /src/webapp:/usr/share/nginx/html \\\n    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \\\n    nginx:alpine\n\n\n1\n2\n3\n4\n5\n\n\n上面的命令挂载主机的 /src/webapp 目录到容器的 /usr/share/nginx/html目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。\n\n本地目录的路径必须是绝对路径，使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，使用 --mount 参数时如果本地目录不存在，Docker 会报错。\n\nDocker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读。\n\n$ docker run -d -P \\\n    --name web \\\n    # -v /src/webapp:/usr/share/nginx/html:ro \\\n    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \\\n    nginx:alpine\n\n\n1\n2\n3\n4\n5\n\n\n加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /usr/share/nginx/html 目录新建文件，会显示如下错误\n\n/usr/share/nginx/html # touch new.txt\ntouch: new.txt: Read-only file system\n\n\n1\n2\n\n\n\n# 查看数据卷的具体信息\n\n在主机里使用以下命令可以查看 web 容器的信息\n\n$ docker inspect web\n\n\n1\n\n\n挂载主机目录 的配置信息在 "Mounts" Key 下面\n\n"Mounts": [\n    {\n        "Type": "bind",\n        "Source": "/src/webapp",\n        "Destination": "/usr/share/nginx/html",\n        "Mode": "",\n        "RW": true,\n        "Propagation": "rprivate"\n    }\n],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'# 使用 dockerfile 定制镜像\n\ndockerfile 是一个文本文件，其内包含了一条条的 指令(instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。\n\n\n# from 指定基础镜像\n\n所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 from 就是指定 基础镜像，因此一个 dockerfile 中 from 是必备的指令，并且必须是第一条指令。\n\n在 docker hub 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。\n\n如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。\n\n\n# run 执行命令\n\nrun 指令是用来执行命令行命令的。\n\n其格式有两种：\n\n * shell 格式：run <命令>，就像直接在命令行中输入的命令一样。\n\nrun echo \'<h1>hello, docker!</h1>\' > /usr/share/nginx/html/index.html\n\n\n1\n\n * exec 格式：run ["可执行文件", "参数1", "参数2"]，这更像是函数调用中的格式。\n\n之前说过，dockerfile 中每一个指令都会建立一层，run 也不例外。每一个 run 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。\n\n * 错误示例\n\nfrom debian:stretch\n\nrun apt-get update\nrun apt-get install -y gcc libc6-dev make wget\nrun wget -o redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"\nrun mkdir -p /usr/src/redis\nrun tar -xzf redis.tar.gz -c /usr/src/redis --strip-components=1\nrun make -c /usr/src/redis\nrun make -c /usr/src/redis install\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。\n\nunion fs 是有最大层数限制的，比如 aufs，曾经是最大不得超过 42 层，现在是不得超过 127 层。\n\n * 最佳实践\n\nfrom debian:stretch\n\nrun set -x; builddeps=\'gcc libc6-dev make wget\' \\\n    && apt-get update \\\n    && apt-get install -y $builddeps \\\n    && wget -o redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \\\n    && mkdir -p /usr/src/redis \\\n    && tar -xzf redis.tar.gz -c /usr/src/redis --strip-components=1 \\\n    && make -c /usr/src/redis \\\n    && make -c /usr/src/redis install \\\n    && rm -rf /var/lib/apt/lists/* \\\n    && rm redis.tar.gz \\\n    && rm -r /usr/src/redis \\\n    && apt-get purge -y --auto-remove $builddeps\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。在撰写 dockerfile 的时候，要经常提醒自己，这并不是在写 shell 脚本，而是在定义每一层该如何构建。\n\n并且，这里为了格式化还进行了换行。dockerfile 支持 shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。\n\n此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。\n\n很多人 docker 初学者制作出很臃肿的镜像的原因之一，就是忘记了在每一层构建的最后一定要清理掉无关文件。\n\n\n# 构建镜像\n\n在 dockerfile 文件所在目录执行：\n\n$ docker build -t nginx:v3 .\nsending build context to docker daemon 2.048 kb\nstep 1 : from nginx\n ---\x3e e43d811ce2f4\nstep 2 : run echo \'<h1>hello, docker!</h1>\' > /usr/share/nginx/html/index.html\n ---\x3e running in 9cdc27646c7b\n ---\x3e 44aa4490ce2c\nremoving intermediate container 9cdc27646c7b\nsuccessfully built 44aa4490ce2c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 step 2 中，run 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。\n\n这里我们使用了 docker build 命令进行镜像构建。其格式为：\n\ndocker build [选项] <上下文路径/url/->\n\n\n1\n\n\n在这里我们指定了最终镜像的名称 -t nginx:v3\n\n\n# 镜像构建上下文（context）\n\n如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 上下文路径。那么什么是上下文呢？\n\n首先我们要理解 docker build 的工作原理。docker 在运行时分为 docker 引擎（也就是服务端守护进程）和客户端工具。docker 的引擎提供了一组 rest api，被称为 docker remote api，而如 docker 命令这样的客户端工具，则是通过这组 api 与 docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（docker 引擎）完成。也因为这种 c/s 设计，让我们操作远程服务器的 docker 引擎变得轻而易举。\n\n当我们进行镜像构建的时候，并非所有定制都会通过 run 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 copy 指令、add 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？\n\n这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 docker 引擎。这样 docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。\n\n如果在 dockerfile 中这么写：\n\ncopy ./package.json /app/\n\n\n1\n\n\n就表示复制 上下文（context） 目录下的 package.json。\n\n因此，copy 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 copy ../package.json /app 或者 copy /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。\n\n现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 docker 引擎以帮助构建镜像。\n\n如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：\n\n$ docker build -t nginx:v3 .\nsending build context to docker daemon 2.048 kb\n...\n\n\n1\n2\n3\n\n\n理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 copy /opt/xxxx /app 不工作后，于是干脆将 dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 gb 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。\n\n一般来说，应该会将 dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 docker 引擎的。\n\n在默认情况下，如果不额外指定 dockerfile 的话，会将上下文目录下的名为 dockerfile 的文件作为 dockerfile。这只是默认行为，实际上 dockerfile 的文件名并不要求必须为 dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../dockerfile.php 参数指定某个文件作为 dockerfile。\n\n当然，一般大家习惯性的会使用默认的文件名 dockerfile，以及会将其置于镜像构建上下文目录中。\n\n\n# dockerfile 指令详解\n\n\n# copy 复制文件\n\n格式：\n\n * copy [--chown=<user>:<group>] <源路径>... <目标路径>\n * copy [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]\n\n和 run 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。\n\ncopy 指令将从构建上下文目录中 <源路径> 的文件/目录复制到新的一层的镜像内的 <目标路径> 位置。比如：\n\ncopy package.json /usr/src/app/\n\n\n1\n\n\n<源路径> 可以是多个，甚至可以是通配符，其通配符规则要满足 go 的 filepath.match 规则，如：\n\ncopy hom* /mydir/\ncopy hom?.txt /mydir/\n\n\n1\n2\n\n\n<目标路径> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 workdir 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。\n\n此外，还需要注意一点，使用 copy 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。\n\n如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。\n\n\n# add 更高级的复制文件\n\nadd 指令和 copy 的格式和性质基本一致。\n\n如果 <源路径> 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，add 指令将会自动解压缩这个压缩文件到 <目标路径> 去。\n\n在 docker 官方的 dockerfile 最佳实践文档 中要求，尽可能的使用 copy，因为 copy 的语义很明确，就是复制文件而已，而 add 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 add 的场合，就是所提及的需要自动解压缩的场合。\n\n另外需要注意的是，add 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。\n\n因此在 copy 和 add 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 copy 指令，仅在需要自动解压缩的场合使用 add。\n\n\n# cmd 容器启动命令\n\ncmd 指令用于指定容器主进程的默认启动命令。\n\n类似于 run 指令，用于运行程序，但二者运行的时间点不同:\n\n * cmd 在docker run 时运行。\n * run 是在 docker build。\n\ncmd 指令的格式和 run 相似，也是两种格式：\n\n * shell 格式：cmd <命令>\n * exec 格式：cmd ["可执行文件", "参数1", "参数2"...]\n * 参数列表格式：cmd ["参数1", "参数2"...]。在指定了 entrypoint 指令后，用 cmd 指定具体的参数。\n\n注意：如果 dockerfile 中如果存在多个 cmd 指令，仅最后一个生效。\n\ncmd 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。比如，ubuntu 镜像默认的 cmd 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。\n\n在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 json 数组，因此一定要使用双引号 "，而不要使用单引号。\n\n如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：\n\ncmd echo $home\n\n\n1\n\n\n在实际执行中，会将其变更为：\n\ncmd [ "sh", "-c", "echo $home" ]\n\n\n1\n\n\n这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。\n\n> 提到 cmd 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。\n> \n> docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。\n> \n> 一些初学者将 cmd 写为：\n> \n> cmd service nginx start\n> \n> \n> 1\n> \n> \n> 然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。\n> \n> 对于容器而言，容器就是为了容器内的应用主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。\n> \n> 例如cmd service nginx start 会被理解为 cmd [ "sh", "-c", "service nginx start"]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。\n> \n> 正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：\n> \n> cmd ["nginx", "-g", "daemon off;"]\n> \n> \n> 1\n\n\n# entrypoint 入口点\n\nentrypoint 的格式和 run 指令格式一样，分为 exec 格式和 shell 格式。\n\nentrypoint 的目的和 cmd 一样，都是在指定容器主进程启动命令及参数。entrypoint 在运行时也可以替代，不过比 cmd 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。\n\n当指定了 entrypoint 后，cmd 的含义就发生了改变，不再是直接的运行其命令，而是将 cmd 的内容作为参数传给 entrypoint 指令，换句话说实际执行时，将变为：\n\n<entrypoint> "<cmd>"\n\n\n1\n\n\n那么有了 cmd 后，为什么还要有 entrypoint 呢？这种 <entrypoint> "<cmd>" 有什么好处么？让我们来看下面的场景。\n\n# 场景：让镜像变成像命令一样使用\n\n假设我们需要一个得知自己当前公网 ip 的镜像，那么可以先用 cmd 来实现：\n\nfrom ubuntu:18.04\nrun apt-get update \\\n    && apt-get install -y curl \\\n    && rm -rf /var/lib/apt/lists/*\ncmd [ "curl", "-s", "http://myip.ipip.net" ]\n\n\n1\n2\n3\n4\n5\n\n\n假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 ip，只需要执行：\n\n$ docker run myip\n当前 ip：61.148.226.66 来自：北京市 联通\n\n\n1\n2\n\n\n嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 cmd 中可以看到实质的命令是 curl，那么如果我们希望显示 http 头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？\n\n$ docker run myip -i\ndocker: error response from daemon: invalid header field value "oci runtime error: container_linux.go:247: starting container process caused \\"exec: \\\\\\"-i\\\\\\": executable file not found in $path\\"\\n".\n\n\n1\n2\n\n\n我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 cmd 的默认值。因此这里的 -i 替换了原来的 cmd，而不是添加在原来的 curl -s http://myip.ipip.net 后面。而 -i 根本不是命令，所以自然找不到。\n\n那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：\n\n$ docker run myip curl -s http://myip.ipip.net -i\n\n\n1\n\n\n这显然不是很好的解决方案，而使用 entrypoint 就可以解决这个问题。现在我们重新用 entrypoint 来实现这个镜像：\n\nfrom ubuntu:18.04\nrun apt-get update \\\n    && apt-get install -y curl \\\n    && rm -rf /var/lib/apt/lists/*\nentrypoint [ "curl", "-s", "http://myip.ipip.net" ]\n\n\n1\n2\n3\n4\n5\n\n\n这次我们再来尝试直接使用 docker run myip -i：\n\n$ docker run myip\n当前 ip：61.148.226.66 来自：北京市 联通\n\n$ docker run myip -i\nhttp/1.1 200 ok\nserver: nginx/1.8.0\ndate: tue, 22 nov 2016 05:12:40 gmt\ncontent-type: text/html; charset=utf-8\nvary: accept-encoding\nx-powered-by: php/5.6.24-1~dotdeb+7.1\nx-cache: miss from cache-2\nx-cache-lookup: miss from cache-2:80\nx-cache: miss from proxy-2_6\ntransfer-encoding: chunked\nvia: 1.1 cache-2:80, 1.1 proxy-2_6:8006\nconnection: keep-alive\n\n当前 ip：61.148.226.66 来自：北京市 联通\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n可以看到，这次成功了。这是因为当存在 entrypoint 后，cmd 的内容将会作为参数传给 entrypoint，而这里 -i 就是新的 cmd，因此会作为参数传给 curl，从而达到了我们预期的效果。\n\n总结\n\n>  * dockfile中的 cmd 指令 和 entrypoint 指令 作用一样，都是用于定义容器主进程的启动命令\n>  * dockfile中可以定义多条 cmd 指令 ，仅最后一个生效，entrypoint 指令也一样\n>  * cmd 指令和entrypoint 指令同时存在时，cmd指令指定的命令会被当做entrypoint 指令指定命令的参数，即 <entrypoint> "<cmd>"\n>  * docker run 命令后追加的 command 可以覆盖cmd指令指定的命令（如果不存在cmd 指令就是新定义一个）\n>  * dockker run 命令后追加的 command 也可以覆盖 entrypoint 指令指定的命令，不过要加 --entrypoint选项（如果不存在entrypoint 指令就是新定义一个）\n\n\n# env 设置环境变量\n\n格式有两种：\n\n * env <key> <value>\n * env <key1>=<value1> <key2>=<value2>...\n\n这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 run，还是运行时的应用，都可以直接使用这里定义的环境变量。\n\nenv version=1.0 debug=on \\\n    name="happy feet"\n\n\n1\n2\n\n\n这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 shell 下的行为是一致的。\n\n下列指令可以支持环境变量展开： add、copy、env、expose、from、label、user、workdir、volume、stopsignal、onbuild、run。\n\n通过环境变量，我们可以让一份 dockerfile 制作更多的镜像，只需使用不同的环境变量即可。\n\n\n# arg 构建参数\n\n格式：arg <参数名>[=<默认值>]\n\n构建参数和 env 的效果一样，都是设置环境变量。所不同的是，arg 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 arg 保存密码之类的信息，因为 docker history 还是可以看到所有值的。\n\ndockerfile 中的 arg 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 --build-arg <参数名>=<值> 来覆盖。\n\n灵活的使用 arg 指令，能够在不修改 dockerfile 的情况下，构建出不同的镜像。\n\n\n# volume 定义匿名卷\n\n格式为：\n\n * volume ["<路径1>", "<路径2>"...]\n * volume <路径>\n\n之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。\n\nvolume /data\n\n\n1\n\n\n这里的 /data 目录就会在容器运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：\n\n$ docker run -d -v mydata:/data xxxx\n\n\n1\n\n\n在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 dockerfile 中定义的匿名卷的挂载配置。\n\n\n# expose 暴露端口\n\n格式为 expose <端口1> [<端口2>...]。\n\nexpose 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -p 时，会自动随机映射 expose 的端口。\n\n要将 expose 和在运行时使用 -p <宿主端口>:<容器端口> 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 expose 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。\n\n\n# workdir 指定工作目录\n\n格式为 workdir <工作目录路径>。\n\n使用 workdir 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如果该目录不存在，workdir 会帮你建立目录。\n\n之前提到一些初学者常犯的错误是把 dockerfile 等同于 shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：\n\nrun cd /app\nrun echo "hello" > world.txt\n\n\n1\n2\n\n\n如果将这个 dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。原因其实很简单，在 shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 dockerfile 中，这两行 run 命令的执行环境根本不同，是两个完全不同的容器。这就是对 dockerfile 构建分层存储的概念不了解所导致的错误。\n\n之前说过每一个 run 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 run cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。\n\n因此如果需要改变以后各层的工作目录的位置，那么应该使用 workdir 指令。\n\nworkdir /app\n\nrun echo "hello" > world.txt\n\n\n1\n2\n3\n\n\n\n# user 指定当前用户\n\n格式：user <用户名>[:<用户组>]\n\nuser 指令和 workdir 相似，都是改变环境状态并影响以后的层。workdir 是改变工作目录，user 则是改变之后层的执行 run, cmd 以及 entrypoint 这类命令的身份。\n\n注意，user 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。\n\nrun groupadd -r redis && useradd -r -g redis redis\nuser redis\nrun [ "redis-server" ]\n\n\n1\n2\n3\n\n\n\n# label 为镜像添加元数据\n\nlabel 指令用来给镜像以键值对的形式添加一些元数据（metadata）。\n\nlabel <key>=<value> <key>=<value> <key>=<value> ...\n\n\n1\n\n\n\n# 数据管理\n\n\n\n在容器中管理数据主要有两种方式：\n\n * 数据卷（volumes）\n * 挂载主机目录 (bind mounts)\n\n\n# 数据卷\n\n数据卷（volumes） ：docker在宿主机文件系统默认开辟的一片空间，默认位于 /var/lib/docker/volumes 目录中；\n\n\n\n由上图可以知道，目前所有container的数据都保存在了这个目录下边，由于没有在创建时指定卷，所以docker帮我们默认创建许多匿名（就上面这一堆很长id的名字）卷。\n\n\n# 创建一个数据卷（具名数据卷）\n\n$ docker volume create my-vol\n\n\n1\n\n\n查看所有的 数据卷\n\n$ docker volume ls\n\ndriver              volume name\nlocal               my-vol\n\n\n1\n2\n3\n4\n\n\n在主机里使用以下命令可以查看指定 数据卷 的信息\n\n$ docker volume inspect my-vol\n[\n    {\n        "driver": "local",\n        "labels": {},\n        "mountpoint": "/var/lib/docker/volumes/my-vol/_data",\n        "name": "my-vol",\n        "options": {},\n        "scope": "local"\n    }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 启动一个挂载数据卷的容器\n\n在用 docker run 命令的时候，使用 --mount 标记来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。\n\n下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /usr/share/nginx/html 目录。\n\n$ docker run -d -p \\\n    --name web \\\n    # -v my-vol:/usr/share/nginx/html \\\n    --mount source=my-vol,target=/usr/share/nginx/html \\\n    nginx:alpine\n\n\n1\n2\n3\n4\n5\n\n\n注意：如果挂载数据卷时直接指定容器中目录，不指定挂载数据卷名，那么就会挂在一个匿名数据卷，不管是具名数据卷还是匿名数据卷，默认都位于/var/lib/docker/volume/中\n\n\n# 查看数据卷的具体信息\n\n在主机里使用以下命令可以查看 web 容器的信息\n\n$ docker inspect web\n\n\n1\n\n\n数据卷 信息在 "mounts" key 下面\n\n"mounts": [\n    {\n        "type": "volume",\n        "name": "my-vol",\n        "source": "/var/lib/docker/volumes/my-vol/_data",\n        "destination": "/usr/share/nginx/html",\n        "driver": "local",\n        "mode": "",\n        "rw": true,\n        "propagation": ""\n    }\n],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 删除数据卷\n\n$ docker volume rm my-vol\n\n\n1\n\n\n数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，docker 不会在容器被删除后自动删除 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。\n\n无主的数据卷可能会占据很多空间，要清理请使用以下命令\n\n$ docker volume prune\n\n\n1\n\n\n\n# 挂载主机目录\n\n\n# 挂载一个主机目录作为数据卷\n\n使用 --mount 标记可以指定挂载一个本地主机的目录到容器中去。\n\n$ docker run -d -p \\\n    --name web \\\n    # -v /src/webapp:/usr/share/nginx/html \\\n    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \\\n    nginx:alpine\n\n\n1\n2\n3\n4\n5\n\n\n上面的命令挂载主机的 /src/webapp 目录到容器的 /usr/share/nginx/html目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。\n\n本地目录的路径必须是绝对路径，使用 -v 参数时如果本地目录不存在 docker 会自动为你创建一个文件夹，使用 --mount 参数时如果本地目录不存在，docker 会报错。\n\ndocker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读。\n\n$ docker run -d -p \\\n    --name web \\\n    # -v /src/webapp:/usr/share/nginx/html:ro \\\n    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \\\n    nginx:alpine\n\n\n1\n2\n3\n4\n5\n\n\n加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /usr/share/nginx/html 目录新建文件，会显示如下错误\n\n/usr/share/nginx/html # touch new.txt\ntouch: new.txt: read-only file system\n\n\n1\n2\n\n\n\n# 查看数据卷的具体信息\n\n在主机里使用以下命令可以查看 web 容器的信息\n\n$ docker inspect web\n\n\n1\n\n\n挂载主机目录 的配置信息在 "mounts" key 下面\n\n"mounts": [\n    {\n        "type": "bind",\n        "source": "/src/webapp",\n        "destination": "/usr/share/nginx/html",\n        "mode": "",\n        "rw": true,\n        "propagation": "rprivate"\n    }\n],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Docker 网络模式和容器间通信",frontmatter:{title:"Docker 网络模式和容器间通信",date:"2022-02-03T00:03:52.000Z",permalink:"/pages/8a7664/",categories:["后端","Docker"],tags:[null]},regularPath:"/25.%E8%BF%90%E7%BB%B4/50.Docker/04.Docker%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E4%BF%A1.html",relativePath:"25.运维/50.Docker/04.Docker 网络模式和容器间通信.md",key:"v-25458d2a",path:"/pages/8a7664/",headers:[{level:2,title:"默认网络",slug:"默认网络",normalizedTitle:"默认网络",charIndex:191},{level:3,title:"bridge 网络模式",slug:"bridge-网络模式",normalizedTitle:"bridge 网络模式",charIndex:614},{level:3,title:"host 网络模式",slug:"host-网络模式",normalizedTitle:"host 网络模式",charIndex:1953},{level:3,title:"none 网络模式",slug:"none-网络模式",normalizedTitle:"none 网络模式",charIndex:2425},{level:3,title:"container 网络模式",slug:"container-网络模式",normalizedTitle:"container 网络模式",charIndex:2906},{level:3,title:"link",slug:"link",normalizedTitle:"link",charIndex:3511},{level:2,title:"自定义网络",slug:"自定义网络",normalizedTitle:"自定义网络",charIndex:3716},{level:3,title:"创建网络",slug:"创建网络",normalizedTitle:"创建网络",charIndex:4015},{level:3,title:"连接网络",slug:"连接网络",normalizedTitle:"连接网络",charIndex:4833},{level:3,title:"断开网络",slug:"断开网络",normalizedTitle:"断开网络",charIndex:4996},{level:3,title:"移除网络",slug:"移除网络",normalizedTitle:"移除网络",charIndex:5167},{level:2,title:"容器间网络通信",slug:"容器间网络通信",normalizedTitle:"容器间网络通信",charIndex:5310}],headersStr:"默认网络 bridge 网络模式 host 网络模式 none 网络模式 container 网络模式 link 自定义网络 创建网络 连接网络 断开网络 移除网络 容器间网络通信",content:"当项目大规模使用 Docker 时，容器通信的问题也就产生了。要解决容器通信问题，必须先了解很多关于网络的知识。Docker 作为目前最火的轻量级容器技术，有很多令人称道的功能，如 Docker 的镜像管理。然而，Docker 同样有着很多不完善的地方，网络方面就是 Docker 比较薄弱的部分。因此，我们有必要深入了解 Docker 的网络知识，以满足更高的网络需求。\n\n\n# 默认网络\n\n安装 Docker 以后，会默认创建三种网络，可以通过 docker network ls 查看。\n\n[root@localhost ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n688d1970f72e        bridge              bridge              local\n885da101da7d        host                host                local\nf4f1b3cf1b7f        none                null                local\n\n\n1\n2\n3\n4\n5\n\n\n在学习 Docker 网络之前，我们有必要先来了解一下这几种网络模式都是什么意思。\n\n\n\n\n\n\n# bridge 网络模式\n\n在该模式中，Docker 守护进程创建了一个虚拟以太网桥 docker0，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包。\n\n默认情况下，守护进程会创建一对对等虚拟设备接口 veth pair，将其中一个接口设置为容器的 eth0 接口（容器的网卡），另一个接口放置在宿主机的命名空间中，以类似 vethxxx 这样的名字命名，从而将宿主机上的所有容器都连接到这个内部网络上。\n\n比如我运行一个基于 busybox 镜像构建的容器 bbox01，查看 ip addr：\n\n> busybox 被称为嵌入式 Linux 的瑞士军刀，整合了很多小的 unix 下的通用功能到一个小的可执行文件中。\n\n\n\n然后宿主机通过 ip addr 查看信息如下：\n\n\n\n通过以上的比较可以发现，证实了之前所说的：守护进程会创建一对对等虚拟设备接口 veth pair，将其中一个接口设置为容器的 eth0 接口（容器的网卡），另一个接口放置在宿主机的命名空间中，以类似 vethxxx 这样的名字命名。\n\n同时，守护进程还会从网桥 docker0 的私有地址空间中分配一个 IP 地址和子网给该容器，并设置 docker0 的 IP 地址为容器的默认网关。也可以安装 yum install -y bridge-utils 以后，通过 brctl show 命令查看网桥信息。\n\n\n\n对于每个容器的 IP 地址和 Gateway 信息，我们可以通过 docker inspect 容器名称 | ID 进行查看，在 NetworkSettings 节点中可以看到详细信息。\n\n\n\n我们可以通过 docker network inspect bridge 查看所有 bridge 网络模式下的容器，在 Containers 节点中可以看到容器名称。\n\n\n\n> 关于 bridge 网络模式的使用，只需要在创建容器时通过参数 --net bridge 或者 --network bridge 指定即可，当然这也是创建容器默认使用的网络模式，也就是说这个参数是可以省略的。\n\nBridge 桥接模式的实现步骤主要如下：\n\n * Docker Daemon 利用 veth pair 技术，在宿主机上创建一对对等虚拟网络接口设备，假设为 veth0 和 veth1。而\n\nveth pair 技术的特性可以保证无论哪一个 veth 接收到网络报文，都会将报文传输给另一方。\n\n * Docker Daemon 将 veth0 附加到 Docker Daemon 创建的 docker0 网桥上。保证宿主机的网络报文可以发往 veth0；\n\n * Docker Daemon 将 veth1 添加到 Docker Container 所属的 namespace 下，并被改名为 eth0。如此一来，宿主机的网络报文若发往 veth0，则立即会被 Container 的 eth0 接收，实现宿主机到 Docker Container 网络的联通性；同时，也保证 Docker Container 单独使用 eth0，实现容器网络环境的隔离性。\n\n\n# host 网络模式\n\n * host 网络模式需要在创建容器时通过参数 --net host 或者 --network host 指定；\n\n * 采用 host 网络模式的 Docker Container，可以直接使用宿主机的 IP 地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有 IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换；\n\n * host 网络模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性。\n\n比如我基于 host 网络模式创建了一个基于 busybox 镜像构建的容器 bbox02，查看 ip addr：\n\n\n\n然后宿主机通过 ip addr 查看信息如下：\n\n\n\n对，你没有看错，返回信息一模一样，我也可以肯定我没有截错图，不信接着往下看。我们可以通过 docker network inspect host 查看所有 host 网络模式下的容器，在 Containers 节点中可以看到容器名称。\n\n\n\n\n# none 网络模式\n\n * none 网络模式是指禁用网络功能，只有 lo 接口 local 的简写，代表 127.0.0.1，即 localhost 本地环回接口。在创建容器时通过参数 --net none 或者 --network none 指定；\n\n * none 网络模式即不为 Docker Container 创建任何的网络环境，容器内部就只能使用 loopback 网络设备，不会再有其他的网络资源。可以说 none 模式为 Docke Container 做了极少的网络设定，但是俗话说得好 “少即是多”，在没有网络配置的情况下，作为 Docker 开发者，才能在这基础做其他无限多可能的网络定制开发。这也恰巧体现了 Docker 设计理念的开放。\n\n比如我基于 none 网络模式创建了一个基于 busybox 镜像构建的容器 bbox03，查看 ip addr：\n\n\n\n我们可以通过 docker network inspect none 查看所有 none 网络模式下的容器，在 Containers 节点中可以看到容器名称。\n\n\n\n\n# container 网络模式\n\n * Container 网络模式是 Docker 中一种较为特别的网络的模式。在创建容器时通过参数 --net container: 已运行的容器名称 | ID 或者 --network container: 已运行的容器名称 | ID 指定；\n\n * 处于这个模式下的 Docker 容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。\n\nContainer 网络模式即新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样两个容器除了网络方面相同之外，其他的如文件系统、进程列表等还是隔离的。\n\n比如我基于容器 bbox01 创建了 container 网络模式的容器 bbox04，查看 ip addr：\n\n\n\n容器 bbox01 的 ip addr 信息如下：\n\n\n\n宿主机的 ip addr 信息如下：\n\n\n\n通过以上测试可以发现，Docker 守护进程只创建了一对对等虚拟设备接口用于连接 bbox01 容器和宿主机，而 bbox04 容器则直接使用了 bbox01 容器的网卡信息。\n\n这个时候如果将 bbox01 容器停止，会发现 bbox04 容器就只剩下 lo 接口了。\n\n\n\n然后 bbox01 容器重启以后，bbox04 容器也重启一下，就又可以获取到网卡信息了。\n\n\n\n\n# link\n\ndocker run --link 可以用来链接两个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量。\n\n这种方式官方已不推荐使用，并且在未来版本可能会被移除，所以这里不作为重点讲解，感兴趣可自行了解。\n\n官网警告信息：https://docs.docker.com/network/links/\n\n\n\n\n# 自定义网络\n\n虽然 Docker 提供的默认网络使用比较简单，但是为了保证各容器中应用的安全性，在实际开发中更推荐使用自定义的网络进行容器管理，以及启用容器名称到 IP 地址的自动 DNS 解析。\n\n> 从 Docker 1.10 版本开始，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过容器名称通信。方法很简单，只要在创建容器时使用 --name 为容器命名即可。\n\n> 但是使用 Docker DNS 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的，所以我们就需要自定义网络。\n\n\n# 创建网络\n\n通过 docker network create 命令可以创建自定义网络模式，命令提示如下：\n\n\n\n进一步查看 docker network create 命令使用详情，发现可以通过 --driver 指定网络模式且默认是 bridge 网络模式，提示如下：\n\n\n\n创建一个基于 bridge 网络模式的自定义网络模式 custom_network，完整命令如下：\n\ndocker network create custom_network\n\n\n1\n\n\n通过 docker network ls 查看网络模式：\n\n[root@localhost ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\nb3634bbd8943        bridge              bridge              local\n062082493d3a        custom_network      bridge              local\n885da101da7d        host                host                local\nf4f1b3cf1b7f        none                null                local\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过自定义网络模式 custom_network 创建容器：\n\ndocker run -di --name bbox05 --net custom_network busybox\n\n\n1\n\n\n通过 docker inspect 容器名称 | ID 查看容器的网络信息，在 NetworkSettings 节点中可以看到详细信息。\n\n\n\n\n# 连接网络\n\n通过 docker network connect 网络名称 容器名称 为容器连接新的网络模式。\n\n\n\ndocker network connect bridge bbox05\n\n\n1\n\n\n通过 docker inspect 容器名称 | ID 再次查看容器的网络信息，多增加了默认的 bridge。\n\n\n\n\n# 断开网络\n\n通过 docker network disconnect 网络名称 容器名称 命令断开网络。\n\ndocker network disconnect custom_network bbox05\n\n\n1\n\n\n通过 docker inspect 容器名称 | ID 再次查看容器的网络信息，发现只剩下默认的 bridge。\n\n\n\n\n# 移除网络\n\n可以通过 docker network rm 网络名称 命令移除自定义网络模式，网络模式移除成功会返回网络模式名称。\n\ndocker network rm custom_network\n\n\n1\n\n\n注意：如果通过某个自定义网络模式创建了容器，则该网络模式无法删除。\n\n\n# 容器间网络通信\n\n接下来我们通过所学的知识实现容器间的网络通信。首先明确一点，容器之间要互相通信，必须要有属于同一个网络的网卡。\n\n我们先创建两个基于默认的 bridge 网络模式的容器。\n\ndocker run -di --name default_bbox01 busybox\n\n\n1\n\n\n通过 docker network inspect bridge 查看两容器的具体 IP 信息。\n\n\n\n然后测试两容器间是否可以进行网络通信。\n\n\n\n经过测试，从结果得知两个属于同一个网络的容器是可以进行网络通信的，但是 IP 地址可能是不固定的，有被更改的情况发生，那容器内所有通信的 IP 地址也需要进行更改，能否使用容器名称进行网络通信？继续测试。\n\n\n\n经过测试，从结果得知使用容器进行网络通信是不行的，那怎么实现这个功能呢？\n\n从 Docker 1.10 版本开始，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过容器名称通信。方法很简单，只要在创建容器时使用 --name 为容器命名即可。\n\n但是使用 Docker DNS 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的，所以我们就需要自定义网络。\n\n我们先基于 bridge 网络模式创建自定义网络 custom_network，然后创建两个基于自定义网络模式的容器。\n\ndocker run -di --name custom_bbox01 --net custom_network busybox\n\n\n1\n\n\n通过 docker network inspect custom_network 查看两容器的具体 IP 信息。\n\n\n\n然后测试两容器间是否可以进行网络通信，分别使用具体 IP 和容器名称进行网络通信。\n\n\n\n经过测试，从结果得知两个属于同一个自定义网络的容器是可以进行网络通信的，并且可以使用容器名称进行网络通信。\n\n那如果此时我希望 bridge 网络下的容器可以和 custom_network 网络下的容器进行网络又该如何操作？其实答案也非常简单：让 bridge 网络下的容器连接至新的 custom_network 网络即可。\n\ndocker network connect custom_network default_bbox01\n\n\n1\n\n\n\n\n学完容器网络通信，大家就可以练习使用多个容器完成常见应用集群的部署了。后面就该学习 Docker 进阶部分的内容 Docker Compose 和 Docker Swarm。\n\n参考：",normalizedContent:"当项目大规模使用 docker 时，容器通信的问题也就产生了。要解决容器通信问题，必须先了解很多关于网络的知识。docker 作为目前最火的轻量级容器技术，有很多令人称道的功能，如 docker 的镜像管理。然而，docker 同样有着很多不完善的地方，网络方面就是 docker 比较薄弱的部分。因此，我们有必要深入了解 docker 的网络知识，以满足更高的网络需求。\n\n\n# 默认网络\n\n安装 docker 以后，会默认创建三种网络，可以通过 docker network ls 查看。\n\n[root@localhost ~]# docker network ls\nnetwork id          name                driver              scope\n688d1970f72e        bridge              bridge              local\n885da101da7d        host                host                local\nf4f1b3cf1b7f        none                null                local\n\n\n1\n2\n3\n4\n5\n\n\n在学习 docker 网络之前，我们有必要先来了解一下这几种网络模式都是什么意思。\n\n\n\n\n\n\n# bridge 网络模式\n\n在该模式中，docker 守护进程创建了一个虚拟以太网桥 docker0，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包。\n\n默认情况下，守护进程会创建一对对等虚拟设备接口 veth pair，将其中一个接口设置为容器的 eth0 接口（容器的网卡），另一个接口放置在宿主机的命名空间中，以类似 vethxxx 这样的名字命名，从而将宿主机上的所有容器都连接到这个内部网络上。\n\n比如我运行一个基于 busybox 镜像构建的容器 bbox01，查看 ip addr：\n\n> busybox 被称为嵌入式 linux 的瑞士军刀，整合了很多小的 unix 下的通用功能到一个小的可执行文件中。\n\n\n\n然后宿主机通过 ip addr 查看信息如下：\n\n\n\n通过以上的比较可以发现，证实了之前所说的：守护进程会创建一对对等虚拟设备接口 veth pair，将其中一个接口设置为容器的 eth0 接口（容器的网卡），另一个接口放置在宿主机的命名空间中，以类似 vethxxx 这样的名字命名。\n\n同时，守护进程还会从网桥 docker0 的私有地址空间中分配一个 ip 地址和子网给该容器，并设置 docker0 的 ip 地址为容器的默认网关。也可以安装 yum install -y bridge-utils 以后，通过 brctl show 命令查看网桥信息。\n\n\n\n对于每个容器的 ip 地址和 gateway 信息，我们可以通过 docker inspect 容器名称 | id 进行查看，在 networksettings 节点中可以看到详细信息。\n\n\n\n我们可以通过 docker network inspect bridge 查看所有 bridge 网络模式下的容器，在 containers 节点中可以看到容器名称。\n\n\n\n> 关于 bridge 网络模式的使用，只需要在创建容器时通过参数 --net bridge 或者 --network bridge 指定即可，当然这也是创建容器默认使用的网络模式，也就是说这个参数是可以省略的。\n\nbridge 桥接模式的实现步骤主要如下：\n\n * docker daemon 利用 veth pair 技术，在宿主机上创建一对对等虚拟网络接口设备，假设为 veth0 和 veth1。而\n\nveth pair 技术的特性可以保证无论哪一个 veth 接收到网络报文，都会将报文传输给另一方。\n\n * docker daemon 将 veth0 附加到 docker daemon 创建的 docker0 网桥上。保证宿主机的网络报文可以发往 veth0；\n\n * docker daemon 将 veth1 添加到 docker container 所属的 namespace 下，并被改名为 eth0。如此一来，宿主机的网络报文若发往 veth0，则立即会被 container 的 eth0 接收，实现宿主机到 docker container 网络的联通性；同时，也保证 docker container 单独使用 eth0，实现容器网络环境的隔离性。\n\n\n# host 网络模式\n\n * host 网络模式需要在创建容器时通过参数 --net host 或者 --network host 指定；\n\n * 采用 host 网络模式的 docker container，可以直接使用宿主机的 ip 地址与外界进行通信，若宿主机的 eth0 是一个公有 ip，那么容器也拥有这个公有 ip。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 nat 转换；\n\n * host 网络模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性。\n\n比如我基于 host 网络模式创建了一个基于 busybox 镜像构建的容器 bbox02，查看 ip addr：\n\n\n\n然后宿主机通过 ip addr 查看信息如下：\n\n\n\n对，你没有看错，返回信息一模一样，我也可以肯定我没有截错图，不信接着往下看。我们可以通过 docker network inspect host 查看所有 host 网络模式下的容器，在 containers 节点中可以看到容器名称。\n\n\n\n\n# none 网络模式\n\n * none 网络模式是指禁用网络功能，只有 lo 接口 local 的简写，代表 127.0.0.1，即 localhost 本地环回接口。在创建容器时通过参数 --net none 或者 --network none 指定；\n\n * none 网络模式即不为 docker container 创建任何的网络环境，容器内部就只能使用 loopback 网络设备，不会再有其他的网络资源。可以说 none 模式为 docke container 做了极少的网络设定，但是俗话说得好 “少即是多”，在没有网络配置的情况下，作为 docker 开发者，才能在这基础做其他无限多可能的网络定制开发。这也恰巧体现了 docker 设计理念的开放。\n\n比如我基于 none 网络模式创建了一个基于 busybox 镜像构建的容器 bbox03，查看 ip addr：\n\n\n\n我们可以通过 docker network inspect none 查看所有 none 网络模式下的容器，在 containers 节点中可以看到容器名称。\n\n\n\n\n# container 网络模式\n\n * container 网络模式是 docker 中一种较为特别的网络的模式。在创建容器时通过参数 --net container: 已运行的容器名称 | id 或者 --network container: 已运行的容器名称 | id 指定；\n\n * 处于这个模式下的 docker 容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。\n\ncontainer 网络模式即新创建的容器不会创建自己的网卡，配置自己的 ip，而是和一个指定的容器共享 ip、端口范围等。同样两个容器除了网络方面相同之外，其他的如文件系统、进程列表等还是隔离的。\n\n比如我基于容器 bbox01 创建了 container 网络模式的容器 bbox04，查看 ip addr：\n\n\n\n容器 bbox01 的 ip addr 信息如下：\n\n\n\n宿主机的 ip addr 信息如下：\n\n\n\n通过以上测试可以发现，docker 守护进程只创建了一对对等虚拟设备接口用于连接 bbox01 容器和宿主机，而 bbox04 容器则直接使用了 bbox01 容器的网卡信息。\n\n这个时候如果将 bbox01 容器停止，会发现 bbox04 容器就只剩下 lo 接口了。\n\n\n\n然后 bbox01 容器重启以后，bbox04 容器也重启一下，就又可以获取到网卡信息了。\n\n\n\n\n# link\n\ndocker run --link 可以用来链接两个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量。\n\n这种方式官方已不推荐使用，并且在未来版本可能会被移除，所以这里不作为重点讲解，感兴趣可自行了解。\n\n官网警告信息：https://docs.docker.com/network/links/\n\n\n\n\n# 自定义网络\n\n虽然 docker 提供的默认网络使用比较简单，但是为了保证各容器中应用的安全性，在实际开发中更推荐使用自定义的网络进行容器管理，以及启用容器名称到 ip 地址的自动 dns 解析。\n\n> 从 docker 1.10 版本开始，docker daemon 实现了一个内嵌的 dns server，使容器可以直接通过容器名称通信。方法很简单，只要在创建容器时使用 --name 为容器命名即可。\n\n> 但是使用 docker dns 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 dns 的，所以我们就需要自定义网络。\n\n\n# 创建网络\n\n通过 docker network create 命令可以创建自定义网络模式，命令提示如下：\n\n\n\n进一步查看 docker network create 命令使用详情，发现可以通过 --driver 指定网络模式且默认是 bridge 网络模式，提示如下：\n\n\n\n创建一个基于 bridge 网络模式的自定义网络模式 custom_network，完整命令如下：\n\ndocker network create custom_network\n\n\n1\n\n\n通过 docker network ls 查看网络模式：\n\n[root@localhost ~]# docker network ls\nnetwork id          name                driver              scope\nb3634bbd8943        bridge              bridge              local\n062082493d3a        custom_network      bridge              local\n885da101da7d        host                host                local\nf4f1b3cf1b7f        none                null                local\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过自定义网络模式 custom_network 创建容器：\n\ndocker run -di --name bbox05 --net custom_network busybox\n\n\n1\n\n\n通过 docker inspect 容器名称 | id 查看容器的网络信息，在 networksettings 节点中可以看到详细信息。\n\n\n\n\n# 连接网络\n\n通过 docker network connect 网络名称 容器名称 为容器连接新的网络模式。\n\n\n\ndocker network connect bridge bbox05\n\n\n1\n\n\n通过 docker inspect 容器名称 | id 再次查看容器的网络信息，多增加了默认的 bridge。\n\n\n\n\n# 断开网络\n\n通过 docker network disconnect 网络名称 容器名称 命令断开网络。\n\ndocker network disconnect custom_network bbox05\n\n\n1\n\n\n通过 docker inspect 容器名称 | id 再次查看容器的网络信息，发现只剩下默认的 bridge。\n\n\n\n\n# 移除网络\n\n可以通过 docker network rm 网络名称 命令移除自定义网络模式，网络模式移除成功会返回网络模式名称。\n\ndocker network rm custom_network\n\n\n1\n\n\n注意：如果通过某个自定义网络模式创建了容器，则该网络模式无法删除。\n\n\n# 容器间网络通信\n\n接下来我们通过所学的知识实现容器间的网络通信。首先明确一点，容器之间要互相通信，必须要有属于同一个网络的网卡。\n\n我们先创建两个基于默认的 bridge 网络模式的容器。\n\ndocker run -di --name default_bbox01 busybox\n\n\n1\n\n\n通过 docker network inspect bridge 查看两容器的具体 ip 信息。\n\n\n\n然后测试两容器间是否可以进行网络通信。\n\n\n\n经过测试，从结果得知两个属于同一个网络的容器是可以进行网络通信的，但是 ip 地址可能是不固定的，有被更改的情况发生，那容器内所有通信的 ip 地址也需要进行更改，能否使用容器名称进行网络通信？继续测试。\n\n\n\n经过测试，从结果得知使用容器进行网络通信是不行的，那怎么实现这个功能呢？\n\n从 docker 1.10 版本开始，docker daemon 实现了一个内嵌的 dns server，使容器可以直接通过容器名称通信。方法很简单，只要在创建容器时使用 --name 为容器命名即可。\n\n但是使用 docker dns 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 dns 的，所以我们就需要自定义网络。\n\n我们先基于 bridge 网络模式创建自定义网络 custom_network，然后创建两个基于自定义网络模式的容器。\n\ndocker run -di --name custom_bbox01 --net custom_network busybox\n\n\n1\n\n\n通过 docker network inspect custom_network 查看两容器的具体 ip 信息。\n\n\n\n然后测试两容器间是否可以进行网络通信，分别使用具体 ip 和容器名称进行网络通信。\n\n\n\n经过测试，从结果得知两个属于同一个自定义网络的容器是可以进行网络通信的，并且可以使用容器名称进行网络通信。\n\n那如果此时我希望 bridge 网络下的容器可以和 custom_network 网络下的容器进行网络又该如何操作？其实答案也非常简单：让 bridge 网络下的容器连接至新的 custom_network 网络即可。\n\ndocker network connect custom_network default_bbox01\n\n\n1\n\n\n\n\n学完容器网络通信，大家就可以练习使用多个容器完成常见应用集群的部署了。后面就该学习 docker 进阶部分的内容 docker compose 和 docker swarm。\n\n参考：",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Docker 搭建 Redis Cluster 集群",frontmatter:{title:"Docker 搭建 Redis Cluster 集群",date:"2022-02-03T00:03:52.000Z",permalink:"/pages/457953/",categories:["后端","Docker"],tags:[null]},regularPath:"/25.%E8%BF%90%E7%BB%B4/50.Docker/05.Docker%20%E6%90%AD%E5%BB%BA%20Redis%20Cluster%20%E9%9B%86%E7%BE%A4.html",relativePath:"25.运维/50.Docker/05.Docker 搭建 Redis Cluster 集群.md",key:"v-dc7c1222",path:"/pages/457953/",headers:[{level:2,title:"环境",slug:"环境",normalizedTitle:"环境",charIndex:120},{level:2,title:"搭建",slug:"搭建",normalizedTitle:"搭建",charIndex:10},{level:3,title:"编写 Redis 配置文件",slug:"编写-redis-配置文件",normalizedTitle:"编写 redis 配置文件",charIndex:698},{level:3,title:"创建 Redis 容器",slug:"创建-redis-容器",normalizedTitle:"创建 redis 容器",charIndex:717},{level:3,title:"创建 Redis Cluster 集群",slug:"创建-redis-cluster-集群",normalizedTitle:"创建 redis cluster 集群",charIndex:734},{level:2,title:"查看集群状态",slug:"查看集群状态",normalizedTitle:"查看集群状态",charIndex:9546},{level:3,title:"检查集群状态",slug:"检查集群状态",normalizedTitle:"检查集群状态",charIndex:9670},{level:3,title:"查看集群信息和节点信息",slug:"查看集群信息和节点信息",normalizedTitle:"查看集群信息和节点信息",charIndex:9742},{level:3,title:"SET/GET",slug:"set-get",normalizedTitle:"set/get",charIndex:9881},{level:2,title:"客户端连接",slug:"客户端连接",normalizedTitle:"客户端连接",charIndex:10847}],headersStr:"环境 搭建 编写 Redis 配置文件 创建 Redis 容器 创建 Redis Cluster 集群 查看集群状态 检查集群状态 查看集群信息和节点信息 SET/GET 客户端连接",content:"使用 Docker 搭建 Redis Cluster，最重要的环节就是容器通信的问题，这一块我们在之前的文章中已经给大家解决了《Docker 网络模式详解及容器间网络通信》，本篇文章主要练习使用多个容器完成 Redis Cluster 集群环境的搭建，顺便为学习 Docker Compose 铺铺路。俗话说没有对比就没有伤害，通过对比才能感受到 Docker Compose 的好处 😄。\n\n关于 Redis Cluster 集群更多的内容请阅读《最通俗易懂的 Redis 架构模式详解》。\n\n按照 Redis 官网：https://redis.io/topics/cluster-tutorial 的提示，为了使 Docker 与 Redis Cluster 兼容，您需要使用 Docker 的 host 网络模式。\n\nhost 网络模式需要在创建容器时通过参数 --net host 或者 --network host 指定，host 网络模式可以让容器共享宿主机网络栈，容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。\n\n\n\n\n# 环境\n\n为了让环境更加真实，本文使用多机环境：\n\n * 192.168.10.10\n\n * 192.168.10.11\n\n每台机器所使用的基础设施环境如下：\n\n * CentOS 7.8.2003\n\n * Docker version 19.03.12\n\n\n\n\n# 搭建\n\n整体搭建步骤主要分为以下几步：\n\n * 下载 Redis 镜像（其实这步可以省略，因为创建容器时，如果本地镜像不存在，就会去远程拉取）；\n\n * 编写 Redis 配置文件；\n\n * 创建 Redis 容器；\n\n * 创建 Redis Cluster 集群。\n\n\n# 编写 Redis 配置文件\n\n# 创建目录及文件\n\n分别在 192.168.10.10 和 192.168.10.11 两台机器上执行以下操作。\n\n# 创建目录\nmkdir -p /usr/local/docker-redis/redis-cluster\n# 切换至指定目录\ncd /usr/local/docker-redis/redis-cluster/\n# 编写 redis-cluster.tmpl 文件\nvi redis-cluster.tmpl\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 编写配置文件\n\n192.168.10.10 机器的 redis-cluster.tmpl 文件内容如下：\n\nport ${PORT}\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.10\ncluster-announce-port ${PORT}\ncluster-announce-bus-port 1${PORT}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n192.168.10.11 机器的 redis-cluster.tmpl 文件内容如下：\n\nport ${PORT}\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.10\ncluster-announce-port ${PORT}\ncluster-announce-bus-port 1${PORT}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n * port：节点端口；\n\n * requirepass：添加访问认证；\n\n * masterauth：如果主节点开启了访问认证，从节点访问主节点需要认证；\n\n * protected-mode：保护模式，默认值 yes，即开启。开启保护模式以后，需配置 bind ip 或者设置访问密码；关闭保护模式，外部网络可以直接访问；\n\n * daemonize：是否以守护线程的方式启动（后台启动），默认 no；\n\n * appendonly：是否开启 AOF 持久化模式，默认 no；\n\n * cluster-enabled：是否开启集群模式，默认 no；\n\n * cluster-config-file：集群节点信息文件；\n\n * cluster-node-timeout：集群节点连接超时时间；\n\n * cluster-announce-ip：集群节点 IP，填写宿主机的 IP；\n\n * cluster-announce-port：集群节点映射端口；\n\n * cluster-announce-bus-port：集群节点总线端口。\n\n> 每个 Redis 集群节点都需要打开两个 TCP 连接。一个用于为客户端提供服务的正常 Redis TCP 端口，例如 6379。还有一个基于 6379 端口加 10000 的端口，比如 16379。\n\n> 第二个端口用于集群总线，这是一个使用二进制协议的节点到节点通信通道。节点使用集群总线进行故障检测、配置更新、故障转移授权等等。客户端永远不要尝试与集群总线端口通信，与正常的 Redis 命令端口通信即可，但是请确保防火墙中的这两个端口都已经打开，否则 Redis 集群节点将无法通信。\n\n在 192.168.10.10 机器的 redis-cluster 目录下执行以下命令：\n\nfor port in `seq 6371 6373`; do \\\n  mkdir -p ${port}/conf \\\n  && PORT=${port} envsubst < redis-cluster.tmpl > ${port}/conf/redis.conf \\\n  && mkdir -p ${port}/data;\\\ndone\n\n\n1\n2\n3\n4\n5\n\n\n在 192.168.10.11 机器的 redis-cluster 目录下执行以下命令：\n\nfor port in `seq 6374 6376`; do \\\n  mkdir -p ${port}/conf \\\n  && PORT=${port} envsubst < redis-cluster.tmpl > ${port}/conf/redis.conf \\\n  && mkdir -p ${port}/data;\\\ndone\n\n\n1\n2\n3\n4\n5\n\n\n上面两段 shell for 语句，意思就是循环创建 6371 ~ 6376 相关的目录及文件。\n\n在 192.168.10.10 机器执行查看命令结果如下，如果没有 tree 命令先安装 yum install -y tree。\n\n\n\n在 192.168.10.11 机器执行查看命令结果如下。\n\n\n\n以下内容为每个节点的配置文件详细信息。\n\n============================== 192.168.10.10 ==============================\n[root@localhost redis-cluster]# cat /usr/local/docker-redis/redis-cluster/637{1..3}/conf/redis.conf\nport 6371\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.10\ncluster-announce-port 6371\ncluster-announce-bus-port 16371\n\nport 6372\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.10\ncluster-announce-port 6372\ncluster-announce-bus-port 16372\n\nport 6373\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.10\ncluster-announce-port 6373\ncluster-announce-bus-port 16373\n============================== 192.168.10.10 ==============================\n\n============================== 192.168.10.11 ==============================\n[root@localhost redis-cluster]# cat /usr/local/docker-redis/redis-cluster/637{4..6}/conf/redis.conf\nport 6374\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.11\ncluster-announce-port 6374\ncluster-announce-bus-port 16374\n\nport 6375\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.11\ncluster-announce-port 6375\ncluster-announce-bus-port 16375\n\nport 6376\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.11\ncluster-announce-port 6376\ncluster-announce-bus-port 16376\n============================== 192.168.10.11 ==============================\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n\n\n# 创建 Redis 容器\n\n# 创建容器\n\n将宿主机的 6371 ~ 6376 之间的端口与 6 个 Redis 容器映射，并将宿主机的目录与容器内的目录进行映射（目录挂载）。记得指定网络模式，使用 host 网络模式。\n\n在 192.168.10.10 机器执行以下命令：\n\nfor port in $(seq 6371 6373); do \\\n  docker run -di --restart always --name redis-${port} --net host \\\n  -v /usr/local/docker-redis/redis-cluster/${port}/conf/redis.conf:/usr/local/etc/redis/redis.conf \\\n  -v /usr/local/docker-redis/redis-cluster/${port}/data:/data \\\n  redis redis-server /usr/local/etc/redis/redis.conf; \\\ndone\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 192.168.10.11 机器执行以下命令：\n\nfor port in $(seq 6374 6376); do \\\n  docker run -di --restart always --name redis-${port} --net host \\\n  -v /usr/local/docker-redis/redis-cluster/${port}/conf/redis.conf:/usr/local/etc/redis/redis.conf \\\n  -v /usr/local/docker-redis/redis-cluster/${port}/data:/data \\\n  redis redis-server /usr/local/etc/redis/redis.conf; \\\ndone\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 192.168.10.10 机器执行 docker ps -n 3 查看容器是否创建成功。\n\n\n\n在 192.168.10.11 机器执行 docker ps -n 3 查看容器是否创建成功。\n\n\n\n\n# 创建 Redis Cluster 集群\n\n随便进入一个容器节点，并进入 /usr/local/bin/ 目录：\n\n# 进入容器\ndocker exec -it redis-6371 bash\n# 切换至指定目录\ncd /usr/local/bin/\n\n\n1\n2\n3\n4\n\n\n接下来我们就可以通过以下命令实现 Redis Cluster 集群的创建。\n\nredis-cli -a 1234 --cluster create 192.168.10.10:6371 192.168.10.10:6372 192.168.10.10:6373 192.168.10.11:6374 192.168.10.11:6375 192.168.10.11:6376 --cluster-replicas 1\n\n\n1\n\n\n出现选择提示信息，输入 yes，结果如下所示：\n\n\n\n集群创建成功如下：\n\n\n\n以下内容是创建集群时返回的详细信息，也就是上两幅图中的所有内容。\n\nroot@localhost:/usr/local/bin# redis-cli -a 1234 --cluster create 192.168.10.10:6371 192.168.10.10:6372 192.168.10.10:6373 192.168.10.11:6374 192.168.10.11:6375 192.168.10.11:6376 --cluster-replicas 1\nWarning: Using a password with '-a' or '-u' option on the command line interface may not be safe.\n>>> Performing hash slots allocation on 6 nodes...\nMaster[0] -> Slots 0 - 5460\nMaster[1] -> Slots 5461 - 10922\nMaster[2] -> Slots 10923 - 16383\nAdding replica 192.168.10.11:6376 to 192.168.10.10:6371\nAdding replica 192.168.10.10:6373 to 192.168.10.11:6374\nAdding replica 192.168.10.11:6375 to 192.168.10.10:6372\nM: 299cf79ddafc83dced27f628f1f82dac483fbc4e 192.168.10.10:6371\n   slots:[0-5460] (5461 slots) master\nM: ac805b90b6e20e26dc4268454bb2855beea6cc19 192.168.10.10:6372\n   slots:[10923-16383] (5461 slots) master\nS: db35494fcc5db0c88d27da7885c817e6cdcc9373 192.168.10.10:6373\n   replicates 7013270480d37eeab79b9cd0272e934d4548136a\nM: 7013270480d37eeab79b9cd0272e934d4548136a 192.168.10.11:6374\n   slots:[5461-10922] (5462 slots) master\nS: 8435e1b0d51f2690c5f94f9a5682a4ac34e94326 192.168.10.11:6375\n   replicates ac805b90b6e20e26dc4268454bb2855beea6cc19\nS: 7b13c16fa6fe8e13cdc0b4846b87edffed55c62e 192.168.10.11:6376\n   replicates 299cf79ddafc83dced27f628f1f82dac483fbc4e\nCan I set the above configuration? (type 'yes' to accept): yes\n>>> Nodes configuration updated\n>>> Assign a different config epoch to each node\n>>> Sending CLUSTER MEET messages to join the cluster\nWaiting for the cluster to join\n.\n>>> Performing Cluster Check (using node 192.168.10.10:6371)\nM: 299cf79ddafc83dced27f628f1f82dac483fbc4e 192.168.10.10:6371\n   slots:[0-5460] (5461 slots) master\n   1 additional replica(s)\nS: 8435e1b0d51f2690c5f94f9a5682a4ac34e94326 192.168.10.11:6375\n   slots: (0 slots) slave\n   replicates ac805b90b6e20e26dc4268454bb2855beea6cc19\nS: db35494fcc5db0c88d27da7885c817e6cdcc9373 192.168.10.10:6373\n   slots: (0 slots) slave\n   replicates 7013270480d37eeab79b9cd0272e934d4548136a\nS: 7b13c16fa6fe8e13cdc0b4846b87edffed55c62e 192.168.10.11:6376\n   slots: (0 slots) slave\n   replicates 299cf79ddafc83dced27f628f1f82dac483fbc4e\nM: 7013270480d37eeab79b9cd0272e934d4548136a 192.168.10.11:6374\n   slots:[5461-10922] (5462 slots) master\n   1 additional replica(s)\nM: ac805b90b6e20e26dc4268454bb2855beea6cc19 192.168.10.10:6372\n   slots:[10923-16383] (5461 slots) master\n   1 additional replica(s)\n[OK] All nodes agree about slots configuration.\n>>> Check for open slots...\n>>> Check slots coverage...\n[OK] All 16384 slots covered.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n至此一个高可用的 Redis Cluster 集群搭建完成，如下图所示，该集群中包含 6 个 Redis 节点，3 主 3 从。三个主节点会分配槽，处理客户端的命令请求，而从节点可用在主节点故障后，顶替主节点。\n\n\n\n\n# 查看集群状态\n\n我们先进入容器，然后通过一些集群常用的命令查看一下集群的状态。\n\n# 进入容器\ndocker exec -it redis-6371 bash\n# 切换至指定目录\ncd /usr/local/bin/\n\n\n1\n2\n3\n4\n\n\n\n# 检查集群状态\n\nredis-cli -a 1234 --cluster check 192.168.10.11:6375\n\n\n1\n\n\n\n\n\n# 查看集群信息和节点信息\n\n# 连接至集群某个节点\nredis-cli -c -a 1234 -h 192.168.10.11 -p 6376\n# 查看集群信息\ncluster info\n# 查看集群结点信息\ncluster nodes\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n# SET/GET\n\n在 6371 节点中执行写入和读取，命令如下：\n\n# 进入容器并连接至集群某个节点\ndocker exec -it redis-6371 /usr/local/bin/redis-cli -c -a 1234 -h 192.168.10.10 -p 6371\n# 写入数据\nset name mrhelloworld\nset aaa 111\nset bbb 222\n# 读取数据\nget name\nget aaa\nget bbb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n别着急，让我来解释一下上图中的操作过程：\n\n * 首先进入容器并连接至集群某个节点；\n\n * 然后执行第一个 set 命令 set name mrhelloworld，name 键根据哈希函数运算以后得到的值为 [5798]。当前集群环境的槽分配情况为：[0-5460] 6371 节点，[5461-10922] 6374 节点，[10923-16383] 6372 节点，所以该键的存储就被分配到了 6374 节点上；\n\n * 再来看第二个 set 命令 set aaa，这里大家可能会有一些疑问，为什么看不到 aaa 键根据哈希函数运算以后得到的值？因为刚才重定向至 6374 节点插入了数据，此时如果还有数据插入，正好键根据哈希函数运算以后得到的值也还在该节点的范围内，那么直接插入数据即可；\n\n * 接着是第三个 set 命令 set bbb，bbb 键根据哈希函数运算以后得到的值为 [5287]，所以该键的存储就被分配到了 6371 节点上；\n\n * 然后是读取操作，第四个命令 get name，name 键根据哈希函数运算以后得到的值为 [5798]，被重定向至 6374 节点读取；\n\n * 第五个命令 get aaa，aaa 键根据哈希函数运算以后得到的值也在 6374 节点，直接读取；\n\n * 第六个命令 get bbb，bbb 键根据哈希函数运算以后得到的值为 [5287]，被重定向至 6371 节点读取。\n\n通过以上操作我们得知 name 键的存储被分配到了 6374 节点，如果直接连接 6374 节点并获取该值会怎么样？没错，不需要重定向节点，因为数据就在该节点，所以直接读取返回。\n\n\n\n\n# 客户端连接\n\n最后来一波客户端连接操作，随便哪个节点，看看可否通过外部访问 Redis Cluster 集群。\n\n\n\n\n\n至此使用多机环境多个容器搭建 Redis Cluster 集群环境就到这里，其实整体搭建过程不算特别麻烦，因为：\n\n * 创建 Redis 集群需要用到 Ruby，否则就得自己关联节点构建集群，自己分配槽；\n\n * 如果使用 Ruby 构建 Redis 集群，就需要安装 Ruby 环境；\n\n * 而 Redis 从 5 版本开始可以直接使用 redis-cli 命令创建集群了，就省去了很多麻烦事；\n\n * 我们还使用了 shell for 循环语句简化了构建过程，否则那些语句一条条执行也够你闹心的。\n\n综上所述，有没有更简单的办法呢？当然有了，不然我在这跟你卖什么关子。\n\n\n\nDocker Compose 就可以解决这个问题。后面我们先学习一下什么是 Docker Compose，然后使用 Docker Compose 再来搭建一遍 Redis Cluster 集群环境，感受感受这前后的区别。\n\n[]: https://xie.infoq.cn/article/a5536b928edd12beb32fcabf9",normalizedContent:"使用 docker 搭建 redis cluster，最重要的环节就是容器通信的问题，这一块我们在之前的文章中已经给大家解决了《docker 网络模式详解及容器间网络通信》，本篇文章主要练习使用多个容器完成 redis cluster 集群环境的搭建，顺便为学习 docker compose 铺铺路。俗话说没有对比就没有伤害，通过对比才能感受到 docker compose 的好处 😄。\n\n关于 redis cluster 集群更多的内容请阅读《最通俗易懂的 redis 架构模式详解》。\n\n按照 redis 官网：https://redis.io/topics/cluster-tutorial 的提示，为了使 docker 与 redis cluster 兼容，您需要使用 docker 的 host 网络模式。\n\nhost 网络模式需要在创建容器时通过参数 --net host 或者 --network host 指定，host 网络模式可以让容器共享宿主机网络栈，容器将不会虚拟出自己的网卡，配置自己的 ip 等，而是使用宿主机的 ip 和端口。\n\n\n\n\n# 环境\n\n为了让环境更加真实，本文使用多机环境：\n\n * 192.168.10.10\n\n * 192.168.10.11\n\n每台机器所使用的基础设施环境如下：\n\n * centos 7.8.2003\n\n * docker version 19.03.12\n\n\n\n\n# 搭建\n\n整体搭建步骤主要分为以下几步：\n\n * 下载 redis 镜像（其实这步可以省略，因为创建容器时，如果本地镜像不存在，就会去远程拉取）；\n\n * 编写 redis 配置文件；\n\n * 创建 redis 容器；\n\n * 创建 redis cluster 集群。\n\n\n# 编写 redis 配置文件\n\n# 创建目录及文件\n\n分别在 192.168.10.10 和 192.168.10.11 两台机器上执行以下操作。\n\n# 创建目录\nmkdir -p /usr/local/docker-redis/redis-cluster\n# 切换至指定目录\ncd /usr/local/docker-redis/redis-cluster/\n# 编写 redis-cluster.tmpl 文件\nvi redis-cluster.tmpl\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 编写配置文件\n\n192.168.10.10 机器的 redis-cluster.tmpl 文件内容如下：\n\nport ${port}\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.10\ncluster-announce-port ${port}\ncluster-announce-bus-port 1${port}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n192.168.10.11 机器的 redis-cluster.tmpl 文件内容如下：\n\nport ${port}\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.10\ncluster-announce-port ${port}\ncluster-announce-bus-port 1${port}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n * port：节点端口；\n\n * requirepass：添加访问认证；\n\n * masterauth：如果主节点开启了访问认证，从节点访问主节点需要认证；\n\n * protected-mode：保护模式，默认值 yes，即开启。开启保护模式以后，需配置 bind ip 或者设置访问密码；关闭保护模式，外部网络可以直接访问；\n\n * daemonize：是否以守护线程的方式启动（后台启动），默认 no；\n\n * appendonly：是否开启 aof 持久化模式，默认 no；\n\n * cluster-enabled：是否开启集群模式，默认 no；\n\n * cluster-config-file：集群节点信息文件；\n\n * cluster-node-timeout：集群节点连接超时时间；\n\n * cluster-announce-ip：集群节点 ip，填写宿主机的 ip；\n\n * cluster-announce-port：集群节点映射端口；\n\n * cluster-announce-bus-port：集群节点总线端口。\n\n> 每个 redis 集群节点都需要打开两个 tcp 连接。一个用于为客户端提供服务的正常 redis tcp 端口，例如 6379。还有一个基于 6379 端口加 10000 的端口，比如 16379。\n\n> 第二个端口用于集群总线，这是一个使用二进制协议的节点到节点通信通道。节点使用集群总线进行故障检测、配置更新、故障转移授权等等。客户端永远不要尝试与集群总线端口通信，与正常的 redis 命令端口通信即可，但是请确保防火墙中的这两个端口都已经打开，否则 redis 集群节点将无法通信。\n\n在 192.168.10.10 机器的 redis-cluster 目录下执行以下命令：\n\nfor port in `seq 6371 6373`; do \\\n  mkdir -p ${port}/conf \\\n  && port=${port} envsubst < redis-cluster.tmpl > ${port}/conf/redis.conf \\\n  && mkdir -p ${port}/data;\\\ndone\n\n\n1\n2\n3\n4\n5\n\n\n在 192.168.10.11 机器的 redis-cluster 目录下执行以下命令：\n\nfor port in `seq 6374 6376`; do \\\n  mkdir -p ${port}/conf \\\n  && port=${port} envsubst < redis-cluster.tmpl > ${port}/conf/redis.conf \\\n  && mkdir -p ${port}/data;\\\ndone\n\n\n1\n2\n3\n4\n5\n\n\n上面两段 shell for 语句，意思就是循环创建 6371 ~ 6376 相关的目录及文件。\n\n在 192.168.10.10 机器执行查看命令结果如下，如果没有 tree 命令先安装 yum install -y tree。\n\n\n\n在 192.168.10.11 机器执行查看命令结果如下。\n\n\n\n以下内容为每个节点的配置文件详细信息。\n\n============================== 192.168.10.10 ==============================\n[root@localhost redis-cluster]# cat /usr/local/docker-redis/redis-cluster/637{1..3}/conf/redis.conf\nport 6371\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.10\ncluster-announce-port 6371\ncluster-announce-bus-port 16371\n\nport 6372\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.10\ncluster-announce-port 6372\ncluster-announce-bus-port 16372\n\nport 6373\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.10\ncluster-announce-port 6373\ncluster-announce-bus-port 16373\n============================== 192.168.10.10 ==============================\n\n============================== 192.168.10.11 ==============================\n[root@localhost redis-cluster]# cat /usr/local/docker-redis/redis-cluster/637{4..6}/conf/redis.conf\nport 6374\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.11\ncluster-announce-port 6374\ncluster-announce-bus-port 16374\n\nport 6375\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.11\ncluster-announce-port 6375\ncluster-announce-bus-port 16375\n\nport 6376\nrequirepass 1234\nmasterauth 1234\nprotected-mode no\ndaemonize no\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\ncluster-announce-ip 192.168.10.11\ncluster-announce-port 6376\ncluster-announce-bus-port 16376\n============================== 192.168.10.11 ==============================\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n\n\n# 创建 redis 容器\n\n# 创建容器\n\n将宿主机的 6371 ~ 6376 之间的端口与 6 个 redis 容器映射，并将宿主机的目录与容器内的目录进行映射（目录挂载）。记得指定网络模式，使用 host 网络模式。\n\n在 192.168.10.10 机器执行以下命令：\n\nfor port in $(seq 6371 6373); do \\\n  docker run -di --restart always --name redis-${port} --net host \\\n  -v /usr/local/docker-redis/redis-cluster/${port}/conf/redis.conf:/usr/local/etc/redis/redis.conf \\\n  -v /usr/local/docker-redis/redis-cluster/${port}/data:/data \\\n  redis redis-server /usr/local/etc/redis/redis.conf; \\\ndone\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 192.168.10.11 机器执行以下命令：\n\nfor port in $(seq 6374 6376); do \\\n  docker run -di --restart always --name redis-${port} --net host \\\n  -v /usr/local/docker-redis/redis-cluster/${port}/conf/redis.conf:/usr/local/etc/redis/redis.conf \\\n  -v /usr/local/docker-redis/redis-cluster/${port}/data:/data \\\n  redis redis-server /usr/local/etc/redis/redis.conf; \\\ndone\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 192.168.10.10 机器执行 docker ps -n 3 查看容器是否创建成功。\n\n\n\n在 192.168.10.11 机器执行 docker ps -n 3 查看容器是否创建成功。\n\n\n\n\n# 创建 redis cluster 集群\n\n随便进入一个容器节点，并进入 /usr/local/bin/ 目录：\n\n# 进入容器\ndocker exec -it redis-6371 bash\n# 切换至指定目录\ncd /usr/local/bin/\n\n\n1\n2\n3\n4\n\n\n接下来我们就可以通过以下命令实现 redis cluster 集群的创建。\n\nredis-cli -a 1234 --cluster create 192.168.10.10:6371 192.168.10.10:6372 192.168.10.10:6373 192.168.10.11:6374 192.168.10.11:6375 192.168.10.11:6376 --cluster-replicas 1\n\n\n1\n\n\n出现选择提示信息，输入 yes，结果如下所示：\n\n\n\n集群创建成功如下：\n\n\n\n以下内容是创建集群时返回的详细信息，也就是上两幅图中的所有内容。\n\nroot@localhost:/usr/local/bin# redis-cli -a 1234 --cluster create 192.168.10.10:6371 192.168.10.10:6372 192.168.10.10:6373 192.168.10.11:6374 192.168.10.11:6375 192.168.10.11:6376 --cluster-replicas 1\nwarning: using a password with '-a' or '-u' option on the command line interface may not be safe.\n>>> performing hash slots allocation on 6 nodes...\nmaster[0] -> slots 0 - 5460\nmaster[1] -> slots 5461 - 10922\nmaster[2] -> slots 10923 - 16383\nadding replica 192.168.10.11:6376 to 192.168.10.10:6371\nadding replica 192.168.10.10:6373 to 192.168.10.11:6374\nadding replica 192.168.10.11:6375 to 192.168.10.10:6372\nm: 299cf79ddafc83dced27f628f1f82dac483fbc4e 192.168.10.10:6371\n   slots:[0-5460] (5461 slots) master\nm: ac805b90b6e20e26dc4268454bb2855beea6cc19 192.168.10.10:6372\n   slots:[10923-16383] (5461 slots) master\ns: db35494fcc5db0c88d27da7885c817e6cdcc9373 192.168.10.10:6373\n   replicates 7013270480d37eeab79b9cd0272e934d4548136a\nm: 7013270480d37eeab79b9cd0272e934d4548136a 192.168.10.11:6374\n   slots:[5461-10922] (5462 slots) master\ns: 8435e1b0d51f2690c5f94f9a5682a4ac34e94326 192.168.10.11:6375\n   replicates ac805b90b6e20e26dc4268454bb2855beea6cc19\ns: 7b13c16fa6fe8e13cdc0b4846b87edffed55c62e 192.168.10.11:6376\n   replicates 299cf79ddafc83dced27f628f1f82dac483fbc4e\ncan i set the above configuration? (type 'yes' to accept): yes\n>>> nodes configuration updated\n>>> assign a different config epoch to each node\n>>> sending cluster meet messages to join the cluster\nwaiting for the cluster to join\n.\n>>> performing cluster check (using node 192.168.10.10:6371)\nm: 299cf79ddafc83dced27f628f1f82dac483fbc4e 192.168.10.10:6371\n   slots:[0-5460] (5461 slots) master\n   1 additional replica(s)\ns: 8435e1b0d51f2690c5f94f9a5682a4ac34e94326 192.168.10.11:6375\n   slots: (0 slots) slave\n   replicates ac805b90b6e20e26dc4268454bb2855beea6cc19\ns: db35494fcc5db0c88d27da7885c817e6cdcc9373 192.168.10.10:6373\n   slots: (0 slots) slave\n   replicates 7013270480d37eeab79b9cd0272e934d4548136a\ns: 7b13c16fa6fe8e13cdc0b4846b87edffed55c62e 192.168.10.11:6376\n   slots: (0 slots) slave\n   replicates 299cf79ddafc83dced27f628f1f82dac483fbc4e\nm: 7013270480d37eeab79b9cd0272e934d4548136a 192.168.10.11:6374\n   slots:[5461-10922] (5462 slots) master\n   1 additional replica(s)\nm: ac805b90b6e20e26dc4268454bb2855beea6cc19 192.168.10.10:6372\n   slots:[10923-16383] (5461 slots) master\n   1 additional replica(s)\n[ok] all nodes agree about slots configuration.\n>>> check for open slots...\n>>> check slots coverage...\n[ok] all 16384 slots covered.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n至此一个高可用的 redis cluster 集群搭建完成，如下图所示，该集群中包含 6 个 redis 节点，3 主 3 从。三个主节点会分配槽，处理客户端的命令请求，而从节点可用在主节点故障后，顶替主节点。\n\n\n\n\n# 查看集群状态\n\n我们先进入容器，然后通过一些集群常用的命令查看一下集群的状态。\n\n# 进入容器\ndocker exec -it redis-6371 bash\n# 切换至指定目录\ncd /usr/local/bin/\n\n\n1\n2\n3\n4\n\n\n\n# 检查集群状态\n\nredis-cli -a 1234 --cluster check 192.168.10.11:6375\n\n\n1\n\n\n\n\n\n# 查看集群信息和节点信息\n\n# 连接至集群某个节点\nredis-cli -c -a 1234 -h 192.168.10.11 -p 6376\n# 查看集群信息\ncluster info\n# 查看集群结点信息\ncluster nodes\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n# set/get\n\n在 6371 节点中执行写入和读取，命令如下：\n\n# 进入容器并连接至集群某个节点\ndocker exec -it redis-6371 /usr/local/bin/redis-cli -c -a 1234 -h 192.168.10.10 -p 6371\n# 写入数据\nset name mrhelloworld\nset aaa 111\nset bbb 222\n# 读取数据\nget name\nget aaa\nget bbb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n别着急，让我来解释一下上图中的操作过程：\n\n * 首先进入容器并连接至集群某个节点；\n\n * 然后执行第一个 set 命令 set name mrhelloworld，name 键根据哈希函数运算以后得到的值为 [5798]。当前集群环境的槽分配情况为：[0-5460] 6371 节点，[5461-10922] 6374 节点，[10923-16383] 6372 节点，所以该键的存储就被分配到了 6374 节点上；\n\n * 再来看第二个 set 命令 set aaa，这里大家可能会有一些疑问，为什么看不到 aaa 键根据哈希函数运算以后得到的值？因为刚才重定向至 6374 节点插入了数据，此时如果还有数据插入，正好键根据哈希函数运算以后得到的值也还在该节点的范围内，那么直接插入数据即可；\n\n * 接着是第三个 set 命令 set bbb，bbb 键根据哈希函数运算以后得到的值为 [5287]，所以该键的存储就被分配到了 6371 节点上；\n\n * 然后是读取操作，第四个命令 get name，name 键根据哈希函数运算以后得到的值为 [5798]，被重定向至 6374 节点读取；\n\n * 第五个命令 get aaa，aaa 键根据哈希函数运算以后得到的值也在 6374 节点，直接读取；\n\n * 第六个命令 get bbb，bbb 键根据哈希函数运算以后得到的值为 [5287]，被重定向至 6371 节点读取。\n\n通过以上操作我们得知 name 键的存储被分配到了 6374 节点，如果直接连接 6374 节点并获取该值会怎么样？没错，不需要重定向节点，因为数据就在该节点，所以直接读取返回。\n\n\n\n\n# 客户端连接\n\n最后来一波客户端连接操作，随便哪个节点，看看可否通过外部访问 redis cluster 集群。\n\n\n\n\n\n至此使用多机环境多个容器搭建 redis cluster 集群环境就到这里，其实整体搭建过程不算特别麻烦，因为：\n\n * 创建 redis 集群需要用到 ruby，否则就得自己关联节点构建集群，自己分配槽；\n\n * 如果使用 ruby 构建 redis 集群，就需要安装 ruby 环境；\n\n * 而 redis 从 5 版本开始可以直接使用 redis-cli 命令创建集群了，就省去了很多麻烦事；\n\n * 我们还使用了 shell for 循环语句简化了构建过程，否则那些语句一条条执行也够你闹心的。\n\n综上所述，有没有更简单的办法呢？当然有了，不然我在这跟你卖什么关子。\n\n\n\ndocker compose 就可以解决这个问题。后面我们先学习一下什么是 docker compose，然后使用 docker compose 再来搭建一遍 redis cluster 集群环境，感受感受这前后的区别。\n\n[]: https://xie.infoq.cn/article/a5536b928edd12beb32fcabf9",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/1b1528/"},regularPath:"/25.%E8%BF%90%E7%BB%B4/60.kubernetes/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"25.运维/60.kubernetes/10.Redis高级客户端Lettuce详解.md",key:"v-69d48d6a",path:"/pages/1b1528/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/2c13c2/"},regularPath:"/30.%E5%B7%A5%E5%85%B7/05.maven/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"30.工具/05.maven/10.Redis高级客户端Lettuce详解.md",key:"v-252683df",path:"/pages/2c13c2/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/2ec465/"},regularPath:"/30.%E5%B7%A5%E5%85%B7/10.svn/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"30.工具/10.svn/10.Redis高级客户端Lettuce详解.md",key:"v-e8a298c2",path:"/pages/2ec465/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/891624/"},regularPath:"/30.%E5%B7%A5%E5%85%B7/20.idea/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"30.工具/20.idea/10.Redis高级客户端Lettuce详解.md",key:"v-dbcc7c0e",path:"/pages/891624/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/df2d8d/"},regularPath:"/30.%E5%B7%A5%E5%85%B7/25.windows/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"30.工具/25.windows/10.Redis高级客户端Lettuce详解.md",key:"v-2dd7091f",path:"/pages/df2d8d/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Java 基础",frontmatter:{title:"Java 基础",date:"2022-02-03T19:02:33.000Z",permalink:"/pages/bbda94/",categories:["面试","Java","Java基础"],tags:[null]},regularPath:"/35.%E9%9D%A2%E8%AF%95/05.Java/05.Java%E5%9F%BA%E7%A1%80/05.Java%20%E5%9F%BA%E7%A1%80.html",relativePath:"35.面试/05.Java/05.Java基础/05.Java 基础.md",key:"v-67e77451",path:"/pages/bbda94/",headers:[{level:2,title:"一、数据类型",slug:"一、数据类型",normalizedTitle:"一、数据类型",charIndex:2},{level:3,title:"基本类型",slug:"基本类型",normalizedTitle:"基本类型",charIndex:13},{level:3,title:"包装类型",slug:"包装类型",normalizedTitle:"包装类型",charIndex:370},{level:3,title:"缓存池",slug:"缓存池",normalizedTitle:"缓存池",charIndex:568},{level:2,title:"二、String",slug:"二、string",normalizedTitle:"二、string",charIndex:2958},{level:3,title:"概览",slug:"概览",normalizedTitle:"概览",charIndex:2971},{level:3,title:"不可变的好处",slug:"不可变的好处",normalizedTitle:"不可变的好处",charIndex:3742},{level:3,title:"String, StringBuffer and StringBuilder",slug:"string-stringbuffer-and-stringbuilder",normalizedTitle:"string, stringbuffer and stringbuilder",charIndex:4208},{level:3,title:"String Pool",slug:"string-pool",normalizedTitle:"string pool",charIndex:3856},{level:3,title:'new String("abc")',slug:"new-string-abc",normalizedTitle:"new string(&quot;abc&quot;)",charIndex:null},{level:2,title:"三、运算",slug:"三、运算",normalizedTitle:"三、运算",charIndex:7021},{level:3,title:"参数传递",slug:"参数传递",normalizedTitle:"参数传递",charIndex:7030},{level:3,title:"float 与 double",slug:"float-与-double",normalizedTitle:"float 与 double",charIndex:8615},{level:3,title:"隐式类型转换",slug:"隐式类型转换",normalizedTitle:"隐式类型转换",charIndex:8787},{level:3,title:"switch",slug:"switch",normalizedTitle:"switch",charIndex:9128},{level:2,title:"四、关键字",slug:"四、关键字",normalizedTitle:"四、关键字",charIndex:9875},{level:3,title:"final",slug:"final",normalizedTitle:"final",charIndex:1227},{level:3,title:"static",slug:"static",normalizedTitle:"static",charIndex:988},{level:2,title:"五、Object 通用方法",slug:"五、object-通用方法",normalizedTitle:"五、object 通用方法",charIndex:12709},{level:3,title:"概览",slug:"概览-2",normalizedTitle:"概览",charIndex:2971},{level:3,title:"equals()",slug:"equals",normalizedTitle:"equals()",charIndex:4682},{level:3,title:"hashCode()",slug:"hashcode",normalizedTitle:"hashcode()",charIndex:12749},{level:3,title:"toString()",slug:"tostring",normalizedTitle:"tostring()",charIndex:7410},{level:3,title:"clone()",slug:"clone",normalizedTitle:"clone()",charIndex:12820},{level:2,title:"六、继承",slug:"六、继承",normalizedTitle:"六、继承",charIndex:20214},{level:3,title:"访问权限",slug:"访问权限",normalizedTitle:"访问权限",charIndex:20223},{level:3,title:"抽象类与接口",slug:"抽象类与接口",normalizedTitle:"抽象类与接口",charIndex:21495},{level:3,title:"super",slug:"super",normalizedTitle:"super",charIndex:7404},{level:3,title:"重写与重载",slug:"重写与重载",normalizedTitle:"重写与重载",charIndex:25188},{level:2,title:"七、反射",slug:"七、反射",normalizedTitle:"七、反射",charIndex:27671},{level:2,title:"八、异常",slug:"八、异常",normalizedTitle:"八、异常",charIndex:28851},{level:2,title:"九、泛型",slug:"九、泛型",normalizedTitle:"九、泛型",charIndex:29182},{level:2,title:"十、注解",slug:"十、注解",normalizedTitle:"十、注解",charIndex:29417},{level:2,title:"十一、特性",slug:"十一、特性",normalizedTitle:"十一、特性",charIndex:29555},{level:3,title:"Java 各版本的新特性",slug:"java-各版本的新特性",normalizedTitle:"java 各版本的新特性",charIndex:29565},{level:3,title:"Java 与 C++ 的区别",slug:"java-与-c-的区别",normalizedTitle:"java 与 c++ 的区别",charIndex:30212},{level:3,title:"JRE or JDK",slug:"jre-or-jdk",normalizedTitle:"jre or jdk",charIndex:30656},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:30896}],headersStr:'一、数据类型 基本类型 包装类型 缓存池 二、String 概览 不可变的好处 String, StringBuffer and StringBuilder String Pool new String("abc") 三、运算 参数传递 float 与 double 隐式类型转换 switch 四、关键字 final static 五、Object 通用方法 概览 equals() hashCode() toString() clone() 六、继承 访问权限 抽象类与接口 super 重写与重载 七、反射 八、异常 九、泛型 十、注解 十一、特性 Java 各版本的新特性 Java 与 C++ 的区别 JRE or JDK 参考资料',content:'# 一、数据类型\n\n\n# 基本类型\n\n * byte/8\n * char/16\n * short/16\n * int/32\n * float/32\n * long/64\n * double/64\n * boolean/~\n\nboolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。\n\n * Primitive Data Types(opens new window)\n * The Java® Virtual Machine Specification(opens new window)\n\n\n# 包装类型\n\n基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。\n\nInteger x = 2;     // 装箱 调用了 Integer.valueOf(2)\nint y = x;         // 拆箱 调用了 X.intValue()\n\n\n1\n2\n\n * Autoboxing and Unboxing(opens new window)\n\n\n# 缓存池\n\nnew Integer(123) 与 Integer.valueOf(123) 的区别在于：\n\n * new Integer(123) 每次都会新建一个对象；\n * Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。\n\nInteger x = new Integer(123);\nInteger y = new Integer(123);\nSystem.out.println(x == y);    // false\nInteger z = Integer.valueOf(123);\nInteger k = Integer.valueOf(123);\nSystem.out.println(z == k);   // true\n\n\n1\n2\n3\n4\n5\n6\n\n\nvalueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。\n\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n\n\n1\n2\n3\n4\n5\n\n\n在 Java 8 中，Integer 缓存池的大小默认为 -128~127。\n\nstatic final int low = -128;\nstatic final int high;\nstatic final Integer cache[];\n\nstatic {\n    // high value may be configured by property\n    int h = 127;\n    String integerCacheHighPropValue =\n        sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");\n    if (integerCacheHighPropValue != null) {\n        try {\n            int i = parseInt(integerCacheHighPropValue);\n            i = Math.max(i, 127);\n            // Maximum array size is Integer.MAX_VALUE\n            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n        } catch( NumberFormatException nfe) {\n            // If the property cannot be parsed into an int, ignore it.\n        }\n    }\n    high = h;\n\n    cache = new Integer[(high - low) + 1];\n    int j = low;\n    for(int k = 0; k < cache.length; k++)\n        cache[k] = new Integer(j++);\n\n    // range [-128, 127] must be interned (JLS7 5.1.7)\n    assert IntegerCache.high >= 127;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。\n\nInteger m = 123;\nInteger n = 123;\nSystem.out.println(m == n); // true\n\n\n1\n2\n3\n\n\n基本类型对应的缓冲池如下：\n\n * boolean values true and false\n * all byte values\n * short values between -128 and 127\n * int values between -128 and 127\n * char in the range \\u0000 to \\u007F\n\n在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。\n\n在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。\n\nStackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123 (opens new window)\n\n\n# 二、String\n\n\n# 概览\n\nString 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）\n\n在 Java 8 中，String 内部使用 char 数组存储数据。\n\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n}\n\n\n1\n2\n3\n4\n5\n\n\n在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。\n\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final byte[] value;\n\n    /** The identifier of the encoding used to encode the bytes in {@code value}. */\n    private final byte coder;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nvalue 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。\n\n\n# 不可变的好处\n\n1. 可以缓存 hash 值\n\n因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。\n\n2. String Pool 的需要\n\n如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。\n\n\n\n3. 安全性\n\nString 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。\n\n4. 线程安全\n\nString 不可变性天生具备线程安全，可以在多个线程中安全地使用。\n\nProgram Creek : Why String is immutable in Java?(opens new window)\n\n\n# String, StringBuffer and StringBuilder\n\n1. 可变性\n\n * String 不可变\n * StringBuffer 和 StringBuilder 可变\n\n2. 线程安全\n\n * String 不可变，因此是线程安全的\n * StringBuilder 不是线程安全的\n * StringBuffer 是线程安全的，内部使用 synchronized 进行同步\n\nStackOverflow : String, StringBuffer, and StringBuilder(opens new window)\n\n\n# String Pool\n\n字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。\n\n当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。\n\n下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 "aaa" 放到 String Pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。\n\nString s1 = new String("aaa");\nString s2 = new String("aaa");\nSystem.out.println(s1 == s2);           // false\nString s3 = s1.intern();\nString s4 = s2.intern();\nSystem.out.println(s3 == s4);           // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果是采用 "bbb" 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。\n\nString s5 = "bbb";\nString s6 = "bbb";\nSystem.out.println(s5 == s6);  // true\n\n\n1\n2\n3\n\n\n在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。\n\n * StackOverflow : What is String interning?(opens new window)\n * 深入解析 String#intern(opens new window)\n\n\n# new String("abc")\n\n使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 "abc" 字符串对象）。\n\n * "abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量；\n * 而使用 new 的方式会在堆中创建一个字符串对象。\n\n创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。\n\npublic class NewStringTest {\n    public static void main(String[] args) {\n        String s = new String("abc");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用 javap -verbose 进行反编译，得到以下内容：\n\n// ...\nConstant pool:\n// ...\n   #2 = Class              #18            // java/lang/String\n   #3 = String             #19            // abc\n// ...\n  #18 = Utf8               java/lang/String\n  #19 = Utf8               abc\n// ...\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=3, locals=2, args_size=1\n         0: new           #2                  // class java/lang/String\n         3: dup\n         4: ldc           #3                  // String abc\n         6: invokespecial #4                  // Method java/lang/String."<init>":(Ljava/lang/String;)V\n         9: astore_1\n// ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在 Constant Pool 中，#19 存储这字符串字面量 "abc"，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。\n\n以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。\n\npublic String(String original) {\n    this.value = original.value;\n    this.hash = original.hash;\n}\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 三、运算\n\n\n# 参数传递\n\nJava 的参数是以值传递的形式传入方法中，而不是引用传递。\n\n以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。\n\npublic class Dog {\n\n    String name;\n\n    Dog(String name) {\n        this.name = name;\n    }\n\n    String getName() {\n        return this.name;\n    }\n\n    void setName(String name) {\n        this.name = name;\n    }\n\n    String getObjectAddress() {\n        return super.toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。\n\nclass PassByValueExample {\n    public static void main(String[] args) {\n        Dog dog = new Dog("A");\n        func(dog);\n        System.out.println(dog.getName());          // B\n    }\n\n    private static void func(Dog dog) {\n        dog.setName("B");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。\n\npublic class PassByValueExample {\n    public static void main(String[] args) {\n        Dog dog = new Dog("A");\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        func(dog);\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        System.out.println(dog.getName());          // A\n    }\n\n    private static void func(Dog dog) {\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        dog = new Dog("B");\n        System.out.println(dog.getObjectAddress()); // Dog@74a14482\n        System.out.println(dog.getName());          // B\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nStackOverflow: Is Java “pass-by-reference” or “pass-by-value”?(opens new window)\n\n\n# float 与 double\n\nJava 不能隐式执行向下转型，因为这会使得精度降低。\n\n1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。\n\n// float f = 1.1;\n\n\n1\n\n\n1.1f 字面量才是 float 类型。\n\nfloat f = 1.1f;\n\n\n1\n\n\n\n# 隐式类型转换\n\n因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。\n\nshort s1 = 1;\n// s1 = s1 + 1;\n\n\n1\n2\n\n\n但是使用 += 或者 ++ 运算符会执行隐式类型转换。\n\ns1 += 1;\ns1++;\n\n\n1\n2\n\n\n上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：\n\ns1 = (short) (s1 + 1);\n\n\n1\n\n\nStackOverflow : Why don\'t Java\'s +=, -=, *=, /= compound assignment operators require casting?(opens new window)\n\n\n# switch\n\n从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。\n\nString s = "a";\nswitch (s) {\n    case "a":\n        System.out.println("aaa");\n        break;\n    case "b":\n        System.out.println("bbb");\n        break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nswitch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。\n\n// long x = 111;\n// switch (x) { // Incompatible types. Found: \'long\', required: \'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum\'\n//     case 111:\n//         System.out.println(111);\n//         break;\n//     case 222:\n//         System.out.println(222);\n//         break;\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nStackOverflow : Why can\'t your switch statement data type be long, Java?(opens new window)\n\n\n# 四、关键字\n\n\n# final\n\n1. 数据\n\n声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。\n\n * 对于基本类型，final 使数值不变；\n * 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。\n\nfinal int x = 1;\n// x = 2;  // cannot assign value to final variable \'x\'\nfinal A y = new A();\ny.a = 1;\n\n\n1\n2\n3\n4\n\n\n2. 方法\n\n声明方法不能被子类重写。\n\nprivate 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。\n\n3. 类\n\n声明类不允许被继承。\n\n\n# static\n\n1. 静态变量\n\n * 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。\n * 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。\n\npublic class A {\n\n    private int x;         // 实例变量\n    private static int y;  // 静态变量\n\n    public static void main(String[] args) {\n        // int x = A.x;  // Non-static field \'x\' cannot be referenced from a static context\n        A a = new A();\n        int x = a.x;\n        int y = A.y;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n2. 静态方法\n\n静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。\n\npublic abstract class A {\n    public static void func1(){\n    }\n    // public abstract static void func2();  // Illegal combination of modifiers: \'abstract\' and \'static\'\n}\n\n\n1\n2\n3\n4\n5\n\n\n只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。\n\npublic class A {\n\n    private static int x;\n    private int y;\n\n    public static void func1(){\n        int a = x;\n        // int b = y;  // Non-static field \'y\' cannot be referenced from a static context\n        // int b = this.y;     // \'A.this\' cannot be referenced from a static context\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n3. 静态语句块\n\n静态语句块在类初始化时运行一次。\n\npublic class A {\n    static {\n        System.out.println("123");\n    }\n\n    public static void main(String[] args) {\n        A a1 = new A();\n        A a2 = new A();\n    }\n}\n123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n4. 静态内部类\n\n非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。\n\npublic class OuterClass {\n\n    class InnerClass {\n    }\n\n    static class StaticInnerClass {\n    }\n\n    public static void main(String[] args) {\n        // InnerClass innerClass = new InnerClass(); // \'OuterClass.this\' cannot be referenced from a static context\n        OuterClass outerClass = new OuterClass();\n        InnerClass innerClass = outerClass.new InnerClass();\n        StaticInnerClass staticInnerClass = new StaticInnerClass();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n静态内部类不能访问外部类的非静态的变量和方法。\n\n5. 静态导包\n\n在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。\n\nimport static com.xxx.ClassName.*\n\n\n1\n\n\n6. 初始化顺序\n\n静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。\n\npublic static String staticField = "静态变量";\nstatic {\n    System.out.println("静态语句块");\n}\npublic String field = "实例变量";\n{\n    System.out.println("普通语句块");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n最后才是构造函数的初始化。\n\npublic InitialOrderTest() {\n    System.out.println("构造函数");\n}\n\n\n1\n2\n3\n\n\n存在继承的情况下，初始化顺序为：\n\n * 父类（静态变量、静态语句块）\n * 子类（静态变量、静态语句块）\n * 父类（实例变量、普通语句块）\n * 父类（构造函数）\n * 子类（实例变量、普通语句块）\n * 子类（构造函数）\n\n\n# 五、Object 通用方法\n\n\n# 概览\n\npublic native int hashCode()\n\npublic boolean equals(Object obj)\n\nprotected native Object clone() throws CloneNotSupportedException\n\npublic String toString()\n\npublic final native Class<?> getClass()\n\nprotected void finalize() throws Throwable {}\n\npublic final native void notify()\n\npublic final native void notifyAll()\n\npublic final native void wait(long timeout) throws InterruptedException\n\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\npublic final void wait() throws InterruptedException\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# equals()\n\n1. 等价关系\n\n两个对象具有等价关系，需要满足以下五个条件：\n\nⅠ 自反性\n\nx.equals(x); // true\n\n\n1\n\n\nⅡ 对称性\n\nx.equals(y) == y.equals(x); // true\n\n\n1\n\n\nⅢ 传递性\n\nif (x.equals(y) && y.equals(z))\n    x.equals(z); // true;\n\n\n1\n2\n\n\nⅣ 一致性\n\n多次调用 equals() 方法结果不变\n\nx.equals(y) == x.equals(y); // true\n\n\n1\n\n\nⅤ 与 null 的比较\n\n对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false\n\nx.equals(null); // false;\n\n\n1\n\n\n2. 等价与相等\n\n * 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。\n * 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。\n\nInteger x = new Integer(1);\nInteger y = new Integer(1);\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x == y);      // false\n\n\n1\n2\n3\n4\n\n\n3. 实现\n\n * 检查是否为同一个对象的引用，如果是直接返回 true；\n * 检查是否是同一个类型，如果不是，直接返回 false；\n * 将 Object 对象进行转型；\n * 判断每个关键域是否相等。\n\npublic class EqualExample {\n\n    private int x;\n    private int y;\n    private int z;\n\n    public EqualExample(int x, int y, int z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        EqualExample that = (EqualExample) o;\n\n        if (x != that.x) return false;\n        if (y != that.y) return false;\n        return z == that.z;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# hashCode()\n\nhashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。\n\n在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。\n\nHashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。\n\n下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。\n\nEqualExample e1 = new EqualExample(1, 1, 1);\nEqualExample e2 = new EqualExample(1, 1, 1);\nSystem.out.println(e1.equals(e2)); // true\nHashSet<EqualExample> set = new HashSet<>();\nset.add(e1);\nset.add(e2);\nSystem.out.println(set.size());   // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。\n\nR 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：31*x == (x<<5)-x，编译器会自动进行这个优化。\n\n@Override\npublic int hashCode() {\n    int result = 17;\n    result = 31 * result + x;\n    result = 31 * result + y;\n    result = 31 * result + z;\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# toString()\n\n默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。\n\npublic class ToStringExample {\n\n    private int number;\n\n    public ToStringExample(int number) {\n        this.number = number;\n    }\n}\nToStringExample example = new ToStringExample(123);\nSystem.out.println(example.toString());\nToStringExample@4554617c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# clone()\n\n1. cloneable\n\nclone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。\n\npublic class CloneExample {\n    private int a;\n    private int b;\n}\nCloneExample e1 = new CloneExample();\n// CloneExample e2 = e1.clone(); // \'clone()\' has protected access in \'java.lang.Object\'\n\n\n1\n2\n3\n4\n5\n6\n\n\n重写 clone() 得到以下实现：\n\npublic class CloneExample {\n    private int a;\n    private int b;\n\n    @Override\n    public CloneExample clone() throws CloneNotSupportedException {\n        return (CloneExample)super.clone();\n    }\n}\nCloneExample e1 = new CloneExample();\ntry {\n    CloneExample e2 = e1.clone();\n} catch (CloneNotSupportedException e) {\n    e.printStackTrace();\n}\njava.lang.CloneNotSupportedException: CloneExample\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。\n\n应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。\n\npublic class CloneExample implements Cloneable {\n    private int a;\n    private int b;\n\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2. 浅拷贝\n\n拷贝对象和原始对象的引用类型引用同一个对象。\n\npublic class ShallowCloneExample implements Cloneable {\n\n    private int[] arr;\n\n    public ShallowCloneExample() {\n        arr = new int[10];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = i;\n        }\n    }\n\n    public void set(int index, int value) {\n        arr[index] = value;\n    }\n\n    public int get(int index) {\n        return arr[index];\n    }\n\n    @Override\n    protected ShallowCloneExample clone() throws CloneNotSupportedException {\n        return (ShallowCloneExample) super.clone();\n    }\n}\nShallowCloneExample e1 = new ShallowCloneExample();\nShallowCloneExample e2 = null;\ntry {\n    e2 = e1.clone();\n} catch (CloneNotSupportedException e) {\n    e.printStackTrace();\n}\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 222\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n3. 深拷贝\n\n拷贝对象和原始对象的引用类型引用不同对象。\n\npublic class DeepCloneExample implements Cloneable {\n\n    private int[] arr;\n\n    public DeepCloneExample() {\n        arr = new int[10];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = i;\n        }\n    }\n\n    public void set(int index, int value) {\n        arr[index] = value;\n    }\n\n    public int get(int index) {\n        return arr[index];\n    }\n\n    @Override\n    protected DeepCloneExample clone() throws CloneNotSupportedException {\n        DeepCloneExample result = (DeepCloneExample) super.clone();\n        result.arr = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            result.arr[i] = arr[i];\n        }\n        return result;\n    }\n}\nDeepCloneExample e1 = new DeepCloneExample();\nDeepCloneExample e2 = null;\ntry {\n    e2 = e1.clone();\n} catch (CloneNotSupportedException e) {\n    e.printStackTrace();\n}\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n4. clone() 的替代方案\n\n使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。\n\npublic class CloneConstructorExample {\n\n    private int[] arr;\n\n    public CloneConstructorExample() {\n        arr = new int[10];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = i;\n        }\n    }\n\n    public CloneConstructorExample(CloneConstructorExample original) {\n        arr = new int[original.arr.length];\n        for (int i = 0; i < original.arr.length; i++) {\n            arr[i] = original.arr[i];\n        }\n    }\n\n    public void set(int index, int value) {\n        arr[index] = value;\n    }\n\n    public int get(int index) {\n        return arr[index];\n    }\n}\nCloneConstructorExample e1 = new CloneConstructorExample();\nCloneConstructorExample e2 = new CloneConstructorExample(e1);\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 六、继承\n\n\n# 访问权限\n\nJava 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。\n\n可以对类或类中的成员（字段和方法）加上访问修饰符。\n\n * 类可见表示其它类可以用这个类创建实例对象。\n * 成员可见表示其它类可以用这个类的实例对象访问到该成员；\n\nprotected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。\n\n设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。\n\n如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。\n\n字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。\n\npublic class AccessExample {\n    public String id;\n}\n\n\n1\n2\n3\n\n\n可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。\n\npublic class AccessExample {\n\n    private int id;\n\n    public String getId() {\n        return id + "";\n    }\n\n    public void setId(String id) {\n        this.id = Integer.valueOf(id);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。\n\npublic class AccessWithInnerClassExample {\n\n    private class InnerClass {\n        int x;\n    }\n\n    private InnerClass innerClass;\n\n    public AccessWithInnerClassExample() {\n        innerClass = new InnerClass();\n    }\n\n    public int getValue() {\n        return innerClass.x;  // 直接访问\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 抽象类与接口\n\n1. 抽象类\n\n抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。\n\n抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。\n\npublic abstract class AbstractClassExample {\n\n    protected int x;\n    private int y;\n\n    public abstract void func1();\n\n    public void func2() {\n        System.out.println("func2");\n    }\n}\npublic class AbstractExtendClassExample extends AbstractClassExample {\n    @Override\n    public void func1() {\n        System.out.println("func1");\n    }\n}\n// AbstractClassExample ac1 = new AbstractClassExample(); // \'AbstractClassExample\' is abstract; cannot be instantiated\nAbstractClassExample ac2 = new AbstractExtendClassExample();\nac2.func1();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n2. 接口\n\n接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。\n\n从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。\n\n接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。\n\n接口的字段默认都是 static 和 final 的。\n\npublic interface InterfaceExample {\n\n    void func1();\n\n    default void func2(){\n        System.out.println("func2");\n    }\n\n    int x = 123;\n    // int y;               // Variable \'y\' might not have been initialized\n    public int z = 0;       // Modifier \'public\' is redundant for interface fields\n    // private int k = 0;   // Modifier \'private\' not allowed here\n    // protected int l = 0; // Modifier \'protected\' not allowed here\n    // private void fun3(); // Modifier \'private\' not allowed here\n}\npublic class InterfaceImplementExample implements InterfaceExample {\n    @Override\n    public void func1() {\n        System.out.println("func1");\n    }\n}\n// InterfaceExample ie1 = new InterfaceExample(); // \'InterfaceExample\' is abstract; cannot be instantiated\nInterfaceExample ie2 = new InterfaceImplementExample();\nie2.func1();\nSystem.out.println(InterfaceExample.x);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n3. 比较\n\n * 从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。\n * 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。\n * 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。\n * 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。\n\n4. 使用选择\n\n使用接口：\n\n * 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；\n * 需要使用多重继承。\n\n使用抽象类：\n\n * 需要在几个相关的类中共享代码。\n * 需要能控制继承来的成员的访问权限，而不是都为 public。\n * 需要继承非静态和非常量字段。\n\n在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。\n\n * Abstract Methods and Classes(opens new window)\n * 深入理解 abstract class 和 interface(opens new window)\n * When to Use Abstract Class and Interface(opens new window)\n * Java 9 Private Methods in Interfaces(opens new window)\n\n\n# super\n\n * 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。\n * 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。\n\npublic class SuperExample {\n\n    protected int x;\n    protected int y;\n\n    public SuperExample(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void func() {\n        System.out.println("SuperExample.func()");\n    }\n}\npublic class SuperExtendExample extends SuperExample {\n\n    private int z;\n\n    public SuperExtendExample(int x, int y, int z) {\n        super(x, y);\n        this.z = z;\n    }\n\n    @Override\n    public void func() {\n        super.func();\n        System.out.println("SuperExtendExample.func()");\n    }\n}\nSuperExample e = new SuperExtendExample(1, 2, 3);\ne.func();\nSuperExample.func()\nSuperExtendExample.func()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nUsing the Keyword super(opens new window)\n\n\n# 重写与重载\n\n1. 重写（Override）\n\n存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。\n\n为了满足里式替换原则，重写有以下三个限制：\n\n * 子类方法的访问权限必须大于等于父类方法；\n * 子类方法的返回类型必须是父类方法返回类型或为其子类型。\n * 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。\n\n使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。\n\n下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：\n\n * 子类方法访问权限为 public，大于父类的 protected。\n * 子类的返回类型为 ArrayList<Integer>，是父类返回类型 List<Integer> 的子类。\n * 子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。\n * 子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。\n\nclass SuperClass {\n    protected List<Integer> func() throws Throwable {\n        return new ArrayList<>();\n    }\n}\n\nclass SubClass extends SuperClass {\n    @Override\n    public ArrayList<Integer> func() throws Exception {\n        return new ArrayList<>();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：\n\n * this.func(this)\n * super.func(this)\n * this.func(super)\n * super.func(super)\n\n/*\n    A\n    |\n    B\n    |\n    C\n    |\n    D\n */\n\n\nclass A {\n\n    public void show(A obj) {\n        System.out.println("A.show(A)");\n    }\n\n    public void show(C obj) {\n        System.out.println("A.show(C)");\n    }\n}\n\nclass B extends A {\n\n    @Override\n    public void show(A obj) {\n        System.out.println("B.show(A)");\n    }\n}\n\nclass C extends B {\n}\n\nclass D extends C {\n}\npublic static void main(String[] args) {\n\n    A a = new A();\n    B b = new B();\n    C c = new C();\n    D d = new D();\n\n    // 在 A 中存在 show(A obj)，直接调用\n    a.show(a); // A.show(A)\n    // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A\n    a.show(b); // A.show(A)\n    // 在 B 中存在从 A 继承来的 show(C obj)，直接调用\n    b.show(c); // A.show(C)\n    // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C\n    b.show(d); // A.show(C)\n\n    // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样\n    A ba = new B();\n    ba.show(c); // A.show(C)\n    ba.show(d); // A.show(C)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n2. 重载（Overload）\n\n存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。\n\n应该注意的是，返回值不同，其它都相同不算是重载。\n\nclass OverloadingExample {\n    public void show(int x) {\n        System.out.println(x);\n    }\n\n    public void show(int x, String y) {\n        System.out.println(x + " " + y);\n    }\n}\npublic static void main(String[] args) {\n    OverloadingExample example = new OverloadingExample();\n    example.show(1);\n    example.show(1, "2");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 七、反射\n\n每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。\n\n类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName("com.mysql.jdbc.Driver") 这种方式来控制类的加载，该方法会返回一个 Class 对象。\n\n反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。\n\nClass 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：\n\n * Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；\n * Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；\n * Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。\n\n反射的优点：\n\n * 可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。\n * 类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。\n * 调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。\n\n反射的缺点：\n\n尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。\n\n * 性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。\n * 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。\n * 内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。\n * Trail: The Reflection API(opens new window)\n * 深入解析 Java 反射（1）- 基础(opens new window)\n\n\n# 八、异常\n\nThrowable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：\n\n * 受检异常 ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；\n * 非受检异常 ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。\n\n\n\n * Java Exception Interview Questions and Answers(opens new window)\n * Java提高篇——Java 异常处理(opens new window)\n\n\n# 九、泛型\n\npublic class Box<T> {\n    // T stands for "Type"\n    private T t;\n    public void set(T t) { this.t = t; }\n    public T get() { return t; }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * Java 泛型详解(opens new window)\n * 10 道 Java 泛型面试题(opens new window)\n\n\n# 十、注解\n\nJava 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。\n\n注解 Annotation 实现原理与自定义注解例子(opens new window)\n\n\n# 十一、特性\n\n\n# Java 各版本的新特性\n\nNew highlights in Java SE 8\n\n 1. Lambda Expressions\n 2. Pipelines and Streams\n 3. Date and Time API\n 4. Default Methods\n 5. Type Annotations\n 6. Nashhorn JavaScript Engine\n 7. Concurrent Accumulators\n 8. Parallel operations\n 9. PermGen Error Removed\n\nNew highlights in Java SE 7\n\n 1. Strings in Switch Statement\n 2. Type Inference for Generic Instance Creation\n 3. Multiple Exception Handling\n 4. Support for Dynamic Languages\n 5. Try with Resources\n 6. Java nio Package\n 7. Binary Literals, Underscore in literals\n 8. Diamond Syntax\n\n * Difference between Java 1.8 and Java 1.7?(opens new window)\n * Java 8 特性(opens new window)\n\n\n# Java 与 C++ 的区别\n\n * Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。\n * Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。\n * Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。\n * Java 支持自动垃圾回收，而 C++ 需要手动回收。\n * Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。\n * Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。\n * Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。\n\nWhat are the main differences between Java and C++?(opens new window)\n\n\n# JRE or JDK\n\n * JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。\n * JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。\n\n\n# 参考资料\n\n * Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.\n * Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.\n\n',normalizedContent:'# 一、数据类型\n\n\n# 基本类型\n\n * byte/8\n * char/16\n * short/16\n * int/32\n * float/32\n * long/64\n * double/64\n * boolean/~\n\nboolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。jvm 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。jvm 支持 boolean 数组，但是是通过读写 byte 数组来实现的。\n\n * primitive data types(opens new window)\n * the java® virtual machine specification(opens new window)\n\n\n# 包装类型\n\n基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。\n\ninteger x = 2;     // 装箱 调用了 integer.valueof(2)\nint y = x;         // 拆箱 调用了 x.intvalue()\n\n\n1\n2\n\n * autoboxing and unboxing(opens new window)\n\n\n# 缓存池\n\nnew integer(123) 与 integer.valueof(123) 的区别在于：\n\n * new integer(123) 每次都会新建一个对象；\n * integer.valueof(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。\n\ninteger x = new integer(123);\ninteger y = new integer(123);\nsystem.out.println(x == y);    // false\ninteger z = integer.valueof(123);\ninteger k = integer.valueof(123);\nsystem.out.println(z == k);   // true\n\n\n1\n2\n3\n4\n5\n6\n\n\nvalueof() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。\n\npublic static integer valueof(int i) {\n    if (i >= integercache.low && i <= integercache.high)\n        return integercache.cache[i + (-integercache.low)];\n    return new integer(i);\n}\n\n\n1\n2\n3\n4\n5\n\n\n在 java 8 中，integer 缓存池的大小默认为 -128~127。\n\nstatic final int low = -128;\nstatic final int high;\nstatic final integer cache[];\n\nstatic {\n    // high value may be configured by property\n    int h = 127;\n    string integercachehighpropvalue =\n        sun.misc.vm.getsavedproperty("java.lang.integer.integercache.high");\n    if (integercachehighpropvalue != null) {\n        try {\n            int i = parseint(integercachehighpropvalue);\n            i = math.max(i, 127);\n            // maximum array size is integer.max_value\n            h = math.min(i, integer.max_value - (-low) -1);\n        } catch( numberformatexception nfe) {\n            // if the property cannot be parsed into an int, ignore it.\n        }\n    }\n    high = h;\n\n    cache = new integer[(high - low) + 1];\n    int j = low;\n    for(int k = 0; k < cache.length; k++)\n        cache[k] = new integer(j++);\n\n    // range [-128, 127] must be interned (jls7 5.1.7)\n    assert integercache.high >= 127;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n编译器会在自动装箱过程调用 valueof() 方法，因此多个值相同且值在缓存池范围内的 integer 实例使用自动装箱来创建，那么就会引用相同的对象。\n\ninteger m = 123;\ninteger n = 123;\nsystem.out.println(m == n); // true\n\n\n1\n2\n3\n\n\n基本类型对应的缓冲池如下：\n\n * boolean values true and false\n * all byte values\n * short values between -128 and 127\n * int values between -128 and 127\n * char in the range \\u0000 to \\u007f\n\n在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。\n\n在 jdk 1.8 所有的数值类缓冲池中，integer 的缓冲池 integercache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -xx:autoboxcachemax=<size> 来指定这个缓冲池的大小，该选项在 jvm 初始化的时候会设定一个名为 java.lang.integercache.high 系统属性，然后 integercache 初始化的时候就会读取该系统属性来决定上界。\n\nstackoverflow : differences between new integer(123), integer.valueof(123) and just 123 (opens new window)\n\n\n# 二、string\n\n\n# 概览\n\nstring 被声明为 final，因此它不可被继承。(integer 等包装类也不能被继承）\n\n在 java 8 中，string 内部使用 char 数组存储数据。\n\npublic final class string\n    implements java.io.serializable, comparable<string>, charsequence {\n    /** the value is used for character storage. */\n    private final char value[];\n}\n\n\n1\n2\n3\n4\n5\n\n\n在 java 9 之后，string 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。\n\npublic final class string\n    implements java.io.serializable, comparable<string>, charsequence {\n    /** the value is used for character storage. */\n    private final byte[] value;\n\n    /** the identifier of the encoding used to encode the bytes in {@code value}. */\n    private final byte coder;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nvalue 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 string 内部没有改变 value 数组的方法，因此可以保证 string 不可变。\n\n\n# 不可变的好处\n\n1. 可以缓存 hash 值\n\n因为 string 的 hash 值经常被使用，例如 string 用做 hashmap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。\n\n2. string pool 的需要\n\n如果一个 string 对象已经被创建过了，那么就会从 string pool 中取得引用。只有 string 是不可变的，才可能使用 string pool。\n\n\n\n3. 安全性\n\nstring 经常作为参数，string 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 string 是可变的，那么在网络连接过程中，string 被改变，改变 string 的那一方以为现在连接的是其它主机，而实际情况却不一定是。\n\n4. 线程安全\n\nstring 不可变性天生具备线程安全，可以在多个线程中安全地使用。\n\nprogram creek : why string is immutable in java?(opens new window)\n\n\n# string, stringbuffer and stringbuilder\n\n1. 可变性\n\n * string 不可变\n * stringbuffer 和 stringbuilder 可变\n\n2. 线程安全\n\n * string 不可变，因此是线程安全的\n * stringbuilder 不是线程安全的\n * stringbuffer 是线程安全的，内部使用 synchronized 进行同步\n\nstackoverflow : string, stringbuffer, and stringbuilder(opens new window)\n\n\n# string pool\n\n字符串常量池（string pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 string 的 intern() 方法在运行过程将字符串添加到 string pool 中。\n\n当一个字符串调用 intern() 方法时，如果 string pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 string pool 中字符串的引用；否则，就会在 string pool 中添加一个新的字符串，并返回这个新字符串的引用。\n\n下面示例中，s1 和 s2 采用 new string() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 "aaa" 放到 string pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。\n\nstring s1 = new string("aaa");\nstring s2 = new string("aaa");\nsystem.out.println(s1 == s2);           // false\nstring s3 = s1.intern();\nstring s4 = s2.intern();\nsystem.out.println(s3 == s4);           // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果是采用 "bbb" 这种字面量的形式创建字符串，会自动地将字符串放入 string pool 中。\n\nstring s5 = "bbb";\nstring s6 = "bbb";\nsystem.out.println(s5 == s6);  // true\n\n\n1\n2\n3\n\n\n在 java 7 之前，string pool 被放在运行时常量池中，它属于永久代。而在 java 7，string pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 outofmemoryerror 错误。\n\n * stackoverflow : what is string interning?(opens new window)\n * 深入解析 string#intern(opens new window)\n\n\n# new string("abc")\n\n使用这种方式一共会创建两个字符串对象（前提是 string pool 中还没有 "abc" 字符串对象）。\n\n * "abc" 属于字符串字面量，因此编译时期会在 string pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量；\n * 而使用 new 的方式会在堆中创建一个字符串对象。\n\n创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。\n\npublic class newstringtest {\n    public static void main(string[] args) {\n        string s = new string("abc");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用 javap -verbose 进行反编译，得到以下内容：\n\n// ...\nconstant pool:\n// ...\n   #2 = class              #18            // java/lang/string\n   #3 = string             #19            // abc\n// ...\n  #18 = utf8               java/lang/string\n  #19 = utf8               abc\n// ...\n\n  public static void main(java.lang.string[]);\n    descriptor: ([ljava/lang/string;)v\n    flags: acc_public, acc_static\n    code:\n      stack=3, locals=2, args_size=1\n         0: new           #2                  // class java/lang/string\n         3: dup\n         4: ldc           #3                  // string abc\n         6: invokespecial #4                  // method java/lang/string."<init>":(ljava/lang/string;)v\n         9: astore_1\n// ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在 constant pool 中，#19 存储这字符串字面量 "abc"，#3 是 string pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 string pool 中的字符串对象作为 string 构造函数的参数。\n\n以下是 string 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。\n\npublic string(string original) {\n    this.value = original.value;\n    this.hash = original.hash;\n}\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 三、运算\n\n\n# 参数传递\n\njava 的参数是以值传递的形式传入方法中，而不是引用传递。\n\n以下代码中 dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。\n\npublic class dog {\n\n    string name;\n\n    dog(string name) {\n        this.name = name;\n    }\n\n    string getname() {\n        return this.name;\n    }\n\n    void setname(string name) {\n        this.name = name;\n    }\n\n    string getobjectaddress() {\n        return super.tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。\n\nclass passbyvalueexample {\n    public static void main(string[] args) {\n        dog dog = new dog("a");\n        func(dog);\n        system.out.println(dog.getname());          // b\n    }\n\n    private static void func(dog dog) {\n        dog.setname("b");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。\n\npublic class passbyvalueexample {\n    public static void main(string[] args) {\n        dog dog = new dog("a");\n        system.out.println(dog.getobjectaddress()); // dog@4554617c\n        func(dog);\n        system.out.println(dog.getobjectaddress()); // dog@4554617c\n        system.out.println(dog.getname());          // a\n    }\n\n    private static void func(dog dog) {\n        system.out.println(dog.getobjectaddress()); // dog@4554617c\n        dog = new dog("b");\n        system.out.println(dog.getobjectaddress()); // dog@74a14482\n        system.out.println(dog.getname());          // b\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nstackoverflow: is java “pass-by-reference” or “pass-by-value”?(opens new window)\n\n\n# float 与 double\n\njava 不能隐式执行向下转型，因为这会使得精度降低。\n\n1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。\n\n// float f = 1.1;\n\n\n1\n\n\n1.1f 字面量才是 float 类型。\n\nfloat f = 1.1f;\n\n\n1\n\n\n\n# 隐式类型转换\n\n因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。\n\nshort s1 = 1;\n// s1 = s1 + 1;\n\n\n1\n2\n\n\n但是使用 += 或者 ++ 运算符会执行隐式类型转换。\n\ns1 += 1;\ns1++;\n\n\n1\n2\n\n\n上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：\n\ns1 = (short) (s1 + 1);\n\n\n1\n\n\nstackoverflow : why don\'t java\'s +=, -=, *=, /= compound assignment operators require casting?(opens new window)\n\n\n# switch\n\n从 java 7 开始，可以在 switch 条件判断语句中使用 string 对象。\n\nstring s = "a";\nswitch (s) {\n    case "a":\n        system.out.println("aaa");\n        break;\n    case "b":\n        system.out.println("bbb");\n        break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nswitch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。\n\n// long x = 111;\n// switch (x) { // incompatible types. found: \'long\', required: \'char, byte, short, int, character, byte, short, integer, string, or an enum\'\n//     case 111:\n//         system.out.println(111);\n//         break;\n//     case 222:\n//         system.out.println(222);\n//         break;\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nstackoverflow : why can\'t your switch statement data type be long, java?(opens new window)\n\n\n# 四、关键字\n\n\n# final\n\n1. 数据\n\n声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。\n\n * 对于基本类型，final 使数值不变；\n * 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。\n\nfinal int x = 1;\n// x = 2;  // cannot assign value to final variable \'x\'\nfinal a y = new a();\ny.a = 1;\n\n\n1\n2\n3\n4\n\n\n2. 方法\n\n声明方法不能被子类重写。\n\nprivate 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。\n\n3. 类\n\n声明类不允许被继承。\n\n\n# static\n\n1. 静态变量\n\n * 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。\n * 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。\n\npublic class a {\n\n    private int x;         // 实例变量\n    private static int y;  // 静态变量\n\n    public static void main(string[] args) {\n        // int x = a.x;  // non-static field \'x\' cannot be referenced from a static context\n        a a = new a();\n        int x = a.x;\n        int y = a.y;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n2. 静态方法\n\n静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。\n\npublic abstract class a {\n    public static void func1(){\n    }\n    // public abstract static void func2();  // illegal combination of modifiers: \'abstract\' and \'static\'\n}\n\n\n1\n2\n3\n4\n5\n\n\n只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。\n\npublic class a {\n\n    private static int x;\n    private int y;\n\n    public static void func1(){\n        int a = x;\n        // int b = y;  // non-static field \'y\' cannot be referenced from a static context\n        // int b = this.y;     // \'a.this\' cannot be referenced from a static context\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n3. 静态语句块\n\n静态语句块在类初始化时运行一次。\n\npublic class a {\n    static {\n        system.out.println("123");\n    }\n\n    public static void main(string[] args) {\n        a a1 = new a();\n        a a2 = new a();\n    }\n}\n123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n4. 静态内部类\n\n非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。\n\npublic class outerclass {\n\n    class innerclass {\n    }\n\n    static class staticinnerclass {\n    }\n\n    public static void main(string[] args) {\n        // innerclass innerclass = new innerclass(); // \'outerclass.this\' cannot be referenced from a static context\n        outerclass outerclass = new outerclass();\n        innerclass innerclass = outerclass.new innerclass();\n        staticinnerclass staticinnerclass = new staticinnerclass();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n静态内部类不能访问外部类的非静态的变量和方法。\n\n5. 静态导包\n\n在使用静态变量和方法时不用再指明 classname，从而简化代码，但可读性大大降低。\n\nimport static com.xxx.classname.*\n\n\n1\n\n\n6. 初始化顺序\n\n静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。\n\npublic static string staticfield = "静态变量";\nstatic {\n    system.out.println("静态语句块");\n}\npublic string field = "实例变量";\n{\n    system.out.println("普通语句块");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n最后才是构造函数的初始化。\n\npublic initialordertest() {\n    system.out.println("构造函数");\n}\n\n\n1\n2\n3\n\n\n存在继承的情况下，初始化顺序为：\n\n * 父类（静态变量、静态语句块）\n * 子类（静态变量、静态语句块）\n * 父类（实例变量、普通语句块）\n * 父类（构造函数）\n * 子类（实例变量、普通语句块）\n * 子类（构造函数）\n\n\n# 五、object 通用方法\n\n\n# 概览\n\npublic native int hashcode()\n\npublic boolean equals(object obj)\n\nprotected native object clone() throws clonenotsupportedexception\n\npublic string tostring()\n\npublic final native class<?> getclass()\n\nprotected void finalize() throws throwable {}\n\npublic final native void notify()\n\npublic final native void notifyall()\n\npublic final native void wait(long timeout) throws interruptedexception\n\npublic final void wait(long timeout, int nanos) throws interruptedexception\n\npublic final void wait() throws interruptedexception\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# equals()\n\n1. 等价关系\n\n两个对象具有等价关系，需要满足以下五个条件：\n\nⅰ 自反性\n\nx.equals(x); // true\n\n\n1\n\n\nⅱ 对称性\n\nx.equals(y) == y.equals(x); // true\n\n\n1\n\n\nⅲ 传递性\n\nif (x.equals(y) && y.equals(z))\n    x.equals(z); // true;\n\n\n1\n2\n\n\nⅳ 一致性\n\n多次调用 equals() 方法结果不变\n\nx.equals(y) == x.equals(y); // true\n\n\n1\n\n\nⅴ 与 null 的比较\n\n对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false\n\nx.equals(null); // false;\n\n\n1\n\n\n2. 等价与相等\n\n * 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。\n * 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。\n\ninteger x = new integer(1);\ninteger y = new integer(1);\nsystem.out.println(x.equals(y)); // true\nsystem.out.println(x == y);      // false\n\n\n1\n2\n3\n4\n\n\n3. 实现\n\n * 检查是否为同一个对象的引用，如果是直接返回 true；\n * 检查是否是同一个类型，如果不是，直接返回 false；\n * 将 object 对象进行转型；\n * 判断每个关键域是否相等。\n\npublic class equalexample {\n\n    private int x;\n    private int y;\n    private int z;\n\n    public equalexample(int x, int y, int z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    @override\n    public boolean equals(object o) {\n        if (this == o) return true;\n        if (o == null || getclass() != o.getclass()) return false;\n\n        equalexample that = (equalexample) o;\n\n        if (x != that.x) return false;\n        if (y != that.y) return false;\n        return z == that.z;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# hashcode()\n\nhashcode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。\n\n在覆盖 equals() 方法时应当总是覆盖 hashcode() 方法，保证等价的两个对象哈希值也相等。\n\nhashset 和 hashmap 等集合类使用了 hashcode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashcode() 方法。\n\n下面的代码中，新建了两个等价的对象，并将它们添加到 hashset 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 equalexample 没有实现 hashcode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。\n\nequalexample e1 = new equalexample(1, 1, 1);\nequalexample e2 = new equalexample(1, 1, 1);\nsystem.out.println(e1.equals(e2)); // true\nhashset<equalexample> set = new hashset<>();\nset.add(e1);\nset.add(e2);\nsystem.out.println(set.size());   // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 r 进制的某一位，然后组成一个 r 进制的整数。\n\nr 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：31*x == (x<<5)-x，编译器会自动进行这个优化。\n\n@override\npublic int hashcode() {\n    int result = 17;\n    result = 31 * result + x;\n    result = 31 * result + y;\n    result = 31 * result + z;\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# tostring()\n\n默认返回 tostringexample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。\n\npublic class tostringexample {\n\n    private int number;\n\n    public tostringexample(int number) {\n        this.number = number;\n    }\n}\ntostringexample example = new tostringexample(123);\nsystem.out.println(example.tostring());\ntostringexample@4554617c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# clone()\n\n1. cloneable\n\nclone() 是 object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。\n\npublic class cloneexample {\n    private int a;\n    private int b;\n}\ncloneexample e1 = new cloneexample();\n// cloneexample e2 = e1.clone(); // \'clone()\' has protected access in \'java.lang.object\'\n\n\n1\n2\n3\n4\n5\n6\n\n\n重写 clone() 得到以下实现：\n\npublic class cloneexample {\n    private int a;\n    private int b;\n\n    @override\n    public cloneexample clone() throws clonenotsupportedexception {\n        return (cloneexample)super.clone();\n    }\n}\ncloneexample e1 = new cloneexample();\ntry {\n    cloneexample e2 = e1.clone();\n} catch (clonenotsupportedexception e) {\n    e.printstacktrace();\n}\njava.lang.clonenotsupportedexception: cloneexample\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n以上抛出了 clonenotsupportedexception，这是因为 cloneexample 没有实现 cloneable 接口。\n\n应该注意的是，clone() 方法并不是 cloneable 接口的方法，而是 object 的一个 protected 方法。cloneable 接口只是规定，如果一个类没有实现 cloneable 接口又调用了 clone() 方法，就会抛出 clonenotsupportedexception。\n\npublic class cloneexample implements cloneable {\n    private int a;\n    private int b;\n\n    @override\n    public object clone() throws clonenotsupportedexception {\n        return super.clone();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2. 浅拷贝\n\n拷贝对象和原始对象的引用类型引用同一个对象。\n\npublic class shallowcloneexample implements cloneable {\n\n    private int[] arr;\n\n    public shallowcloneexample() {\n        arr = new int[10];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = i;\n        }\n    }\n\n    public void set(int index, int value) {\n        arr[index] = value;\n    }\n\n    public int get(int index) {\n        return arr[index];\n    }\n\n    @override\n    protected shallowcloneexample clone() throws clonenotsupportedexception {\n        return (shallowcloneexample) super.clone();\n    }\n}\nshallowcloneexample e1 = new shallowcloneexample();\nshallowcloneexample e2 = null;\ntry {\n    e2 = e1.clone();\n} catch (clonenotsupportedexception e) {\n    e.printstacktrace();\n}\ne1.set(2, 222);\nsystem.out.println(e2.get(2)); // 222\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n3. 深拷贝\n\n拷贝对象和原始对象的引用类型引用不同对象。\n\npublic class deepcloneexample implements cloneable {\n\n    private int[] arr;\n\n    public deepcloneexample() {\n        arr = new int[10];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = i;\n        }\n    }\n\n    public void set(int index, int value) {\n        arr[index] = value;\n    }\n\n    public int get(int index) {\n        return arr[index];\n    }\n\n    @override\n    protected deepcloneexample clone() throws clonenotsupportedexception {\n        deepcloneexample result = (deepcloneexample) super.clone();\n        result.arr = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            result.arr[i] = arr[i];\n        }\n        return result;\n    }\n}\ndeepcloneexample e1 = new deepcloneexample();\ndeepcloneexample e2 = null;\ntry {\n    e2 = e1.clone();\n} catch (clonenotsupportedexception e) {\n    e.printstacktrace();\n}\ne1.set(2, 222);\nsystem.out.println(e2.get(2)); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n4. clone() 的替代方案\n\n使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。effective java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。\n\npublic class cloneconstructorexample {\n\n    private int[] arr;\n\n    public cloneconstructorexample() {\n        arr = new int[10];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = i;\n        }\n    }\n\n    public cloneconstructorexample(cloneconstructorexample original) {\n        arr = new int[original.arr.length];\n        for (int i = 0; i < original.arr.length; i++) {\n            arr[i] = original.arr[i];\n        }\n    }\n\n    public void set(int index, int value) {\n        arr[index] = value;\n    }\n\n    public int get(int index) {\n        return arr[index];\n    }\n}\ncloneconstructorexample e1 = new cloneconstructorexample();\ncloneconstructorexample e2 = new cloneconstructorexample(e1);\ne1.set(2, 222);\nsystem.out.println(e2.get(2)); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 六、继承\n\n\n# 访问权限\n\njava 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。\n\n可以对类或类中的成员（字段和方法）加上访问修饰符。\n\n * 类可见表示其它类可以用这个类创建实例对象。\n * 成员可见表示其它类可以用这个类的实例对象访问到该成员；\n\nprotected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。\n\n设计良好的模块会隐藏所有的实现细节，把它的 api 与它的实现清晰地隔离开来。模块之间只通过它们的 api 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。\n\n如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。\n\n字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，accessexample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。\n\npublic class accessexample {\n    public string id;\n}\n\n\n1\n2\n3\n\n\n可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。\n\npublic class accessexample {\n\n    private int id;\n\n    public string getid() {\n        return id + "";\n    }\n\n    public void setid(string id) {\n        this.id = integer.valueof(id);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。\n\npublic class accesswithinnerclassexample {\n\n    private class innerclass {\n        int x;\n    }\n\n    private innerclass innerclass;\n\n    public accesswithinnerclassexample() {\n        innerclass = new innerclass();\n    }\n\n    public int getvalue() {\n        return innerclass.x;  // 直接访问\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 抽象类与接口\n\n1. 抽象类\n\n抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。\n\n抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。\n\npublic abstract class abstractclassexample {\n\n    protected int x;\n    private int y;\n\n    public abstract void func1();\n\n    public void func2() {\n        system.out.println("func2");\n    }\n}\npublic class abstractextendclassexample extends abstractclassexample {\n    @override\n    public void func1() {\n        system.out.println("func1");\n    }\n}\n// abstractclassexample ac1 = new abstractclassexample(); // \'abstractclassexample\' is abstract; cannot be instantiated\nabstractclassexample ac2 = new abstractextendclassexample();\nac2.func1();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n2. 接口\n\n接口是抽象类的延伸，在 java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。\n\n从 java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。\n\n接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。\n\n接口的字段默认都是 static 和 final 的。\n\npublic interface interfaceexample {\n\n    void func1();\n\n    default void func2(){\n        system.out.println("func2");\n    }\n\n    int x = 123;\n    // int y;               // variable \'y\' might not have been initialized\n    public int z = 0;       // modifier \'public\' is redundant for interface fields\n    // private int k = 0;   // modifier \'private\' not allowed here\n    // protected int l = 0; // modifier \'protected\' not allowed here\n    // private void fun3(); // modifier \'private\' not allowed here\n}\npublic class interfaceimplementexample implements interfaceexample {\n    @override\n    public void func1() {\n        system.out.println("func1");\n    }\n}\n// interfaceexample ie1 = new interfaceexample(); // \'interfaceexample\' is abstract; cannot be instantiated\ninterfaceexample ie2 = new interfaceimplementexample();\nie2.func1();\nsystem.out.println(interfaceexample.x);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n3. 比较\n\n * 从设计层面上看，抽象类提供了一种 is-a 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 like-a 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 is-a 关系。\n * 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。\n * 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。\n * 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。\n\n4. 使用选择\n\n使用接口：\n\n * 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 comparable 接口中的 compareto() 方法；\n * 需要使用多重继承。\n\n使用抽象类：\n\n * 需要在几个相关的类中共享代码。\n * 需要能控制继承来的成员的访问权限，而不是都为 public。\n * 需要继承非静态和非常量字段。\n\n在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。\n\n * abstract methods and classes(opens new window)\n * 深入理解 abstract class 和 interface(opens new window)\n * when to use abstract class and interface(opens new window)\n * java 9 private methods in interfaces(opens new window)\n\n\n# super\n\n * 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。\n * 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。\n\npublic class superexample {\n\n    protected int x;\n    protected int y;\n\n    public superexample(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void func() {\n        system.out.println("superexample.func()");\n    }\n}\npublic class superextendexample extends superexample {\n\n    private int z;\n\n    public superextendexample(int x, int y, int z) {\n        super(x, y);\n        this.z = z;\n    }\n\n    @override\n    public void func() {\n        super.func();\n        system.out.println("superextendexample.func()");\n    }\n}\nsuperexample e = new superextendexample(1, 2, 3);\ne.func();\nsuperexample.func()\nsuperextendexample.func()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nusing the keyword super(opens new window)\n\n\n# 重写与重载\n\n1. 重写（override）\n\n存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。\n\n为了满足里式替换原则，重写有以下三个限制：\n\n * 子类方法的访问权限必须大于等于父类方法；\n * 子类方法的返回类型必须是父类方法返回类型或为其子类型。\n * 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。\n\n使用 @override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。\n\n下面的示例中，subclass 为 superclass 的子类，subclass 重写了 superclass 的 func() 方法。其中：\n\n * 子类方法访问权限为 public，大于父类的 protected。\n * 子类的返回类型为 arraylist<integer>，是父类返回类型 list<integer> 的子类。\n * 子类抛出的异常类型为 exception，是父类抛出异常 throwable 的子类。\n * 子类重写方法使用 @override 注解，从而让编译器自动检查是否满足限制条件。\n\nclass superclass {\n    protected list<integer> func() throws throwable {\n        return new arraylist<>();\n    }\n}\n\nclass subclass extends superclass {\n    @override\n    public arraylist<integer> func() throws exception {\n        return new arraylist<>();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：\n\n * this.func(this)\n * super.func(this)\n * this.func(super)\n * super.func(super)\n\n/*\n    a\n    |\n    b\n    |\n    c\n    |\n    d\n */\n\n\nclass a {\n\n    public void show(a obj) {\n        system.out.println("a.show(a)");\n    }\n\n    public void show(c obj) {\n        system.out.println("a.show(c)");\n    }\n}\n\nclass b extends a {\n\n    @override\n    public void show(a obj) {\n        system.out.println("b.show(a)");\n    }\n}\n\nclass c extends b {\n}\n\nclass d extends c {\n}\npublic static void main(string[] args) {\n\n    a a = new a();\n    b b = new b();\n    c c = new c();\n    d d = new d();\n\n    // 在 a 中存在 show(a obj)，直接调用\n    a.show(a); // a.show(a)\n    // 在 a 中不存在 show(b obj)，将 b 转型成其父类 a\n    a.show(b); // a.show(a)\n    // 在 b 中存在从 a 继承来的 show(c obj)，直接调用\n    b.show(c); // a.show(c)\n    // 在 b 中不存在 show(d obj)，但是存在从 a 继承来的 show(c obj)，将 d 转型成其父类 c\n    b.show(d); // a.show(c)\n\n    // 引用的还是 b 对象，所以 ba 和 b 的调用结果一样\n    a ba = new b();\n    ba.show(c); // a.show(c)\n    ba.show(d); // a.show(c)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n2. 重载（overload）\n\n存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。\n\n应该注意的是，返回值不同，其它都相同不算是重载。\n\nclass overloadingexample {\n    public void show(int x) {\n        system.out.println(x);\n    }\n\n    public void show(int x, string y) {\n        system.out.println(x + " " + y);\n    }\n}\npublic static void main(string[] args) {\n    overloadingexample example = new overloadingexample();\n    example.show(1);\n    example.show(1, "2");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 七、反射\n\n每个类都有一个 class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 class 对象。\n\n类加载相当于 class 对象的加载，类在第一次使用时才动态加载到 jvm 中。也可以使用 class.forname("com.mysql.jdbc.driver") 这种方式来控制类的加载，该方法会返回一个 class 对象。\n\n反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。\n\nclass 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：\n\n * field ：可以使用 get() 和 set() 方法读取和修改 field 对象关联的字段；\n * method ：可以使用 invoke() 方法调用与 method 对象关联的方法；\n * constructor ：可以用 constructor 的 newinstance() 创建新的对象。\n\n反射的优点：\n\n * 可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。\n * 类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 ide）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。\n * 调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 api 定义，以确保一组测试中有较高的代码覆盖率。\n\n反射的缺点：\n\n尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。\n\n * 性能开销 ：反射涉及了动态类型的解析，所以 jvm 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。\n * 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 applet，那么这就是个问题了。\n * 内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。\n * trail: the reflection api(opens new window)\n * 深入解析 java 反射（1）- 基础(opens new window)\n\n\n# 八、异常\n\nthrowable 可以用来表示任何可以作为异常抛出的类，分为两种： error 和 exception。其中 error 用来表示 jvm 无法处理的错误，exception 分为两种：\n\n * 受检异常 ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；\n * 非受检异常 ：是程序运行时错误，例如除 0 会引发 arithmetic exception，此时程序崩溃并且无法恢复。\n\n\n\n * java exception interview questions and answers(opens new window)\n * java提高篇——java 异常处理(opens new window)\n\n\n# 九、泛型\n\npublic class box<t> {\n    // t stands for "type"\n    private t t;\n    public void set(t t) { this.t = t; }\n    public t get() { return t; }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * java 泛型详解(opens new window)\n * 10 道 java 泛型面试题(opens new window)\n\n\n# 十、注解\n\njava 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。\n\n注解 annotation 实现原理与自定义注解例子(opens new window)\n\n\n# 十一、特性\n\n\n# java 各版本的新特性\n\nnew highlights in java se 8\n\n 1. lambda expressions\n 2. pipelines and streams\n 3. date and time api\n 4. default methods\n 5. type annotations\n 6. nashhorn javascript engine\n 7. concurrent accumulators\n 8. parallel operations\n 9. permgen error removed\n\nnew highlights in java se 7\n\n 1. strings in switch statement\n 2. type inference for generic instance creation\n 3. multiple exception handling\n 4. support for dynamic languages\n 5. try with resources\n 6. java nio package\n 7. binary literals, underscore in literals\n 8. diamond syntax\n\n * difference between java 1.8 and java 1.7?(opens new window)\n * java 8 特性(opens new window)\n\n\n# java 与 c++ 的区别\n\n * java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.object，c++ 为了兼容 c 即支持面向对象也支持面向过程。\n * java 通过虚拟机从而实现跨平台特性，但是 c++ 依赖于特定的平台。\n * java 没有指针，它的引用可以理解为安全指针，而 c++ 具有和 c 一样的指针。\n * java 支持自动垃圾回收，而 c++ 需要手动回收。\n * java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 c++ 支持多重继承。\n * java 不支持操作符重载，虽然可以对两个 string 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 c++ 可以。\n * java 的 goto 是保留字，但是不可用，c++ 可以使用 goto。\n\nwhat are the main differences between java and c++?(opens new window)\n\n\n# jre or jdk\n\n * jre：java runtime environment，java 运行环境的简称，为 java 的运行提供了所需的环境。它是一个 jvm 程序，主要包括了 jvm 的标准实现和一些 java 基本类库。\n * jdk：java development kit，java 开发工具包，提供了 java 的开发及运行环境。jdk 是 java 开发的核心，集成了 jre 以及一些其它的工具，比如编译 java 源码的编译器 javac 等。\n\n\n# 参考资料\n\n * eckel b. java 编程思想[m]. 机械工业出版社, 2002.\n * bloch j. effective java[m]. addison-wesley professional, 2017.\n\n',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Java 容器",frontmatter:{title:"Java 容器",date:"2022-02-03T19:02:23.000Z",permalink:"/pages/17acab/",categories:["面试","Java","Java基础"],tags:[null]},regularPath:"/35.%E9%9D%A2%E8%AF%95/05.Java/05.Java%E5%9F%BA%E7%A1%80/10.Java%20%E5%AE%B9%E5%99%A8.html",relativePath:"35.面试/05.Java/05.Java基础/10.Java 容器.md",key:"v-18cea7e8",path:"/pages/17acab/",headers:[{level:2,title:"Collection",slug:"collection",normalizedTitle:"collection",charIndex:15},{level:2,title:"1. Set",slug:"_1-set",normalizedTitle:"1. set",charIndex:100},{level:2,title:"2. List",slug:"_2-list",normalizedTitle:"2. list",charIndex:352},{level:2,title:"3. Queue",slug:"_3-queue",normalizedTitle:"3. queue",charIndex:505},{level:2,title:"Map",slug:"map",normalizedTitle:"map",charIndex:28},{level:2,title:"迭代器模式",slug:"迭代器模式",normalizedTitle:"迭代器模式",charIndex:884},{level:2,title:"适配器模式",slug:"适配器模式",normalizedTitle:"适配器模式",charIndex:1188},{level:2,title:"ArrayList",slug:"arraylist",normalizedTitle:"arraylist",charIndex:361},{level:3,title:"1. 概览",slug:"_1-概览",normalizedTitle:"1. 概览",charIndex:1615},{level:3,title:"2. 扩容",slug:"_2-扩容",normalizedTitle:"2. 扩容",charIndex:1891},{level:3,title:"3. 删除元素",slug:"_3-删除元素",normalizedTitle:"3. 删除元素",charIndex:3323},{level:3,title:"4. Fail-Fast",slug:"_4-fail-fast",normalizedTitle:"4. fail-fast",charIndex:3788},{level:3,title:"5. 序列化",slug:"_5-序列化",normalizedTitle:"5. 序列化",charIndex:4664},{level:2,title:"Vector",slug:"vector",normalizedTitle:"vector",charIndex:389},{level:3,title:"1. 同步",slug:"_1-同步",normalizedTitle:"1. 同步",charIndex:6446},{level:3,title:"2. 与 ArrayList 的比较",slug:"_2-与-arraylist-的比较",normalizedTitle:"2. 与 arraylist 的比较",charIndex:6852},{level:3,title:"3. 替代方案",slug:"_3-替代方案",normalizedTitle:"3. 替代方案",charIndex:7007},{level:2,title:"CopyOnWriteArrayList",slug:"copyonwritearraylist",normalizedTitle:"copyonwritearraylist",charIndex:7201},{level:3,title:"读写分离",slug:"读写分离",normalizedTitle:"读写分离",charIndex:7310},{level:3,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:8083},{level:2,title:"LinkedList",slug:"linkedlist",normalizedTitle:"linkedlist",charIndex:422},{level:3,title:"1. 概览",slug:"_1-概览-2",normalizedTitle:"1. 概览",charIndex:1615},{level:3,title:"2. 与 ArrayList 的比较",slug:"_2-与-arraylist-的比较-2",normalizedTitle:"2. 与 arraylist 的比较",charIndex:6852},{level:2,title:"HashMap",slug:"hashmap",normalizedTitle:"hashmap",charIndex:610},{level:3,title:"1. 存储结构",slug:"_1-存储结构",normalizedTitle:"1. 存储结构",charIndex:8707},{level:3,title:"2. 拉链法的工作原理",slug:"_2-拉链法的工作原理",normalizedTitle:"2. 拉链法的工作原理",charIndex:10208},{level:3,title:"3. put 操作",slug:"_3-put-操作",normalizedTitle:"3. put 操作",charIndex:10711},{level:3,title:"4. 确定桶下标",slug:"_4-确定桶下标",normalizedTitle:"4. 确定桶下标",charIndex:12654},{level:3,title:"5. 扩容-基本原理",slug:"_5-扩容-基本原理",normalizedTitle:"5. 扩容-基本原理",charIndex:13852},{level:3,title:"6. 扩容-重新计算桶下标",slug:"_6-扩容-重新计算桶下标",normalizedTitle:"6. 扩容-重新计算桶下标",charIndex:16052},{level:3,title:"7. 计算数组容量",slug:"_7-计算数组容量",normalizedTitle:"7. 计算数组容量",charIndex:16306},{level:3,title:"8. 链表转红黑树",slug:"_8-链表转红黑树",normalizedTitle:"8. 链表转红黑树",charIndex:16880},{level:3,title:"9. 与 HashTable 的比较",slug:"_9-与-hashtable-的比较",normalizedTitle:"9. 与 hashtable 的比较",charIndex:16936},{level:2,title:"ConcurrentHashMap",slug:"concurrenthashmap",normalizedTitle:"concurrenthashmap",charIndex:725},{level:3,title:"1. 存储结构",slug:"_1-存储结构-2",normalizedTitle:"1. 存储结构",charIndex:8707},{level:3,title:"2. size 操作",slug:"_2-size-操作",normalizedTitle:"2. size 操作",charIndex:18055},{level:3,title:"3. JDK 1.8 的改动",slug:"_3-jdk-1-8-的改动",normalizedTitle:"3. jdk 1.8 的改动",charIndex:20576},{level:2,title:"LinkedHashMap",slug:"linkedhashmap",normalizedTitle:"linkedhashmap",charIndex:812},{level:3,title:"存储结构",slug:"存储结构",normalizedTitle:"存储结构",charIndex:8710},{level:3,title:"afterNodeAccess()",slug:"afternodeaccess",normalizedTitle:"afternodeaccess()",charIndex:21377},{level:3,title:"afterNodeInsertion()",slug:"afternodeinsertion",normalizedTitle:"afternodeinsertion()",charIndex:22226},{level:3,title:"LRU 缓存",slug:"lru-缓存",normalizedTitle:"lru 缓存",charIndex:22923},{level:2,title:"WeakHashMap",slug:"weakhashmap",normalizedTitle:"weakhashmap",charIndex:23698},{level:3,title:"存储结构",slug:"存储结构-2",normalizedTitle:"存储结构",charIndex:8710},{level:3,title:"ConcurrentCache",slug:"concurrentcache",normalizedTitle:"concurrentcache",charIndex:23957},{level:3,title:"取模运算可以转换成位于运算内部原理分析:",slug:"取模运算可以转换成位于运算内部原理分析",normalizedTitle:"取模运算可以转换成位于运算内部原理分析:",charIndex:25411}],headersStr:"Collection 1. Set 2. List 3. Queue Map 迭代器模式 适配器模式 ArrayList 1. 概览 2. 扩容 3. 删除元素 4. Fail-Fast 5. 序列化 Vector 1. 同步 2. 与 ArrayList 的比较 3. 替代方案 CopyOnWriteArrayList 读写分离 适用场景 LinkedList 1. 概览 2. 与 ArrayList 的比较 HashMap 1. 存储结构 2. 拉链法的工作原理 3. put 操作 4. 确定桶下标 5. 扩容-基本原理 6. 扩容-重新计算桶下标 7. 计算数组容量 8. 链表转红黑树 9. 与 HashTable 的比较 ConcurrentHashMap 1. 存储结构 2. size 操作 3. JDK 1.8 的改动 LinkedHashMap 存储结构 afterNodeAccess() afterNodeInsertion() LRU 缓存 WeakHashMap 存储结构 ConcurrentCache 取模运算可以转换成位于运算内部原理分析:",content:'# 一、概览\n\n容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。\n\n\n# Collection\n\n\n\n\n# 1. Set\n\nTreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。\n\nHashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。\n\nLinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。\n\n\n# 2. List\n\nArrayList：基于动态数组实现，支持随机访问。\n\nVector：和 ArrayList 类似，但它是线程安全的。\n\nLinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。\n\n\n# 3. Queue\n\nLinkedList：可以用它来实现双向队列。\n\nPriorityQueue：基于堆结构实现，可以用它来实现优先队列。\n\n\n# Map\n\n\n\n * TreeMap：基于红黑树实现。\n\n * HashMap：基于哈希表实现。\n\n * HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。\n\n * LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。\n\n\n# 二、容器中的设计模式\n\n\n# 迭代器模式\n\n\n\nCollection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。\n\n从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。\n\nList<String> list = new ArrayList<>();\nlist.add("a");\nlist.add("b");\nfor (String item : list) {\n    System.out.println(item);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 适配器模式\n\njava.util.Arrays#asList() 可以把数组类型转换为 List 类型。\n\n@SafeVarargs\npublic static <T> List<T> asList(T... a)\n\n\n1\n2\n\n\n应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。\n\nInteger[] arr = {1, 2, 3};\nList list = Arrays.asList(arr);\n\n\n1\n2\n\n\n也可以使用以下方式调用 asList()：\n\nList list = Arrays.asList(1, 2, 3);\n\n\n1\n\n\n\n# 三、源码分析\n\n如果没有特别说明，以下源码分析基于 JDK 1.8。\n\n在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。\n\n\n# ArrayList\n\n\n# 1. 概览\n\n因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n\n\n1\n2\n\n\n数组的默认大小为 10。\n\nprivate static final int DEFAULT_CAPACITY = 10;\n\n\n1\n\n\n\n\n\n# 2. 扩容\n\n添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 oldCapacity + (oldCapacity >> 1)，也就是旧容量的 1.5 倍。\n\n扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。\n\npublic boolean add(E e) {\n    // size 为数组中当前元素数量\n    ensureCapacityInternal(size + 1); \n    elementData[size++] = e;\n    return true;\n}\nprivate void ensureCapacityInternal(int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    ensureExplicitCapacity(minCapacity);\n}\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++; // Increments modCount!!\n    // overflow-conscious code （针对溢出进行考虑的代码）\n    // 如果本次添加元素需要的最小数组容量比当前数组容量大，则需要进行扩容操作。\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\nprivate void grow(int minCapacity) {\n    // overflow-conscious code（针对溢出进行考虑的代码）\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    // 把当前数组元素复制到扩容后的新数组中\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3. 删除元素\n\n需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。\n\npublic E remove(int index) {\n    rangeCheck(index);\n    modCount++;\n    E oldValue = elementData(index);\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index, numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n    return oldValue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 4. Fail-Fast\n\nmodCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。\n\n在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。\n\nprivate void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException{\n    // 操作开始之前先保存初始modCount，操作结束后判断modCount是否改变\n    int expectedModCount = modCount;\n    // Write out element count, and any hidden stuff\n    s.defaultWriteObject();\n\n    // Write out size as capacity for behavioural compatibility with clone()\n    // 写入数组元素数量作为数组容量\n    s.writeInt(size);\n\n    // Write out all elements in the proper order.\n    // 只序列化有值的数组元素\n    for (int i=0; i<size; i++) {\n        s.writeObject(elementData[i]);\n    }\n\n    if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 5. 序列化\n\nArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。\n\n保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。\n\ntransient Object[] elementData; // non-private to simplify nested class access\n\n\n1\n\n\nArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。\n\nprivate void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n    elementData = EMPTY_ELEMENTDATA;\n\n    // Read in size, and any hidden stuff\n    s.defaultReadObject();\n\n    // Read in capacity\n    s.readInt(); // ignored\n\n    if (size > 0) {\n        // be like clone(), allocate array based upon size not capacity\n        ensureCapacityInternal(size);\n\n        Object[] a = elementData;\n        // Read in all elements in the proper order.\n        for (int i=0; i<size; i++) {\n            a[i] = s.readObject();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nprivate void writeObject(java.io.ObjectOutputStream s)    throws java.io.IOException{    // Write out element count, and any hidden stuff    int expectedModCount = modCount;    s.defaultWriteObject();    // Write out size as capacity for behavioural compatibility with clone()    s.writeInt(size);    // Write out all elements in the proper order.    for (int i=0; i<size; i++) {        s.writeObject(elementData[i]);    }    if (modCount != expectedModCount) {        throw new ConcurrentModificationException();    }}\n\n\n1\n\n\n序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。\n\nArrayList list = new ArrayList();\nObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));\noos.writeObject(list);\n\n\n1\n2\n3\n\n\n\n# Vector\n\n\n# 1. 同步\n\n它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。\n\npublic synchronized boolean add(E e) {\n    modCount++;\n    ensureCapacityHelper(elementCount + 1);\n    elementData[elementCount++] = e;\n    return true;\n}\n\npublic synchronized E get(int index) {\n    if (index >= elementCount)\n        throw new ArrayIndexOutOfBoundsException(index);\n\n    return elementData(index);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2. 与 ArrayList 的比较\n\nVector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制； Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。\n\n\n# 3. 替代方案\n\n可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。\n\nList<String> list = new ArrayList<>();List<String> synList = Collections.synchronizedList(list);\n\n\n1\n\n\n也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。\n\nList<String> list = new CopyOnWriteArrayList<>();\n\n\n1\n\n\n\n# CopyOnWriteArrayList\n\n\n# 读写分离\n\n写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。\n\n写操作需要加锁，防止并发写入时导致写入数据丢失。\n\n写操作结束之后需要把原始数组指向新的复制数组。\n\npublic boolean add(E e) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        // 得到原数组\n        Object[] elements = getArray();\n        // 得到原数组长度\n        int len = elements.length;\n        // 把原数组元素复制到一个新数组中，长度加一\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e;\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n\nfinal void setArray(Object[] a) {\n    // 新数组赋值给数组变量\n    array = a;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n@SuppressWarnings("unchecked")\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\n\n\n1\n2\n3\n4\n\n\n\n# 适用场景\n\nCopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。\n\n但是 CopyOnWriteArrayList 有其缺陷：\n\n * 内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；\n * 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。 所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。\n\n\n# LinkedList\n\n\n# 1. 概览\n\n基于双向链表实现，使用 Node 存储链表节点信息。\n\nprivate static class Node<E> {    E item;    Node<E> next;    Node<E> prev;}\n\n\n1\n\n\n每个链表存储了 first 和 last 指针：\n\ntransient Node<E> first;transient Node<E> last;\n\n\n1\n\n\n\n\n\n# 2. 与 ArrayList 的比较\n\n * ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；\n * ArrayList 支持随机访问，LinkedList 不支持；\n * LinkedList 在任意位置添加删除元素更快。\n\n\n# HashMap\n\n为了便于理解，以下源码分析以 JDK 1.7 为主。\n\n\n# 1. 存储结构\n\n内部包含了一个 Entry 类型的数组 table。\n\ntransient Entry[] table;\n\n\n1\n\n\nEntry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。\n\n\n\nstatic class Entry<K,V> implements Map.Entry<K,V> {\n    final K key;\n    V value;\n    Entry<K,V> next;\n    int hash;\n\n    Entry(int h, K k, V v, Entry<K,V> n) {\n        value = v;\n        next = n;\n        key = k;\n        hash = h;\n    }\n\n    public final K getKey() {\n        return key;\n    }\n\n    public final V getValue() {\n        return value;\n    }\n\n    public final V setValue(V newValue) {\n        V oldValue = value;\n        value = newValue;\n        return oldValue;\n    }\n\n    public final boolean equals(Object o) {\n        if (!(o instanceof Map.Entry))\n            return false;\n        Map.Entry e = (Map.Entry)o;\n        Object k1 = getKey();\n        Object k2 = e.getKey();\n        if (k1 == k2 || (k1 != null && k1.equals(k2))) {\n            Object v1 = getValue();\n            Object v2 = e.getValue();\n            if (v1 == v2 || (v1 != null && v1.equals(v2)))\n                return true;\n        }\n        return false;\n    }\n\n    public final int hashCode() {\n        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());\n    }\n\n    public final String toString() {\n        return getKey() + "=" + getValue();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 2. 拉链法的工作原理\n\nHashMap<String, String> map = new HashMap<>();\nmap.put("K1", "V1");\nmap.put("K2", "V2");\nmap.put("K3", "V3");\n\n\n1\n2\n3\n4\n\n\n新建一个 HashMap，默认大小为 16；\n\n * 插入 <K1,V1> 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。\n * 插入 <K2,V2> 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。\n * 插入 <K3,V3> 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 <K2,V2> 前面。 应该注意到链表的插入是以头插法方式进行的，例如上面的 <K3,V3> 不是插在 <K2,V2> 后面，而是插入在链表头部。\n\n查找需要分成两步进行：\n\n * 计算键值对所在的桶；\n * 在链表上顺序查找，时间复杂度显然和链表的长度成正比。\n\n\n\n\n# 3. put 操作\n\npublic V put(K key, V value) {\n    if (table == EMPTY_TABLE) {\n        inflateTable(threshold);\n    }\n    // 键为 null 单独处理\n    if (key == null)\n        return putForNullKey(value);\n    int hash = hash(key);\n    // 确定桶下标\n    int i = indexFor(hash, table.length);\n    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n\n    modCount++;\n    // 插入新键值对\n    addEntry(hash, key, value, i);\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nHashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。\n\nprivate V putForNullKey(V value) {    for (Entry<K,V> e = table[0]; e != null; e = e.next) {        if (e.key == null) {            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        }    }    modCount++;    addEntry(0, null, value, 0);    return null;}\n\n\n1\n\n\n使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。\n\nvoid addEntry(int hash, K key, V value, int bucketIndex) {    // 键值对数量超过临界值并且hash到的桶位置已经有元素存放时，进行扩容操作。    if ((size >= threshold) && (null != table[bucketIndex])) {        resize(2 * table.length);        // 计算hash值        hash = (null != key) ? hash(key) : 0;        // 计算桶位置        bucketIndex = indexFor(hash, table.length);    }    createEntry(hash, key, value, bucketIndex);}void createEntry(int hash, K key, V value, int bucketIndex) {    // 得到目标桶位置链表头元素    Entry<K,V> e = table[bucketIndex];    // 头插法体现    table[bucketIndex] = new Entry<>(hash, key, value, e);    size++;}\n\n\n1\n\n\nEntry(int h, K k, V v, Entry<K,V> n) {    value = v;    next = n;    key = k;    hash = h;}\n\n\n1\n\n\n\n# 4. 确定桶下标\n\n很多操作都需要先确定一个键值对所在的桶下标。\n\nint hash = hash(key);\nint i = indexFor(hash, table.length);\n\n\n1\n2\n\n\n# 4.1 计算 hash 值\n\nfinal int hash(Object k) {\n    int h = hashSeed;\n    if (0 != h && k instanceof String) {\n        return sun.misc.Hashing.stringHash32((String) k);\n    }\n\n    h ^= k.hashCode();\n\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\npublic final int hashCode() {\n    return Objects.hashCode(key) ^ Objects.hashCode(value);\n}\n\n\n1\n2\n3\n\n\n# 4.2 取模\n\n令 x = 1<<4，即 x 为 2 的 4 次方，它具有以下性质：\n\nx   : 00010000\nx-1 : 00001111\n\n\n1\n2\n\n\n令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：\n\ny       : 10110010\nx-1     : 00001111\ny&(x-1) : 00000010\n\n\n1\n2\n3\n\n\n这个性质和 y 对 x 取模效果是一样的：\n\ny   : 10110010\nx   : 00010000\ny%x : 00000010\n\n\n1\n2\n3\n\n\n我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。\n\n确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。\n\nstatic int indexFor(int h, int length) {\n    return h & (length-1);\n}\n\n\n1\n2\n3\n\n\n\n# 5. 扩容-基本原理\n\n设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。\n\n为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。\n\n和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。\n\n参数           含义\ncapacity     table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。\nsize         键值对数量。\nthreshold    size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。\nloadFactor   装载因子，table 能够使用的比例，threshold = capacity * loadFactor。\n\nstatic final int DEFAULT_INITIAL_CAPACITY = 16;static final int MAXIMUM_CAPACITY = 1 << 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;transient Entry[] table;transient int size;int threshold;final float loadFactor;transient int modCount;\n\n\n1\n\n\n从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。\n\nvoid addEntry(int hash, K key, V value, int bucketIndex) {    Entry<K,V> e = table[bucketIndex];    table[bucketIndex] = new Entry<>(hash, key, value, e);    if (size++ >= threshold)        resize(2 * table.length);}\n\n\n1\n\n\n扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。\n\nvoid resize(int newCapacity) {    Entry[] oldTable = table;    int oldCapacity = oldTable.length;    if (oldCapacity == MAXIMUM_CAPACITY) {        threshold = Integer.MAX_VALUE;        return;    }    // 构造新的Entry数组，容量为newCapacity（2倍于原容量）    Entry[] newTable = new Entry[newCapacity];    // 把旧Entry数组里的元素移动到新Entry数组里    transfer(newTable);    // 数组变量指向新Entry数组    table = newTable;    threshold = (int)(newCapacity * loadFactor);}void transfer(Entry[] newTable) {    // 得到原 Entry 数组    Entry[] src = table;    int newCapacity = newTable.length;    // 两层循环分别遍历原数组以及原数组元素中的Entry链表    for (int j = 0; j < src.length; j++) {        Entry<K,V> e = src[j];        if (e != null) {            // clear to let GC do its work            src[j] = null;            do {                Entry<K,V> next = e.next;                // 根据hash值和新数组容量计算出散列到新数组中的桶的位置                int i = indexFor(e.hash, newCapacity);                // 下面两步是头插法                e.next = newTable[i];                newTable[i] = e;                // 指向链表中下一元素，进行下一次循环处理                e = next;            } while (e != null);        }    }}\n\n\n1\n\n\n\n# 6. 扩容-重新计算桶下标\n\n在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。\n\n假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：\n\ncapacity     : 00010000new capacity : 00100000\n\n\n1\n\n\n对于一个 Key，\n\n * 它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；\n * 如果为 1，那么得到的结果为原来的结果 +16。\n\n\n# 7. 计算数组容量\n\nHashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。\n\n先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：\n\nmask |= mask >> 1    11011000mask |= mask >> 2    11111110mask |= mask >> 4    11111111\n\n\n1\n\n\nmask+1 是大于原始数字的最小的 2 的 n 次方。\n\nnum     10010000\nmask+1 100000000\n\n\n1\n2\n\n\n以下是 HashMap 中计算数组容量的代码：\n\nstatic final int tableSizeFor(int cap) {\n    int n = cap - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 8. 链表转红黑树\n\n从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。\n\n\n# 9. 与 HashTable 的比较\n\n * HashTable 使用 synchronized 来进行同步。\n * HashMap 可以插入键为 null 的 Entry。\n * HashMap 的迭代器是 fail-fast 迭代器。\n * HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。\n\n\n# ConcurrentHashMap\n\n\n# 1. 存储结构\n\nstatic final class HashEntry<K,V> {\n    final int hash;\n    final K key;\n    volatile V value;\n    volatile HashEntry<K,V> next;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。\n\nSegment 继承自 ReentrantLock。\n\nstatic final class Segment<K,V> extends ReentrantLock implements Serializable {\n\n    private static final long serialVersionUID = 2249069246763182397L;\n\n    static final int MAX_SCAN_RETRIES =\n        Runtime.getRuntime().availableProcessors() > 1 ? 64 : 1;\n\n    transient volatile HashEntry<K,V>[] table;\n\n    transient int count;\n\n    transient int modCount;\n\n    transient int threshold;\n\n    final float loadFactor;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nfinal Segment<K,V>[] segments;\n\n\n1\n\n\n默认的并发级别为 16，也就是说默认创建 16 个 Segment。\n\nstatic final int DEFAULT_CONCURRENCY_LEVEL = 16;\n\n\n1\n\n\n\n\n\n# 2. size 操作\n\n每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。\n\n/**\n * The number of elements. Accessed only either within locks\n * or among other volatile reads that maintain visibility.\n */\ntransient int count;\n\n\n1\n2\n3\n4\n5\n\n\n在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。\n\nConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。\n\n尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。\n\n如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。\n\n/**\n * Number of unsynchronized retries in size and containsValue\n * methods before resorting to locking. This is used to avoid\n * unbounded retries if tables undergo continuous modification\n * which would make it impossible to obtain an accurate result.\n * 译：在锁定之前，size方法和containsValue方法中不同步重试的次数。\n * 这样做是为了避免在表不断修改的情况下进行无界重试，因为修改会导致无法获得准确的结果。\n */\nstatic final int RETRIES_BEFORE_LOCK = 2;\n\npublic int size() {\n    // Try a few times to get accurate count. On failure due to\n    // continuous async changes in table, resort to locking.\n    // 试几次，以获得准确的计数。由于表中的连续异步更改而导致失败时，请使用锁定。\n    final Segment<K,V>[] segments = this.segments;\n    int size;\n    boolean overflow; // true if size overflows 32 bits\n    long sum;         // sum of modCounts\n    long last = 0L;   // previous sum(即上一次得到的count结果值)\n    int retries = -1; // first iteration isn\'t retry\n    try {\n        for (;;) {\n            // 超过尝试次数，则对每个 Segment 加锁\n            if (retries++ == RETRIES_BEFORE_LOCK) {\n                for (int j = 0; j < segments.length; ++j)\n                    ensureSegment(j).lock(); // force creation\n            }\n            sum = 0L;\n            size = 0;\n            overflow = false;\n            for (int j = 0; j < segments.length; ++j) {\n                Segment<K,V> seg = segmentAt(segments, j);\n                if (seg != null) {\n                    sum += seg.modCount;\n                    // 下面两步是位溢出判断操作\n                    int c = seg.count;\n                    if (c < 0 || (size += c) < 0)\n                        overflow = true;\n                }\n            }\n            // 连续两次得到的结果一致，则认为这个结果是正确的\n            if (sum == last)\n                break;\n            last = sum;\n        }\n    } finally {\n        if (retries > RETRIES_BEFORE_LOCK) {\n            for (int j = 0; j < segments.length; ++j)\n                segmentAt(segments, j).unlock();\n        }\n    }\n    return overflow ? Integer.MAX_VALUE : size;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 3. JDK 1.8 的改动\n\nJDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock， 并发度与 Segment数量相等。\n\nJDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。\n\n并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。\n\n\n# LinkedHashMap\n\n\n# 存储结构\n\n继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。\n\npublic class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>\n\n\n1\n\n\n内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。\n\n/**\n * The head (eldest) of the doubly linked list.\n */\ntransient LinkedHashMap.Entry<K,V> head;\n\n/**\n * The tail (youngest) of the doubly linked list.\n */\ntransient LinkedHashMap.Entry<K,V> tail;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\naccessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。\n\nfinal boolean accessOrder;\n\n\n1\n\n\nLinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。\n\nvoid afterNodeAccess(Node<K,V> p) { }\nvoid afterNodeInsertion(boolean evict) { }\n\n\n1\n2\n\n\n\n# afterNodeAccess()\n\n当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。\n\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n    LinkedHashMap.Entry<K,V> last;\n    // LRU && 访问的元素非尾元素\n    if (accessOrder && (last = tail) != e) {\n        LinkedHashMap.Entry<K,V> p =\n            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n        p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a != null)\n            a.before = b;\n        else\n            last = b;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modCount;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n\n# afterNodeInsertion()\n\n在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。\n\nevict 只有在构建 Map 的时候才为 false，在这里为 true。\n\nvoid afterNodeInsertion(boolean evict) { // possibly remove eldest\n    LinkedHashMap.Entry<K,V> first;\n    // 头部节点 != null && removeEldestEntry方法返回true\n    if (evict && (first = head) != null && removeEldestEntry(first)) {\n        K key = first.key;\n        removeNode(hash(key), key, null, false, true);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nremoveEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。\n\nprotected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n    return false;\n}\n\n\n1\n2\n3\n\n\n\n# LRU 缓存\n\n以下是使用 LinkedHashMap 实现的一个 LRU 缓存：\n\n设定最大缓存空间 MAX_ENTRIES 为 3； 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序； 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。\n\nclass LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private static final int MAX_ENTRIES = 3;\n\n    protected boolean removeEldestEntry(Map.Entry eldest) {\n        return size() > MAX_ENTRIES;\n    }\n\n    LRUCache() {\n        super(MAX_ENTRIES, 0.75f, true);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\npublic static void main(String[] args) {\n    LRUCache<Integer, String> cache = new LRUCache<>();\n    cache.put(1, "a");\n    cache.put(2, "b");\n    cache.put(3, "c");\n    cache.get(1);\n    cache.put(4, "d");\n    System.out.println(cache.keySet());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n[3, 1, 4]\n\n\n1\n\n\n\n# WeakHashMap\n\n\n# 存储结构\n\nWeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。\n\nWeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。\n\nprivate static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V>\n\n\n1\n\n\n\n# ConcurrentCache\n\nTomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。\n\nConcurrentCache 采取的是分代缓存：\n\n * 经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；\n * 不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。\n * 当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。\n * 当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。\n\npublic final class ConcurrentCache<K, V> {\n\n    private final int size;\n\n    private final Map<K, V> eden;\n\n    private final Map<K, V> longterm;\n\n    public ConcurrentCache(int size) {\n        this.size = size;\n        this.eden = new ConcurrentHashMap<>(size);\n        this.longterm = new WeakHashMap<>(size);\n    }\n\n    public V get(K k) {\n        V v = this.eden.get(k);\n        if (v == null) {\n            v = this.longterm.get(k);\n            if (v != null)\n                this.eden.put(k, v);\n        }\n        return v;\n    }\n\n    public void put(K k, V v) {\n        if (this.eden.size() >= size) {\n            this.longterm.putAll(this.eden);\n            this.eden.clear();\n        }\n        this.eden.put(k, v);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n----------------------------------------\n\n参考：\n\n * 漫画：什么是HashMap？\n\n关键点\n\n * 为什么采用头插法？\n\n> HashMap的发明者认为，后插入的Entry被查找的可能性更大。\n\n * HashMap的默认初始长度是16，并且每次自动扩展或手动初始化时，长度必须是2的幂，为什么？\n\n> 之所以选择16，是为了可以将求模运算转换成位于运算，提高hash效率\n\n\n# 取模运算可以转换成位于运算内部原理分析:\n\n假设一个key的hashcode为56，table容量为16，正常取模后余数为8，即放到索引为8的桶中。\n\n如果采用位于运算：hashcode & ( length - 1 )\n\n56 二进制为：111000\n\n16 - 1 二进制为：1111\n\n  111000\n& 001111\n--------\n  001000\n\n\n1\n2\n3\n4\n\n\n结果也是8\n\n位于运算可以保证均匀分布的原因是：一个key的hashcode 和 16 -1 = 15 进行位与运算，因为15的后四位都是1，1和谁与结果就是谁，前面位数全是0，0和谁与结果都是0，所以计算后的结果就是hashcode的后四位且小于等于15，而所有key的hashcode都是随机的，后四位也是随机的（整体随机，局部也随机），可以保证结果为随机均匀分布。',normalizedContent:'# 一、概览\n\n容器主要包括 collection 和 map 两种，collection 存储着对象的集合，而 map 存储着键值对（两个对象）的映射表。\n\n\n# collection\n\n\n\n\n# 1. set\n\ntreeset：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 hashset，hashset 查找的时间复杂度为 o(1)，treeset 则为 o(logn)。\n\nhashset：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 iterator 遍历 hashset 得到的结果是不确定的。\n\nlinkedhashset：具有 hashset 的查找效率，且内部使用双向链表维护元素的插入顺序。\n\n\n# 2. list\n\narraylist：基于动态数组实现，支持随机访问。\n\nvector：和 arraylist 类似，但它是线程安全的。\n\nlinkedlist：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，linkedlist 还可以用作栈、队列和双向队列。\n\n\n# 3. queue\n\nlinkedlist：可以用它来实现双向队列。\n\npriorityqueue：基于堆结构实现，可以用它来实现优先队列。\n\n\n# map\n\n\n\n * treemap：基于红黑树实现。\n\n * hashmap：基于哈希表实现。\n\n * hashtable：和 hashmap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 hashtable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 concurrenthashmap 来支持线程安全，并且 concurrenthashmap 的效率会更高，因为 concurrenthashmap 引入了分段锁。\n\n * linkedhashmap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（lru）顺序。\n\n\n# 二、容器中的设计模式\n\n\n# 迭代器模式\n\n\n\ncollection 继承了 iterable 接口，其中的 iterator() 方法能够产生一个 iterator 对象，通过这个对象就可以迭代遍历 collection 中的元素。\n\n从 jdk 1.5 之后可以使用 foreach 方法来遍历实现了 iterable 接口的聚合对象。\n\nlist<string> list = new arraylist<>();\nlist.add("a");\nlist.add("b");\nfor (string item : list) {\n    system.out.println(item);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 适配器模式\n\njava.util.arrays#aslist() 可以把数组类型转换为 list 类型。\n\n@safevarargs\npublic static <t> list<t> aslist(t... a)\n\n\n1\n2\n\n\n应该注意的是 aslist() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。\n\ninteger[] arr = {1, 2, 3};\nlist list = arrays.aslist(arr);\n\n\n1\n2\n\n\n也可以使用以下方式调用 aslist()：\n\nlist list = arrays.aslist(1, 2, 3);\n\n\n1\n\n\n\n# 三、源码分析\n\n如果没有特别说明，以下源码分析基于 jdk 1.8。\n\n在 idea 中 double shift 调出 search everywhere，查找源码文件，找到之后就可以阅读源码。\n\n\n# arraylist\n\n\n# 1. 概览\n\n因为 arraylist 是基于数组实现的，所以支持快速随机访问。randomaccess 接口标识着该类支持快速随机访问。\n\npublic class arraylist<e> extends abstractlist<e>\n        implements list<e>, randomaccess, cloneable, java.io.serializable\n\n\n1\n2\n\n\n数组的默认大小为 10。\n\nprivate static final int default_capacity = 10;\n\n\n1\n\n\n\n\n\n# 2. 扩容\n\n添加元素时使用 ensurecapacityinternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 oldcapacity + (oldcapacity >> 1)，也就是旧容量的 1.5 倍。\n\n扩容操作需要调用 arrays.copyof() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 arraylist 对象时就指定大概的容量大小，减少扩容操作的次数。\n\npublic boolean add(e e) {\n    // size 为数组中当前元素数量\n    ensurecapacityinternal(size + 1); \n    elementdata[size++] = e;\n    return true;\n}\nprivate void ensurecapacityinternal(int mincapacity) {\n    if (elementdata == defaultcapacity_empty_elementdata) {\n        mincapacity = math.max(default_capacity, mincapacity);\n    }\n    ensureexplicitcapacity(mincapacity);\n}\nprivate void ensureexplicitcapacity(int mincapacity) {\n    modcount++; // increments modcount!!\n    // overflow-conscious code （针对溢出进行考虑的代码）\n    // 如果本次添加元素需要的最小数组容量比当前数组容量大，则需要进行扩容操作。\n    if (mincapacity - elementdata.length > 0)\n        grow(mincapacity);\n}\nprivate void grow(int mincapacity) {\n    // overflow-conscious code（针对溢出进行考虑的代码）\n    int oldcapacity = elementdata.length;\n    int newcapacity = oldcapacity + (oldcapacity >> 1);\n    if (newcapacity - mincapacity < 0)\n        newcapacity = mincapacity;\n    if (newcapacity - max_array_size > 0)\n        newcapacity = hugecapacity(mincapacity);\n    // mincapacity is usually close to size, so this is a win:\n    // 把当前数组元素复制到扩容后的新数组中\n    elementdata = arrays.copyof(elementdata, newcapacity);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3. 删除元素\n\n需要调用 system.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 o(n)，可以看出 arraylist 删除元素的代价是非常高的。\n\npublic e remove(int index) {\n    rangecheck(index);\n    modcount++;\n    e oldvalue = elementdata(index);\n    int nummoved = size - index - 1;\n    if (nummoved > 0)\n        system.arraycopy(elementdata, index+1, elementdata, index, nummoved);\n    elementdata[--size] = null; // clear to let gc do its work\n    return oldvalue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 4. fail-fast\n\nmodcount 用来记录 arraylist 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。\n\n在进行序列化或者迭代等操作时，需要比较操作前后 modcount 是否改变，如果改变了需要抛出 concurrentmodificationexception。\n\nprivate void writeobject(java.io.objectoutputstream s)\n    throws java.io.ioexception{\n    // 操作开始之前先保存初始modcount，操作结束后判断modcount是否改变\n    int expectedmodcount = modcount;\n    // write out element count, and any hidden stuff\n    s.defaultwriteobject();\n\n    // write out size as capacity for behavioural compatibility with clone()\n    // 写入数组元素数量作为数组容量\n    s.writeint(size);\n\n    // write out all elements in the proper order.\n    // 只序列化有值的数组元素\n    for (int i=0; i<size; i++) {\n        s.writeobject(elementdata[i]);\n    }\n\n    if (modcount != expectedmodcount) {\n        throw new concurrentmodificationexception();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 5. 序列化\n\narraylist 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。\n\n保存元素的数组 elementdata 使用 transient 修饰，该关键字声明数组默认不会被序列化。\n\ntransient object[] elementdata; // non-private to simplify nested class access\n\n\n1\n\n\narraylist 实现了 writeobject() 和 readobject() 来控制只序列化数组中有元素填充那部分内容。\n\nprivate void readobject(java.io.objectinputstream s)\n    throws java.io.ioexception, classnotfoundexception {\n    elementdata = empty_elementdata;\n\n    // read in size, and any hidden stuff\n    s.defaultreadobject();\n\n    // read in capacity\n    s.readint(); // ignored\n\n    if (size > 0) {\n        // be like clone(), allocate array based upon size not capacity\n        ensurecapacityinternal(size);\n\n        object[] a = elementdata;\n        // read in all elements in the proper order.\n        for (int i=0; i<size; i++) {\n            a[i] = s.readobject();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nprivate void writeobject(java.io.objectoutputstream s)    throws java.io.ioexception{    // write out element count, and any hidden stuff    int expectedmodcount = modcount;    s.defaultwriteobject();    // write out size as capacity for behavioural compatibility with clone()    s.writeint(size);    // write out all elements in the proper order.    for (int i=0; i<size; i++) {        s.writeobject(elementdata[i]);    }    if (modcount != expectedmodcount) {        throw new concurrentmodificationexception();    }}\n\n\n1\n\n\n序列化时需要使用 objectoutputstream 的 writeobject() 将对象转换为字节流并输出。而 writeobject() 方法在传入的对象存在 writeobject() 的时候会去反射调用该对象的 writeobject() 来实现序列化。反序列化使用的是 objectinputstream 的 readobject() 方法，原理类似。\n\narraylist list = new arraylist();\nobjectoutputstream oos = new objectoutputstream(new fileoutputstream(file));\noos.writeobject(list);\n\n\n1\n2\n3\n\n\n\n# vector\n\n\n# 1. 同步\n\n它的实现与 arraylist 类似，但是使用了 synchronized 进行同步。\n\npublic synchronized boolean add(e e) {\n    modcount++;\n    ensurecapacityhelper(elementcount + 1);\n    elementdata[elementcount++] = e;\n    return true;\n}\n\npublic synchronized e get(int index) {\n    if (index >= elementcount)\n        throw new arrayindexoutofboundsexception(index);\n\n    return elementdata(index);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2. 与 arraylist 的比较\n\nvector 是同步的，因此开销就比 arraylist 要大，访问速度更慢。最好使用 arraylist 而不是 vector，因为同步操作完全可以由程序员自己来控制； vector 每次扩容请求其大小的 2 倍空间，而 arraylist 是 1.5 倍。\n\n\n# 3. 替代方案\n\n可以使用 collections.synchronizedlist(); 得到一个线程安全的 arraylist。\n\nlist<string> list = new arraylist<>();list<string> synlist = collections.synchronizedlist(list);\n\n\n1\n\n\n也可以使用 concurrent 并发包下的 copyonwritearraylist 类。\n\nlist<string> list = new copyonwritearraylist<>();\n\n\n1\n\n\n\n# copyonwritearraylist\n\n\n# 读写分离\n\n写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。\n\n写操作需要加锁，防止并发写入时导致写入数据丢失。\n\n写操作结束之后需要把原始数组指向新的复制数组。\n\npublic boolean add(e e) {\n    final reentrantlock lock = this.lock;\n    lock.lock();\n    try {\n        // 得到原数组\n        object[] elements = getarray();\n        // 得到原数组长度\n        int len = elements.length;\n        // 把原数组元素复制到一个新数组中，长度加一\n        object[] newelements = arrays.copyof(elements, len + 1);\n        newelements[len] = e;\n        setarray(newelements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n\nfinal void setarray(object[] a) {\n    // 新数组赋值给数组变量\n    array = a;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n@suppresswarnings("unchecked")\nprivate e get(object[] a, int index) {\n    return (e) a[index];\n}\n\n\n1\n2\n3\n4\n\n\n\n# 适用场景\n\ncopyonwritearraylist 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。\n\n但是 copyonwritearraylist 有其缺陷：\n\n * 内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；\n * 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。 所以 copyonwritearraylist 不适合内存敏感以及对实时性要求很高的场景。\n\n\n# linkedlist\n\n\n# 1. 概览\n\n基于双向链表实现，使用 node 存储链表节点信息。\n\nprivate static class node<e> {    e item;    node<e> next;    node<e> prev;}\n\n\n1\n\n\n每个链表存储了 first 和 last 指针：\n\ntransient node<e> first;transient node<e> last;\n\n\n1\n\n\n\n\n\n# 2. 与 arraylist 的比较\n\n * arraylist 基于动态数组实现，linkedlist 基于双向链表实现；\n * arraylist 支持随机访问，linkedlist 不支持；\n * linkedlist 在任意位置添加删除元素更快。\n\n\n# hashmap\n\n为了便于理解，以下源码分析以 jdk 1.7 为主。\n\n\n# 1. 存储结构\n\n内部包含了一个 entry 类型的数组 table。\n\ntransient entry[] table;\n\n\n1\n\n\nentry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。hashmap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 entry。\n\n\n\nstatic class entry<k,v> implements map.entry<k,v> {\n    final k key;\n    v value;\n    entry<k,v> next;\n    int hash;\n\n    entry(int h, k k, v v, entry<k,v> n) {\n        value = v;\n        next = n;\n        key = k;\n        hash = h;\n    }\n\n    public final k getkey() {\n        return key;\n    }\n\n    public final v getvalue() {\n        return value;\n    }\n\n    public final v setvalue(v newvalue) {\n        v oldvalue = value;\n        value = newvalue;\n        return oldvalue;\n    }\n\n    public final boolean equals(object o) {\n        if (!(o instanceof map.entry))\n            return false;\n        map.entry e = (map.entry)o;\n        object k1 = getkey();\n        object k2 = e.getkey();\n        if (k1 == k2 || (k1 != null && k1.equals(k2))) {\n            object v1 = getvalue();\n            object v2 = e.getvalue();\n            if (v1 == v2 || (v1 != null && v1.equals(v2)))\n                return true;\n        }\n        return false;\n    }\n\n    public final int hashcode() {\n        return objects.hashcode(getkey()) ^ objects.hashcode(getvalue());\n    }\n\n    public final string tostring() {\n        return getkey() + "=" + getvalue();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 2. 拉链法的工作原理\n\nhashmap<string, string> map = new hashmap<>();\nmap.put("k1", "v1");\nmap.put("k2", "v2");\nmap.put("k3", "v3");\n\n\n1\n2\n3\n4\n\n\n新建一个 hashmap，默认大小为 16；\n\n * 插入 <k1,v1> 键值对，先计算 k1 的 hashcode 为 115，使用除留余数法得到所在的桶下标 115%16=3。\n * 插入 <k2,v2> 键值对，先计算 k2 的 hashcode 为 118，使用除留余数法得到所在的桶下标 118%16=6。\n * 插入 <k3,v3> 键值对，先计算 k3 的 hashcode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 <k2,v2> 前面。 应该注意到链表的插入是以头插法方式进行的，例如上面的 <k3,v3> 不是插在 <k2,v2> 后面，而是插入在链表头部。\n\n查找需要分成两步进行：\n\n * 计算键值对所在的桶；\n * 在链表上顺序查找，时间复杂度显然和链表的长度成正比。\n\n\n\n\n# 3. put 操作\n\npublic v put(k key, v value) {\n    if (table == empty_table) {\n        inflatetable(threshold);\n    }\n    // 键为 null 单独处理\n    if (key == null)\n        return putfornullkey(value);\n    int hash = hash(key);\n    // 确定桶下标\n    int i = indexfor(hash, table.length);\n    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value\n    for (entry<k,v> e = table[i]; e != null; e = e.next) {\n        object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            v oldvalue = e.value;\n            e.value = value;\n            e.recordaccess(this);\n            return oldvalue;\n        }\n    }\n\n    modcount++;\n    // 插入新键值对\n    addentry(hash, key, value, i);\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nhashmap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashcode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。hashmap 使用第 0 个桶存放键为 null 的键值对。\n\nprivate v putfornullkey(v value) {    for (entry<k,v> e = table[0]; e != null; e = e.next) {        if (e.key == null) {            v oldvalue = e.value;            e.value = value;            e.recordaccess(this);            return oldvalue;        }    }    modcount++;    addentry(0, null, value, 0);    return null;}\n\n\n1\n\n\n使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。\n\nvoid addentry(int hash, k key, v value, int bucketindex) {    // 键值对数量超过临界值并且hash到的桶位置已经有元素存放时，进行扩容操作。    if ((size >= threshold) && (null != table[bucketindex])) {        resize(2 * table.length);        // 计算hash值        hash = (null != key) ? hash(key) : 0;        // 计算桶位置        bucketindex = indexfor(hash, table.length);    }    createentry(hash, key, value, bucketindex);}void createentry(int hash, k key, v value, int bucketindex) {    // 得到目标桶位置链表头元素    entry<k,v> e = table[bucketindex];    // 头插法体现    table[bucketindex] = new entry<>(hash, key, value, e);    size++;}\n\n\n1\n\n\nentry(int h, k k, v v, entry<k,v> n) {    value = v;    next = n;    key = k;    hash = h;}\n\n\n1\n\n\n\n# 4. 确定桶下标\n\n很多操作都需要先确定一个键值对所在的桶下标。\n\nint hash = hash(key);\nint i = indexfor(hash, table.length);\n\n\n1\n2\n\n\n# 4.1 计算 hash 值\n\nfinal int hash(object k) {\n    int h = hashseed;\n    if (0 != h && k instanceof string) {\n        return sun.misc.hashing.stringhash32((string) k);\n    }\n\n    h ^= k.hashcode();\n\n    // this function ensures that hashcodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\npublic final int hashcode() {\n    return objects.hashcode(key) ^ objects.hashcode(value);\n}\n\n\n1\n2\n3\n\n\n# 4.2 取模\n\n令 x = 1<<4，即 x 为 2 的 4 次方，它具有以下性质：\n\nx   : 00010000\nx-1 : 00001111\n\n\n1\n2\n\n\n令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：\n\ny       : 10110010\nx-1     : 00001111\ny&(x-1) : 00000010\n\n\n1\n2\n3\n\n\n这个性质和 y 对 x 取模效果是一样的：\n\ny   : 10110010\nx   : 00010000\ny%x : 00000010\n\n\n1\n2\n3\n\n\n我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。\n\n确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。\n\nstatic int indexfor(int h, int length) {\n    return h & (length-1);\n}\n\n\n1\n2\n3\n\n\n\n# 5. 扩容-基本原理\n\n设 hashmap 的 table 长度为 m，需要存储的键值对数量为 n，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 n/m，因此平均查找次数的复杂度为 o(n/m)。\n\n为了让查找的成本降低，应该尽可能使得 n/m 尽可能小，因此需要保证 m 尽可能大，也就是说 table 要尽可能大。hashmap 采用动态扩容来根据当前的 n 值来调整 m 值，使得空间效率和时间效率都能得到保证。\n\n和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。\n\n参数           含义\ncapacity     table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。\nsize         键值对数量。\nthreshold    size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。\nloadfactor   装载因子，table 能够使用的比例，threshold = capacity * loadfactor。\n\nstatic final int default_initial_capacity = 16;static final int maximum_capacity = 1 << 30;static final float default_load_factor = 0.75f;transient entry[] table;transient int size;int threshold;final float loadfactor;transient int modcount;\n\n\n1\n\n\n从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。\n\nvoid addentry(int hash, k key, v value, int bucketindex) {    entry<k,v> e = table[bucketindex];    table[bucketindex] = new entry<>(hash, key, value, e);    if (size++ >= threshold)        resize(2 * table.length);}\n\n\n1\n\n\n扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldtable 的所有键值对重新插入 newtable 中，因此这一步是很费时的。\n\nvoid resize(int newcapacity) {    entry[] oldtable = table;    int oldcapacity = oldtable.length;    if (oldcapacity == maximum_capacity) {        threshold = integer.max_value;        return;    }    // 构造新的entry数组，容量为newcapacity（2倍于原容量）    entry[] newtable = new entry[newcapacity];    // 把旧entry数组里的元素移动到新entry数组里    transfer(newtable);    // 数组变量指向新entry数组    table = newtable;    threshold = (int)(newcapacity * loadfactor);}void transfer(entry[] newtable) {    // 得到原 entry 数组    entry[] src = table;    int newcapacity = newtable.length;    // 两层循环分别遍历原数组以及原数组元素中的entry链表    for (int j = 0; j < src.length; j++) {        entry<k,v> e = src[j];        if (e != null) {            // clear to let gc do its work            src[j] = null;            do {                entry<k,v> next = e.next;                // 根据hash值和新数组容量计算出散列到新数组中的桶的位置                int i = indexfor(e.hash, newcapacity);                // 下面两步是头插法                e.next = newtable[i];                newtable[i] = e;                // 指向链表中下一元素，进行下一次循环处理                e = next;            } while (e != null);        }    }}\n\n\n1\n\n\n\n# 6. 扩容-重新计算桶下标\n\n在进行扩容时，需要把键值对重新放到对应的桶上。hashmap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。\n\n假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：\n\ncapacity     : 00010000new capacity : 00100000\n\n\n1\n\n\n对于一个 key，\n\n * 它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；\n * 如果为 1，那么得到的结果为原来的结果 +16。\n\n\n# 7. 计算数组容量\n\nhashmap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。\n\n先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：\n\nmask |= mask >> 1    11011000mask |= mask >> 2    11111110mask |= mask >> 4    11111111\n\n\n1\n\n\nmask+1 是大于原始数字的最小的 2 的 n 次方。\n\nnum     10010000\nmask+1 100000000\n\n\n1\n2\n\n\n以下是 hashmap 中计算数组容量的代码：\n\nstatic final int tablesizefor(int cap) {\n    int n = cap - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= maximum_capacity) ? maximum_capacity : n + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 8. 链表转红黑树\n\n从 jdk 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。\n\n\n# 9. 与 hashtable 的比较\n\n * hashtable 使用 synchronized 来进行同步。\n * hashmap 可以插入键为 null 的 entry。\n * hashmap 的迭代器是 fail-fast 迭代器。\n * hashmap 不能保证随着时间的推移 map 中的元素次序是不变的。\n\n\n# concurrenthashmap\n\n\n# 1. 存储结构\n\nstatic final class hashentry<k,v> {\n    final int hash;\n    final k key;\n    volatile v value;\n    volatile hashentry<k,v> next;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nconcurrenthashmap 和 hashmap 实现上类似，最主要的差别是 concurrenthashmap 采用了分段锁（segment），每个分段锁维护着几个桶（hashentry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 segment 的个数）。\n\nsegment 继承自 reentrantlock。\n\nstatic final class segment<k,v> extends reentrantlock implements serializable {\n\n    private static final long serialversionuid = 2249069246763182397l;\n\n    static final int max_scan_retries =\n        runtime.getruntime().availableprocessors() > 1 ? 64 : 1;\n\n    transient volatile hashentry<k,v>[] table;\n\n    transient int count;\n\n    transient int modcount;\n\n    transient int threshold;\n\n    final float loadfactor;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nfinal segment<k,v>[] segments;\n\n\n1\n\n\n默认的并发级别为 16，也就是说默认创建 16 个 segment。\n\nstatic final int default_concurrency_level = 16;\n\n\n1\n\n\n\n\n\n# 2. size 操作\n\n每个 segment 维护了一个 count 变量来统计该 segment 中的键值对个数。\n\n/**\n * the number of elements. accessed only either within locks\n * or among other volatile reads that maintain visibility.\n */\ntransient int count;\n\n\n1\n2\n3\n4\n5\n\n\n在执行 size 操作时，需要遍历所有 segment 然后把 count 累计起来。\n\nconcurrenthashmap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。\n\n尝试次数使用 retries_before_lock 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。\n\n如果尝试的次数超过 3 次，就需要对每个 segment 加锁。\n\n/**\n * number of unsynchronized retries in size and containsvalue\n * methods before resorting to locking. this is used to avoid\n * unbounded retries if tables undergo continuous modification\n * which would make it impossible to obtain an accurate result.\n * 译：在锁定之前，size方法和containsvalue方法中不同步重试的次数。\n * 这样做是为了避免在表不断修改的情况下进行无界重试，因为修改会导致无法获得准确的结果。\n */\nstatic final int retries_before_lock = 2;\n\npublic int size() {\n    // try a few times to get accurate count. on failure due to\n    // continuous async changes in table, resort to locking.\n    // 试几次，以获得准确的计数。由于表中的连续异步更改而导致失败时，请使用锁定。\n    final segment<k,v>[] segments = this.segments;\n    int size;\n    boolean overflow; // true if size overflows 32 bits\n    long sum;         // sum of modcounts\n    long last = 0l;   // previous sum(即上一次得到的count结果值)\n    int retries = -1; // first iteration isn\'t retry\n    try {\n        for (;;) {\n            // 超过尝试次数，则对每个 segment 加锁\n            if (retries++ == retries_before_lock) {\n                for (int j = 0; j < segments.length; ++j)\n                    ensuresegment(j).lock(); // force creation\n            }\n            sum = 0l;\n            size = 0;\n            overflow = false;\n            for (int j = 0; j < segments.length; ++j) {\n                segment<k,v> seg = segmentat(segments, j);\n                if (seg != null) {\n                    sum += seg.modcount;\n                    // 下面两步是位溢出判断操作\n                    int c = seg.count;\n                    if (c < 0 || (size += c) < 0)\n                        overflow = true;\n                }\n            }\n            // 连续两次得到的结果一致，则认为这个结果是正确的\n            if (sum == last)\n                break;\n            last = sum;\n        }\n    } finally {\n        if (retries > retries_before_lock) {\n            for (int j = 0; j < segments.length; ++j)\n                segmentat(segments, j).unlock();\n        }\n    }\n    return overflow ? integer.max_value : size;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 3. jdk 1.8 的改动\n\njdk 1.7 使用分段锁机制来实现并发更新操作，核心类为 segment，它继承自重入锁 reentrantlock， 并发度与 segment数量相等。\n\njdk 1.8 使用了 cas 操作来支持更高的并发度，在 cas 操作失败时使用内置锁 synchronized。\n\n并且 jdk 1.8 的实现也在链表过长时会转换为红黑树。\n\n\n# linkedhashmap\n\n\n# 存储结构\n\n继承自 hashmap，因此具有和 hashmap 一样的快速查找特性。\n\npublic class linkedhashmap<k,v> extends hashmap<k,v> implements map<k,v>\n\n\n1\n\n\n内部维护了一个双向链表，用来维护插入顺序或者 lru 顺序。\n\n/**\n * the head (eldest) of the doubly linked list.\n */\ntransient linkedhashmap.entry<k,v> head;\n\n/**\n * the tail (youngest) of the doubly linked list.\n */\ntransient linkedhashmap.entry<k,v> tail;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\naccessorder 决定了顺序，默认为 false，此时维护的是插入顺序。\n\nfinal boolean accessorder;\n\n\n1\n\n\nlinkedhashmap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。\n\nvoid afternodeaccess(node<k,v> p) { }\nvoid afternodeinsertion(boolean evict) { }\n\n\n1\n2\n\n\n\n# afternodeaccess()\n\n当一个节点被访问时，如果 accessorder 为 true，则会将该节点移到链表尾部。也就是说指定为 lru 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。\n\nvoid afternodeaccess(node<k,v> e) { // move node to last\n    linkedhashmap.entry<k,v> last;\n    // lru && 访问的元素非尾元素\n    if (accessorder && (last = tail) != e) {\n        linkedhashmap.entry<k,v> p =\n            (linkedhashmap.entry<k,v>)e, b = p.before, a = p.after;\n        p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a != null)\n            a.before = b;\n        else\n            last = b;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modcount;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n\n# afternodeinsertion()\n\n在 put 等操作之后执行，当 removeeldestentry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。\n\nevict 只有在构建 map 的时候才为 false，在这里为 true。\n\nvoid afternodeinsertion(boolean evict) { // possibly remove eldest\n    linkedhashmap.entry<k,v> first;\n    // 头部节点 != null && removeeldestentry方法返回true\n    if (evict && (first = head) != null && removeeldestentry(first)) {\n        k key = first.key;\n        removenode(hash(key), key, null, false, true);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nremoveeldestentry() 默认为 false，如果需要让它为 true，需要继承 linkedhashmap 并且覆盖这个方法的实现，这在实现 lru 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。\n\nprotected boolean removeeldestentry(map.entry<k,v> eldest) {\n    return false;\n}\n\n\n1\n2\n3\n\n\n\n# lru 缓存\n\n以下是使用 linkedhashmap 实现的一个 lru 缓存：\n\n设定最大缓存空间 max_entries 为 3； 使用 linkedhashmap 的构造函数将 accessorder 设置为 true，开启 lru 顺序； 覆盖 removeeldestentry() 方法实现，在节点多于 max_entries 就会将最近最久未使用的数据移除。\n\nclass lrucache<k, v> extends linkedhashmap<k, v> {\n    private static final int max_entries = 3;\n\n    protected boolean removeeldestentry(map.entry eldest) {\n        return size() > max_entries;\n    }\n\n    lrucache() {\n        super(max_entries, 0.75f, true);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\npublic static void main(string[] args) {\n    lrucache<integer, string> cache = new lrucache<>();\n    cache.put(1, "a");\n    cache.put(2, "b");\n    cache.put(3, "c");\n    cache.get(1);\n    cache.put(4, "d");\n    system.out.println(cache.keyset());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n[3, 1, 4]\n\n\n1\n\n\n\n# weakhashmap\n\n\n# 存储结构\n\nweakhashmap 的 entry 继承自 weakreference，被 weakreference 关联的对象在下一次垃圾回收时会被回收。\n\nweakhashmap 主要用来实现缓存，通过使用 weakhashmap 来引用缓存对象，由 jvm 对这部分缓存进行回收。\n\nprivate static class entry<k,v> extends weakreference<object> implements map.entry<k,v>\n\n\n1\n\n\n\n# concurrentcache\n\ntomcat 中的 concurrentcache 使用了 weakhashmap 来实现缓存功能。\n\nconcurrentcache 采取的是分代缓存：\n\n * 经常使用的对象放入 eden 中，eden 使用 concurrenthashmap 实现，不用担心会被回收（伊甸园）；\n * 不常用的对象放入 longterm，longterm 使用 weakhashmap 实现，这些老对象会被垃圾收集器回收。\n * 当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。\n * 当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。\n\npublic final class concurrentcache<k, v> {\n\n    private final int size;\n\n    private final map<k, v> eden;\n\n    private final map<k, v> longterm;\n\n    public concurrentcache(int size) {\n        this.size = size;\n        this.eden = new concurrenthashmap<>(size);\n        this.longterm = new weakhashmap<>(size);\n    }\n\n    public v get(k k) {\n        v v = this.eden.get(k);\n        if (v == null) {\n            v = this.longterm.get(k);\n            if (v != null)\n                this.eden.put(k, v);\n        }\n        return v;\n    }\n\n    public void put(k k, v v) {\n        if (this.eden.size() >= size) {\n            this.longterm.putall(this.eden);\n            this.eden.clear();\n        }\n        this.eden.put(k, v);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n----------------------------------------\n\n参考：\n\n * 漫画：什么是hashmap？\n\n关键点\n\n * 为什么采用头插法？\n\n> hashmap的发明者认为，后插入的entry被查找的可能性更大。\n\n * hashmap的默认初始长度是16，并且每次自动扩展或手动初始化时，长度必须是2的幂，为什么？\n\n> 之所以选择16，是为了可以将求模运算转换成位于运算，提高hash效率\n\n\n# 取模运算可以转换成位于运算内部原理分析:\n\n假设一个key的hashcode为56，table容量为16，正常取模后余数为8，即放到索引为8的桶中。\n\n如果采用位于运算：hashcode & ( length - 1 )\n\n56 二进制为：111000\n\n16 - 1 二进制为：1111\n\n  111000\n& 001111\n--------\n  001000\n\n\n1\n2\n3\n4\n\n\n结果也是8\n\n位于运算可以保证均匀分布的原因是：一个key的hashcode 和 16 -1 = 15 进行位与运算，因为15的后四位都是1，1和谁与结果就是谁，前面位数全是0，0和谁与结果都是0，所以计算后的结果就是hashcode的后四位且小于等于15，而所有key的hashcode都是随机的，后四位也是随机的（整体随机，局部也随机），可以保证结果为随机均匀分布。',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Java IO",frontmatter:{title:"Java IO",date:"2022-02-03T19:02:41.000Z",permalink:"/pages/5859c4/",categories:["面试","Java","Java基础"],tags:[null]},regularPath:"/35.%E9%9D%A2%E8%AF%95/05.Java/05.Java%E5%9F%BA%E7%A1%80/15.Java%20IO.html",relativePath:"35.面试/05.Java/05.Java基础/15.Java IO.md",key:"v-fdf3da36",path:"/pages/5859c4/",headers:[{level:3,title:"实现文件复制",slug:"实现文件复制",normalizedTitle:"实现文件复制",charIndex:575},{level:3,title:"装饰者模式",slug:"装饰者模式",normalizedTitle:"装饰者模式",charIndex:1093},{level:3,title:"编码与解码",slug:"编码与解码",normalizedTitle:"编码与解码",charIndex:1627},{level:3,title:"String 的编码方式",slug:"string-的编码方式",normalizedTitle:"string 的编码方式",charIndex:2032},{level:3,title:"Reader 与 Writer",slug:"reader-与-writer",normalizedTitle:"reader 与 writer",charIndex:2450},{level:3,title:"实现逐行输出文本文件的内容",slug:"实现逐行输出文本文件的内容",normalizedTitle:"实现逐行输出文本文件的内容",charIndex:2611},{level:3,title:"序列化",slug:"序列化",normalizedTitle:"序列化",charIndex:3159},{level:3,title:"Serializable",slug:"serializable",normalizedTitle:"serializable",charIndex:112},{level:3,title:"transient",slug:"transient",normalizedTitle:"transient",charIndex:4286},{level:3,title:"InetAddress",slug:"inetaddress",normalizedTitle:"inetaddress",charIndex:4529},{level:3,title:"URL",slug:"url",normalizedTitle:"url",charIndex:4566},{level:3,title:"Sockets",slug:"sockets",normalizedTitle:"sockets",charIndex:4582},{level:3,title:"Datagram",slug:"datagram",normalizedTitle:"datagram",charIndex:4610},{level:3,title:"流与块",slug:"流与块",normalizedTitle:"流与块",charIndex:5515},{level:3,title:"通道与缓冲区",slug:"通道与缓冲区",normalizedTitle:"通道与缓冲区",charIndex:5900},{level:3,title:"缓冲区状态变量",slug:"缓冲区状态变量",normalizedTitle:"缓冲区状态变量",charIndex:6489},{level:3,title:"文件 NIO 实例",slug:"文件-nio-实例",normalizedTitle:"文件 nio 实例",charIndex:6909},{level:3,title:"选择器",slug:"选择器",normalizedTitle:"选择器",charIndex:7826},{level:3,title:"套接字 NIO 实例",slug:"套接字-nio-实例",normalizedTitle:"套接字 nio 实例",charIndex:9978},{level:3,title:"内存映射文件",slug:"内存映射文件",normalizedTitle:"内存映射文件",charIndex:12895},{level:3,title:"对比",slug:"对比",normalizedTitle:"对比",charIndex:13237}],headersStr:"实现文件复制 装饰者模式 编码与解码 String 的编码方式 Reader 与 Writer 实现逐行输出文本文件的内容 序列化 Serializable transient InetAddress URL Sockets Datagram 流与块 通道与缓冲区 缓冲区状态变量 文件 NIO 实例 选择器 套接字 NIO 实例 内存映射文件 对比",content:'# 一、概览\n\nJava 的 I/O 大概可以分成以下几类：\n\n * 磁盘操作：File\n * 字节操作：InputStream 和 OutputStream\n * 字符操作：Reader 和 Writer\n * 对象操作：Serializable\n * 网络操作：Socket\n * 新的输入/输出：NIO\n\n\n# 二、磁盘操作\n\nFile 类可以用于表示文件和目录的信息，但是它不表示文件的内容。\n\n递归地列出一个目录下所有文件：\n\npublic static void listAllFiles(File dir) {\n    if (dir == null || !dir.exists()) {\n        return;\n    }\n    if (dir.isFile()) {\n        System.out.println(dir.getName());\n        return;\n    }\n    for (File file : dir.listFiles()) {\n        listAllFiles(file);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n从 Java7 开始，可以使用 Paths 和 Files 代替 File。\n\n\n# 三、字节操作\n\n\n# 实现文件复制\n\npublic static void copyFile(String src, String dist) throws IOException {\n    FileInputStream in = new FileInputStream(src);\n    FileOutputStream out = new FileOutputStream(dist);\n\n    byte[] buffer = new byte[20 * 1024];\n    int cnt;\n\n    // read() 最多读取 buffer.length 个字节\n    // 返回的是实际读取的个数\n    // 返回 -1 的时候表示读到 eof，即文件尾\n    while ((cnt = in.read(buffer, 0, buffer.length)) != -1) {\n        out.write(buffer, 0, cnt);\n    }\n\n    in.close();\n    out.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 装饰者模式\n\nJava I/O 使用了装饰者模式来实现。以 InputStream 为例，\n\n * InputStream 是抽象组件；\n * FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；\n * FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。\n\n\n\n实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。\n\nFileInputStream fileInputStream = new FileInputStream(filePath);\nBufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);\n\n\n1\n2\n\n\nDataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。\n\n\n# 四、字符操作\n\n\n# 编码与解码\n\n编码就是把字符转换为字节，而解码是把字节重新组合成字符。\n\n如果编码和解码过程使用不同的编码方式那么就出现了乱码。\n\n * GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；\n * UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；\n * UTF-16be 编码中，中文字符和英文字符都占 2 个字节。\n\nUTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。\n\nJava 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。\n\n\n# String 的编码方式\n\nString 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。\n\nString str1 = "中文";\nbyte[] bytes = str1.getBytes("UTF-8");\nString str2 = new String(bytes, "UTF-8");\nSystem.out.println(str2);\n\n\n1\n2\n3\n4\n\n\n在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。\n\nbyte[] bytes = str1.getBytes();\n\n\n1\n\n\n\n# Reader 与 Writer\n\n不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。\n\n * InputStreamReader 实现从字节流解码成字符流；\n * OutputStreamWriter 实现字符流编码成为字节流。\n\n\n# 实现逐行输出文本文件的内容\n\npublic static void readFileContent(String filePath) throws IOException {\n\n    FileReader fileReader = new FileReader(filePath);\n    BufferedReader bufferedReader = new BufferedReader(fileReader);\n\n    String line;\n    while ((line = bufferedReader.readLine()) != null) {\n        System.out.println(line);\n    }\n\n    // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象\n    // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法\n    // 因此只要一个 close() 调用即可\n    bufferedReader.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 五、对象操作\n\n\n# 序列化\n\n序列化就是将一个对象转换成字节序列，方便存储和传输。\n\n * 序列化：ObjectOutputStream.writeObject()\n * 反序列化：ObjectInputStream.readObject()\n\n不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。\n\n\n# Serializable\n\n序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。\n\npublic static void main(String[] args) throws IOException, ClassNotFoundException {\n\n    A a1 = new A(123, "abc");\n    String objectFile = "file/a1";\n\n    ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile));\n    objectOutputStream.writeObject(a1);\n    objectOutputStream.close();\n\n    ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile));\n    A a2 = (A) objectInputStream.readObject();\n    objectInputStream.close();\n    System.out.println(a2);\n}\n\nprivate static class A implements Serializable {\n\n    private int x;\n    private String y;\n\n    A(int x, String y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public String toString() {\n        return "x = " + x + "  " + "y = " + y;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# transient\n\ntransient 关键字可以使一些属性不会被序列化。\n\nArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。\n\nprivate transient Object[] elementData;\n\n\n1\n\n\n\n# 六、网络操作\n\nJava 中的网络支持：\n\n * InetAddress：用于表示网络上的硬件资源，即 IP 地址；\n * URL：统一资源定位符；\n * Sockets：使用 TCP 协议实现网络通信；\n * Datagram：使用 UDP 协议实现网络通信。\n\n\n# InetAddress\n\n没有公有的构造函数，只能通过静态方法来创建实例。\n\nInetAddress.getByName(String host);\nInetAddress.getByAddress(byte[] address);\n\n\n1\n2\n\n\n\n# URL\n\n可以直接从 URL 中读取字节流数据。\n\npublic static void main(String[] args) throws IOException {\n\n    URL url = new URL("http://www.baidu.com");\n\n    /* 字节流 */\n    InputStream is = url.openStream();\n\n    /* 字符流 */\n    InputStreamReader isr = new InputStreamReader(is, "utf-8");\n\n    /* 提供缓存功能 */\n    BufferedReader br = new BufferedReader(isr);\n\n    String line;\n    while ((line = br.readLine()) != null) {\n        System.out.println(line);\n    }\n\n    br.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Sockets\n\n * ServerSocket：服务器端类\n * Socket：客户端类\n * 服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。\n\n\n\n\n# Datagram\n\n * DatagramSocket：通信类\n * DatagramPacket：数据包类\n\n\n# 七、NIO\n\n新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。\n\n\n# 流与块\n\nI/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。\n\n面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。\n\n面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。\n\nI/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。\n\n\n# 通道与缓冲区\n\n# 1. 通道\n\n通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。\n\n通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。\n\n通道包括以下类型：\n\n * FileChannel：从文件中读写数据；\n * DatagramChannel：通过 UDP 读写网络中数据；\n * SocketChannel：通过 TCP 读写网络中数据；\n * ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。\n\n# 2. 缓冲区\n\n发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。\n\n缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。\n\n缓冲区包括以下类型：\n\n * ByteBuffer\n * CharBuffer\n * ShortBuffer\n * IntBuffer\n * LongBuffer\n * FloatBuffer\n * DoubleBuffer\n\n\n# 缓冲区状态变量\n\n * capacity：最大容量；\n * position：当前已经读写的字节数；\n * limit：还可以读写的字节数。\n\n状态变量的改变过程举例：\n\n① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。\n\n\n\n② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。\n\n\n\n③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。\n\n\n\n④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。\n\n\n\n⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。\n\n\n\n\n# 文件 NIO 实例\n\n以下展示了使用 NIO 快速复制文件的实例：\n\npublic static void fastCopy(String src, String dist) throws IOException {\n\n    /* 获得源文件的输入字节流 */\n    FileInputStream fin = new FileInputStream(src);\n\n    /* 获取输入字节流的文件通道 */\n    FileChannel fcin = fin.getChannel();\n\n    /* 获取目标文件的输出字节流 */\n    FileOutputStream fout = new FileOutputStream(dist);\n\n    /* 获取输出字节流的文件通道 */\n    FileChannel fcout = fout.getChannel();\n\n    /* 为缓冲区分配 1024 个字节 */\n    ByteBuffer buffer = ByteBuffer.allocateDirect(1024);\n\n    while (true) {\n\n        /* 从输入通道中读取数据到缓冲区中 */\n        int r = fcin.read(buffer);\n\n        /* read() 返回 -1 表示 EOF */\n        if (r == -1) {\n            break;\n        }\n\n        /* 切换读写 */\n        buffer.flip();\n\n        /* 把缓冲区的内容写入输出文件中 */\n        fcout.write(buffer);\n\n        /* 清空缓冲区 */\n        buffer.clear();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 选择器\n\nNIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。\n\nNIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。\n\n通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。\n\n因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。\n\n应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。\n\n\n\n# 1. 创建选择器\n\nSelector selector = Selector.open();\n\n\n1\n\n\n# 2. 将通道注册到选择器上\n\nServerSocketChannel ssChannel = ServerSocketChannel.open();\nssChannel.configureBlocking(false);\nssChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n\n1\n2\n3\n\n\n通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。\n\n在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：\n\n * SelectionKey.OP_CONNECT\n * SelectionKey.OP_ACCEPT\n * SelectionKey.OP_READ\n * SelectionKey.OP_WRITE\n\n它们在 SelectionKey 的定义如下：\n\npublic static final int OP_READ = 1 << 0;\npublic static final int OP_WRITE = 1 << 2;\npublic static final int OP_CONNECT = 1 << 3;\npublic static final int OP_ACCEPT = 1 << 4;\n\n\n1\n2\n3\n4\n\n\n可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：\n\nint interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n\n\n1\n\n\n# 3. 监听事件\n\nint num = selector.select();\n\n\n1\n\n\n使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。\n\n# 4. 获取到达的事件\n\nSet<SelectionKey> keys = selector.selectedKeys();\nIterator<SelectionKey> keyIterator = keys.iterator();\nwhile (keyIterator.hasNext()) {\n    SelectionKey key = keyIterator.next();\n    if (key.isAcceptable()) {\n        // ...\n    } else if (key.isReadable()) {\n        // ...\n    }\n    keyIterator.remove();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 5. 事件循环\n\n因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。\n\nwhile (true) {\n    int num = selector.select();\n    Set<SelectionKey> keys = selector.selectedKeys();\n    Iterator<SelectionKey> keyIterator = keys.iterator();\n    while (keyIterator.hasNext()) {\n        SelectionKey key = keyIterator.next();\n        if (key.isAcceptable()) {\n            // ...\n        } else if (key.isReadable()) {\n            // ...\n        }\n        keyIterator.remove();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 套接字 NIO 实例\n\npublic class NIOServer {\n\n    public static void main(String[] args) throws IOException {\n\n        Selector selector = Selector.open();\n\n        ServerSocketChannel ssChannel = ServerSocketChannel.open();\n        ssChannel.configureBlocking(false);\n        ssChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        ServerSocket serverSocket = ssChannel.socket();\n        InetSocketAddress address = new InetSocketAddress("127.0.0.1", 8888);\n        serverSocket.bind(address);\n\n        while (true) {\n            // 轮训注册到selector的多个通道，监听通道上的IO事件是否到达，因为通道配置成非阻塞，所以selector不会在通道上阻塞而是轮训其他通道，\n            // 在没有通道上的IO事件到达时，selector从外部来看是阻塞在此的，即这里的select方法。\n            selector.select();\n            Set<SelectionKey> keys = selector.selectedKeys();\n            Iterator<SelectionKey> keyIterator = keys.iterator();\n\n            while (keyIterator.hasNext()) {\n\n                SelectionKey key = keyIterator.next();\n                // 通道有accept事件到达\n                if (key.isAcceptable()) {\n                    // 获取事件到达的通道（这里因为已经判断出是accept事件，所以通道相应为ServerSocketChannel）\n                    \n                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();\n\n                    // 服务器会为每个新连接创建一个 SocketChannel\n                    // 因为通道上已经监听到accept事件，所以这里直接调用accept方法可以直接得到一个SocketChannel\n                    SocketChannel sChannel = ssChannel1.accept();\n                    sChannel.configureBlocking(false);\n\n                    // 这个新连接主要用于从客户端读取数据\n                    // 同样把这个用来通过socket进行读写的通道注册到selector，从而监听IO读事件\n                    sChannel.register(selector, SelectionKey.OP_READ);\n\n                } else if (key.isReadable()) {\n\n                    SocketChannel sChannel = (SocketChannel) key.channel();\n                    System.out.println(readDataFromSocketChannel(sChannel));\n                    sChannel.close();\n                }\n                // 处理完通道上的IO事件后，从到达事件列表中删除，避免重复处理\n                keyIterator.remove();\n            }\n        }\n    }\n\n    private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException {\n\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        StringBuilder data = new StringBuilder();\n\n        while (true) {\n\n            buffer.clear();\n            int n = sChannel.read(buffer);\n            if (n == -1) {\n                break;\n            }\n            buffer.flip();\n            int limit = buffer.limit();\n            char[] dst = new char[limit];\n            for (int i = 0; i < limit; i++) {\n                dst[i] = (char) buffer.get(i);\n            }\n            data.append(dst);\n            buffer.clear();\n        }\n        return data.toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n\n# 内存映射文件\n\n内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。\n\n向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。\n\n下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。\n\nMappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);\n\n\n1\n\n\n\n# 对比\n\nNIO 与普通 I/O 的区别主要有以下两点：\n\n * NIO 是非阻塞的；\n * NIO 面向块，I/O 面向流。',normalizedContent:'# 一、概览\n\njava 的 i/o 大概可以分成以下几类：\n\n * 磁盘操作：file\n * 字节操作：inputstream 和 outputstream\n * 字符操作：reader 和 writer\n * 对象操作：serializable\n * 网络操作：socket\n * 新的输入/输出：nio\n\n\n# 二、磁盘操作\n\nfile 类可以用于表示文件和目录的信息，但是它不表示文件的内容。\n\n递归地列出一个目录下所有文件：\n\npublic static void listallfiles(file dir) {\n    if (dir == null || !dir.exists()) {\n        return;\n    }\n    if (dir.isfile()) {\n        system.out.println(dir.getname());\n        return;\n    }\n    for (file file : dir.listfiles()) {\n        listallfiles(file);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n从 java7 开始，可以使用 paths 和 files 代替 file。\n\n\n# 三、字节操作\n\n\n# 实现文件复制\n\npublic static void copyfile(string src, string dist) throws ioexception {\n    fileinputstream in = new fileinputstream(src);\n    fileoutputstream out = new fileoutputstream(dist);\n\n    byte[] buffer = new byte[20 * 1024];\n    int cnt;\n\n    // read() 最多读取 buffer.length 个字节\n    // 返回的是实际读取的个数\n    // 返回 -1 的时候表示读到 eof，即文件尾\n    while ((cnt = in.read(buffer, 0, buffer.length)) != -1) {\n        out.write(buffer, 0, cnt);\n    }\n\n    in.close();\n    out.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 装饰者模式\n\njava i/o 使用了装饰者模式来实现。以 inputstream 为例，\n\n * inputstream 是抽象组件；\n * fileinputstream 是 inputstream 的子类，属于具体组件，提供了字节流的输入操作；\n * filterinputstream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 bufferedinputstream 为 fileinputstream 提供缓存的功能。\n\n\n\n实例化一个具有缓存功能的字节流对象时，只需要在 fileinputstream 对象上再套一层 bufferedinputstream 对象即可。\n\nfileinputstream fileinputstream = new fileinputstream(filepath);\nbufferedinputstream bufferedinputstream = new bufferedinputstream(fileinputstream);\n\n\n1\n2\n\n\ndatainputstream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。\n\n\n# 四、字符操作\n\n\n# 编码与解码\n\n编码就是把字符转换为字节，而解码是把字节重新组合成字符。\n\n如果编码和解码过程使用不同的编码方式那么就出现了乱码。\n\n * gbk 编码中，中文字符占 2 个字节，英文字符占 1 个字节；\n * utf-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；\n * utf-16be 编码中，中文字符和英文字符都占 2 个字节。\n\nutf-16be 中的 be 指的是 big endian，也就是大端。相应地也有 utf-16le，le 指的是 little endian，也就是小端。\n\njava 的内存编码使用双字节编码 utf-16be，这不是指 java 只支持这一种编码方式，而是说 char 这种类型使用 utf-16be 进行编码。char 类型占 16 位，也就是两个字节，java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。\n\n\n# string 的编码方式\n\nstring 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 string。\n\nstring str1 = "中文";\nbyte[] bytes = str1.getbytes("utf-8");\nstring str2 = new string(bytes, "utf-8");\nsystem.out.println(str2);\n\n\n1\n2\n3\n4\n\n\n在调用无参数 getbytes() 方法时，默认的编码方式不是 utf-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 string 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getbytes() 的默认编码方式与平台有关，一般为 utf-8。\n\nbyte[] bytes = str1.getbytes();\n\n\n1\n\n\n\n# reader 与 writer\n\n不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。\n\n * inputstreamreader 实现从字节流解码成字符流；\n * outputstreamwriter 实现字符流编码成为字节流。\n\n\n# 实现逐行输出文本文件的内容\n\npublic static void readfilecontent(string filepath) throws ioexception {\n\n    filereader filereader = new filereader(filepath);\n    bufferedreader bufferedreader = new bufferedreader(filereader);\n\n    string line;\n    while ((line = bufferedreader.readline()) != null) {\n        system.out.println(line);\n    }\n\n    // 装饰者模式使得 bufferedreader 组合了一个 reader 对象\n    // 在调用 bufferedreader 的 close() 方法时会去调用 reader 的 close() 方法\n    // 因此只要一个 close() 调用即可\n    bufferedreader.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 五、对象操作\n\n\n# 序列化\n\n序列化就是将一个对象转换成字节序列，方便存储和传输。\n\n * 序列化：objectoutputstream.writeobject()\n * 反序列化：objectinputstream.readobject()\n\n不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。\n\n\n# serializable\n\n序列化的类需要实现 serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。\n\npublic static void main(string[] args) throws ioexception, classnotfoundexception {\n\n    a a1 = new a(123, "abc");\n    string objectfile = "file/a1";\n\n    objectoutputstream objectoutputstream = new objectoutputstream(new fileoutputstream(objectfile));\n    objectoutputstream.writeobject(a1);\n    objectoutputstream.close();\n\n    objectinputstream objectinputstream = new objectinputstream(new fileinputstream(objectfile));\n    a a2 = (a) objectinputstream.readobject();\n    objectinputstream.close();\n    system.out.println(a2);\n}\n\nprivate static class a implements serializable {\n\n    private int x;\n    private string y;\n\n    a(int x, string y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    @override\n    public string tostring() {\n        return "x = " + x + "  " + "y = " + y;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# transient\n\ntransient 关键字可以使一些属性不会被序列化。\n\narraylist 中存储数据的数组 elementdata 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。\n\nprivate transient object[] elementdata;\n\n\n1\n\n\n\n# 六、网络操作\n\njava 中的网络支持：\n\n * inetaddress：用于表示网络上的硬件资源，即 ip 地址；\n * url：统一资源定位符；\n * sockets：使用 tcp 协议实现网络通信；\n * datagram：使用 udp 协议实现网络通信。\n\n\n# inetaddress\n\n没有公有的构造函数，只能通过静态方法来创建实例。\n\ninetaddress.getbyname(string host);\ninetaddress.getbyaddress(byte[] address);\n\n\n1\n2\n\n\n\n# url\n\n可以直接从 url 中读取字节流数据。\n\npublic static void main(string[] args) throws ioexception {\n\n    url url = new url("http://www.baidu.com");\n\n    /* 字节流 */\n    inputstream is = url.openstream();\n\n    /* 字符流 */\n    inputstreamreader isr = new inputstreamreader(is, "utf-8");\n\n    /* 提供缓存功能 */\n    bufferedreader br = new bufferedreader(isr);\n\n    string line;\n    while ((line = br.readline()) != null) {\n        system.out.println(line);\n    }\n\n    br.close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# sockets\n\n * serversocket：服务器端类\n * socket：客户端类\n * 服务器和客户端通过 inputstream 和 outputstream 进行输入输出。\n\n\n\n\n# datagram\n\n * datagramsocket：通信类\n * datagrampacket：数据包类\n\n\n# 七、nio\n\n新的输入/输出 (nio) 库是在 jdk 1.4 中引入的，弥补了原来的 i/o 的不足，提供了高速的、面向块的 i/o。\n\n\n# 流与块\n\ni/o 与 nio 最重要的区别是数据打包和传输的方式，i/o 以流的方式处理数据，而 nio 以块的方式处理数据。\n\n面向流的 i/o 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 i/o 通常相当慢。\n\n面向块的 i/o 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 i/o 缺少一些面向流的 i/o 所具有的优雅性和简单性。\n\ni/o 包和 nio 已经很好地集成了，java.io.* 已经以 nio 为基础重新实现了，所以现在它可以利用 nio 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。\n\n\n# 通道与缓冲区\n\n# 1. 通道\n\n通道 channel 是对原 i/o 包中的流的模拟，可以通过它读取和写入数据。\n\n通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 inputstream 或者 outputstream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。\n\n通道包括以下类型：\n\n * filechannel：从文件中读写数据；\n * datagramchannel：通过 udp 读写网络中数据；\n * socketchannel：通过 tcp 读写网络中数据；\n * serversocketchannel：可以监听新进来的 tcp 连接，对每一个新进来的连接都会创建一个 socketchannel。\n\n# 2. 缓冲区\n\n发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。\n\n缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。\n\n缓冲区包括以下类型：\n\n * bytebuffer\n * charbuffer\n * shortbuffer\n * intbuffer\n * longbuffer\n * floatbuffer\n * doublebuffer\n\n\n# 缓冲区状态变量\n\n * capacity：最大容量；\n * position：当前已经读写的字节数；\n * limit：还可以读写的字节数。\n\n状态变量的改变过程举例：\n\n① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。\n\n\n\n② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。\n\n\n\n③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。\n\n\n\n④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。\n\n\n\n⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。\n\n\n\n\n# 文件 nio 实例\n\n以下展示了使用 nio 快速复制文件的实例：\n\npublic static void fastcopy(string src, string dist) throws ioexception {\n\n    /* 获得源文件的输入字节流 */\n    fileinputstream fin = new fileinputstream(src);\n\n    /* 获取输入字节流的文件通道 */\n    filechannel fcin = fin.getchannel();\n\n    /* 获取目标文件的输出字节流 */\n    fileoutputstream fout = new fileoutputstream(dist);\n\n    /* 获取输出字节流的文件通道 */\n    filechannel fcout = fout.getchannel();\n\n    /* 为缓冲区分配 1024 个字节 */\n    bytebuffer buffer = bytebuffer.allocatedirect(1024);\n\n    while (true) {\n\n        /* 从输入通道中读取数据到缓冲区中 */\n        int r = fcin.read(buffer);\n\n        /* read() 返回 -1 表示 eof */\n        if (r == -1) {\n            break;\n        }\n\n        /* 切换读写 */\n        buffer.flip();\n\n        /* 把缓冲区的内容写入输出文件中 */\n        fcout.write(buffer);\n\n        /* 清空缓冲区 */\n        buffer.clear();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 选择器\n\nnio 常常被叫做非阻塞 io，主要是因为 nio 在网络通信中的非阻塞特性被广泛使用。\n\nnio 实现了 io 多路复用中的 reactor 模型，一个线程 thread 使用一个选择器 selector 通过轮询的方式去监听多个通道 channel 上的事件，从而让一个线程就可以处理多个事件。\n\n通过配置监听的通道 channel 为非阻塞，那么当 channel 上的 io 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 channel，找到 io 事件已经到达的 channel 执行。\n\n因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 io 密集型的应用具有很好地性能。\n\n应该注意的是，只有套接字 channel 才能配置为非阻塞，而 filechannel 不能，为 filechannel 配置非阻塞也没有意义。\n\n\n\n# 1. 创建选择器\n\nselector selector = selector.open();\n\n\n1\n\n\n# 2. 将通道注册到选择器上\n\nserversocketchannel sschannel = serversocketchannel.open();\nsschannel.configureblocking(false);\nsschannel.register(selector, selectionkey.op_accept);\n\n\n1\n2\n3\n\n\n通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。\n\n在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：\n\n * selectionkey.op_connect\n * selectionkey.op_accept\n * selectionkey.op_read\n * selectionkey.op_write\n\n它们在 selectionkey 的定义如下：\n\npublic static final int op_read = 1 << 0;\npublic static final int op_write = 1 << 2;\npublic static final int op_connect = 1 << 3;\npublic static final int op_accept = 1 << 4;\n\n\n1\n2\n3\n4\n\n\n可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：\n\nint interestset = selectionkey.op_read | selectionkey.op_write;\n\n\n1\n\n\n# 3. 监听事件\n\nint num = selector.select();\n\n\n1\n\n\n使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。\n\n# 4. 获取到达的事件\n\nset<selectionkey> keys = selector.selectedkeys();\niterator<selectionkey> keyiterator = keys.iterator();\nwhile (keyiterator.hasnext()) {\n    selectionkey key = keyiterator.next();\n    if (key.isacceptable()) {\n        // ...\n    } else if (key.isreadable()) {\n        // ...\n    }\n    keyiterator.remove();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 5. 事件循环\n\n因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。\n\nwhile (true) {\n    int num = selector.select();\n    set<selectionkey> keys = selector.selectedkeys();\n    iterator<selectionkey> keyiterator = keys.iterator();\n    while (keyiterator.hasnext()) {\n        selectionkey key = keyiterator.next();\n        if (key.isacceptable()) {\n            // ...\n        } else if (key.isreadable()) {\n            // ...\n        }\n        keyiterator.remove();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 套接字 nio 实例\n\npublic class nioserver {\n\n    public static void main(string[] args) throws ioexception {\n\n        selector selector = selector.open();\n\n        serversocketchannel sschannel = serversocketchannel.open();\n        sschannel.configureblocking(false);\n        sschannel.register(selector, selectionkey.op_accept);\n\n        serversocket serversocket = sschannel.socket();\n        inetsocketaddress address = new inetsocketaddress("127.0.0.1", 8888);\n        serversocket.bind(address);\n\n        while (true) {\n            // 轮训注册到selector的多个通道，监听通道上的io事件是否到达，因为通道配置成非阻塞，所以selector不会在通道上阻塞而是轮训其他通道，\n            // 在没有通道上的io事件到达时，selector从外部来看是阻塞在此的，即这里的select方法。\n            selector.select();\n            set<selectionkey> keys = selector.selectedkeys();\n            iterator<selectionkey> keyiterator = keys.iterator();\n\n            while (keyiterator.hasnext()) {\n\n                selectionkey key = keyiterator.next();\n                // 通道有accept事件到达\n                if (key.isacceptable()) {\n                    // 获取事件到达的通道（这里因为已经判断出是accept事件，所以通道相应为serversocketchannel）\n                    \n                    serversocketchannel sschannel1 = (serversocketchannel) key.channel();\n\n                    // 服务器会为每个新连接创建一个 socketchannel\n                    // 因为通道上已经监听到accept事件，所以这里直接调用accept方法可以直接得到一个socketchannel\n                    socketchannel schannel = sschannel1.accept();\n                    schannel.configureblocking(false);\n\n                    // 这个新连接主要用于从客户端读取数据\n                    // 同样把这个用来通过socket进行读写的通道注册到selector，从而监听io读事件\n                    schannel.register(selector, selectionkey.op_read);\n\n                } else if (key.isreadable()) {\n\n                    socketchannel schannel = (socketchannel) key.channel();\n                    system.out.println(readdatafromsocketchannel(schannel));\n                    schannel.close();\n                }\n                // 处理完通道上的io事件后，从到达事件列表中删除，避免重复处理\n                keyiterator.remove();\n            }\n        }\n    }\n\n    private static string readdatafromsocketchannel(socketchannel schannel) throws ioexception {\n\n        bytebuffer buffer = bytebuffer.allocate(1024);\n        stringbuilder data = new stringbuilder();\n\n        while (true) {\n\n            buffer.clear();\n            int n = schannel.read(buffer);\n            if (n == -1) {\n                break;\n            }\n            buffer.flip();\n            int limit = buffer.limit();\n            char[] dst = new char[limit];\n            for (int i = 0; i < limit; i++) {\n                dst[i] = (char) buffer.get(i);\n            }\n            data.append(dst);\n            buffer.clear();\n        }\n        return data.tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n\n# 内存映射文件\n\n内存映射文件 i/o 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 i/o 快得多。\n\n向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。\n\n下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 mappedbytebuffer，它是 bytebuffer 的子类。因此，可以像使用其他任何 bytebuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。\n\nmappedbytebuffer mbb = fc.map(filechannel.mapmode.read_write, 0, 1024);\n\n\n1\n\n\n\n# 对比\n\nnio 与普通 i/o 的区别主要有以下两点：\n\n * nio 是非阻塞的；\n * nio 面向块，i/o 面向流。',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"JDK 动态代理",frontmatter:{title:"JDK 动态代理",date:"2022-02-03T19:02:27.000Z",permalink:"/pages/e5ea78/",categories:["面试","Java","Java基础"],tags:[null]},regularPath:"/35.%E9%9D%A2%E8%AF%95/05.Java/05.Java%E5%9F%BA%E7%A1%80/30.JDK%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html",relativePath:"35.面试/05.Java/05.Java基础/30.JDK 动态代理.md",key:"v-52f3ee7a",path:"/pages/e5ea78/",headersStr:null,content:'看了好多关于代理的文章，理解和整理一下。\n\n\n# 1、代理的基本构成\n\n * 抽象角色：声明真实对象和代理对象的共同接口,这样可在任何使用真实对象的地方都可以使用代理对象（多态）。\n * 代理角色：代理对象内部含有真实对象的引用，从而可以在任何时候操作真实对象。代理对象和真实对象具有相同的接口，这样就可以在任何时候替代真实对象。代理对象通常在 【客户端调用传递给真实对象】 之前或之后，执行某个操作，而不是单纯地将调用传递给真实对象，同时，代理对象可以在执行真实对象操作前后，附加其他的操作，相当于对真实对象进行封装。\n * 真实角色：即为代理对象所代表的目标对象，代理角色所代表的真实对象，是我们最终要引用的对象。\n\n下图有三种角色：Subject抽象角色、RealSubject真实角色、Proxy代理角色。其中：Subject角色负责定义RealSubject和Proxy角色应该实现的接口；RealSubject角色用来真正完成业务服务功能；Proxy角色负责将自身的request请求，调用RealSubject对应的request功能来实现业务功能，自己不真正做业务。\n\n\n# 2、静态代理\n\ninterface Subject//抽象角色\n{  \n    public void doSomething();  \n}\nclass RealSubject implements Subject//真实角色\n{  \n    public void doSomething()  \n  {  \n    System.out.println( "call doSomething()" );  \n  }  \n}\nclass SubjectProxy implements Subject//代理角色\n{\n  //代理模式的作用是：为其他对象提供一种代理以控制对这个对象的访问。\n  Subject subimpl = new RealSubject();\n  public void doSomething()\n  {\n     System.out.println("before"); //调用目标对象之前可以做相关操作\n     subimpl.doSomething();\n     System.out.println("after");//调用目标对象之后可以做相关操作\n  }\n}\n \npublic class Test\n{\n    public static void main(String[] args) throws Exception\n    {\n        Subject sub = new SubjectProxy();\n        sub.doSomething();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n可以看到，SubjectProxy实现了Subject接口（和RealSubject实现相同接口），并持有的是Subject接口类型的引用。这样调用的依然是doSomething方法，只是实例化对象的过程改变了，结果来看，代理类SubjectProxy可以自动为我们加上了before和after等我们需要的动作。\n\n如果将来需要实现一个新的接口，就需要在代理类里再写该接口的实现方法，会导致代理类的代码变得臃肿；另一方面，当需要改变抽象角色接口时，无疑真实角色和代理角色也需要改变。\n\n\n# 3、JDK动态代理\n\ninterface Subject  \n{  \n    public void doSomething();  \n}\nclass RealSubject implements Subject  \n{  \n    public void doSomething()  \n  {  \n     System.out.println( "call doSomething()" );  \n  }  \n}\nclass ProxyHandler implements InvocationHandler\n{\n    private Object target;\n    //传入目标对象，返回代理对象\n    public Object getProxyInstance(Object target)\n    {\n        this.target = target;\n        // 使用 Proxy 生成目标类的代理类\n        return Proxy.newProxyInstance(target.getClass().getClassLoader(),// 生成的代理对象和目标对象使用同一类加载器\n                                      target.getClass().getInterfaces(),// 目标对象实现的所有接口，因为生成的代理类也需要实现这些接口\n                                      this);// InvocationHandler 对象，\n    } \n    /**\n     * proxy: 生成的代理对象\n     * method：目标类方法\n     * args：目标类方法的参数\n     */\n    public Object invoke(Object proxy , Method method , Object[] args)throws Throwable//不依赖具体接口实现\n    {\n        Object result = null;//被代理的类型为Object基类\n        //这里就可以进行所谓的AOP编程了\n        //在调用目标方法前，执行功能处理\n        result = method.invoke(tar,args);\n        //在调用目标方法后，执行功能处理\n        return result;\n    }\n}\npublic class Test\n{\n    public static void main(String args[])\n    {      // 将JDK动态代理生成的class文件保存到本地\n           System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");\n           ProxyHandler proxyHandler = new ProxyHandler();\n           // 生成代理对象sub\n           Subject sub = (Subject) proxyHandler.getProxyInstance(new RealSubject());\n           // 使用代理对象调用doSomething()方法，实际调用的是代理对象里的invoke方法（生成的代理类继承了Proxy，重写invoke方法，而invoke方法的逻辑由“回调函数”InvocationHandler指定）\n           // 生成代理类要么是实现和目标类相同的接口，要么是直接继承目标类作为其子类，而JDK动态代理机制生成的代理类已经继承了一个Proxy类，不能再继承目标类了（java是单继承），所以只能通过实现和目标类相同的接口的形式去代理目标类。这就是为什么使用JDK动态代理目标类必须实现接口的原因！\n           sub.doSomething();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n在调用过程中使用了通用的代理类包装了RealSubject实例，然后调用了Jdk的代理工厂方法实例化了一个具体的代理类。最后调用代理的doSomething方法，还有附加的before、after方法可以被任意复用（只要我们在调用代码处使用这个通用代理类去包装任意想要需要包装的被代理类即可）。当接口改变的时候，虽然【被代理类】需要改变，但是我们的代理类却不用改变了。这个调用虽然足够灵活，可以动态生成一个具体的代理类，而不用自己显示的创建一个实现具体接口的代理类。\n\n----------------------------------------\n\n>  1. 代理类继承了Proxy类\n>  2. 代理类实现了和目标类一样的接口Airplane\n>  3. m1、m2、m3、m4 是目标类里的方法，即hashcode、tostring、equal、buyTicket方法\n\n\n\n>  1. 构造方法传入InvocationHandler对象，所以这里代理调用每个方法都是通过InvocationHandler对象的invoke方法去调的\n>  2. 方法参数\n>     1. this: 代理类\n>     2. m3：目标方法\n>     3. new Object[]{var1}：目标方法参数\n>  3. 这样“回调函数”里的invoke方法就拿到了上面三个参数，然后可以在实际执行目标方法前后织入相关逻辑\n\n\n# 4、Cglib 动态代理\n\n\n\n 1. Cglib生成的代理类是实现了一个Factory接口，所以还可以继承，所以可以通过继承目标类的方式生成代理\n 2. 这里的interrupt方法对应JDK动态代理里的invoke',normalizedContent:'看了好多关于代理的文章，理解和整理一下。\n\n\n# 1、代理的基本构成\n\n * 抽象角色：声明真实对象和代理对象的共同接口,这样可在任何使用真实对象的地方都可以使用代理对象（多态）。\n * 代理角色：代理对象内部含有真实对象的引用，从而可以在任何时候操作真实对象。代理对象和真实对象具有相同的接口，这样就可以在任何时候替代真实对象。代理对象通常在 【客户端调用传递给真实对象】 之前或之后，执行某个操作，而不是单纯地将调用传递给真实对象，同时，代理对象可以在执行真实对象操作前后，附加其他的操作，相当于对真实对象进行封装。\n * 真实角色：即为代理对象所代表的目标对象，代理角色所代表的真实对象，是我们最终要引用的对象。\n\n下图有三种角色：subject抽象角色、realsubject真实角色、proxy代理角色。其中：subject角色负责定义realsubject和proxy角色应该实现的接口；realsubject角色用来真正完成业务服务功能；proxy角色负责将自身的request请求，调用realsubject对应的request功能来实现业务功能，自己不真正做业务。\n\n\n# 2、静态代理\n\ninterface subject//抽象角色\n{  \n    public void dosomething();  \n}\nclass realsubject implements subject//真实角色\n{  \n    public void dosomething()  \n  {  \n    system.out.println( "call dosomething()" );  \n  }  \n}\nclass subjectproxy implements subject//代理角色\n{\n  //代理模式的作用是：为其他对象提供一种代理以控制对这个对象的访问。\n  subject subimpl = new realsubject();\n  public void dosomething()\n  {\n     system.out.println("before"); //调用目标对象之前可以做相关操作\n     subimpl.dosomething();\n     system.out.println("after");//调用目标对象之后可以做相关操作\n  }\n}\n \npublic class test\n{\n    public static void main(string[] args) throws exception\n    {\n        subject sub = new subjectproxy();\n        sub.dosomething();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n可以看到，subjectproxy实现了subject接口（和realsubject实现相同接口），并持有的是subject接口类型的引用。这样调用的依然是dosomething方法，只是实例化对象的过程改变了，结果来看，代理类subjectproxy可以自动为我们加上了before和after等我们需要的动作。\n\n如果将来需要实现一个新的接口，就需要在代理类里再写该接口的实现方法，会导致代理类的代码变得臃肿；另一方面，当需要改变抽象角色接口时，无疑真实角色和代理角色也需要改变。\n\n\n# 3、jdk动态代理\n\ninterface subject  \n{  \n    public void dosomething();  \n}\nclass realsubject implements subject  \n{  \n    public void dosomething()  \n  {  \n     system.out.println( "call dosomething()" );  \n  }  \n}\nclass proxyhandler implements invocationhandler\n{\n    private object target;\n    //传入目标对象，返回代理对象\n    public object getproxyinstance(object target)\n    {\n        this.target = target;\n        // 使用 proxy 生成目标类的代理类\n        return proxy.newproxyinstance(target.getclass().getclassloader(),// 生成的代理对象和目标对象使用同一类加载器\n                                      target.getclass().getinterfaces(),// 目标对象实现的所有接口，因为生成的代理类也需要实现这些接口\n                                      this);// invocationhandler 对象，\n    } \n    /**\n     * proxy: 生成的代理对象\n     * method：目标类方法\n     * args：目标类方法的参数\n     */\n    public object invoke(object proxy , method method , object[] args)throws throwable//不依赖具体接口实现\n    {\n        object result = null;//被代理的类型为object基类\n        //这里就可以进行所谓的aop编程了\n        //在调用目标方法前，执行功能处理\n        result = method.invoke(tar,args);\n        //在调用目标方法后，执行功能处理\n        return result;\n    }\n}\npublic class test\n{\n    public static void main(string args[])\n    {      // 将jdk动态代理生成的class文件保存到本地\n           system.getproperties().put("sun.misc.proxygenerator.savegeneratedfiles", "true");\n           proxyhandler proxyhandler = new proxyhandler();\n           // 生成代理对象sub\n           subject sub = (subject) proxyhandler.getproxyinstance(new realsubject());\n           // 使用代理对象调用dosomething()方法，实际调用的是代理对象里的invoke方法（生成的代理类继承了proxy，重写invoke方法，而invoke方法的逻辑由“回调函数”invocationhandler指定）\n           // 生成代理类要么是实现和目标类相同的接口，要么是直接继承目标类作为其子类，而jdk动态代理机制生成的代理类已经继承了一个proxy类，不能再继承目标类了（java是单继承），所以只能通过实现和目标类相同的接口的形式去代理目标类。这就是为什么使用jdk动态代理目标类必须实现接口的原因！\n           sub.dosomething();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n在调用过程中使用了通用的代理类包装了realsubject实例，然后调用了jdk的代理工厂方法实例化了一个具体的代理类。最后调用代理的dosomething方法，还有附加的before、after方法可以被任意复用（只要我们在调用代码处使用这个通用代理类去包装任意想要需要包装的被代理类即可）。当接口改变的时候，虽然【被代理类】需要改变，但是我们的代理类却不用改变了。这个调用虽然足够灵活，可以动态生成一个具体的代理类，而不用自己显示的创建一个实现具体接口的代理类。\n\n----------------------------------------\n\n>  1. 代理类继承了proxy类\n>  2. 代理类实现了和目标类一样的接口airplane\n>  3. m1、m2、m3、m4 是目标类里的方法，即hashcode、tostring、equal、buyticket方法\n\n\n\n>  1. 构造方法传入invocationhandler对象，所以这里代理调用每个方法都是通过invocationhandler对象的invoke方法去调的\n>  2. 方法参数\n>     1. this: 代理类\n>     2. m3：目标方法\n>     3. new object[]{var1}：目标方法参数\n>  3. 这样“回调函数”里的invoke方法就拿到了上面三个参数，然后可以在实际执行目标方法前后织入相关逻辑\n\n\n# 4、cglib 动态代理\n\n\n\n 1. cglib生成的代理类是实现了一个factory接口，所以还可以继承，所以可以通过继承目标类的方式生成代理\n 2. 这里的interrupt方法对应jdk动态代理里的invoke',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/14fc4f/"},regularPath:"/35.%E9%9D%A2%E8%AF%95/10.Java%20Web/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"35.面试/10.Java Web/10.Redis高级客户端Lettuce详解.md",key:"v-6e96fc20",path:"/pages/14fc4f/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/1ca50c/"},regularPath:"/35.%E9%9D%A2%E8%AF%95/15.%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"35.面试/15.框架原理/10.Redis高级客户端Lettuce详解.md",key:"v-3cfa8772",path:"/pages/1ca50c/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/657a34/"},regularPath:"/30.%E5%B7%A5%E5%85%B7/15.git/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"30.工具/15.git/10.Redis高级客户端Lettuce详解.md",key:"v-2a641a1f",path:"/pages/657a34/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/6678f4/"},regularPath:"/35.%E9%9D%A2%E8%AF%95/20.%E6%95%B0%E6%8D%AE%E5%BA%93/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"35.面试/20.数据库/10.Redis高级客户端Lettuce详解.md",key:"v-abf399c4",path:"/pages/6678f4/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/ddeaf7/"},regularPath:"/35.%E9%9D%A2%E8%AF%95/25.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"35.面试/25.设计模式/10.Redis高级客户端Lettuce详解.md",key:"v-dc40f1c0",path:"/pages/ddeaf7/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"IO 模型",frontmatter:{title:"IO 模型",date:"2022-02-03T18:54:29.000Z",permalink:"/pages/bc7c50/",categories:["面试","计算机基础"],tags:[null]},regularPath:"/35.%E9%9D%A2%E8%AF%95/30.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.IO%20%E6%A8%A1%E5%9E%8B.html",relativePath:"35.面试/30.计算机基础/10.IO 模型.md",key:"v-10ef9d52",path:"/pages/bc7c50/",headers:[{level:3,title:"1. 阻塞式 I/O（BIO）",slug:"_1-阻塞式-i-o-bio",normalizedTitle:"1. 阻塞式 i/o（bio）",charIndex:244},{level:3,title:"2. 非阻塞式 I/O",slug:"_2-非阻塞式-i-o",normalizedTitle:"2. 非阻塞式 i/o",charIndex:586},{level:3,title:"3. I/O （多路）复用（NIO）",slug:"_3-i-o-多路-复用-nio",normalizedTitle:"3. i/o （多路）复用（nio）",charIndex:723},{level:3,title:"4. 信号驱动 I/O",slug:"_4-信号驱动-i-o",normalizedTitle:"4. 信号驱动 i/o",charIndex:1024},{level:3,title:"5. 异步 I/O（AIO）",slug:"_5-异步-i-o-aio",normalizedTitle:"5. 异步 i/o（aio）",charIndex:1213},{level:3,title:"五大 I/O 模型比较",slug:"五大-i-o-模型比较",normalizedTitle:"五大 i/o 模型比较",charIndex:1380},{level:2,title:"1. select/poll比较",slug:"_1-select-poll比较",normalizedTitle:"1. select/poll比较",charIndex:1639},{level:2,title:"2. epoll",slug:"_2-epoll",normalizedTitle:"2. epoll",charIndex:2192},{level:2,title:"3. 应用场景",slug:"_3-应用场景",normalizedTitle:"3. 应用场景",charIndex:2404}],headersStr:"1. 阻塞式 I/O（BIO） 2. 非阻塞式 I/O 3. I/O （多路）复用（NIO） 4. 信号驱动 I/O 5. 异步 I/O（AIO） 五大 I/O 模型比较 1. select/poll比较 2. epoll 3. 应用场景",content:"# 一、I/O 模型\n\n一个输入操作通常包括两个阶段：\n\n * 等待数据准备好\n * 从内核向进程复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\nUnix 有五种 I/O 模型：\n\n * 阻塞式 I/O\n * 非阻塞式 I/O\n * I/O 复用（select 和 poll）\n * 信号驱动式 I/O（SIGIO）\n * 异步 I/O（AIO）\n\n\n# 1. 阻塞式 I/O（BIO）\n\n应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。\n\n应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。\n\n下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。\n\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\n\n\n1\n\n\n\n\n\n# 2. 非阻塞式 I/O\n\n应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。\n\n由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。\n\n\n\n\n# 3. I/O （多路）复用（NIO）\n\n使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。\n\n它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。\n\n如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。\n\n\n\n\n# 4. 信号驱动 I/O\n\n应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。\n\n相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。\n\n\n\n\n# 5. 异步 I/O（AIO）\n\n应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。\n\n异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。\n\n\n\n\n# 五大 I/O 模型比较\n\n * 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。\n * 异步 I/O：不会阻塞。\n\n阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。\n\n非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。\n\n\n\n\n# 二、I/O （多路）复用\n\nselect/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。\n\n\n# 1. select/poll比较\n\n# I. 功能\n\nselect 和 poll 的功能基本相同，不过在一些实现细节上有所不同。\n\n * select 会修改描述符，而 poll 不会；\n * select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。 如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 的描述符类型使用链表实现，没有描述符数量的限制；\n * poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。\n * 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。\n\n# II. 速度\n\nselect 和 poll 速度都比较慢。\n\n * select 和 poll 每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。\n * select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用轮询的方式来找到 I/O 完成的描述符。\n\n\n\n\n1\n\n\n# 3. 可移植性\n\n几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。\n\n\n# 2. epoll\n\nepoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。\n\nepoll 仅适用于 Linux OS。\n\nepoll 比 select 和 poll 更加灵活而且没有描述符数量限制。\n\nepoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。\n\n\n# 3. 应用场景\n\n很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。\n\n# I. select 应用场景\n\nselect 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。\n\nselect 可移植性更好，几乎被所有主流平台所支持。\n\n# II. poll 应用场景\n\npoll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。\n\n# III. epoll 应用场景\n\n只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。\n\n需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。\n\n需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。",normalizedContent:"# 一、i/o 模型\n\n一个输入操作通常包括两个阶段：\n\n * 等待数据准备好\n * 从内核向进程复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\nunix 有五种 i/o 模型：\n\n * 阻塞式 i/o\n * 非阻塞式 i/o\n * i/o 复用（select 和 poll）\n * 信号驱动式 i/o（sigio）\n * 异步 i/o（aio）\n\n\n# 1. 阻塞式 i/o（bio）\n\n应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。\n\n应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 cpu 时间，这种模型的 cpu 利用率会比较高。\n\n下图中，recvfrom() 用于接收 socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。\n\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\n\n\n1\n\n\n\n\n\n# 2. 非阻塞式 i/o\n\n应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 i/o 是否完成，这种方式称为轮询（polling）。\n\n由于 cpu 要处理更多的系统调用，因此这种模型的 cpu 利用率比较低。\n\n\n\n\n# 3. i/o （多路）复用（nio）\n\n使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。\n\n它可以让单个进程具有处理多个 i/o 事件的能力。又被称为 event driven i/o，即事件驱动 i/o。\n\n如果一个 web 服务器没有 i/o 复用，那么每一个 socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，i/o 复用不需要进程线程创建和切换的开销，系统开销更小。\n\n\n\n\n# 4. 信号驱动 i/o\n\n应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 sigio 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。\n\n相比于非阻塞式 i/o 的轮询方式，信号驱动 i/o 的 cpu 利用率更高。\n\n\n\n\n# 5. 异步 i/o（aio）\n\n应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。\n\n异步 i/o 与信号驱动 i/o 的区别在于，异步 i/o 的信号是通知应用进程 i/o 完成，而信号驱动 i/o 的信号是通知应用进程可以开始 i/o。\n\n\n\n\n# 五大 i/o 模型比较\n\n * 同步 i/o：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。\n * 异步 i/o：不会阻塞。\n\n阻塞式 i/o、非阻塞式 i/o、i/o 复用和信号驱动 i/o 都是同步 i/o，它们的主要区别在第一个阶段。\n\n非阻塞式 i/o 、信号驱动 i/o 和异步 i/o 在第一阶段不会阻塞。\n\n\n\n\n# 二、i/o （多路）复用\n\nselect/poll/epoll 都是 i/o 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。\n\n\n# 1. select/poll比较\n\n# i. 功能\n\nselect 和 poll 的功能基本相同，不过在一些实现细节上有所不同。\n\n * select 会修改描述符，而 poll 不会；\n * select 的描述符类型使用数组实现，fd_setsize 大小默认为 1024，因此默认只能监听 1024 个描述符。 如果要监听更多描述符的话，需要修改 fd_setsize 之后重新编译；而 poll 的描述符类型使用链表实现，没有描述符数量的限制；\n * poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。\n * 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。\n\n# ii. 速度\n\nselect 和 poll 速度都比较慢。\n\n * select 和 poll 每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。\n * select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用轮询的方式来找到 i/o 完成的描述符。\n\n\n\n\n1\n\n\n# 3. 可移植性\n\n几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。\n\n\n# 2. epoll\n\nepoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。\n\nepoll 仅适用于 linux os。\n\nepoll 比 select 和 poll 更加灵活而且没有描述符数量限制。\n\nepoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。\n\n\n# 3. 应用场景\n\n很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。\n\n# i. select 应用场景\n\nselect 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。\n\nselect 可移植性更好，几乎被所有主流平台所支持。\n\n# ii. poll 应用场景\n\npoll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。\n\n# iii. epoll 应用场景\n\n只需要运行在 linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。\n\n需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。\n\n需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Redis高级客户端Lettuce详解",frontmatter:{title:"Redis高级客户端Lettuce详解",date:"2022-02-03T23:04:37.000Z",categories:["框架","Redis"],tags:[null],permalink:"/pages/bdd0da/"},regularPath:"/40.%E6%9B%B4%E5%A4%9A/10.Redis%E9%AB%98%E7%BA%A7%E5%AE%A2%E6%88%B7%E7%AB%AFLettuce%E8%AF%A6%E8%A7%A3.html",relativePath:"40.更多/10.Redis高级客户端Lettuce详解.md",key:"v-3b86a05e",path:"/pages/bdd0da/",headersStr:null,content:" * Redis高级客户端Lettuce详解",normalizedContent:" * redis高级客户端lettuce详解",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-5176e105",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-75e41c65",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-3249c685",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"你知道的越多，不知道的也就越多",frontmatter:{title:"你知道的越多，不知道的也就越多",date:"2020-05-06T15:52:40.000Z",permalink:"/pages/f2e63f",sidebar:"auto",categories:["随笔"],tags:["学习","知识","鸡汤"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%B6%8A%E5%A4%9A%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B9%9F%E5%B0%B1%E8%B6%8A%E5%A4%9A.html",relativePath:"_posts/随笔/你知道的越多，不知道的也就越多.md",key:"v-ec84fed2",path:"/pages/f2e63f/",excerpt:"<p>不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。</p>\n",headersStr:null,content:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",normalizedContent:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"拥抱生活，拥抱快乐",frontmatter:{title:"拥抱生活，拥抱快乐",date:"2020-06-26T20:40:38.000Z",permalink:"/pages/cd8bde/",sidebar:"auto",categories:["随笔"],tags:["鸡汤"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E6%8B%A5%E6%8A%B1%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8B%A5%E6%8A%B1%E5%BF%AB%E4%B9%90.html",relativePath:"_posts/随笔/拥抱生活，拥抱快乐.md",key:"v-2100b3d2",path:"/pages/cd8bde/",excerpt:"<p>生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。</p>\n",headersStr:null,content:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:B站视频《罗翔说刑法》，链接https://b23.tv/K8ulrE",normalizedContent:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:b站视频《罗翔说刑法》，链接https://b23.tv/k8ulre",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Home",frontmatter:{home:!0,heroText:"Evan's blog",tagline:"Web前端技术博客，积跬步以至千里，致敬每个爱学习的你。",features:[{title:"前端",details:"JavaScript、ES6、Vue框架等前端技术",link:"/web/",imgUrl:"/img/web.png"},{title:"页面",details:"html(5)/css(3)，前端页面相关技术",link:"/ui/",imgUrl:"/img/ui.png"},{title:"技术",details:"技术文档、教程、技巧、总结等文章",link:"/technology/",imgUrl:"/img/other.png"}]},regularPath:"/",relativePath:"index.md",key:"v-2b7111c4",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"ECMAScript 6 简介",frontmatter:{title:"ECMAScript 6 简介",date:"2020-01-12T15:45:35.000Z",permalink:"/pages/f344d070a1031ef7",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/01.ECMAScript%206%20%E7%AE%80%E4%BB%8B.html",relativePath:"《ES6 教程》笔记/01.ECMAScript 6 简介.md",key:"v-7b48c50c",path:"/pages/f344d070a1031ef7/",headers:[{level:2,title:"ECMAScript 和 JavaScript 的关系",slug:"ecmascript-和-javascript-的关系",normalizedTitle:"ecmascript 和 javascript 的关系",charIndex:210},{level:2,title:"ES6 与 ECMAScript 2015 的关系",slug:"es6-与-ecmascript-2015-的关系",normalizedTitle:"es6 与 ecmascript 2015 的关系",charIndex:795},{level:2,title:"语法提案的批准流程",slug:"语法提案的批准流程",normalizedTitle:"语法提案的批准流程",charIndex:1756},{level:2,title:"ECMAScript 的历史",slug:"ecmascript-的历史",normalizedTitle:"ecmascript 的历史",charIndex:2184},{level:2,title:"部署进度",slug:"部署进度",normalizedTitle:"部署进度",charIndex:3648},{level:2,title:"Babel 转码器",slug:"babel-转码器",normalizedTitle:"babel 转码器",charIndex:4336},{level:3,title:"配置文件.babelrc",slug:"配置文件-babelrc",normalizedTitle:"配置文件.babelrc",charIndex:4688},{level:3,title:"命令行转码",slug:"命令行转码",normalizedTitle:"命令行转码",charIndex:5176},{level:3,title:"babel-node",slug:"babel-node",normalizedTitle:"babel-node",charIndex:5638},{level:3,title:"@babel/register 模块",slug:"babel-register-模块",normalizedTitle:"@babel/register 模块",charIndex:6011},{level:3,title:"babel API",slug:"babel-api",normalizedTitle:"babel api",charIndex:6406},{level:3,title:"@babel/polyfill",slug:"babel-polyfill",normalizedTitle:"@babel/polyfill",charIndex:7300},{level:3,title:"浏览器环境",slug:"浏览器环境",normalizedTitle:"浏览器环境",charIndex:7791},{level:2,title:"Traceur 转码器",slug:"traceur-转码器",normalizedTitle:"traceur 转码器",charIndex:8118},{level:3,title:"直接插入网页",slug:"直接插入网页",normalizedTitle:"直接插入网页",charIndex:8178},{level:3,title:"在线转换",slug:"在线转换",normalizedTitle:"在线转换",charIndex:9938},{level:3,title:"命令行转换",slug:"命令行转换",normalizedTitle:"命令行转换",charIndex:10679},{level:3,title:"Node 环境的用法",slug:"node-环境的用法",normalizedTitle:"node 环境的用法",charIndex:11158}],excerpt:'<blockquote>\n<p>说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener noreferrer">http://es6.ruanyifeng.com/<OutboundLink/></a>，教程版权归原作者所有。</p>\n</blockquote>\n<h1 id="ecmascript-6-简介"><a class="header-anchor" href="#ecmascript-6-简介">#</a> ECMAScript 6 简介</h1>\n<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\n',headersStr:"ECMAScript 和 JavaScript 的关系 ES6 与 ECMAScript 2015 的关系 语法提案的批准流程 ECMAScript 的历史 部署进度 Babel 转码器 配置文件.babelrc 命令行转码 babel-node @babel/register 模块 babel API @babel/polyfill 浏览器环境 Traceur 转码器 直接插入网页 在线转换 命令行转换 Node 环境的用法",content:"> 说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源http://es6.ruanyifeng.com/，教程版权归原作者所有。\n\n\n# ECMAScript 6 简介\n\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n\n\n# ECMAScript 和 JavaScript 的关系\n\n一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？\n\n要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。\n\n该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。\n\n因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。\n\n\n# ES6 与 ECMAScript 2015 的关系\n\nECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？\n\n2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。\n\n但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。\n\n但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。\n\n标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。\n\nES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。\n\n因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。\n\n\n# 语法提案的批准流程\n\n任何人都可以向标准委员会（又称 TC39 委员会）提案，要求修改语言标准。\n\n一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。\n\n * Stage 0 - Strawman（展示阶段）\n * Stage 1 - Proposal（征求意见阶段）\n * Stage 2 - Draft（草案阶段）\n * Stage 3 - Candidate（候选人阶段）\n * Stage 4 - Finished（定案阶段）\n\n一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在 TC39 的官方网站GitHub.com/tc39/ecma262查看。\n\n本书的写作目标之一，是跟踪 ECMAScript 语言的最新进展，介绍 5.1 版本以后所有的新语法。对于那些明确或很有希望，将要列入标准的新语法，都将予以介绍。\n\n\n# ECMAScript 的历史\n\nES6 从开始制定到最后发布，整整用了 15 年。\n\n前面提到，ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998 年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。\n\n2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6 继承了。因此，ES6 制定的起点其实是 2000 年。\n\n为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3 做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA 的第 39 号技术专家委员会（Technical Committee 39，简称 TC39）负责制订 ECMAScript 标准，成员包括 Microsoft、Mozilla、Google 等大公司。\n\n2007 年 10 月，ECMAScript 4.0 版草案发布，本来预计次年 8 月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。\n\n2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。\n\n2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 委员会的总体考虑是，ES5 与 ES3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是 ES6，第六版发布以后，就指 ES7。TC39 的判断是，ES5 会在 2013 年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。\n\n2011 年 6 月，ECMAScript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。\n\n2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。\n\n2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。\n\n2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。从 2000 年算起，这时已经过去了 15 年。\n\n\n# 部署进度\n\n各大浏览器的最新版本，对 ES6 的支持可以查看kangax.github.io/compat-table/es6/。随着时间的推移，支持度已经越来越高了，超过 90%的 ES6 语法特性都实现了。\n\nNode 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 Node 已经实现的 ES6 特性。\n\n// Linux & Mac\n$ node --v8-options | grep harmony\n\n// Windows\n$ node --v8-options | findstr harmony\n\n\n1\n2\n3\n4\n5\n\n\n我写了一个工具 ES-Checker，用来检查各种运行环境对 ES6 的支持情况。访问ruanyf.github.io/es-checker，可以看到您的浏览器支持 ES6 的程度。运行下面的命令，可以查看你正在使用的 Node 环境对 ES6 的支持程度。\n\n$ npm install -g es-checker\n$ es-checker\n\n=========================================\nPasses 24 feature Detections\nYour runtime supports 57% of ECMAScript 6\n=========================================\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Babel 转码器\n\nBabel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。\n\n// 转码前\ninput.map(item => item + 1);\n\n// 转码后\ninput.map(function (item) {\n  return item + 1;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。\n\n下面的命令在项目目录中，安装 Babel。\n\n$ npm install --save-dev @babel/core\n\n\n1\n\n\n\n# 配置文件.babelrc\n\nBabel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。\n\n该文件用来设置转码规则和插件，基本格式如下。\n\n{\n  \"presets\": [],\n  \"plugins\": []\n}\n\n\n1\n2\n3\n4\n\n\npresets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。\n\n# 最新转码规则\n$ npm install --save-dev @babel/preset-env\n\n# react 转码规则\n$ npm install --save-dev @babel/preset-react\n\n\n1\n2\n3\n4\n5\n\n\n然后，将这些规则加入.babelrc。\n\n  {\n    \"presets\": [\n      \"@babel/env\",\n      \"@babel/preset-react\"\n    ],\n    \"plugins\": []\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。\n\n\n# 命令行转码\n\nBabel 提供命令行工具@babel/cli，用于命令行转码。\n\n它的安装命令如下。\n\n$ npm install --save-dev @babel/cli\n\n\n1\n\n\n基本用法如下。\n\n# 转码结果输出到标准输出\n$ npx babel example.js\n\n# 转码结果写入一个文件\n# --out-file 或 -o 参数指定输出文件\n$ npx babel example.js --out-file compiled.js\n# 或者\n$ npx babel example.js -o compiled.js\n\n# 整个目录转码\n# --out-dir 或 -d 参数指定输出目录\n$ npx babel src --out-dir lib\n# 或者\n$ npx babel src -d lib\n\n# -s 参数生成source map文件\n$ npx babel src -d lib -s\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# babel-node\n\n@babel/node模块的babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。\n\n首先，安装这个模块。\n\n$ npm install --save-dev @babel/node\n\n\n1\n\n\n然后，执行babel-node就进入 REPL 环境。\n\n$ npx babel-node\n> (x => x * 2)(1)\n2\n\n\n1\n2\n3\n\n\nbabel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。\n\n# es6.js 的代码\n# console.log((x => x * 2)(1));\n$ npx babel-node es6.js\n2\n\n\n1\n2\n3\n4\n\n\n\n# @babel/register 模块\n\n@babel/register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码。\n\n$ npm install --save-dev @babel/register\n\n\n1\n\n\n使用时，必须首先加载@babel/register。\n\n// index.js\nrequire('@babel/register');\nrequire('./es6.js');\n\n\n1\n2\n3\n\n\n然后，就不需要手动对index.js转码了。\n\n$ node index.js\n2\n\n\n1\n2\n\n\n需要注意的是，@babel/register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。\n\n\n# babel API\n\n如果某些代码需要调用 Babel 的 API 进行转码，就要使用@babel/core模块。\n\nvar babel = require('@babel/core');\n\n// 字符串转码\nbabel.transform('code();', options);\n// => { code, map, ast }\n\n// 文件转码（异步）\nbabel.transformFile('filename.js', options, function(err, result) {\n  result; // => { code, map, ast }\n});\n\n// 文件转码（同步）\nbabel.transformFileSync('filename.js', options);\n// => { code, map, ast }\n\n// Babel AST转码\nbabel.transformFromAst(ast, code, options);\n// => { code, map, ast }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n配置对象options，可以参看官方文档http://babeljs.io/docs/usage/options/。\n\n下面是一个例子。\n\nvar es6Code = 'let x = n => n + 1';\nvar es5Code = require('@babel/core')\n  .transform(es6Code, {\n    presets: ['@babel/env']\n  })\n  .code;\n\nconsole.log(es5Code);\n// '\"use strict\";\\n\\nvar x = function x(n) {\\n  return n + 1;\\n};'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。\n\n\n# @babel/polyfill\n\nBabel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。\n\n举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。\n\n安装命令如下。\n\n$ npm install --save-dev @babel/polyfill\n\n\n1\n\n\n然后，在脚本头部，加入如下一行代码。\n\nimport '@babel/polyfill';\n// 或者\nrequire('@babel/polyfill');\n\n\n1\n2\n3\n\n\nBabel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。\n\n\n# 浏览器环境\n\nBabel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。\n\n<script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"><\/script>\n<script type=\"text/babel\">\n// Your ES6 code\n<\/script>\n\n\n1\n2\n3\n4\n\n\n注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。\n\nBabel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。\n\n\n# Traceur 转码器\n\nGoogle 公司的Traceur转码器，也可以将 ES6 代码转为 ES5 代码。\n\n\n# 直接插入网页\n\nTraceur 允许将 ES6 代码直接插入网页。首先，必须在网页头部加载 Traceur 库文件。\n\n<script src=\"https://google.github.io/traceur-compiler/bin/traceur.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/bin/BrowserSystem.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/src/bootstrap.js\"><\/script>\n<script type=\"module\">\n  import './Greeter.js';\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，一共有 4 个script标签。第一个是加载 Traceur 的库文件，第二个和第三个是将这个库文件用于浏览器环境，第四个则是加载用户脚本，这个脚本里面可以使用 ES6 代码。\n\n注意，第四个script标签的type属性的值是module，而不是text/javascript。这是 Traceur 编译器识别 ES6 代码的标志，编译器会自动将所有type=module的代码编译为 ES5，然后再交给浏览器执行。\n\n除了引用外部 ES6 脚本，也可以直接在网页中放置 ES6 代码。\n\n<script type=\"module\">\n  class Calc {\n    constructor() {\n      console.log('Calc constructor');\n    }\n    add(a, b) {\n      return a + b;\n    }\n  }\n\n  var c = new Calc();\n  console.log(c.add(4,5));\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n正常情况下，上面代码会在控制台打印出9。\n\n如果想对 Traceur 的行为有精确控制，可以采用下面参数配置的写法。\n\n<script>\n  // Create the System object\n  window.System = new traceur.runtime.BrowserTraceurLoader();\n  // Set some experimental options\n  var metadata = {\n    traceurOptions: {\n      experimental: true,\n      properTailCalls: true,\n      symbols: true,\n      arrayComprehension: true,\n      asyncFunctions: true,\n      asyncGenerators: exponentiation,\n      forOn: true,\n      generatorComprehension: true\n    }\n  };\n  // Load your module\n  System.import('./myModule.js', {metadata: metadata}).catch(function(ex) {\n    console.error('Import failed', ex.stack || ex);\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面代码中，首先生成 Traceur 的全局对象window.System，然后System.import方法可以用来加载 ES6。加载的时候，需要传入一个配置对象metadata，该对象的traceurOptions属性可以配置支持 ES6 功能。如果设为experimental: true，就表示除了 ES6 以外，还支持一些实验性的新功能。\n\n\n# 在线转换\n\nTraceur 也提供一个在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。\n\n上面的例子转为 ES5 代码运行，就是下面这个样子。\n\n<script src=\"https://google.github.io/traceur-compiler/bin/traceur.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/bin/BrowserSystem.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/src/bootstrap.js\"><\/script>\n<script>\n$traceurRuntime.ModuleStore.getAnonymousModule(function() {\n  \"use strict\";\n\n  var Calc = function Calc() {\n    console.log('Calc constructor');\n  };\n\n  ($traceurRuntime.createClass)(Calc, {add: function(a, b) {\n    return a + b;\n  }}, {});\n\n  var c = new Calc();\n  console.log(c.add(4, 5));\n  return {};\n});\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 命令行转换\n\n作为命令行工具使用时，Traceur 是一个 Node 的模块，首先需要用 npm 安装。\n\n$ npm install -g traceur\n\n\n1\n\n\n安装成功后，就可以在命令行下使用 Traceur 了。\n\nTraceur 直接运行 ES6 脚本文件，会在标准输出显示运行结果，以前面的calc.js为例。\n\n$ traceur calc.js\nCalc constructor\n9\n\n\n1\n2\n3\n\n\n如果要将 ES6 脚本转为 ES5 保存，要采用下面的写法。\n\n$ traceur --script calc.es6.js --out calc.es5.js\n\n\n1\n\n\n上面代码的--script选项表示指定输入文件，--out选项表示指定输出文件。\n\n为了防止有些特性编译不成功，最好加上--experimental选项。\n\n$ traceur --script calc.es6.js --out calc.es5.js --experimental\n\n\n1\n\n\n命令行下转换生成的文件，就可以直接放到浏览器中运行。\n\n\n# Node 环境的用法\n\nTraceur 的 Node 用法如下（假定已安装traceur模块）。\n\nvar traceur = require('traceur');\nvar fs = require('fs');\n\n// 将 ES6 脚本转为字符串\nvar contents = fs.readFileSync('es6-file.js').toString();\n\nvar result = traceur.compile(contents, {\n  filename: 'es6-file.js',\n  sourceMap: true,\n  // 其他设置\n  modules: 'commonjs'\n});\n\nif (result.error)\n  throw result.error;\n\n// result 对象的 js 属性就是转换后的 ES5 代码\nfs.writeFileSync('out.js', result.js);\n// sourceMap 属性对应 map 文件\nfs.writeFileSync('out.js.map', result.sourceMap);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",normalizedContent:"> 说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源http://es6.ruanyifeng.com/，教程版权归原作者所有。\n\n\n# ecmascript 6 简介\n\necmascript 6.0（以下简称 es6）是 javascript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 javascript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n\n\n# ecmascript 和 javascript 的关系\n\n一个常见的问题是，ecmascript 和 javascript 到底是什么关系？\n\n要讲清楚这个问题，需要回顾历史。1996 年 11 月，javascript 的创造者 netscape 公司，决定将 javascript 提交给标准化组织 ecma，希望这种语言能够成为国际标准。次年，ecma 发布 262 号标准文件（ecma-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ecmascript，这个版本就是 1.0 版。\n\n该标准从一开始就是针对 javascript 语言制定的，但是之所以不叫 javascript，有两个原因。一是商标，java 是 sun 公司的商标，根据授权协议，只有 netscape 公司可以合法地使用 javascript 这个名字，且 javascript 本身也已经被 netscape 公司注册为商标。二是想体现这门语言的制定者是 ecma，不是 netscape，这样有利于保证这门语言的开放性和中立性。\n\n因此，ecmascript 和 javascript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ecmascript 方言还有 jscript 和 actionscript）。日常场合，这两个词是可以互换的。\n\n\n# es6 与 ecmascript 2015 的关系\n\necmascript 2015（简称 es2015）这个词，也是经常可以看到的。它与 es6 是什么关系呢？\n\n2011 年，ecmascript 5.1 版发布后，就开始制定 6.0 版了。因此，es6 这个词的原意，就是指 javascript 语言的下一个版本。\n\n但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。\n\n但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。\n\n标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。\n\nes6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ecmascript 2015 标准》（简称 es2015）。2016 年 6 月，小幅修订的《ecmascript 2016 标准》（简称 es2016）如期发布，这个版本可以看作是 es6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 es2017 标准。\n\n因此，es6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 javascript 的下一代标准，涵盖了 es2015、es2016、es2017 等等，而 es2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 es6 的地方，一般是指 es2015 标准，但有时也是泛指“下一代 javascript 语言”。\n\n\n# 语法提案的批准流程\n\n任何人都可以向标准委员会（又称 tc39 委员会）提案，要求修改语言标准。\n\n一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 tc39 委员会批准。\n\n * stage 0 - strawman（展示阶段）\n * stage 1 - proposal（征求意见阶段）\n * stage 2 - draft（草案阶段）\n * stage 3 - candidate（候选人阶段）\n * stage 4 - finished（定案阶段）\n\n一个提案只要能进入 stage 2，就差不多肯定会包括在以后的正式标准里面。ecmascript 当前的所有提案，可以在 tc39 的官方网站github.com/tc39/ecma262查看。\n\n本书的写作目标之一，是跟踪 ecmascript 语言的最新进展，介绍 5.1 版本以后所有的新语法。对于那些明确或很有希望，将要列入标准的新语法，都将予以介绍。\n\n\n# ecmascript 的历史\n\nes6 从开始制定到最后发布，整整用了 15 年。\n\n前面提到，ecmascript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ecmascript 2.0（1998 年 6 月）和 ecmascript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 javascript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 javascript，其实就是在学 3.0 版的语法。\n\n2000 年，ecmascript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 es6 继承了。因此，es6 制定的起点其实是 2000 年。\n\n为什么 es4 没有通过呢？因为这个版本太激进了，对 es3 做了彻底升级，导致标准委员会的一些成员不愿意接受。ecma 的第 39 号技术专家委员会（technical committee 39，简称 tc39）负责制订 ecmascript 标准，成员包括 microsoft、mozilla、google 等大公司。\n\n2007 年 10 月，ecmascript 4.0 版草案发布，本来预计次年 8 月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以 yahoo、microsoft、google 为首的大公司，反对 javascript 的大幅升级，主张小幅改动；以 javascript 创造者 brendan eich 为首的 mozilla 公司，则坚持当前的草案。\n\n2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ecma 开会决定，中止 ecmascript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ecmascript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 harmony（和谐）。会后不久，ecmascript 3.1 就改名为 ecmascript 5。\n\n2009 年 12 月，ecmascript 5.0 版正式发布。harmony 项目则一分为二，一些较为可行的设想定名为 javascript.next 继续开发，后来演变成 ecmascript 6；一些不是很成熟的设想，则被视为 javascript.next.next，在更远的将来再考虑推出。tc39 委员会的总体考虑是，es5 与 es3 基本保持兼容，较大的语法修正和新功能加入，将由 javascript.next 完成。当时，javascript.next 指的是 es6，第六版发布以后，就指 es7。tc39 的判断是，es5 会在 2013 年的年中成为 javascript 开发的主流标准，并在此后五年中一直保持这个位置。\n\n2011 年 6 月，ecmascript 5.1 版发布，并且成为 iso 国际标准（iso/iec 16262:2011）。\n\n2013 年 3 月，ecmascript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ecmascript 7。\n\n2013 年 12 月，ecmascript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。\n\n2015 年 6 月，ecmascript 6 正式通过，成为国际标准。从 2000 年算起，这时已经过去了 15 年。\n\n\n# 部署进度\n\n各大浏览器的最新版本，对 es6 的支持可以查看kangax.github.io/compat-table/es6/。随着时间的推移，支持度已经越来越高了，超过 90%的 es6 语法特性都实现了。\n\nnode 是 javascript 的服务器运行环境（runtime）。它对 es6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 node 已经实现的 es6 特性。\n\n// linux & mac\n$ node --v8-options | grep harmony\n\n// windows\n$ node --v8-options | findstr harmony\n\n\n1\n2\n3\n4\n5\n\n\n我写了一个工具 es-checker，用来检查各种运行环境对 es6 的支持情况。访问ruanyf.github.io/es-checker，可以看到您的浏览器支持 es6 的程度。运行下面的命令，可以查看你正在使用的 node 环境对 es6 的支持程度。\n\n$ npm install -g es-checker\n$ es-checker\n\n=========================================\npasses 24 feature detections\nyour runtime supports 57% of ecmascript 6\n=========================================\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# babel 转码器\n\nbabel 是一个广泛使用的 es6 转码器，可以将 es6 代码转为 es5 代码，从而在现有环境执行。这意味着，你可以用 es6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。\n\n// 转码前\ninput.map(item => item + 1);\n\n// 转码后\ninput.map(function (item) {\n  return item + 1;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的原始代码用了箭头函数，babel 将其转为普通函数，就能在不支持箭头函数的 javascript 环境执行了。\n\n下面的命令在项目目录中，安装 babel。\n\n$ npm install --save-dev @babel/core\n\n\n1\n\n\n\n# 配置文件.babelrc\n\nbabel 的配置文件是.babelrc，存放在项目的根目录下。使用 babel 的第一步，就是配置这个文件。\n\n该文件用来设置转码规则和插件，基本格式如下。\n\n{\n  \"presets\": [],\n  \"plugins\": []\n}\n\n\n1\n2\n3\n4\n\n\npresets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。\n\n# 最新转码规则\n$ npm install --save-dev @babel/preset-env\n\n# react 转码规则\n$ npm install --save-dev @babel/preset-react\n\n\n1\n2\n3\n4\n5\n\n\n然后，将这些规则加入.babelrc。\n\n  {\n    \"presets\": [\n      \"@babel/env\",\n      \"@babel/preset-react\"\n    ],\n    \"plugins\": []\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，以下所有 babel 工具和模块的使用，都必须先写好.babelrc。\n\n\n# 命令行转码\n\nbabel 提供命令行工具@babel/cli，用于命令行转码。\n\n它的安装命令如下。\n\n$ npm install --save-dev @babel/cli\n\n\n1\n\n\n基本用法如下。\n\n# 转码结果输出到标准输出\n$ npx babel example.js\n\n# 转码结果写入一个文件\n# --out-file 或 -o 参数指定输出文件\n$ npx babel example.js --out-file compiled.js\n# 或者\n$ npx babel example.js -o compiled.js\n\n# 整个目录转码\n# --out-dir 或 -d 参数指定输出目录\n$ npx babel src --out-dir lib\n# 或者\n$ npx babel src -d lib\n\n# -s 参数生成source map文件\n$ npx babel src -d lib -s\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# babel-node\n\n@babel/node模块的babel-node命令，提供一个支持 es6 的 repl 环境。它支持 node 的 repl 环境的所有功能，而且可以直接运行 es6 代码。\n\n首先，安装这个模块。\n\n$ npm install --save-dev @babel/node\n\n\n1\n\n\n然后，执行babel-node就进入 repl 环境。\n\n$ npx babel-node\n> (x => x * 2)(1)\n2\n\n\n1\n2\n3\n\n\nbabel-node命令可以直接运行 es6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。\n\n# es6.js 的代码\n# console.log((x => x * 2)(1));\n$ npx babel-node es6.js\n2\n\n\n1\n2\n3\n4\n\n\n\n# @babel/register 模块\n\n@babel/register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 babel 进行转码。\n\n$ npm install --save-dev @babel/register\n\n\n1\n\n\n使用时，必须首先加载@babel/register。\n\n// index.js\nrequire('@babel/register');\nrequire('./es6.js');\n\n\n1\n2\n3\n\n\n然后，就不需要手动对index.js转码了。\n\n$ node index.js\n2\n\n\n1\n2\n\n\n需要注意的是，@babel/register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。\n\n\n# babel api\n\n如果某些代码需要调用 babel 的 api 进行转码，就要使用@babel/core模块。\n\nvar babel = require('@babel/core');\n\n// 字符串转码\nbabel.transform('code();', options);\n// => { code, map, ast }\n\n// 文件转码（异步）\nbabel.transformfile('filename.js', options, function(err, result) {\n  result; // => { code, map, ast }\n});\n\n// 文件转码（同步）\nbabel.transformfilesync('filename.js', options);\n// => { code, map, ast }\n\n// babel ast转码\nbabel.transformfromast(ast, code, options);\n// => { code, map, ast }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n配置对象options，可以参看官方文档http://babeljs.io/docs/usage/options/。\n\n下面是一个例子。\n\nvar es6code = 'let x = n => n + 1';\nvar es5code = require('@babel/core')\n  .transform(es6code, {\n    presets: ['@babel/env']\n  })\n  .code;\n\nconsole.log(es5code);\n// '\"use strict\";\\n\\nvar x = function x(n) {\\n  return n + 1;\\n};'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 es6 代码，第二个参数是转换的配置对象。\n\n\n# @babel/polyfill\n\nbabel 默认只转换新的 javascript 句法（syntax），而不转换新的 api，比如iterator、generator、set、map、proxy、reflect、symbol、promise等全局对象，以及一些定义在全局对象上的方法（比如object.assign）都不会转码。\n\n举例来说，es6 在array对象上新增了array.from方法。babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。\n\n安装命令如下。\n\n$ npm install --save-dev @babel/polyfill\n\n\n1\n\n\n然后，在脚本头部，加入如下一行代码。\n\nimport '@babel/polyfill';\n// 或者\nrequire('@babel/polyfill');\n\n\n1\n2\n3\n\n\nbabel 默认不转码的 api 非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。\n\n\n# 浏览器环境\n\nbabel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。\n\n<script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"><\/script>\n<script type=\"text/babel\">\n// your es6 code\n<\/script>\n\n\n1\n2\n3\n4\n\n\n注意，网页实时将 es6 代码转为 es5，对性能会有影响。生产环境需要加载已经转码完成的脚本。\n\nbabel 提供一个repl 在线编译器，可以在线将 es6 代码转为 es5 代码。转换后的代码，可以直接作为 es5 代码插入网页运行。\n\n\n# traceur 转码器\n\ngoogle 公司的traceur转码器，也可以将 es6 代码转为 es5 代码。\n\n\n# 直接插入网页\n\ntraceur 允许将 es6 代码直接插入网页。首先，必须在网页头部加载 traceur 库文件。\n\n<script src=\"https://google.github.io/traceur-compiler/bin/traceur.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/bin/browsersystem.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/src/bootstrap.js\"><\/script>\n<script type=\"module\">\n  import './greeter.js';\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，一共有 4 个script标签。第一个是加载 traceur 的库文件，第二个和第三个是将这个库文件用于浏览器环境，第四个则是加载用户脚本，这个脚本里面可以使用 es6 代码。\n\n注意，第四个script标签的type属性的值是module，而不是text/javascript。这是 traceur 编译器识别 es6 代码的标志，编译器会自动将所有type=module的代码编译为 es5，然后再交给浏览器执行。\n\n除了引用外部 es6 脚本，也可以直接在网页中放置 es6 代码。\n\n<script type=\"module\">\n  class calc {\n    constructor() {\n      console.log('calc constructor');\n    }\n    add(a, b) {\n      return a + b;\n    }\n  }\n\n  var c = new calc();\n  console.log(c.add(4,5));\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n正常情况下，上面代码会在控制台打印出9。\n\n如果想对 traceur 的行为有精确控制，可以采用下面参数配置的写法。\n\n<script>\n  // create the system object\n  window.system = new traceur.runtime.browsertraceurloader();\n  // set some experimental options\n  var metadata = {\n    traceuroptions: {\n      experimental: true,\n      propertailcalls: true,\n      symbols: true,\n      arraycomprehension: true,\n      asyncfunctions: true,\n      asyncgenerators: exponentiation,\n      foron: true,\n      generatorcomprehension: true\n    }\n  };\n  // load your module\n  system.import('./mymodule.js', {metadata: metadata}).catch(function(ex) {\n    console.error('import failed', ex.stack || ex);\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面代码中，首先生成 traceur 的全局对象window.system，然后system.import方法可以用来加载 es6。加载的时候，需要传入一个配置对象metadata，该对象的traceuroptions属性可以配置支持 es6 功能。如果设为experimental: true，就表示除了 es6 以外，还支持一些实验性的新功能。\n\n\n# 在线转换\n\ntraceur 也提供一个在线编译器，可以在线将 es6 代码转为 es5 代码。转换后的代码，可以直接作为 es5 代码插入网页运行。\n\n上面的例子转为 es5 代码运行，就是下面这个样子。\n\n<script src=\"https://google.github.io/traceur-compiler/bin/traceur.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/bin/browsersystem.js\"><\/script>\n<script src=\"https://google.github.io/traceur-compiler/src/bootstrap.js\"><\/script>\n<script>\n$traceurruntime.modulestore.getanonymousmodule(function() {\n  \"use strict\";\n\n  var calc = function calc() {\n    console.log('calc constructor');\n  };\n\n  ($traceurruntime.createclass)(calc, {add: function(a, b) {\n    return a + b;\n  }}, {});\n\n  var c = new calc();\n  console.log(c.add(4, 5));\n  return {};\n});\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 命令行转换\n\n作为命令行工具使用时，traceur 是一个 node 的模块，首先需要用 npm 安装。\n\n$ npm install -g traceur\n\n\n1\n\n\n安装成功后，就可以在命令行下使用 traceur 了。\n\ntraceur 直接运行 es6 脚本文件，会在标准输出显示运行结果，以前面的calc.js为例。\n\n$ traceur calc.js\ncalc constructor\n9\n\n\n1\n2\n3\n\n\n如果要将 es6 脚本转为 es5 保存，要采用下面的写法。\n\n$ traceur --script calc.es6.js --out calc.es5.js\n\n\n1\n\n\n上面代码的--script选项表示指定输入文件，--out选项表示指定输出文件。\n\n为了防止有些特性编译不成功，最好加上--experimental选项。\n\n$ traceur --script calc.es6.js --out calc.es5.js --experimental\n\n\n1\n\n\n命令行下转换生成的文件，就可以直接放到浏览器中运行。\n\n\n# node 环境的用法\n\ntraceur 的 node 用法如下（假定已安装traceur模块）。\n\nvar traceur = require('traceur');\nvar fs = require('fs');\n\n// 将 es6 脚本转为字符串\nvar contents = fs.readfilesync('es6-file.js').tostring();\n\nvar result = traceur.compile(contents, {\n  filename: 'es6-file.js',\n  sourcemap: true,\n  // 其他设置\n  modules: 'commonjs'\n});\n\nif (result.error)\n  throw result.error;\n\n// result 对象的 js 属性就是转换后的 es5 代码\nfs.writefilesync('out.js', result.js);\n// sourcemap 属性对应 map 文件\nfs.writefilesync('out.js.map', result.sourcemap);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"let 和 const 命令",frontmatter:{title:"let 和 const 命令",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/c1edd70a6b7c7872",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/02.let%20%E5%92%8C%20const%20%E5%91%BD%E4%BB%A4.html",relativePath:"《ES6 教程》笔记/02.let 和 const 命令.md",key:"v-399fd293",path:"/pages/c1edd70a6b7c7872/",headers:[{level:2,title:"let 命令",slug:"let-命令",normalizedTitle:"let 命令",charIndex:21},{level:3,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:32},{level:3,title:"不存在变量提升",slug:"不存在变量提升",normalizedTitle:"不存在变量提升",charIndex:1395},{level:3,title:"暂时性死区",slug:"暂时性死区",normalizedTitle:"暂时性死区",charIndex:1807},{level:3,title:"不允许重复声明",slug:"不允许重复声明",normalizedTitle:"不允许重复声明",charIndex:3512},{level:2,title:"块级作用域",slug:"块级作用域",normalizedTitle:"块级作用域",charIndex:95},{level:3,title:"为什么需要块级作用域？",slug:"为什么需要块级作用域",normalizedTitle:"为什么需要块级作用域？",charIndex:3848},{level:3,title:"ES6 的块级作用域",slug:"es6-的块级作用域",normalizedTitle:"es6 的块级作用域",charIndex:4363},{level:3,title:"块级作用域与函数声明",slug:"块级作用域与函数声明",normalizedTitle:"块级作用域与函数声明",charIndex:5026},{level:2,title:"const 命令",slug:"const-命令",normalizedTitle:"const 命令",charIndex:8},{level:3,title:"基本用法",slug:"基本用法-2",normalizedTitle:"基本用法",charIndex:32},{level:3,title:"本质",slug:"本质",normalizedTitle:"本质",charIndex:3441},{level:3,title:"ES6 声明变量的六种方法",slug:"es6-声明变量的六种方法",normalizedTitle:"es6 声明变量的六种方法",charIndex:9231},{level:2,title:"顶层对象的属性",slug:"顶层对象的属性",normalizedTitle:"顶层对象的属性",charIndex:9364},{level:2,title:"globalThis 对象",slug:"globalthis-对象",normalizedTitle:"globalthis 对象",charIndex:10123}],excerpt:'<h1 id="let-和-const-命令"><a class="header-anchor" href="#let-和-const-命令">#</a> let 和 const 命令</h1>\n<h2 id="let-命令"><a class="header-anchor" href="#let-命令">#</a> let 命令</h2>\n<h3 id="基本用法"><a class="header-anchor" href="#基本用法">#</a> 基本用法</h3>\n<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，<strong>只在<code>let</code>命令所在的代码块内有效(块级作用域)</strong>。</p>\n\x3c!--beforebegin--\x3e<div class="language-javascript line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-javascript"><code><span class="token punctuation">{</span>\n  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\na <span class="token comment">// ReferenceError: a is not defined.</span>\nb <span class="token comment">// 1</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"let 命令 基本用法 不存在变量提升 暂时性死区 不允许重复声明 块级作用域 为什么需要块级作用域？ ES6 的块级作用域 块级作用域与函数声明 const 命令 基本用法 本质 ES6 声明变量的六种方法 顶层对象的属性 globalThis 对象",content:"# let 和 const 命令\n\n\n# let 命令\n\n\n# 基本用法\n\nES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效(块级作用域)。\n\n{\n  let a = 10;\n  var b = 1;\n}\n\na // ReferenceError: a is not defined.\nb // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。\n\nfor循环的计数器，就很合适使用let命令。\n\nfor (let i = 0; i < 10; i++) {\n  // ...\n}\n\nconsole.log(i);\n// ReferenceError: i is not defined\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。\n\n> 如果for循环内用var声明i，则会打印10\n\n下面的代码如果使用var，最后输出的是10。\n\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () { // 循环时只是将函数赋值给a[i],并未执行函数。函数内的i是全局的i\n    console.log(i);\n  };\n}\na[6](); // 10\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。\n\n如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。\n\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。\n\n另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\n\nfor (let i = 0; i < 3; i++) {\n  let i = 'abc';\n  console.log(i);\n}\n// abc\n// abc\n// abc\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。\n\n\n# 不存在变量提升\n\nvar命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。\n\n为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。\n\n// var 的情况\nconsole.log(foo); // 输出undefined\nvar foo = 2;\n\n// let 的情况\nconsole.log(bar); // 报错ReferenceError\nlet bar = 2;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。\n\n\n# 暂时性死区\n\n只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。\n\nvar tmp = 123;\n\nif (true) {\n  tmp = 'abc'; // ReferenceError\n  let tmp;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。\n\nES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n\n总之，在代码块内，**使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（**temporal dead zone，简称 TDZ）。\n\nif (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。\n\n“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。\n\ntypeof x; // ReferenceError\nlet x;\n\n\n1\n2\n\n\n上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。\n\n作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。\n\ntypeof undeclared_variable // \"undefined\"\n\n\n1\n\n\n上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。\n\n有些“死区”比较隐蔽，不太容易发现。\n\nfunction bar(x = y, y = 2) {\n  return [x, y];\n}\n\nbar(); // 报错\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。\n\nfunction bar(x = 2, y = x) {\n  return [x, y];\n}\nbar(); // [2, 2]\n\n\n1\n2\n3\n4\n\n\n另外，下面的代码也会报错，与var的行为不同。\n\n// 不报错\nvar x = x;\n\n// 报错\nlet x = x;\n// ReferenceError: x is not defined\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。\n\nES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。\n\n总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。\n\n\n# 不允许重复声明\n\nlet不允许在相同作用域内，重复声明同一个变量。\n\n// 报错\nfunction func() {\n  let a = 10;\n  var a = 1;\n}\n\n// 报错\nfunction func() {\n  let a = 10;\n  let a = 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n因此，不能在函数内部重新声明参数。\n\nfunction func(arg) {\n  let arg;\n}\nfunc() // 报错\n\nfunction func(arg) {\n  {\n    let arg;\n  }\n}\nfunc() // 不报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 块级作用域\n\n\n# 为什么需要块级作用域？\n\nES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。\n\n第一种场景，内层变量可能会覆盖外层变量。\n\nvar tmp = new Date();\n\nfunction f() {\n  console.log(tmp);\n  if (false) {\n    var tmp = 'hello world';\n  }\n}\n\nf(); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。\n\n第二种场景，用来计数的循环变量泄露为全局变量。\n\nvar s = 'hello';\n\nfor (var i = 0; i < s.length; i++) {\n  console.log(s[i]);\n}\n\nconsole.log(i); // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。\n\n\n# ES6 的块级作用域\n\nlet实际上为 JavaScript 新增了块级作用域。\n\nfunction f1() {\n  let n = 5;\n  if (true) {\n    let n = 10;\n  }\n  console.log(n); // 5\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。\n\nES6 允许块级作用域的任意嵌套。\n\n{{{{\n  {let insane = 'Hello World'}\n  console.log(insane); // 报错\n}}}};\n\n\n1\n2\n3\n4\n\n\n上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。\n\n内层作用域可以定义外层作用域的同名变量。\n\n{{{{\n  let insane = 'Hello World';\n  {let insane = 'Hello World'}\n}}}};\n\n\n1\n2\n3\n4\n\n\n块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。\n\n// IIFE 写法\n(function () {\n  var tmp = ...;\n  ...\n}());\n\n// 块级作用域写法\n{\n  let tmp = ...;\n  ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 块级作用域与函数声明\n\n函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。\n\nES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。\n\n// 情况一\nif (true) {\n  function f() {}\n}\n\n// 情况二\ntry {\n  function f() {}\n} catch(e) {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面两种函数声明，根据 ES5 的规定都是非法的。\n\n但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。\n\nES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。\n\nfunction f() { console.log('I am outside!'); }\n\n(function () {\n  if (false) {\n    // 重复声明一次函数f\n    function f() { console.log('I am inside!'); }\n  }\n\n  f();\n}());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。\n\n// ES5 环境\nfunction f() { console.log('I am outside!'); }\n\n(function () {\n  function f() { console.log('I am inside!'); }\n  if (false) {\n  }\n  f();\n}());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？\n\n// 浏览器的 ES6 环境\nfunction f() { console.log('I am outside!'); }\n\n(function () {\n  if (false) {\n    // 重复声明一次函数f\n    function f() { console.log('I am inside!'); }\n  }\n\n  f();\n}());\n// Uncaught TypeError: f is not a function\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面的代码在 ES6 浏览器中，都会报错。\n\n原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。\n\n * 允许在块级作用域内声明函数。\n * 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。\n * 同时，函数声明还会提升到所在的块级作用域的头部。\n\n注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。\n\n根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。上面的例子实际运行的代码如下。\n\n// 浏览器的 ES6 环境\nfunction f() { console.log('I am outside!'); }\n(function () {\n  var f = undefined;\n  if (false) {\n    function f() { console.log('I am inside!'); }\n  }\n\n  f();\n}());\n// Uncaught TypeError: f is not a function\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。\n\n// 块级作用域内部的函数声明语句，建议不要使用\n{\n  let a = 'secret';\n  function f() {\n    return a;\n  }\n}\n\n// 块级作用域内部，优先使用函数表达式\n{\n  let a = 'secret';\n  let f = function () {\n    return a;\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。\n\n// 第一种写法，报错\nif (true) let x = 1;\n\n// 第二种写法，不报错\nif (true) {\n  let x = 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，第一种写法没有大括号，所以不存在块级作用域，而let只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。\n\n函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。\n\n// 不报错\n'use strict';\nif (true) {\n  function f() {}\n}\n\n// 报错\n'use strict';\nif (true)\n  function f() {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# const 命令\n\n\n# 基本用法\n\nconst声明一个只读的常量。一旦声明，常量的值就不能改变。\n\nconst PI = 3.1415;\nPI // 3.1415\n\nPI = 3;\n// TypeError: Assignment to constant variable.\n\n\n1\n2\n3\n4\n5\n\n\n上面代码表明改变常量的值会报错。\n\nconst声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。\n\nconst foo;\n// SyntaxError: Missing initializer in const declaration\n\n\n1\n2\n\n\n上面代码表示，对于const来说，只声明不赋值，就会报错。\n\nconst的作用域与let命令相同：只在声明所在的块级作用域内有效。\n\nif (true) {\n  const MAX = 5;\n}\n\nMAX // Uncaught ReferenceError: MAX is not defined\n\n\n1\n2\n3\n4\n5\n\n\nconst命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。\n\nif (true) {\n  console.log(MAX); // ReferenceError\n  const MAX = 5;\n}\n\n\n1\n2\n3\n4\n\n\n上面代码在常量MAX声明之前就调用，结果报错。\n\nconst声明的常量，也与let一样不可重复声明。\n\nvar message = \"Hello!\";\nlet age = 25;\n\n// 以下两行都会报错\nconst message = \"Goodbye!\";\nconst age = 30;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 本质\n\nconst实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。\n\nconst foo = {};\n\n// 为 foo 添加一个属性，可以成功\nfoo.prop = 123;\nfoo.prop // 123\n\n// 将 foo 指向另一个对象，就会报错\nfoo = {}; // TypeError: \"foo\" is read-only\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。\n\n下面是另一个例子。\n\nconst a = [];\na.push('Hello'); // 可执行\na.length = 0;    // 可执行\na = ['Dave'];    // 报错\n\n\n1\n2\n3\n4\n\n\n上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。\n\n如果真的想将对象冻结，应该使用Object.freeze方法。\n\nconst foo = Object.freeze({});\n\n// 常规模式时，下面一行不起作用；\n// 严格模式时，该行会报错\nfoo.prop = 123;\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。\n\n除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。\n\nvar constantize = (obj) => {\n  Object.freeze(obj);\n  Object.keys(obj).forEach( (key, i) => {\n    if ( typeof obj[key] === 'object' ) {\n      constantize( obj[key] );\n    }\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# ES6 声明变量的六种方法\n\nES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。\n\n\n# 顶层对象的属性\n\n顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。\n\nwindow.a = 1;\na // 1\n\na = 2;\nwindow.a // 2\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。\n\n顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。\n\nES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。\n\nvar a = 1;\n// 如果在 Node 的 REPL 环境，可以写成 global.a\n// 或者采用通用方法，写成 this.a\nwindow.a // 1\n\nlet b = 1;\nwindow.b // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。\n\n\n# globalThis 对象\n\nJavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。\n\n * 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。\n * 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。\n * Node 里面，顶层对象是global，但其他环境都不支持。\n\n同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。\n\n * 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。\n * 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。\n * 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。\n\n综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。\n\n// 方法一\n(typeof window !== 'undefined'\n   ? window\n   : (typeof process === 'object' &&\n      typeof require === 'function' &&\n      typeof global === 'object')\n     ? global\n     : this);\n\n// 方法二\nvar getGlobal = function () {\n  if (typeof self !== 'undefined') { return self; }\n  if (typeof window !== 'undefined') { return window; }\n  if (typeof global !== 'undefined') { return global; }\n  throw new Error('unable to locate global object');\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。\n\n垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。",normalizedContent:"# let 和 const 命令\n\n\n# let 命令\n\n\n# 基本用法\n\nes6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效(块级作用域)。\n\n{\n  let a = 10;\n  var b = 1;\n}\n\na // referenceerror: a is not defined.\nb // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。\n\nfor循环的计数器，就很合适使用let命令。\n\nfor (let i = 0; i < 10; i++) {\n  // ...\n}\n\nconsole.log(i);\n// referenceerror: i is not defined\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。\n\n> 如果for循环内用var声明i，则会打印10\n\n下面的代码如果使用var，最后输出的是10。\n\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () { // 循环时只是将函数赋值给a[i],并未执行函数。函数内的i是全局的i\n    console.log(i);\n  };\n}\na[6](); // 10\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。\n\n如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。\n\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 javascript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。\n\n另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\n\nfor (let i = 0; i < 3; i++) {\n  let i = 'abc';\n  console.log(i);\n}\n// abc\n// abc\n// abc\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。\n\n\n# 不存在变量提升\n\nvar命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。\n\n为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。\n\n// var 的情况\nconsole.log(foo); // 输出undefined\nvar foo = 2;\n\n// let 的情况\nconsole.log(bar); // 报错referenceerror\nlet bar = 2;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。\n\n\n# 暂时性死区\n\n只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。\n\nvar tmp = 123;\n\nif (true) {\n  tmp = 'abc'; // referenceerror\n  let tmp;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。\n\nes6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n\n总之，在代码块内，**使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（**temporal dead zone，简称 tdz）。\n\nif (true) {\n  // tdz开始\n  tmp = 'abc'; // referenceerror\n  console.log(tmp); // referenceerror\n\n  let tmp; // tdz结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。\n\n“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。\n\ntypeof x; // referenceerror\nlet x;\n\n\n1\n2\n\n\n上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个referenceerror。\n\n作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。\n\ntypeof undeclared_variable // \"undefined\"\n\n\n1\n\n\n上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。\n\n有些“死区”比较隐蔽，不太容易发现。\n\nfunction bar(x = y, y = 2) {\n  return [x, y];\n}\n\nbar(); // 报错\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。\n\nfunction bar(x = 2, y = x) {\n  return [x, y];\n}\nbar(); // [2, 2]\n\n\n1\n2\n3\n4\n\n\n另外，下面的代码也会报错，与var的行为不同。\n\n// 不报错\nvar x = x;\n\n// 报错\nlet x = x;\n// referenceerror: x is not defined\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。\n\nes6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 es5 是很常见的，现在有了这种规定，避免此类错误就很容易了。\n\n总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。\n\n\n# 不允许重复声明\n\nlet不允许在相同作用域内，重复声明同一个变量。\n\n// 报错\nfunction func() {\n  let a = 10;\n  var a = 1;\n}\n\n// 报错\nfunction func() {\n  let a = 10;\n  let a = 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n因此，不能在函数内部重新声明参数。\n\nfunction func(arg) {\n  let arg;\n}\nfunc() // 报错\n\nfunction func(arg) {\n  {\n    let arg;\n  }\n}\nfunc() // 不报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 块级作用域\n\n\n# 为什么需要块级作用域？\n\nes5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。\n\n第一种场景，内层变量可能会覆盖外层变量。\n\nvar tmp = new date();\n\nfunction f() {\n  console.log(tmp);\n  if (false) {\n    var tmp = 'hello world';\n  }\n}\n\nf(); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。\n\n第二种场景，用来计数的循环变量泄露为全局变量。\n\nvar s = 'hello';\n\nfor (var i = 0; i < s.length; i++) {\n  console.log(s[i]);\n}\n\nconsole.log(i); // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。\n\n\n# es6 的块级作用域\n\nlet实际上为 javascript 新增了块级作用域。\n\nfunction f1() {\n  let n = 5;\n  if (true) {\n    let n = 10;\n  }\n  console.log(n); // 5\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。\n\nes6 允许块级作用域的任意嵌套。\n\n{{{{\n  {let insane = 'hello world'}\n  console.log(insane); // 报错\n}}}};\n\n\n1\n2\n3\n4\n\n\n上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。\n\n内层作用域可以定义外层作用域的同名变量。\n\n{{{{\n  let insane = 'hello world';\n  {let insane = 'hello world'}\n}}}};\n\n\n1\n2\n3\n4\n\n\n块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 iife）不再必要了。\n\n// iife 写法\n(function () {\n  var tmp = ...;\n  ...\n}());\n\n// 块级作用域写法\n{\n  let tmp = ...;\n  ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 块级作用域与函数声明\n\n函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。\n\nes5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。\n\n// 情况一\nif (true) {\n  function f() {}\n}\n\n// 情况二\ntry {\n  function f() {}\n} catch(e) {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面两种函数声明，根据 es5 的规定都是非法的。\n\n但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。\n\nes6 引入了块级作用域，明确允许在块级作用域之中声明函数。es6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。\n\nfunction f() { console.log('i am outside!'); }\n\n(function () {\n  if (false) {\n    // 重复声明一次函数f\n    function f() { console.log('i am inside!'); }\n  }\n\n  f();\n}());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码在 es5 中运行，会得到“i am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。\n\n// es5 环境\nfunction f() { console.log('i am outside!'); }\n\n(function () {\n  function f() { console.log('i am inside!'); }\n  if (false) {\n  }\n  f();\n}());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nes6 就完全不一样了，理论上会得到“i am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 es6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？\n\n// 浏览器的 es6 环境\nfunction f() { console.log('i am outside!'); }\n\n(function () {\n  if (false) {\n    // 重复声明一次函数f\n    function f() { console.log('i am inside!'); }\n  }\n\n  f();\n}());\n// uncaught typeerror: f is not a function\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面的代码在 es6 浏览器中，都会报错。\n\n原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，es6 在附录 b里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。\n\n * 允许在块级作用域内声明函数。\n * 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。\n * 同时，函数声明还会提升到所在的块级作用域的头部。\n\n注意，上面三条规则只对 es6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。\n\n根据这三条规则，浏览器的 es6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。上面的例子实际运行的代码如下。\n\n// 浏览器的 es6 环境\nfunction f() { console.log('i am outside!'); }\n(function () {\n  var f = undefined;\n  if (false) {\n    function f() { console.log('i am inside!'); }\n  }\n\n  f();\n}());\n// uncaught typeerror: f is not a function\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。\n\n// 块级作用域内部的函数声明语句，建议不要使用\n{\n  let a = 'secret';\n  function f() {\n    return a;\n  }\n}\n\n// 块级作用域内部，优先使用函数表达式\n{\n  let a = 'secret';\n  let f = function () {\n    return a;\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n另外，还有一个需要注意的地方。es6 的块级作用域必须有大括号，如果没有大括号，javascript 引擎就认为不存在块级作用域。\n\n// 第一种写法，报错\nif (true) let x = 1;\n\n// 第二种写法，不报错\nif (true) {\n  let x = 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，第一种写法没有大括号，所以不存在块级作用域，而let只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。\n\n函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。\n\n// 不报错\n'use strict';\nif (true) {\n  function f() {}\n}\n\n// 报错\n'use strict';\nif (true)\n  function f() {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# const 命令\n\n\n# 基本用法\n\nconst声明一个只读的常量。一旦声明，常量的值就不能改变。\n\nconst pi = 3.1415;\npi // 3.1415\n\npi = 3;\n// typeerror: assignment to constant variable.\n\n\n1\n2\n3\n4\n5\n\n\n上面代码表明改变常量的值会报错。\n\nconst声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。\n\nconst foo;\n// syntaxerror: missing initializer in const declaration\n\n\n1\n2\n\n\n上面代码表示，对于const来说，只声明不赋值，就会报错。\n\nconst的作用域与let命令相同：只在声明所在的块级作用域内有效。\n\nif (true) {\n  const max = 5;\n}\n\nmax // uncaught referenceerror: max is not defined\n\n\n1\n2\n3\n4\n5\n\n\nconst命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。\n\nif (true) {\n  console.log(max); // referenceerror\n  const max = 5;\n}\n\n\n1\n2\n3\n4\n\n\n上面代码在常量max声明之前就调用，结果报错。\n\nconst声明的常量，也与let一样不可重复声明。\n\nvar message = \"hello!\";\nlet age = 25;\n\n// 以下两行都会报错\nconst message = \"goodbye!\";\nconst age = 30;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 本质\n\nconst实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。\n\nconst foo = {};\n\n// 为 foo 添加一个属性，可以成功\nfoo.prop = 123;\nfoo.prop // 123\n\n// 将 foo 指向另一个对象，就会报错\nfoo = {}; // typeerror: \"foo\" is read-only\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。\n\n下面是另一个例子。\n\nconst a = [];\na.push('hello'); // 可执行\na.length = 0;    // 可执行\na = ['dave'];    // 报错\n\n\n1\n2\n3\n4\n\n\n上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。\n\n如果真的想将对象冻结，应该使用object.freeze方法。\n\nconst foo = object.freeze({});\n\n// 常规模式时，下面一行不起作用；\n// 严格模式时，该行会报错\nfoo.prop = 123;\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。\n\n除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。\n\nvar constantize = (obj) => {\n  object.freeze(obj);\n  object.keys(obj).foreach( (key, i) => {\n    if ( typeof obj[key] === 'object' ) {\n      constantize( obj[key] );\n    }\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# es6 声明变量的六种方法\n\nes5 只有两种声明变量的方法：var命令和function命令。es6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，es6 一共有 6 种声明变量的方法。\n\n\n# 顶层对象的属性\n\n顶层对象，在浏览器环境指的是window对象，在 node 指的是global对象。es5 之中，顶层对象的属性与全局变量是等价的。\n\nwindow.a = 1;\na // 1\n\na = 2;\nwindow.a // 2\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。\n\n顶层对象的属性与全局变量挂钩，被认为是 javascript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。\n\nes6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 es6 开始，全局变量将逐步与顶层对象的属性脱钩。\n\nvar a = 1;\n// 如果在 node 的 repl 环境，可以写成 global.a\n// 或者采用通用方法，写成 this.a\nwindow.a // 1\n\nlet b = 1;\nwindow.b // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。\n\n\n# globalthis 对象\n\njavascript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。\n\n * 浏览器里面，顶层对象是window，但 node 和 web worker 没有window。\n * 浏览器和 web worker 里面，self也指向顶层对象，但是 node 没有self。\n * node 里面，顶层对象是global，但其他环境都不支持。\n\n同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。\n\n * 全局环境中，this会返回顶层对象。但是，node 模块和 es6 模块中，this返回的是当前模块。\n * 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。\n * 不管是严格模式，还是普通模式，new function('return this')()，总是会返回全局对象。但是，如果浏览器用了 csp（content security policy，内容安全策略），那么eval、new function这些方法都可能无法使用。\n\n综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。\n\n// 方法一\n(typeof window !== 'undefined'\n   ? window\n   : (typeof process === 'object' &&\n      typeof require === 'function' &&\n      typeof global === 'object')\n     ? global\n     : this);\n\n// 方法二\nvar getglobal = function () {\n  if (typeof self !== 'undefined') { return self; }\n  if (typeof window !== 'undefined') { return window; }\n  if (typeof global !== 'undefined') { return global; }\n  throw new error('unable to locate global object');\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nes2020 在语言标准的层面，引入globalthis作为顶层对象。也就是说，任何环境下，globalthis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。\n\n垫片库global-this模拟了这个提案，可以在所有环境拿到globalthis。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"变量的解构赋值",frontmatter:{title:"变量的解构赋值",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/b1ab10a62f7564da",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/03.%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html",relativePath:"《ES6 教程》笔记/03.变量的解构赋值.md",key:"v-346f208f",path:"/pages/b1ab10a62f7564da/",headers:[{level:2,title:"数组的解构赋值",slug:"数组的解构赋值",normalizedTitle:"数组的解构赋值",charIndex:14},{level:3,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:26},{level:3,title:"默认值",slug:"默认值",normalizedTitle:"默认值",charIndex:1628},{level:2,title:"对象的解构赋值",slug:"对象的解构赋值",normalizedTitle:"对象的解构赋值",charIndex:2516},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2528},{level:3,title:"默认值",slug:"默认值-2",normalizedTitle:"默认值",charIndex:1628},{level:3,title:"注意点",slug:"注意点",normalizedTitle:"注意点",charIndex:5548},{level:2,title:"字符串的解构赋值",slug:"字符串的解构赋值",normalizedTitle:"字符串的解构赋值",charIndex:6212},{level:2,title:"数值和布尔值的解构赋值",slug:"数值和布尔值的解构赋值",normalizedTitle:"数值和布尔值的解构赋值",charIndex:6441},{level:2,title:"函数参数的解构赋值",slug:"函数参数的解构赋值",normalizedTitle:"函数参数的解构赋值",charIndex:6840},{level:2,title:"圆括号问题",slug:"圆括号问题",normalizedTitle:"圆括号问题",charIndex:7706},{level:3,title:"不能使用圆括号的情况",slug:"不能使用圆括号的情况",normalizedTitle:"不能使用圆括号的情况",charIndex:7904},{level:3,title:"可以使用圆括号的情况",slug:"可以使用圆括号的情况",normalizedTitle:"可以使用圆括号的情况",charIndex:8440},{level:2,title:"用途",slug:"用途",normalizedTitle:"用途",charIndex:8693}],excerpt:'<h1 id="变量的解构赋值"><a class="header-anchor" href="#变量的解构赋值">#</a> 变量的解构赋值</h1>\n<h2 id="数组的解构赋值"><a class="header-anchor" href="#数组的解构赋值">#</a> 数组的解构赋值</h2>\n<h3 id="基本用法"><a class="header-anchor" href="#基本用法">#</a> 基本用法</h3>\n<p>ES6 允许按照一定模式，<strong>从数组和对象中提取值，对变量进行赋值，这被称为解构</strong>（Destructuring）。</p>\n<p>以前，为变量赋值，只能直接指定值。</p>\n\x3c!--beforebegin--\x3e<div class="language-javascript line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"数组的解构赋值 基本用法 默认值 对象的解构赋值 简介 默认值 注意点 字符串的解构赋值 数值和布尔值的解构赋值 函数参数的解构赋值 圆括号问题 不能使用圆括号的情况 可以使用圆括号的情况 用途",content:"# 变量的解构赋值\n\n\n# 数组的解构赋值\n\n\n# 基本用法\n\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。\n\n以前，为变量赋值，只能直接指定值。\n\nlet a = 1;\nlet b = 2;\nlet c = 3;\n\n\n1\n2\n3\n\n\nES6 允许写成下面这样。\n\nlet [a, b, c] = [1, 2, 3];\n\n\n1\n\n\n上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\n\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\n\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = ['a'];\nx // \"a\"\ny // undefined\nz // []\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如果解构不成功，变量的值就等于undefined。\n\nlet [foo] = [];\nlet [bar, foo] = [1];\n\n\n1\n2\n\n\n以上两种情况都属于解构不成功，foo的值都会等于undefined。\n\n另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。\n\nlet [x, y] = [1, 2, 3];\nx // 1\ny // 2\n\nlet [a, [b], d] = [1, [2, 3], 4];\na // 1\nb // 2\nd // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面两个例子，都属于不完全解构，但是可以成功。\n\n如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。\n\n// 报错\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。\n\n对于 Set 结构，也可以使用数组的解构赋值。\n\nlet [x, y, z] = new Set(['a', 'b', 'c']);\nx // \"a\"\n\n\n1\n2\n\n\n事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。\n\nfunction* fibs() {\n  let a = 0;\n  let b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nlet [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。\n\n\n# 默认值\n\n解构赋值允许指定默认值。\n\nlet [foo = true] = [];\nfoo // true\n\nlet [x, y = 'b'] = ['a']; // x='a', y='b'\nlet [x, y = 'b'] = ['a', undefined]; // x='a', y='b'\n\n\n1\n2\n3\n4\n5\n\n\n注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有 当一个数组成员严格等于undefined，默认值才会生效。\n\nlet [x = 1] = [undefined];\nx // 1\n\nlet [x = 1] = [null];\nx // null\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。\n\n如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。\n\nfunction f() {\n  console.log('aaa');\n}\n\nlet [x = f()] = [1];\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。\n\nlet x;\nif ([1][0] === undefined) {\n  x = f();\n} else {\n  x = [1][0];\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n\nlet [x = 1, y = x] = [];     // x=1; y=1\nlet [x = 1, y = x] = [2];    // x=2; y=2\nlet [x = 1, y = x] = [1, 2]; // x=1; y=2\nlet [x = y, y = 1] = [];     // ReferenceError: y is not defined\n\n\n1\n2\n3\n4\n\n\n上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。\n\n\n# 对象的解构赋值\n\n\n# 简介\n\n解构不仅可以用于数组，还可以用于对象。\n\nlet { foo, bar } = { foo: 'aaa', bar: 'bbb' };\nfoo // \"aaa\"\nbar // \"bbb\"\n\n\n1\n2\n3\n\n\n对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n\nlet { bar, foo } = { foo: 'aaa', bar: 'bbb' };\nfoo // \"aaa\"\nbar // \"bbb\"\n\nlet { baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // undefined\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。\n\n如果解构失败，变量的值等于undefined。\n\nlet {foo} = {bar: 'baz'};\nfoo // undefined\n\n\n1\n2\n\n\n上面代码中，等号右边的对象没有foo属性，所以变量foo取不到值，所以等于undefined。\n\n对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。\n\n// 例一\nlet { log, sin, cos } = Math;\n\n// 例二\nconst { log } = console;\nlog('hello') // hello\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的例一将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将console.log赋值到log变量。\n\n如果变量名与属性名不一致，必须写成下面这样。\n\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\n\nlet obj = { first: 'hello', last: 'world' };\nlet { first: f, last: l } = obj;\nf // 'hello'\nl // 'world'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。\n\nlet { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };\n\n\n1\n\n\n也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。\n\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\nfoo // error: foo is not defined\n\n\n1\n2\n3\n\n\n上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。\n\n与数组一样，解构也可以用于嵌套结构的对象。\n\nlet obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\n\nlet { p: [x, { y }] } = obj;\nx // \"Hello\"\ny // \"World\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。\n\nlet obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\n\nlet { p, p: [x, { y }] } = obj;\nx // \"Hello\"\ny // \"World\"\np // [\"Hello\", {y: \"World\"}]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n下面是另一个例子。\n\nconst node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }\n};\n\nlet { loc, loc: { start }, loc: { start: { line }} } = node;\nline // 1\nloc  // Object {start: Object}\nstart // Object {line: 1, column: 5}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。\n\n下面是嵌套赋值的例子。\n\nlet obj = {};\nlet arr = [];\n\n({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });\n\nobj // {prop:123}\narr // [true]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。\n\n// 报错\nlet {foo: {bar}} = {baz: 'baz'};\n\n\n1\n2\n\n\n上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错。\n\n注意，对象的解构赋值可以取到继承的属性。\n\nconst obj1 = {};\nconst obj2 = { foo: 'bar' };\nObject.setPrototypeOf(obj1, obj2);\n\nconst { foo } = obj1;\nfoo // \"bar\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，对象obj1的原型对象是obj2。foo属性不是obj1自身的属性，而是继承自obj2的属性，解构赋值可以取到这个属性。\n\n\n# 默认值\n\n对象的解构也可以指定默认值。\n\nvar {x = 3} = {};\nx // 3\n\nvar {x, y = 5} = {x: 1};\nx // 1\ny // 5\n\nvar {x: y = 3} = {};\ny // 3\n\nvar {x: y = 3} = {x: 5};\ny // 5\n\nvar { message: msg = 'Something went wrong' } = {};\nmsg // \"Something went wrong\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n默认值生效的条件是，对象的属性值严格等于undefined。\n\nvar {x = 3} = {x: undefined};\nx // 3\n\nvar {x = 3} = {x: null};\nx // null\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。\n\n\n# 注意点\n\n（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。\n\n// 错误的写法\nlet x;\n{x} = {x: 1};\n// SyntaxError: syntax error\n\n\n1\n2\n3\n4\n\n\n上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。\n\n// 正确的写法\nlet x;\n({x} = {x: 1});\n\n\n1\n2\n3\n\n\n上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。\n\n（2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。\n\n({} = [true, false]);\n({} = 'abc');\n({} = []);\n\n\n1\n2\n3\n\n\n上面的表达式虽然毫无意义，但是语法是合法的，可以执行。\n\n（3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。\n\nlet arr = [1, 2, 3];\nlet {0 : first, [arr.length - 1] : last} = arr;\nfirst // 1\nlast // 3\n\n\n1\n2\n3\n4\n\n\n上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。\n\n\n# 字符串的解构赋值\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。\n\nconst [a, b, c, d, e] = 'hello';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。\n\nlet {length : len} = 'hello';\nlen // 5\n\n\n1\n2\n\n\n\n# 数值和布尔值的解构赋值\n\n解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。\n\nlet {toString: s} = 123;\ns === Number.prototype.toString // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。\n\n解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。\n\nlet { prop: x } = undefined; // TypeError\nlet { prop: y } = null; // TypeError\n\n\n1\n2\n\n\n\n# 函数参数的解构赋值\n\n函数的参数也可以使用解构赋值。\n\nfunction add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]); // 3\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。\n\n下面是另一个例子。\n\n[[1, 2], [3, 4]].map(([a, b]) => a + b);\n// [ 3, 7 ]\n\n\n1\n2\n\n\n函数参数的解构也可以使用默认值。\n\nfunction move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。\n\n注意，下面的写法会得到不一样的结果。\n\nfunction move({x, y} = { x: 0, y: 0 }) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, undefined]\nmove({}); // [undefined, undefined]\nmove(); // [0, 0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。\n\nundefined就会触发函数参数的默认值。\n\n[1, undefined, 3].map((x = 'yes') => x);\n// [ 1, 'yes', 3 ]\n\n\n1\n2\n\n\n\n# 圆括号问题\n\n解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。\n\n由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。\n\n但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。\n\n\n# 不能使用圆括号的情况\n\n以下三种解构赋值不得使用圆括号。\n\n（1）变量声明语句\n\n// 全部报错\nlet [(a)] = [1];\n\nlet {x: (c)} = {};\nlet ({x: c}) = {};\nlet {(x: c)} = {};\nlet {(x): c} = {};\n\nlet { o: ({ p: p }) } = { o: { p: 2 } };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。\n\n（2）函数参数\n\n函数参数也属于变量声明，因此不能带有圆括号。\n\n// 报错\nfunction f([(z)]) { return z; }\n// 报错\nfunction f([z,(x)]) { return x; }\n\n\n1\n2\n3\n4\n\n\n（3）赋值语句的模式\n\n// 全部报错\n({ p: a }) = { p: 42 };\n([a]) = [5];\n\n\n1\n2\n3\n\n\n上面代码将整个模式放在圆括号之中，导致报错。\n\n// 报错\n[({ p: a }), { x: c }] = [{}, {}];\n\n\n1\n2\n\n\n上面代码将一部分模式放在圆括号之中，导致报错。\n\n\n# 可以使用圆括号的情况\n\n可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。\n\n[(b)] = [3]; // 正确\n({ p: (d) } = {}); // 正确\n[(parseInt.prop)] = [3]; // 正确\n\n\n1\n2\n3\n\n\n上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。\n\n\n# 用途\n\n变量的解构赋值用途很多。\n\n（1）交换变量的值\n\nlet x = 1;\nlet y = 2;\n\n[x, y] = [y, x];\n\n\n1\n2\n3\n4\n\n\n上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。\n\n（2）从函数返回多个值\n\n函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。\n\n// 返回一个数组\n\nfunction example() {\n  return [1, 2, 3];\n}\nlet [a, b, c] = example();\n\n// 返回一个对象\n\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2\n  };\n}\nlet { foo, bar } = example();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n（3）函数参数的定义\n\n解构赋值可以方便地将一组参数与变量名对应起来。\n\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（4）提取 JSON 数据\n\n解构赋值对提取 JSON 对象中的数据，尤其有用。\n\nlet jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]\n};\n\nlet { id, status, data: number } = jsonData;\n\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码可以快速提取 JSON 数据的值。\n\n（5）函数参数的默认值\n\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function () {},\n  cache = true,\n  complete = function () {},\n  crossDomain = false,\n  global = true,\n  // ... more config\n} = {}) {\n  // ... do stuff\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。\n\n（6）遍历 Map 结构\n\n任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。\n\nconst map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n// first is hello\n// second is world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果只想获取键名，或者只想获取键值，可以写成下面这样。\n\n// 获取键名\nfor (let [key] of map) {\n  // ...\n}\n\n// 获取键值\nfor (let [,value] of map) {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n（7）输入模块的指定方法\n\n加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。\n\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n\n\n1\n",normalizedContent:"# 变量的解构赋值\n\n\n# 数组的解构赋值\n\n\n# 基本用法\n\nes6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（destructuring）。\n\n以前，为变量赋值，只能直接指定值。\n\nlet a = 1;\nlet b = 2;\nlet c = 3;\n\n\n1\n2\n3\n\n\nes6 允许写成下面这样。\n\nlet [a, b, c] = [1, 2, 3];\n\n\n1\n\n\n上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\n\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\n\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = ['a'];\nx // \"a\"\ny // undefined\nz // []\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如果解构不成功，变量的值就等于undefined。\n\nlet [foo] = [];\nlet [bar, foo] = [1];\n\n\n1\n2\n\n\n以上两种情况都属于解构不成功，foo的值都会等于undefined。\n\n另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。\n\nlet [x, y] = [1, 2, 3];\nx // 1\ny // 2\n\nlet [a, [b], d] = [1, [2, 3], 4];\na // 1\nb // 2\nd // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面两个例子，都属于不完全解构，但是可以成功。\n\n如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《iterator》一章），那么将会报错。\n\n// 报错\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = nan;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 iterator 接口（前五个表达式），要么本身就不具备 iterator 接口（最后一个表达式）。\n\n对于 set 结构，也可以使用数组的解构赋值。\n\nlet [x, y, z] = new set(['a', 'b', 'c']);\nx // \"a\"\n\n\n1\n2\n\n\n事实上，只要某种数据结构具有 iterator 接口，都可以采用数组形式的解构赋值。\n\nfunction* fibs() {\n  let a = 0;\n  let b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nlet [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，fibs是一个 generator 函数（参见《generator 函数》一章），原生具有 iterator 接口。解构赋值会依次从这个接口获取值。\n\n\n# 默认值\n\n解构赋值允许指定默认值。\n\nlet [foo = true] = [];\nfoo // true\n\nlet [x, y = 'b'] = ['a']; // x='a', y='b'\nlet [x, y = 'b'] = ['a', undefined]; // x='a', y='b'\n\n\n1\n2\n3\n4\n5\n\n\n注意，es6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有 当一个数组成员严格等于undefined，默认值才会生效。\n\nlet [x = 1] = [undefined];\nx // 1\n\nlet [x = 1] = [null];\nx // null\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。\n\n如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。\n\nfunction f() {\n  console.log('aaa');\n}\n\nlet [x = f()] = [1];\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。\n\nlet x;\nif ([1][0] === undefined) {\n  x = f();\n} else {\n  x = [1][0];\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n\nlet [x = 1, y = x] = [];     // x=1; y=1\nlet [x = 1, y = x] = [2];    // x=2; y=2\nlet [x = 1, y = x] = [1, 2]; // x=1; y=2\nlet [x = y, y = 1] = [];     // referenceerror: y is not defined\n\n\n1\n2\n3\n4\n\n\n上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。\n\n\n# 对象的解构赋值\n\n\n# 简介\n\n解构不仅可以用于数组，还可以用于对象。\n\nlet { foo, bar } = { foo: 'aaa', bar: 'bbb' };\nfoo // \"aaa\"\nbar // \"bbb\"\n\n\n1\n2\n3\n\n\n对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n\nlet { bar, foo } = { foo: 'aaa', bar: 'bbb' };\nfoo // \"aaa\"\nbar // \"bbb\"\n\nlet { baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // undefined\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。\n\n如果解构失败，变量的值等于undefined。\n\nlet {foo} = {bar: 'baz'};\nfoo // undefined\n\n\n1\n2\n\n\n上面代码中，等号右边的对象没有foo属性，所以变量foo取不到值，所以等于undefined。\n\n对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。\n\n// 例一\nlet { log, sin, cos } = math;\n\n// 例二\nconst { log } = console;\nlog('hello') // hello\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的例一将math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将console.log赋值到log变量。\n\n如果变量名与属性名不一致，必须写成下面这样。\n\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\n\nlet obj = { first: 'hello', last: 'world' };\nlet { first: f, last: l } = obj;\nf // 'hello'\nl // 'world'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。\n\nlet { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };\n\n\n1\n\n\n也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。\n\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\nfoo // error: foo is not defined\n\n\n1\n2\n3\n\n\n上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。\n\n与数组一样，解构也可以用于嵌套结构的对象。\n\nlet obj = {\n  p: [\n    'hello',\n    { y: 'world' }\n  ]\n};\n\nlet { p: [x, { y }] } = obj;\nx // \"hello\"\ny // \"world\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。\n\nlet obj = {\n  p: [\n    'hello',\n    { y: 'world' }\n  ]\n};\n\nlet { p, p: [x, { y }] } = obj;\nx // \"hello\"\ny // \"world\"\np // [\"hello\", {y: \"world\"}]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n下面是另一个例子。\n\nconst node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }\n};\n\nlet { loc, loc: { start }, loc: { start: { line }} } = node;\nline // 1\nloc  // object {start: object}\nstart // object {line: 1, column: 5}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。\n\n下面是嵌套赋值的例子。\n\nlet obj = {};\nlet arr = [];\n\n({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });\n\nobj // {prop:123}\narr // [true]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。\n\n// 报错\nlet {foo: {bar}} = {baz: 'baz'};\n\n\n1\n2\n\n\n上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错。\n\n注意，对象的解构赋值可以取到继承的属性。\n\nconst obj1 = {};\nconst obj2 = { foo: 'bar' };\nobject.setprototypeof(obj1, obj2);\n\nconst { foo } = obj1;\nfoo // \"bar\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，对象obj1的原型对象是obj2。foo属性不是obj1自身的属性，而是继承自obj2的属性，解构赋值可以取到这个属性。\n\n\n# 默认值\n\n对象的解构也可以指定默认值。\n\nvar {x = 3} = {};\nx // 3\n\nvar {x, y = 5} = {x: 1};\nx // 1\ny // 5\n\nvar {x: y = 3} = {};\ny // 3\n\nvar {x: y = 3} = {x: 5};\ny // 5\n\nvar { message: msg = 'something went wrong' } = {};\nmsg // \"something went wrong\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n默认值生效的条件是，对象的属性值严格等于undefined。\n\nvar {x = 3} = {x: undefined};\nx // 3\n\nvar {x = 3} = {x: null};\nx // null\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。\n\n\n# 注意点\n\n（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。\n\n// 错误的写法\nlet x;\n{x} = {x: 1};\n// syntaxerror: syntax error\n\n\n1\n2\n3\n4\n\n\n上面代码的写法会报错，因为 javascript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 javascript 将其解释为代码块，才能解决这个问题。\n\n// 正确的写法\nlet x;\n({x} = {x: 1});\n\n\n1\n2\n3\n\n\n上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。\n\n（2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。\n\n({} = [true, false]);\n({} = 'abc');\n({} = []);\n\n\n1\n2\n3\n\n\n上面的表达式虽然毫无意义，但是语法是合法的，可以执行。\n\n（3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。\n\nlet arr = [1, 2, 3];\nlet {0 : first, [arr.length - 1] : last} = arr;\nfirst // 1\nlast // 3\n\n\n1\n2\n3\n4\n\n\n上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。\n\n\n# 字符串的解构赋值\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。\n\nconst [a, b, c, d, e] = 'hello';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。\n\nlet {length : len} = 'hello';\nlen // 5\n\n\n1\n2\n\n\n\n# 数值和布尔值的解构赋值\n\n解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。\n\nlet {tostring: s} = 123;\ns === number.prototype.tostring // true\n\nlet {tostring: s} = true;\ns === boolean.prototype.tostring // true\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，数值和布尔值的包装对象都有tostring属性，因此变量s都能取到值。\n\n解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。\n\nlet { prop: x } = undefined; // typeerror\nlet { prop: y } = null; // typeerror\n\n\n1\n2\n\n\n\n# 函数参数的解构赋值\n\n函数的参数也可以使用解构赋值。\n\nfunction add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]); // 3\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。\n\n下面是另一个例子。\n\n[[1, 2], [3, 4]].map(([a, b]) => a + b);\n// [ 3, 7 ]\n\n\n1\n2\n\n\n函数参数的解构也可以使用默认值。\n\nfunction move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。\n\n注意，下面的写法会得到不一样的结果。\n\nfunction move({x, y} = { x: 0, y: 0 }) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, undefined]\nmove({}); // [undefined, undefined]\nmove(); // [0, 0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。\n\nundefined就会触发函数参数的默认值。\n\n[1, undefined, 3].map((x = 'yes') => x);\n// [ 1, 'yes', 3 ]\n\n\n1\n2\n\n\n\n# 圆括号问题\n\n解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。\n\n由此带来的问题是，如果模式中出现圆括号怎么处理。es6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。\n\n但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。\n\n\n# 不能使用圆括号的情况\n\n以下三种解构赋值不得使用圆括号。\n\n（1）变量声明语句\n\n// 全部报错\nlet [(a)] = [1];\n\nlet {x: (c)} = {};\nlet ({x: c}) = {};\nlet {(x: c)} = {};\nlet {(x): c} = {};\n\nlet { o: ({ p: p }) } = { o: { p: 2 } };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。\n\n（2）函数参数\n\n函数参数也属于变量声明，因此不能带有圆括号。\n\n// 报错\nfunction f([(z)]) { return z; }\n// 报错\nfunction f([z,(x)]) { return x; }\n\n\n1\n2\n3\n4\n\n\n（3）赋值语句的模式\n\n// 全部报错\n({ p: a }) = { p: 42 };\n([a]) = [5];\n\n\n1\n2\n3\n\n\n上面代码将整个模式放在圆括号之中，导致报错。\n\n// 报错\n[({ p: a }), { x: c }] = [{}, {}];\n\n\n1\n2\n\n\n上面代码将一部分模式放在圆括号之中，导致报错。\n\n\n# 可以使用圆括号的情况\n\n可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。\n\n[(b)] = [3]; // 正确\n({ p: (d) } = {}); // 正确\n[(parseint.prop)] = [3]; // 正确\n\n\n1\n2\n3\n\n\n上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。\n\n\n# 用途\n\n变量的解构赋值用途很多。\n\n（1）交换变量的值\n\nlet x = 1;\nlet y = 2;\n\n[x, y] = [y, x];\n\n\n1\n2\n3\n4\n\n\n上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。\n\n（2）从函数返回多个值\n\n函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。\n\n// 返回一个数组\n\nfunction example() {\n  return [1, 2, 3];\n}\nlet [a, b, c] = example();\n\n// 返回一个对象\n\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2\n  };\n}\nlet { foo, bar } = example();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n（3）函数参数的定义\n\n解构赋值可以方便地将一组参数与变量名对应起来。\n\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（4）提取 json 数据\n\n解构赋值对提取 json 对象中的数据，尤其有用。\n\nlet jsondata = {\n  id: 42,\n  status: \"ok\",\n  data: [867, 5309]\n};\n\nlet { id, status, data: number } = jsondata;\n\nconsole.log(id, status, number);\n// 42, \"ok\", [867, 5309]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码可以快速提取 json 数据的值。\n\n（5）函数参数的默认值\n\njquery.ajax = function (url, {\n  async = true,\n  beforesend = function () {},\n  cache = true,\n  complete = function () {},\n  crossdomain = false,\n  global = true,\n  // ... more config\n} = {}) {\n  // ... do stuff\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。\n\n（6）遍历 map 结构\n\n任何部署了 iterator 接口的对象，都可以用for...of循环遍历。map 结构原生支持 iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。\n\nconst map = new map();\nmap.set('first', 'hello');\nmap.set('second', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n// first is hello\n// second is world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果只想获取键名，或者只想获取键值，可以写成下面这样。\n\n// 获取键名\nfor (let [key] of map) {\n  // ...\n}\n\n// 获取键值\nfor (let [,value] of map) {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n（7）输入模块的指定方法\n\n加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。\n\nconst { sourcemapconsumer, sourcenode } = require(\"source-map\");\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"字符串的新增方法",frontmatter:{title:"字符串的新增方法",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/a650b4a0ebfc9350",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/05.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.html",relativePath:"《ES6 教程》笔记/05.字符串的新增方法.md",key:"v-4d3a6db4",path:"/pages/a650b4a0ebfc9350/",headers:[{level:2,title:"String.fromCodePoint()",slug:"string-fromcodepoint",normalizedTitle:"string.fromcodepoint()",charIndex:32},{level:2,title:"String.raw()",slug:"string-raw",normalizedTitle:"string.raw()",charIndex:630},{level:2,title:"实例方法：codePointAt()",slug:"实例方法-codepointat",normalizedTitle:"实例方法：codepointat()",charIndex:1613},{level:2,title:"实例方法：normalize()",slug:"实例方法-normalize",normalizedTitle:"实例方法：normalize()",charIndex:3275},{level:2,title:"实例方法：includes() 包含, startsWith() 头部包含, endsWith() 末尾包含",slug:"实例方法-includes-包含-startswith-头部包含-endswith-末尾包含",normalizedTitle:"实例方法：includes() 包含, startswith() 头部包含, endswith() 末尾包含",charIndex:4453},{level:2,title:"实例方法：repeat() 重复",slug:"实例方法-repeat-重复",normalizedTitle:"实例方法：repeat() 重复",charIndex:5046},{level:2,title:"实例方法：padStart() 补全头部，padEnd() 补全末尾",slug:"实例方法-padstart-补全头部-padend-补全末尾",normalizedTitle:"实例方法：padstart() 补全头部，padend() 补全末尾",charIndex:5579},{level:2,title:"实例方法：trimStart() 修剪头部，trimEnd() 修剪末尾",slug:"实例方法-trimstart-修剪头部-trimend-修剪末尾",normalizedTitle:"实例方法：trimstart() 修剪头部，trimend() 修剪末尾",charIndex:6504},{level:2,title:"实例方法：matchAll()",slug:"实例方法-matchall",normalizedTitle:"实例方法：matchall()",charIndex:6936}],excerpt:'<h1 id="字符串的新增方法"><a class="header-anchor" href="#字符串的新增方法">#</a> 字符串的新增方法</h1>\n<p>本章介绍字符串对象的新增方法。</p>\n<h2 id="string-fromcodepoint"><a class="header-anchor" href="#string-fromcodepoint">#</a> String.fromCodePoint()</h2>\n<p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>\n\x3c!--beforebegin--\x3e<div class="language-javascript line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-javascript"><code>String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span><span class="token number">0x20BB7</span><span class="token punctuation">)</span>\n<span class="token comment">// "ஷ"</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"String.fromCodePoint() String.raw() 实例方法：codePointAt() 实例方法：normalize() 实例方法：includes() 包含, startsWith() 头部包含, endsWith() 末尾包含 实例方法：repeat() 重复 实例方法：padStart() 补全头部，padEnd() 补全末尾 实例方法：trimStart() 修剪头部，trimEnd() 修剪末尾 实例方法：matchAll()",content:"# 字符串的新增方法\n\n本章介绍字符串对象的新增方法。\n\n\n# String.fromCodePoint()\n\nES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。\n\nString.fromCharCode(0x20BB7)\n// \"ஷ\"\n\n\n1\n2\n\n\n上面代码中，String.fromCharCode()不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。\n\nES6 提供了String.fromCodePoint()方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode()方法的不足。在作用上，正好与下面的codePointAt()方法相反。\n\nString.fromCodePoint(0x20BB7)\n// \"𠮷\"\nString.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y'\n// true\n\n\n1\n2\n3\n4\n\n\n上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。\n\n注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。\n\n\n# String.raw()\n\nES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。\n\nString.raw`Hi\\n${2+3}!`\n// 实际返回 \"Hi\\\\n5!\"，显示的是转义后的结果 \"Hi\\n5!\"\n\nString.raw`Hi\\u000A!`;\n// 实际返回 \"Hi\\\\u000A!\"，显示的是转义后的结果 \"Hi\\u000A!\"\n\n\n1\n2\n3\n4\n5\n\n\n如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。\n\nString.raw`Hi\\\\n`\n// 返回 \"Hi\\\\\\\\n\"\n\nString.raw`Hi\\\\n` === \"Hi\\\\\\\\n\" // true\n\n\n1\n2\n3\n4\n\n\nString.raw()方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。\n\nString.raw()本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组，对应模板字符串解析后的值。\n\n// `foo${1 + 2}bar`\n// 等同于\nString.raw({ raw: ['foo', 'bar'] }, 1 + 2) // \"foo3bar\"\n\n\n1\n2\n3\n\n\n上面代码中，String.raw()方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。\n\n作为函数，String.raw()的代码实现基本如下。\n\nString.raw = function (strings, ...values) {\n  let output = '';\n  let index;\n  for (index = 0; index < values.length; index++) {\n    output += strings.raw[index] + values[index];\n  }\n\n  output += strings.raw[index]\n  return output;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 实例方法：codePointAt()\n\nJavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。\n\nvar s = \"𠮷\";\n\ns.length // 2\ns.charAt(0) // ''\ns.charAt(1) // ''\ns.charCodeAt(0) // 55362\ns.charCodeAt(1) // 57271\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt()方法无法读取整个字符，charCodeAt()方法只能分别返回前两个字节和后两个字节的值。\n\nES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。\n\nlet s = '𠮷a';\n\ns.codePointAt(0) // 134071\ns.codePointAt(1) // 57271\n\ns.codePointAt(2) // 97\n\n\n1\n2\n3\n4\n5\n6\n\n\ncodePointAt()方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt()方法的结果与charCodeAt()方法相同。\n\n总之，codePointAt()方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt()方法相同。\n\ncodePointAt()方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString()方法转换一下。\n\nlet s = '𠮷a';\n\ns.codePointAt(0).toString(16) // \"20bb7\"\ns.codePointAt(2).toString(16) // \"61\"\n\n\n1\n2\n3\n4\n\n\n你可能注意到了，codePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt()方法传入 2。解决这个问题的一个办法是使用for...of循环，因为它会正确识别 32 位的 UTF-16 字符。\n\nlet s = '𠮷a';\nfor (let ch of s) {\n  console.log(ch.codePointAt(0).toString(16));\n}\n// 20bb7\n// 61\n\n\n1\n2\n3\n4\n5\n6\n\n\n另一种方法也可以，使用扩展运算符（...）进行展开运算。\n\nlet arr = [...'𠮷a']; // arr.length === 2\narr.forEach(\n  ch => console.log(ch.codePointAt(0).toString(16))\n);\n// 20bb7\n// 61\n\n\n1\n2\n3\n4\n5\n6\n\n\ncodePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。\n\nfunction is32Bit(c) {\n  return c.codePointAt(0) > 0xFFFF;\n}\n\nis32Bit(\"𠮷\") // true\nis32Bit(\"a\") // false\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 实例方法：normalize()\n\n许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。\n\n这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。\n\n'\\u01D1'==='\\u004F\\u030C' //false\n\n'\\u01D1'.length // 1\n'\\u004F\\u030C'.length // 2\n\n\n1\n2\n3\n4\n\n\n上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。\n\nES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。\n\n'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize()\n// true\n\n\n1\n2\n\n\nnormalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。\n\n * NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。\n * NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。\n * NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）\n * NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。\n\n'\\u004F\\u030C'.normalize('NFC').length // 1\n'\\u004F\\u030C'.normalize('NFD').length // 2\n\n\n1\n2\n\n\n上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。\n\n不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。\n\n\n# 实例方法：includes() 包含, startsWith() 头部包含, endsWith() 末尾包含\n\n传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。\n\n * includes()：返回布尔值，表示是否找到了参数字符串。\n * startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。\n * endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\n\nlet s = 'Hello world!';\n\ns.startsWith('Hello') // true\ns.endsWith('!') // true\ns.includes('o') // true\n\n\n1\n2\n3\n4\n5\n\n\n这三个方法都支持第二个参数，表示开始搜索的位置。\n\nlet s = 'Hello world!';\n\ns.startsWith('world', 6) // true\ns.endsWith('Hello', 5) // true\ns.includes('Hello', 6) // false\n\n\n1\n2\n3\n4\n5\n\n\n上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。\n\n\n# 实例方法：repeat() 重复\n\nrepeat方法返回一个新字符串，表示将原字符串重复n次。\n\n'x'.repeat(3) // \"xxx\"\n'hello'.repeat(2) // \"hellohello\"\n'na'.repeat(0) // \"\"\n\n\n1\n2\n3\n\n\n参数如果是小数，会被取整。\n\n'na'.repeat(2.9) // \"nana\"\n\n\n1\n\n\n如果repeat的参数是负数或者Infinity，会报错。\n\n'na'.repeat(Infinity)\n// RangeError\n'na'.repeat(-1)\n// RangeError\n\n\n1\n2\n3\n4\n\n\n但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。\n\n'na'.repeat(-0.9) // \"\"\n\n\n1\n\n\n参数NaN等同于 0。\n\n'na'.repeat(NaN) // \"\"\n\n\n1\n\n\n如果repeat的参数是字符串，则会先转换成数字。\n\n'na'.repeat('na') // \"\"\n'na'.repeat('3') // \"nanana\"\n\n\n1\n2\n\n\n\n# 实例方法：padStart() 补全头部，padEnd() 补全末尾\n\nES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。\n\n'x'.padStart(5, 'ab') // 'ababx'\n'x'.padStart(4, 'ab') // 'abax'\n\n'x'.padEnd(5, 'ab') // 'xabab'\n'x'.padEnd(4, 'ab') // 'xaba'\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。\n\n如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。\n\n'xxx'.padStart(2, 'ab') // 'xxx'\n'xxx'.padEnd(2, 'ab') // 'xxx'\n\n\n1\n2\n\n\n如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。\n\n'abc'.padStart(10, '0123456789')\n// '0123456abc'\n\n\n1\n2\n\n\n如果省略第二个参数，默认使用空格补全长度。\n\n'x'.padStart(4) // '   x'\n'x'.padEnd(4) // 'x   '\n\n\n1\n2\n\n\npadStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。\n\n'1'.padStart(10, '0') // \"0000000001\"\n'12'.padStart(10, '0') // \"0000000012\"\n'123456'.padStart(10, '0') // \"0000123456\"\n\n\n1\n2\n3\n\n\n另一个用途是提示字符串格式。\n\n'12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\"\n'09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\"\n\n\n1\n2\n\n\n\n# 实例方法：trimStart() 修剪头部，trimEnd() 修剪末尾\n\nES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。\n\nconst s = '  abc  ';\n\ns.trim() // \"abc\"\ns.trimStart() // \"abc  \"\ns.trimEnd() // \"  abc\"\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，trimStart()只消除头部的空格，保留尾部的空格。trimEnd()也是类似行为。\n\n除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。\n\n浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。\n\n\n# 实例方法：matchAll()\n\nmatchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。",normalizedContent:"# 字符串的新增方法\n\n本章介绍字符串对象的新增方法。\n\n\n# string.fromcodepoint()\n\nes5 提供string.fromcharcode()方法，用于从 unicode 码点返回对应字符，但是这个方法不能识别码点大于0xffff的字符。\n\nstring.fromcharcode(0x20bb7)\n// \"ஷ\"\n\n\n1\n2\n\n\n上面代码中，string.fromcharcode()不能识别大于0xffff的码点，所以0x20bb7就发生了溢出，最高位2被舍弃了，最后返回码点u+0bb7对应的字符，而不是码点u+20bb7对应的字符。\n\nes6 提供了string.fromcodepoint()方法，可以识别大于0xffff的字符，弥补了string.fromcharcode()方法的不足。在作用上，正好与下面的codepointat()方法相反。\n\nstring.fromcodepoint(0x20bb7)\n// \"𠮷\"\nstring.fromcodepoint(0x78, 0x1f680, 0x79) === 'x\\ud83d\\ude80y'\n// true\n\n\n1\n2\n3\n4\n\n\n上面代码中，如果string.fromcodepoint方法有多个参数，则它们会被合并成一个字符串返回。\n\n注意，fromcodepoint方法定义在string对象上，而codepointat方法定义在字符串的实例对象上。\n\n\n# string.raw()\n\nes6 还为原生的 string 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。\n\nstring.raw`hi\\n${2+3}!`\n// 实际返回 \"hi\\\\n5!\"，显示的是转义后的结果 \"hi\\n5!\"\n\nstring.raw`hi\\u000a!`;\n// 实际返回 \"hi\\\\u000a!\"，显示的是转义后的结果 \"hi\\u000a!\"\n\n\n1\n2\n3\n4\n5\n\n\n如果原字符串的斜杠已经转义，那么string.raw()会进行再次转义。\n\nstring.raw`hi\\\\n`\n// 返回 \"hi\\\\\\\\n\"\n\nstring.raw`hi\\\\n` === \"hi\\\\\\\\n\" // true\n\n\n1\n2\n3\n4\n\n\nstring.raw()方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。\n\nstring.raw()本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组，对应模板字符串解析后的值。\n\n// `foo${1 + 2}bar`\n// 等同于\nstring.raw({ raw: ['foo', 'bar'] }, 1 + 2) // \"foo3bar\"\n\n\n1\n2\n3\n\n\n上面代码中，string.raw()方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。\n\n作为函数，string.raw()的代码实现基本如下。\n\nstring.raw = function (strings, ...values) {\n  let output = '';\n  let index;\n  for (index = 0; index < values.length; index++) {\n    output += strings.raw[index] + values[index];\n  }\n\n  output += strings.raw[index]\n  return output;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 实例方法：codepointat()\n\njavascript 内部，字符以 utf-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（unicode 码点大于0xffff的字符），javascript 会认为它们是两个字符。\n\nvar s = \"𠮷\";\n\ns.length // 2\ns.charat(0) // ''\ns.charat(1) // ''\ns.charcodeat(0) // 55362\ns.charcodeat(1) // 57271\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20bb7，utf-16 编码为0xd842 0xdfb7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，javascript 不能正确处理，字符串长度会误判为2，而且charat()方法无法读取整个字符，charcodeat()方法只能分别返回前两个字节和后两个字节的值。\n\nes6 提供了codepointat()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。\n\nlet s = '𠮷a';\n\ns.codepointat(0) // 134071\ns.codepointat(1) // 57271\n\ns.codepointat(2) // 97\n\n\n1\n2\n3\n4\n5\n6\n\n\ncodepointat()方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，javascript 将“𠮷a”视为三个字符，codepointat 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20bb7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codepointat()方法的结果与charcodeat()方法相同。\n\n总之，codepointat()方法会正确返回 32 位的 utf-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charcodeat()方法相同。\n\ncodepointat()方法返回的是码点的十进制值，如果想要十六进制的值，可以使用tostring()方法转换一下。\n\nlet s = '𠮷a';\n\ns.codepointat(0).tostring(16) // \"20bb7\"\ns.codepointat(2).tostring(16) // \"61\"\n\n\n1\n2\n3\n4\n\n\n你可能注意到了，codepointat()方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codepointat()方法传入 2。解决这个问题的一个办法是使用for...of循环，因为它会正确识别 32 位的 utf-16 字符。\n\nlet s = '𠮷a';\nfor (let ch of s) {\n  console.log(ch.codepointat(0).tostring(16));\n}\n// 20bb7\n// 61\n\n\n1\n2\n3\n4\n5\n6\n\n\n另一种方法也可以，使用扩展运算符（...）进行展开运算。\n\nlet arr = [...'𠮷a']; // arr.length === 2\narr.foreach(\n  ch => console.log(ch.codepointat(0).tostring(16))\n);\n// 20bb7\n// 61\n\n\n1\n2\n3\n4\n5\n6\n\n\ncodepointat()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。\n\nfunction is32bit(c) {\n  return c.codepointat(0) > 0xffff;\n}\n\nis32bit(\"𠮷\") // true\nis32bit(\"a\") // false\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 实例方法：normalize()\n\n许多欧洲语言有语调符号和重音符号。为了表示它们，unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如o（\\u01d1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如o（\\u004f）和ˇ（\\u030c）合成o（\\u004f\\u030c）。\n\n这两种表示方法，在视觉和语义上都等价，但是 javascript 不能识别。\n\n'\\u01d1'==='\\u004f\\u030c' //false\n\n'\\u01d1'.length // 1\n'\\u004f\\u030c'.length // 2\n\n\n1\n2\n3\n4\n\n\n上面代码表示，javascript 将合成字符视为两个字符，导致两种表示方法不相等。\n\nes6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 unicode 正规化。\n\n'\\u01d1'.normalize() === '\\u004f\\u030c'.normalize()\n// true\n\n\n1\n2\n\n\nnormalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。\n\n * nfc，默认参数，表示“标准等价合成”（normalization form canonical composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。\n * nfd，表示“标准等价分解”（normalization form canonical decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。\n * nfkc，表示“兼容等价合成”（normalization form compatibility composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）\n * nfkd，表示“兼容等价分解”（normalization form compatibility decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。\n\n'\\u004f\\u030c'.normalize('nfc').length // 1\n'\\u004f\\u030c'.normalize('nfd').length // 2\n\n\n1\n2\n\n\n上面代码表示，nfc参数返回字符的合成形式，nfd参数返回字符的分解形式。\n\n不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 unicode 编号区间判断。\n\n\n# 实例方法：includes() 包含, startswith() 头部包含, endswith() 末尾包含\n\n传统上，javascript 只有indexof方法，可以用来确定一个字符串是否包含在另一个字符串中。es6 又提供了三种新方法。\n\n * includes()：返回布尔值，表示是否找到了参数字符串。\n * startswith()：返回布尔值，表示参数字符串是否在原字符串的头部。\n * endswith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\n\nlet s = 'hello world!';\n\ns.startswith('hello') // true\ns.endswith('!') // true\ns.includes('o') // true\n\n\n1\n2\n3\n4\n5\n\n\n这三个方法都支持第二个参数，表示开始搜索的位置。\n\nlet s = 'hello world!';\n\ns.startswith('world', 6) // true\ns.endswith('hello', 5) // true\ns.includes('hello', 6) // false\n\n\n1\n2\n3\n4\n5\n\n\n上面代码表示，使用第二个参数n时，endswith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。\n\n\n# 实例方法：repeat() 重复\n\nrepeat方法返回一个新字符串，表示将原字符串重复n次。\n\n'x'.repeat(3) // \"xxx\"\n'hello'.repeat(2) // \"hellohello\"\n'na'.repeat(0) // \"\"\n\n\n1\n2\n3\n\n\n参数如果是小数，会被取整。\n\n'na'.repeat(2.9) // \"nana\"\n\n\n1\n\n\n如果repeat的参数是负数或者infinity，会报错。\n\n'na'.repeat(infinity)\n// rangeerror\n'na'.repeat(-1)\n// rangeerror\n\n\n1\n2\n3\n4\n\n\n但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。\n\n'na'.repeat(-0.9) // \"\"\n\n\n1\n\n\n参数nan等同于 0。\n\n'na'.repeat(nan) // \"\"\n\n\n1\n\n\n如果repeat的参数是字符串，则会先转换成数字。\n\n'na'.repeat('na') // \"\"\n'na'.repeat('3') // \"nanana\"\n\n\n1\n2\n\n\n\n# 实例方法：padstart() 补全头部，padend() 补全末尾\n\nes2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padstart()用于头部补全，padend()用于尾部补全。\n\n'x'.padstart(5, 'ab') // 'ababx'\n'x'.padstart(4, 'ab') // 'abax'\n\n'x'.padend(5, 'ab') // 'xabab'\n'x'.padend(4, 'ab') // 'xaba'\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，padstart()和padend()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。\n\n如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。\n\n'xxx'.padstart(2, 'ab') // 'xxx'\n'xxx'.padend(2, 'ab') // 'xxx'\n\n\n1\n2\n\n\n如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。\n\n'abc'.padstart(10, '0123456789')\n// '0123456abc'\n\n\n1\n2\n\n\n如果省略第二个参数，默认使用空格补全长度。\n\n'x'.padstart(4) // '   x'\n'x'.padend(4) // 'x   '\n\n\n1\n2\n\n\npadstart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。\n\n'1'.padstart(10, '0') // \"0000000001\"\n'12'.padstart(10, '0') // \"0000000012\"\n'123456'.padstart(10, '0') // \"0000123456\"\n\n\n1\n2\n3\n\n\n另一个用途是提示字符串格式。\n\n'12'.padstart(10, 'yyyy-mm-dd') // \"yyyy-mm-12\"\n'09-12'.padstart(10, 'yyyy-mm-dd') // \"yyyy-09-12\"\n\n\n1\n2\n\n\n\n# 实例方法：trimstart() 修剪头部，trimend() 修剪末尾\n\nes2019 对字符串实例新增了trimstart()和trimend()这两个方法。它们的行为与trim()一致，trimstart()消除字符串头部的空格，trimend()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。\n\nconst s = '  abc  ';\n\ns.trim() // \"abc\"\ns.trimstart() // \"abc  \"\ns.trimend() // \"  abc\"\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，trimstart()只消除头部的空格，保留尾部的空格。trimend()也是类似行为。\n\n除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。\n\n浏览器还部署了额外的两个方法，trimleft()是trimstart()的别名，trimright()是trimend()的别名。\n\n\n# 实例方法：matchall()\n\nmatchall()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"正则的扩展",frontmatter:{title:"正则的扩展",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/0473261a6ab0ee8c",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/06.%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95.html",relativePath:"《ES6 教程》笔记/06.正则的扩展.md",key:"v-05ba6584",path:"/pages/0473261a6ab0ee8c/",headers:[{level:2,title:"RegExp 构造函数",slug:"regexp-构造函数",normalizedTitle:"regexp 构造函数",charIndex:12},{level:2,title:"字符串的正则方法",slug:"字符串的正则方法",normalizedTitle:"字符串的正则方法",charIndex:614},{level:2,title:"u 修饰符",slug:"u-修饰符",normalizedTitle:"u 修饰符",charIndex:1001},{level:2,title:"RegExp.prototype.unicode 属性",slug:"regexp-prototype-unicode-属性",normalizedTitle:"regexp.prototype.unicode 属性",charIndex:2659},{level:2,title:"y 修饰符",slug:"y-修饰符",normalizedTitle:"y 修饰符",charIndex:2857},{level:2,title:"RegExp.prototype.sticky 属性",slug:"regexp-prototype-sticky-属性",normalizedTitle:"regexp.prototype.sticky 属性",charIndex:5123},{level:2,title:"RegExp.prototype.flags 属性",slug:"regexp-prototype-flags-属性",normalizedTitle:"regexp.prototype.flags 属性",charIndex:5244},{level:2,title:"s 修饰符：dotAll 模式",slug:"s-修饰符-dotall-模式",normalizedTitle:"s 修饰符：dotall 模式",charIndex:5445},{level:2,title:"后行断言",slug:"后行断言",normalizedTitle:"后行断言",charIndex:6245},{level:2,title:"Unicode 属性类",slug:"unicode-属性类",normalizedTitle:"unicode 属性类",charIndex:7842},{level:2,title:"具名组匹配",slug:"具名组匹配",normalizedTitle:"具名组匹配",charIndex:9210},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:9220},{level:3,title:"解构赋值和替换",slug:"解构赋值和替换",normalizedTitle:"解构赋值和替换",charIndex:10371},{level:3,title:"引用",slug:"引用",normalizedTitle:"引用",charIndex:7630},{level:2,title:"String.prototype.matchAll()",slug:"string-prototype-matchall",normalizedTitle:"string.prototype.matchall()",charIndex:11613}],excerpt:'<h1 id="正则的扩展"><a class="header-anchor" href="#正则的扩展">#</a> 正则的扩展</h1>\n<h2 id="regexp-构造函数"><a class="header-anchor" href="#regexp-构造函数">#</a> RegExp 构造函数</h2>\n<p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>\n<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>\n\x3c!--beforebegin--\x3e<div class="language-javascript line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-javascript"><code><span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">\'xyz\'</span><span class="token punctuation">,</span> <span class="token string">\'i\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 等价于</span>\n<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">xyz</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">;</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"RegExp 构造函数 字符串的正则方法 u 修饰符 RegExp.prototype.unicode 属性 y 修饰符 RegExp.prototype.sticky 属性 RegExp.prototype.flags 属性 s 修饰符：dotAll 模式 后行断言 Unicode 属性类 具名组匹配 简介 解构赋值和替换 引用 String.prototype.matchAll()",content:"# 正则的扩展\n\n\n# RegExp 构造函数\n\n在 ES5 中，RegExp构造函数的参数有两种情况。\n\n第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。\n\nvar regex = new RegExp('xyz', 'i');\n// 等价于\nvar regex = /xyz/i;\n\n\n1\n2\n3\n\n\n第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。\n\nvar regex = new RegExp(/xyz/i);\n// 等价于\nvar regex = /xyz/i;\n\n\n1\n2\n3\n\n\n但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。\n\nvar regex = new RegExp(/xyz/, 'i');\n// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another\n\n\n1\n2\n\n\nES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。\n\nnew RegExp(/abc/ig, 'i').flags\n// \"i\"\n\n\n1\n2\n\n\n上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。\n\n\n# 字符串的正则方法\n\n字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。\n\nES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。\n\n * String.prototype.match 调用 RegExp.prototype[Symbol.match]\n * String.prototype.replace 调用 RegExp.prototype[Symbol.replace]\n * String.prototype.search 调用 RegExp.prototype[Symbol.search]\n * String.prototype.split 调用 RegExp.prototype[Symbol.split]\n\n\n# u 修饰符\n\nES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。\n\n/^\\uD83D/u.test('\\uD83D\\uDC2A') // false\n/^\\uD83D/.test('\\uD83D\\uDC2A') // true\n\n\n1\n2\n\n\n上面代码中，\\uD83D\\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。\n\n一旦加上u修饰符号，就会修改下面这些正则表达式的行为。\n\n（1）点字符\n\n点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。\n\nvar s = '𠮷';\n\n/^.$/.test(s) // false\n/^.$/u.test(s) // true\n\n\n1\n2\n3\n4\n\n\n上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。\n\n（2）Unicode 字符表示法\n\nES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。\n\n/\\u{61}/.test('a') // false\n/\\u{61}/u.test('a') // true\n/\\u{20BB7}/u.test('𠮷') // true\n\n\n1\n2\n3\n\n\n上面代码表示，如果不加u修饰符，正则表达式无法识别\\u{61}这种表示法，只会认为这匹配 61 个连续的u。\n\n（3）量词\n\n使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。\n\n/a{2}/.test('aa') // true\n/a{2}/u.test('aa') // true\n/𠮷{2}/.test('𠮷𠮷') // false\n/𠮷{2}/u.test('𠮷𠮷') // true\n\n\n1\n2\n3\n4\n\n\n（4）预定义模式\n\nu修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。\n\n/^\\S$/.test('𠮷') // false\n/^\\S$/u.test('𠮷') // true\n\n\n1\n2\n\n\n上面代码的\\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。\n\n利用这一点，可以写出一个正确返回字符串长度的函数。\n\nfunction codePointLength(text) {\n  var result = text.match(/[\\s\\S]/gu);\n  return result ? result.length : 0;\n}\n\nvar s = '𠮷𠮷';\n\ns.length // 4\ncodePointLength(s) // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n（5）i 修饰符\n\n有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。\n\n/[a-z]/i.test('\\u212A') // false\n/[a-z]/iu.test('\\u212A') // true\n\n\n1\n2\n\n\n上面代码中，不加u修饰符，就无法识别非规范的K字符。\n\n（6）转义\n\n没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义\\,）无效，而在u模式会报错。\n\n/\\,/ // /\\,/\n/\\,/u // 报错\n\n\n1\n2\n\n\n上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。\n\n\n# RegExp.prototype.unicode 属性\n\n正则实例对象新增unicode属性，表示是否设置了u修饰符。\n\nconst r1 = /hello/;\nconst r2 = /hello/u;\n\nr1.unicode // false\nr2.unicode // true\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。\n\n\n# y 修饰符\n\n除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。\n\ny修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。\n\nvar s = 'aaa_aa_a';\nvar r1 = /a+/g;\nvar r2 = /a+/y;\n\nr1.exec(s) // [\"aaa\"]\nr2.exec(s) // [\"aaa\"]\n\nr1.exec(s) // [\"aa\"]\nr2.exec(s) // null\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。\n\n如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。\n\nvar s = 'aaa_aa_a';\nvar r = /a+_/y;\n\nr.exec(s) // [\"aaa_\"]\nr.exec(s) // [\"aa_\"]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码每次匹配，都是从剩余字符串的头部开始。\n\n使用lastIndex属性，可以更好地说明y修饰符。\n\nconst REGEX = /a/g;\n\n// 指定从2号位置（y）开始匹配\nREGEX.lastIndex = 2;\n\n// 匹配成功\nconst match = REGEX.exec('xaya');\n\n// 在3号位置匹配成功\nmatch.index // 3\n\n// 下一次匹配从4号位开始\nREGEX.lastIndex // 4\n\n// 4号位开始匹配失败\nREGEX.exec('xaya') // null\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。\n\ny修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。\n\nconst REGEX = /a/y;\n\n// 指定从2号位置开始匹配\nREGEX.lastIndex = 2;\n\n// 不是粘连，匹配失败\nREGEX.exec('xaya') // null\n\n// 指定从3号位置开始匹配\nREGEX.lastIndex = 3;\n\n// 3号位置是粘连，匹配成功\nconst match = REGEX.exec('xaya');\nmatch.index // 3\nREGEX.lastIndex // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n实际上，y修饰符号隐含了头部匹配的标志^。\n\n/b/y.exec('aba')\n// null\n\n\n1\n2\n\n\n上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。\n\n下面是字符串对象的replace方法的例子。\n\nconst REGEX = /a/gy;\n'aaxa'.replace(REGEX, '-') // '--xa'\n\n\n1\n2\n\n\n上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。\n\n单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。\n\n'a1a2a3'.match(/a\\d/y) // [\"a1\"]\n'a1a2a3'.match(/a\\d/gy) // [\"a1\", \"a2\", \"a3\"]\n\n\n1\n2\n\n\ny修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。\n\nconst TOKEN_Y = /\\s*(\\+|[0-9]+)\\s*/y;\nconst TOKEN_G  = /\\s*(\\+|[0-9]+)\\s*/g;\n\ntokenize(TOKEN_Y, '3 + 4')\n// [ '3', '+', '4' ]\ntokenize(TOKEN_G, '3 + 4')\n// [ '3', '+', '4' ]\n\nfunction tokenize(TOKEN_REGEX, str) {\n  let result = [];\n  let match;\n  while (match = TOKEN_REGEX.exec(str)) {\n    result.push(match[1]);\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。\n\ntokenize(TOKEN_Y, '3x + 4')\n// [ '3' ]\ntokenize(TOKEN_G, '3x + 4')\n// [ '3', '+', '4' ]\n\n\n1\n2\n3\n4\n\n\n上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。\n\n\n# RegExp.prototype.sticky 属性\n\n与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。\n\nvar r = /hello\\d/y;\nr.sticky // true\n\n\n1\n2\n\n\n\n# RegExp.prototype.flags 属性\n\nES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。\n\n// ES5 的 source 属性\n// 返回正则表达式的正文\n/abc/ig.source\n// \"abc\"\n\n// ES6 的 flags 属性\n// 返回正则表达式的修饰符\n/abc/ig.flags\n// 'gi'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# s 修饰符：dotAll 模式\n\n正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。\n\n所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。\n\n * U+000A 换行符（\\n）\n * U+000D 回车符（\\r）\n * U+2028 行分隔符（line separator）\n * U+2029 段分隔符（paragraph separator）\n\n/foo.bar/.test('foo\\nbar')\n// false\n\n\n1\n2\n\n\n上面代码中，因为.不匹配\\n，所以正则表达式返回false。\n\n但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。\n\n/foo[^]bar/.test('foo\\nbar')\n// true\n\n\n1\n2\n\n\n这种解决方案毕竟不太符合直觉，ES2018 引入s修饰符，使得.可以匹配任意单个字符。\n\n/foo.bar/s.test('foo\\nbar') // true\n\n\n1\n\n\n这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。\n\nconst re = /foo.bar/s;\n// 另一种写法\n// const re = new RegExp('foo.bar', 's');\n\nre.test('foo\\nbar') // true\nre.dotAll // true\nre.flags // 's'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n/s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。\n\n\n# 后行断言\n\nJavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。\n\n“先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。\n\n/\\d+(?=%)/.exec('100% of US presidents have been male')  // [\"100\"]\n/\\d+(?!%)/.exec('that’s all 44 of them')                 // [\"44\"]\n\n\n1\n2\n\n\n上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（(?=%)），是不计入返回结果的。\n\n“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?<=y)x/。比如，只匹配美元符号之后的数字，要写成/(?<=\\$)\\d+/。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成/(?<!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?<!\\$)\\d+/。\n\n/(?<=\\$)\\d+/.exec('Benjamin Franklin is on the $100 bill')  // [\"100\"]\n/(?<!\\$)\\d+/.exec('it’s is worth about €90')                // [\"90\"]\n\n\n1\n2\n\n\n上面的例子中，“后行断言”的括号之中的部分（(?<=\\$)），也是不计入返回结果。\n\n下面的例子是使用后行断言进行字符串替换。\n\nconst RE_DOLLAR_PREFIX = /(?<=\\$)foo/g;\n'$foo %foo foo'.replace(RE_DOLLAR_PREFIX, 'bar');\n// '$bar %foo foo'\n\n\n1\n2\n3\n\n\n上面代码中，只有在美元符号后面的foo才会被替换。\n\n“后行断言”的实现，需要先匹配/(?<=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。\n\n首先，后行断言的组匹配，与正常情况下结果是不一样的。\n\n/(?<=(\\d+)(\\d+))$/.exec('1053') // [\"\", \"1\", \"053\"]\n/^(\\d+)(\\d+)$/.exec('1053') // [\"1053\", \"105\", \"3\"]\n\n\n1\n2\n\n\n上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。\n\n其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。\n\n/(?<=(o)d\\1)r/.exec('hodor')  // null\n/(?<=\\1d(o))r/.exec('hodor')  // [\"r\", \"o\"]\n\n\n1\n2\n\n\n上面代码中，如果后行断言的反斜杠引用（\\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。\n\n\n# Unicode 属性类\n\nES2018 引入了一种新的类的写法\\p{...}和\\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。\n\nconst regexGreekSymbol = /\\p{Script=Greek}/u;\nregexGreekSymbol.test('π') // true\n\n\n1\n2\n\n\n上面代码中，\\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。\n\nUnicode 属性类要指定属性名和属性值。\n\n\\p{UnicodePropertyName=UnicodePropertyValue}\n\n\n1\n\n\n对于某些属性，可以只写属性名，或者只写属性值。\n\n\\p{UnicodePropertyName}\n\\p{UnicodePropertyValue}\n\n\n1\n2\n\n\n\\P{…}是\\p{…}的反向匹配，即匹配不满足条件的字符。\n\n注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\\p和\\P会报错，ECMAScript 预留了这两个类。\n\n由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。\n\nconst regex = /^\\p{Decimal_Number}+$/u;\nregex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true\n\n\n1\n2\n\n\n上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。\n\n\\p{Number}甚至能匹配罗马数字。\n\n// 匹配所有数字\nconst regex = /^\\p{Number}+$/u;\nregex.test('²³¹¼½¾') // true\nregex.test('㉛㉜㉝') // true\nregex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true\n\n\n1\n2\n3\n4\n5\n\n\n下面是其他一些例子。\n\n// 匹配所有空格\n\\p{White_Space}\n\n// 匹配各种文字的所有字母，等同于 Unicode 版的 \\w\n[\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]\n\n// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W\n[^\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]\n\n// 匹配 Emoji\n/\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F/gu\n\n// 匹配所有的箭头字符\nconst regexArrows = /^\\p{Block=Arrows}+$/u;\nregexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 具名组匹配\n\n\n# 简介\n\n正则表达式使用圆括号进行组匹配。\n\nconst RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\n\n\n1\n\n\n上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。\n\nconst RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\n\nconst matchObj = RE_DATE.exec('1999-12-31');\nconst year = matchObj[1]; // 1999\nconst month = matchObj[2]; // 12\nconst day = matchObj[3]; // 31\n\n\n1\n2\n3\n4\n5\n6\n\n\n组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。\n\nES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。\n\nconst RE_DATE = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n\nconst matchObj = RE_DATE.exec('1999-12-31');\nconst year = matchObj.groups.year; // 1999\nconst month = matchObj.groups.month; // 12\nconst day = matchObj.groups.day; // 31\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?<year>），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。\n\n具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。\n\n如果具名组没有匹配，那么对应的groups对象属性会是undefined。\n\nconst RE_OPT_A = /^(?<as>a+)?$/;\nconst matchObj = RE_OPT_A.exec('');\n\nmatchObj.groups.as // undefined\n'as' in matchObj.groups // true\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。\n\n\n# 解构赋值和替换\n\n有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。\n\nlet {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');\none  // foo\ntwo  // bar\n\n\n1\n2\n3\n\n\n字符串替换时，使用$<组名>引用具名组。\n\nlet re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\n\n'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')\n// '02/01/2015'\n\n\n1\n2\n3\n4\n\n\n上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。\n\nreplace方法的第二个参数也可以是函数，该函数的参数序列如下。\n\n'2015-01-02'.replace(re, (\n   matched, // 整个匹配结果 2015-01-02\n   capture1, // 第一个组匹配 2015\n   capture2, // 第二个组匹配 01\n   capture3, // 第三个组匹配 02\n   position, // 匹配开始的位置 0\n   S, // 原字符串 2015-01-02\n   groups // 具名组构成的一个对象 {year, month, day}\n ) => {\n let {day, month, year} = groups;\n return `${day}/${month}/${year}`;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。\n\n\n# 引用\n\n如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k<组名>的写法。\n\nconst RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n\n\n1\n2\n3\n\n\n数字引用（\\1）依然有效。\n\nconst RE_TWICE = /^(?<word>[a-z]+)!\\1$/;\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n\n\n1\n2\n3\n\n\n这两种引用语法还可以同时使用。\n\nconst RE_TWICE = /^(?<word>[a-z]+)!\\k<word>!\\1$/;\nRE_TWICE.test('abc!abc!abc') // true\nRE_TWICE.test('abc!abc!ab') // false\n\n\n1\n2\n3\n\n\n\n# String.prototype.matchAll()\n\n如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。\n\nvar regex = /t(e)(st(\\d?))/g;\nvar string = 'test1test2test3';\n\nvar matches = [];\nvar match;\nwhile (match = regex.exec(string)) {\n  matches.push(match);\n}\n\nmatches\n// [\n//   [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"],\n//   [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"],\n//   [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"]\n// ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，while循环取出每一轮的正则匹配，一共三轮。\n\nES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。\n\nconst string = 'test1test2test3';\n\n// g 修饰符加不加都可以\nconst regex = /t(e)(st(\\d?))/g;\n\nfor (const match of string.matchAll(regex)) {\n  console.log(match);\n}\n// [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"]\n// [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"]\n// [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for...of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。\n\n遍历器转为数组是非常简单的，使用...运算符和Array.from()方法就可以了。\n\n// 转为数组方法一\n[...string.matchAll(regex)]\n\n// 转为数组方法二\nArray.from(string.matchAll(regex))\n\n\n1\n2\n3\n4\n5\n",normalizedContent:"# 正则的扩展\n\n\n# regexp 构造函数\n\n在 es5 中，regexp构造函数的参数有两种情况。\n\n第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。\n\nvar regex = new regexp('xyz', 'i');\n// 等价于\nvar regex = /xyz/i;\n\n\n1\n2\n3\n\n\n第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。\n\nvar regex = new regexp(/xyz/i);\n// 等价于\nvar regex = /xyz/i;\n\n\n1\n2\n3\n\n\n但是，es5 不允许此时使用第二个参数添加修饰符，否则会报错。\n\nvar regex = new regexp(/xyz/, 'i');\n// uncaught typeerror: cannot supply flags when constructing one regexp from another\n\n\n1\n2\n\n\nes6 改变了这种行为。如果regexp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。\n\nnew regexp(/abc/ig, 'i').flags\n// \"i\"\n\n\n1\n2\n\n\n上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。\n\n\n# 字符串的正则方法\n\n字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。\n\nes6 将这 4 个方法，在语言内部全部调用regexp的实例方法，从而做到所有与正则相关的方法，全都定义在regexp对象上。\n\n * string.prototype.match 调用 regexp.prototype[symbol.match]\n * string.prototype.replace 调用 regexp.prototype[symbol.replace]\n * string.prototype.search 调用 regexp.prototype[symbol.search]\n * string.prototype.split 调用 regexp.prototype[symbol.split]\n\n\n# u 修饰符\n\nes6 对正则表达式添加了u修饰符，含义为“unicode 模式”，用来正确处理大于\\uffff的 unicode 字符。也就是说，会正确处理四个字节的 utf-16 编码。\n\n/^\\ud83d/u.test('\\ud83d\\udc2a') // false\n/^\\ud83d/.test('\\ud83d\\udc2a') // true\n\n\n1\n2\n\n\n上面代码中，\\ud83d\\udc2a是一个四个字节的 utf-16 编码，代表一个字符。但是，es5 不支持四个字节的 utf-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，es6 就会识别其为一个字符，所以第一行代码结果为false。\n\n一旦加上u修饰符号，就会修改下面这些正则表达式的行为。\n\n（1）点字符\n\n点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xffff的 unicode 字符，点字符不能识别，必须加上u修饰符。\n\nvar s = '𠮷';\n\n/^.$/.test(s) // false\n/^.$/u.test(s) // true\n\n\n1\n2\n3\n4\n\n\n上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。\n\n（2）unicode 字符表示法\n\nes6 新增了使用大括号表示 unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。\n\n/\\u{61}/.test('a') // false\n/\\u{61}/u.test('a') // true\n/\\u{20bb7}/u.test('𠮷') // true\n\n\n1\n2\n3\n\n\n上面代码表示，如果不加u修饰符，正则表达式无法识别\\u{61}这种表示法，只会认为这匹配 61 个连续的u。\n\n（3）量词\n\n使用u修饰符后，所有量词都会正确识别码点大于0xffff的 unicode 字符。\n\n/a{2}/.test('aa') // true\n/a{2}/u.test('aa') // true\n/𠮷{2}/.test('𠮷𠮷') // false\n/𠮷{2}/u.test('𠮷𠮷') // true\n\n\n1\n2\n3\n4\n\n\n（4）预定义模式\n\nu修饰符也影响到预定义模式，能否正确识别码点大于0xffff的 unicode 字符。\n\n/^\\s$/.test('𠮷') // false\n/^\\s$/u.test('𠮷') // true\n\n\n1\n2\n\n\n上面代码的\\s是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xffff的 unicode 字符。\n\n利用这一点，可以写出一个正确返回字符串长度的函数。\n\nfunction codepointlength(text) {\n  var result = text.match(/[\\s\\s]/gu);\n  return result ? result.length : 0;\n}\n\nvar s = '𠮷𠮷';\n\ns.length // 4\ncodepointlength(s) // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n（5）i 修饰符\n\n有些 unicode 字符的编码不同，但是字型很相近，比如，\\u004b与\\u212a都是大写的k。\n\n/[a-z]/i.test('\\u212a') // false\n/[a-z]/iu.test('\\u212a') // true\n\n\n1\n2\n\n\n上面代码中，不加u修饰符，就无法识别非规范的k字符。\n\n（6）转义\n\n没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义\\,）无效，而在u模式会报错。\n\n/\\,/ // /\\,/\n/\\,/u // 报错\n\n\n1\n2\n\n\n上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。\n\n\n# regexp.prototype.unicode 属性\n\n正则实例对象新增unicode属性，表示是否设置了u修饰符。\n\nconst r1 = /hello/;\nconst r2 = /hello/u;\n\nr1.unicode // false\nr2.unicode // true\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。\n\n\n# y 修饰符\n\n除了u修饰符，es6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。\n\ny修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。\n\nvar s = 'aaa_aa_a';\nvar r1 = /a+/g;\nvar r2 = /a+/y;\n\nr1.exec(s) // [\"aaa\"]\nr2.exec(s) // [\"aaa\"]\n\nr1.exec(s) // [\"aa\"]\nr2.exec(s) // null\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。\n\n如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。\n\nvar s = 'aaa_aa_a';\nvar r = /a+_/y;\n\nr.exec(s) // [\"aaa_\"]\nr.exec(s) // [\"aa_\"]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码每次匹配，都是从剩余字符串的头部开始。\n\n使用lastindex属性，可以更好地说明y修饰符。\n\nconst regex = /a/g;\n\n// 指定从2号位置（y）开始匹配\nregex.lastindex = 2;\n\n// 匹配成功\nconst match = regex.exec('xaya');\n\n// 在3号位置匹配成功\nmatch.index // 3\n\n// 下一次匹配从4号位开始\nregex.lastindex // 4\n\n// 4号位开始匹配失败\nregex.exec('xaya') // null\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，lastindex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。\n\ny修饰符同样遵守lastindex属性，但是要求必须在lastindex指定的位置发现匹配。\n\nconst regex = /a/y;\n\n// 指定从2号位置开始匹配\nregex.lastindex = 2;\n\n// 不是粘连，匹配失败\nregex.exec('xaya') // null\n\n// 指定从3号位置开始匹配\nregex.lastindex = 3;\n\n// 3号位置是粘连，匹配成功\nconst match = regex.exec('xaya');\nmatch.index // 3\nregex.lastindex // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n实际上，y修饰符号隐含了头部匹配的标志^。\n\n/b/y.exec('aba')\n// null\n\n\n1\n2\n\n\n上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。\n\n下面是字符串对象的replace方法的例子。\n\nconst regex = /a/gy;\n'aaxa'.replace(regex, '-') // '--xa'\n\n\n1\n2\n\n\n上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。\n\n单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。\n\n'a1a2a3'.match(/a\\d/y) // [\"a1\"]\n'a1a2a3'.match(/a\\d/gy) // [\"a1\", \"a2\", \"a3\"]\n\n\n1\n2\n\n\ny修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。\n\nconst token_y = /\\s*(\\+|[0-9]+)\\s*/y;\nconst token_g  = /\\s*(\\+|[0-9]+)\\s*/g;\n\ntokenize(token_y, '3 + 4')\n// [ '3', '+', '4' ]\ntokenize(token_g, '3 + 4')\n// [ '3', '+', '4' ]\n\nfunction tokenize(token_regex, str) {\n  let result = [];\n  let match;\n  while (match = token_regex.exec(str)) {\n    result.push(match[1]);\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。\n\ntokenize(token_y, '3x + 4')\n// [ '3' ]\ntokenize(token_g, '3x + 4')\n// [ '3', '+', '4' ]\n\n\n1\n2\n3\n4\n\n\n上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。\n\n\n# regexp.prototype.sticky 属性\n\n与y修饰符相匹配，es6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。\n\nvar r = /hello\\d/y;\nr.sticky // true\n\n\n1\n2\n\n\n\n# regexp.prototype.flags 属性\n\nes6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。\n\n// es5 的 source 属性\n// 返回正则表达式的正文\n/abc/ig.source\n// \"abc\"\n\n// es6 的 flags 属性\n// 返回正则表达式的修饰符\n/abc/ig.flags\n// 'gi'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# s 修饰符：dotall 模式\n\n正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 utf-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。\n\n所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。\n\n * u+000a 换行符（\\n）\n * u+000d 回车符（\\r）\n * u+2028 行分隔符（line separator）\n * u+2029 段分隔符（paragraph separator）\n\n/foo.bar/.test('foo\\nbar')\n// false\n\n\n1\n2\n\n\n上面代码中，因为.不匹配\\n，所以正则表达式返回false。\n\n但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。\n\n/foo[^]bar/.test('foo\\nbar')\n// true\n\n\n1\n2\n\n\n这种解决方案毕竟不太符合直觉，es2018 引入s修饰符，使得.可以匹配任意单个字符。\n\n/foo.bar/s.test('foo\\nbar') // true\n\n\n1\n\n\n这被称为dotall模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotall属性，返回一个布尔值，表示该正则表达式是否处在dotall模式。\n\nconst re = /foo.bar/s;\n// 另一种写法\n// const re = new regexp('foo.bar', 's');\n\nre.test('foo\\nbar') // true\nre.dotall // true\nre.flags // 's'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n/s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。\n\n\n# 后行断言\n\njavascript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。es2018 引入后行断言，v8 引擎 4.9 版（chrome 62）已经支持。\n\n“先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。\n\n/\\d+(?=%)/.exec('100% of us presidents have been male')  // [\"100\"]\n/\\d+(?!%)/.exec('that’s all 44 of them')                 // [\"44\"]\n\n\n1\n2\n\n\n上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（(?=%)），是不计入返回结果的。\n\n“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?<=y)x/。比如，只匹配美元符号之后的数字，要写成/(?<=\\$)\\d+/。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成/(?<!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?<!\\$)\\d+/。\n\n/(?<=\\$)\\d+/.exec('benjamin franklin is on the $100 bill')  // [\"100\"]\n/(?<!\\$)\\d+/.exec('it’s is worth about €90')                // [\"90\"]\n\n\n1\n2\n\n\n上面的例子中，“后行断言”的括号之中的部分（(?<=\\$)），也是不计入返回结果。\n\n下面的例子是使用后行断言进行字符串替换。\n\nconst re_dollar_prefix = /(?<=\\$)foo/g;\n'$foo %foo foo'.replace(re_dollar_prefix, 'bar');\n// '$bar %foo foo'\n\n\n1\n2\n3\n\n\n上面代码中，只有在美元符号后面的foo才会被替换。\n\n“后行断言”的实现，需要先匹配/(?<=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。\n\n首先，后行断言的组匹配，与正常情况下结果是不一样的。\n\n/(?<=(\\d+)(\\d+))$/.exec('1053') // [\"\", \"1\", \"053\"]\n/^(\\d+)(\\d+)$/.exec('1053') // [\"1053\", \"105\", \"3\"]\n\n\n1\n2\n\n\n上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。\n\n其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。\n\n/(?<=(o)d\\1)r/.exec('hodor')  // null\n/(?<=\\1d(o))r/.exec('hodor')  // [\"r\", \"o\"]\n\n\n1\n2\n\n\n上面代码中，如果后行断言的反斜杠引用（\\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。\n\n\n# unicode 属性类\n\nes2018 引入了一种新的类的写法\\p{...}和\\p{...}，允许正则表达式匹配符合 unicode 某种属性的所有字符。\n\nconst regexgreeksymbol = /\\p{script=greek}/u;\nregexgreeksymbol.test('π') // true\n\n\n1\n2\n\n\n上面代码中，\\p{script=greek}指定匹配一个希腊文字母，所以匹配π成功。\n\nunicode 属性类要指定属性名和属性值。\n\n\\p{unicodepropertyname=unicodepropertyvalue}\n\n\n1\n\n\n对于某些属性，可以只写属性名，或者只写属性值。\n\n\\p{unicodepropertyname}\n\\p{unicodepropertyvalue}\n\n\n1\n2\n\n\n\\p{…}是\\p{…}的反向匹配，即匹配不满足条件的字符。\n\n注意，这两种类只对 unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\\p和\\p会报错，ecmascript 预留了这两个类。\n\n由于 unicode 的各种属性非常多，所以这种新的类的表达能力非常强。\n\nconst regex = /^\\p{decimal_number}+$/u;\nregex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true\n\n\n1\n2\n\n\n上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。\n\n\\p{number}甚至能匹配罗马数字。\n\n// 匹配所有数字\nconst regex = /^\\p{number}+$/u;\nregex.test('²³¹¼½¾') // true\nregex.test('㉛㉜㉝') // true\nregex.test('ⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺⅻ') // true\n\n\n1\n2\n3\n4\n5\n\n\n下面是其他一些例子。\n\n// 匹配所有空格\n\\p{white_space}\n\n// 匹配各种文字的所有字母，等同于 unicode 版的 \\w\n[\\p{alphabetic}\\p{mark}\\p{decimal_number}\\p{connector_punctuation}\\p{join_control}]\n\n// 匹配各种文字的所有非字母的字符，等同于 unicode 版的 \\w\n[^\\p{alphabetic}\\p{mark}\\p{decimal_number}\\p{connector_punctuation}\\p{join_control}]\n\n// 匹配 emoji\n/\\p{emoji_modifier_base}\\p{emoji_modifier}?|\\p{emoji_presentation}|\\p{emoji}\\ufe0f/gu\n\n// 匹配所有的箭头字符\nconst regexarrows = /^\\p{block=arrows}+$/u;\nregexarrows.test('←↑→↓↔↕↖↗↘↙⇒⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 具名组匹配\n\n\n# 简介\n\n正则表达式使用圆括号进行组匹配。\n\nconst re_date = /(\\d{4})-(\\d{2})-(\\d{2})/;\n\n\n1\n\n\n上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。\n\nconst re_date = /(\\d{4})-(\\d{2})-(\\d{2})/;\n\nconst matchobj = re_date.exec('1999-12-31');\nconst year = matchobj[1]; // 1999\nconst month = matchobj[2]; // 12\nconst day = matchobj[3]; // 31\n\n\n1\n2\n3\n4\n5\n6\n\n\n组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchobj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。\n\nes2018 引入了具名组匹配（named capture groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。\n\nconst re_date = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n\nconst matchobj = re_date.exec('1999-12-31');\nconst year = matchobj.groups.year; // 1999\nconst month = matchobj.groups.month; // 12\nconst day = matchobj.groups.day; // 31\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?<year>），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchobj[1]）依然有效。\n\n具名组匹配等于为每一组匹配加上了 id，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。\n\n如果具名组没有匹配，那么对应的groups对象属性会是undefined。\n\nconst re_opt_a = /^(?<as>a+)?$/;\nconst matchobj = re_opt_a.exec('');\n\nmatchobj.groups.as // undefined\n'as' in matchobj.groups // true\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，具名组as没有找到匹配，那么matchobj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。\n\n\n# 解构赋值和替换\n\n有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。\n\nlet {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');\none  // foo\ntwo  // bar\n\n\n1\n2\n3\n\n\n字符串替换时，使用$<组名>引用具名组。\n\nlet re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\n\n'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')\n// '02/01/2015'\n\n\n1\n2\n3\n4\n\n\n上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。\n\nreplace方法的第二个参数也可以是函数，该函数的参数序列如下。\n\n'2015-01-02'.replace(re, (\n   matched, // 整个匹配结果 2015-01-02\n   capture1, // 第一个组匹配 2015\n   capture2, // 第二个组匹配 01\n   capture3, // 第三个组匹配 02\n   position, // 匹配开始的位置 0\n   s, // 原字符串 2015-01-02\n   groups // 具名组构成的一个对象 {year, month, day}\n ) => {\n let {day, month, year} = groups;\n return `${day}/${month}/${year}`;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。\n\n\n# 引用\n\n如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k<组名>的写法。\n\nconst re_twice = /^(?<word>[a-z]+)!\\k<word>$/;\nre_twice.test('abc!abc') // true\nre_twice.test('abc!ab') // false\n\n\n1\n2\n3\n\n\n数字引用（\\1）依然有效。\n\nconst re_twice = /^(?<word>[a-z]+)!\\1$/;\nre_twice.test('abc!abc') // true\nre_twice.test('abc!ab') // false\n\n\n1\n2\n3\n\n\n这两种引用语法还可以同时使用。\n\nconst re_twice = /^(?<word>[a-z]+)!\\k<word>!\\1$/;\nre_twice.test('abc!abc!abc') // true\nre_twice.test('abc!abc!ab') // false\n\n\n1\n2\n3\n\n\n\n# string.prototype.matchall()\n\n如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。\n\nvar regex = /t(e)(st(\\d?))/g;\nvar string = 'test1test2test3';\n\nvar matches = [];\nvar match;\nwhile (match = regex.exec(string)) {\n  matches.push(match);\n}\n\nmatches\n// [\n//   [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"],\n//   [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"],\n//   [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"]\n// ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，while循环取出每一轮的正则匹配，一共三轮。\n\nes2020 增加了string.prototype.matchall()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（iterator），而不是数组。\n\nconst string = 'test1test2test3';\n\n// g 修饰符加不加都可以\nconst regex = /t(e)(st(\\d?))/g;\n\nfor (const match of string.matchall(regex)) {\n  console.log(match);\n}\n// [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"]\n// [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"]\n// [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，由于string.matchall(regex)返回的是遍历器，所以可以用for...of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。\n\n遍历器转为数组是非常简单的，使用...运算符和array.from()方法就可以了。\n\n// 转为数组方法一\n[...string.matchall(regex)]\n\n// 转为数组方法二\narray.from(string.matchall(regex))\n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"数值的扩展",frontmatter:{title:"数值的扩展",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/5dfea9a0f2d1a392",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/07.%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95.html",relativePath:"《ES6 教程》笔记/07.数值的扩展.md",key:"v-e165eb18",path:"/pages/5dfea9a0f2d1a392/",headers:[{level:2,title:"二进制和八进制表示法",slug:"二进制和八进制表示法",normalizedTitle:"二进制和八进制表示法",charIndex:12},{level:2,title:"Number.isFinite() 是否为有限, Number.isNaN() 是否为NaN",slug:"number-isfinite-是否为有限-number-isnan-是否为nan",normalizedTitle:"number.isfinite() 是否为有限, number.isnan() 是否为nan",charIndex:508},{level:2,title:"Number.parseInt(), Number.parseFloat()",slug:"number-parseint-number-parsefloat",normalizedTitle:"number.parseint(), number.parsefloat()",charIndex:1690},{level:2,title:"Number.isInteger() 是否为整数",slug:"number-isinteger-是否为整数",normalizedTitle:"number.isinteger() 是否为整数",charIndex:2072},{level:2,title:"Number.EPSILON 用于浮点数误差检查",slug:"number-epsilon-用于浮点数误差检查",normalizedTitle:"number.epsilon 用于浮点数误差检查",charIndex:3060},{level:2,title:"安全整数和 Number.isSafeInteger()",slug:"安全整数和-number-issafeinteger",normalizedTitle:"安全整数和 number.issafeinteger()",charIndex:4277},{level:2,title:"Math 对象的扩展",slug:"math-对象的扩展",normalizedTitle:"math 对象的扩展",charIndex:6745},{level:3,title:"Math.trunc() 去除一个数的小数部分，返回整数部分",slug:"math-trunc-去除一个数的小数部分-返回整数部分",normalizedTitle:"math.trunc() 去除一个数的小数部分，返回整数部分",charIndex:6821},{level:3,title:"Math.sign() 判断一个数是正数、负数、还是零",slug:"math-sign-判断一个数是正数、负数、还是零",normalizedTitle:"math.sign() 判断一个数是正数、负数、还是零",charIndex:7441},{level:3,title:"Math.cbrt() 计算一个数的立方根",slug:"math-cbrt-计算一个数的立方根",normalizedTitle:"math.cbrt() 计算一个数的立方根",charIndex:8155},{level:3,title:"Math.clz32()",slug:"math-clz32",normalizedTitle:"math.clz32()",charIndex:8551},{level:3,title:"Math.imul()",slug:"math-imul",normalizedTitle:"math.imul()",charIndex:9529},{level:3,title:"Math.fround()",slug:"math-fround",normalizedTitle:"math.fround()",charIndex:10121},{level:3,title:"Math.hypot()",slug:"math-hypot",normalizedTitle:"math.hypot()",charIndex:11181},{level:3,title:"对数方法",slug:"对数方法",normalizedTitle:"对数方法",charIndex:11578},{level:3,title:"双曲函数方法",slug:"双曲函数方法",normalizedTitle:"双曲函数方法",charIndex:12907},{level:2,title:"指数运算符",slug:"指数运算符",normalizedTitle:"指数运算符",charIndex:13231},{level:2,title:"BigInt 数据类型",slug:"bigint-数据类型",normalizedTitle:"bigint 数据类型",charIndex:13734},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:13750},{level:3,title:"BigInt 对象",slug:"bigint-对象",normalizedTitle:"bigint 对象",charIndex:15038},{level:3,title:"转换规则",slug:"转换规则",normalizedTitle:"转换规则",charIndex:15097},{level:3,title:"数学运算",slug:"数学运算",normalizedTitle:"数学运算",charIndex:17239},{level:3,title:"其他运算",slug:"其他运算",normalizedTitle:"其他运算",charIndex:18036}],excerpt:'<h1 id="数值的扩展"><a class="header-anchor" href="#数值的扩展">#</a> 数值的扩展</h1>\n<h2 id="二进制和八进制表示法"><a class="header-anchor" href="#二进制和八进制表示法">#</a> 二进制和八进制表示法</h2>\n<p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>\n\x3c!--beforebegin--\x3e<div class="language-javascript line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-javascript"><code><span class="token number">0b111110111</span> <span class="token operator">===</span> <span class="token number">503</span> <span class="token comment">// true</span>\n<span class="token number">0o767</span> <span class="token operator">===</span> <span class="token number">503</span> <span class="token comment">// true</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"二进制和八进制表示法 Number.isFinite() 是否为有限, Number.isNaN() 是否为NaN Number.parseInt(), Number.parseFloat() Number.isInteger() 是否为整数 Number.EPSILON 用于浮点数误差检查 安全整数和 Number.isSafeInteger() Math 对象的扩展 Math.trunc() 去除一个数的小数部分，返回整数部分 Math.sign() 判断一个数是正数、负数、还是零 Math.cbrt() 计算一个数的立方根 Math.clz32() Math.imul() Math.fround() Math.hypot() 对数方法 双曲函数方法 指数运算符 BigInt 数据类型 简介 BigInt 对象 转换规则 数学运算 其他运算",content:"# 数值的扩展\n\n\n# 二进制和八进制表示法\n\nES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。\n\n0b111110111 === 503 // true\n0o767 === 503 // true\n\n\n1\n2\n\n\n从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。\n\n// 非严格模式\n(function(){\n  console.log(0o11 === 011);\n})() // true\n\n// 严格模式\n(function(){\n  'use strict';\n  console.log(0o11 === 011);\n})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。\n\nNumber('0b111')  // 7\nNumber('0o10')  // 8\n\n\n1\n2\n\n\n\n# Number.isFinite() 是否为有限, Number.isNaN() 是否为NaN\n\nES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。\n\nNumber.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。\n\nNumber.isFinite(15); // true\nNumber.isFinite(0.8); // true\nNumber.isFinite(NaN); // false\nNumber.isFinite(Infinity); // false\nNumber.isFinite(-Infinity); // false\nNumber.isFinite('foo'); // false\nNumber.isFinite('15'); // false\nNumber.isFinite(true); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意，如果参数类型不是数值，Number.isFinite一律返回false。\n\nNumber.isNaN()用来检查一个值是否为NaN。\n\nNumber.isNaN(NaN) // true\nNumber.isNaN(15) // false\nNumber.isNaN('15') // false\nNumber.isNaN(true) // false\nNumber.isNaN(9/NaN) // true\nNumber.isNaN('true' / 0) // true\nNumber.isNaN('true' / 'true') // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果参数类型不是NaN，Number.isNaN一律返回false。\n\n它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。\n\nisFinite(25) // true\nisFinite(\"25\") // true\nNumber.isFinite(25) // true\nNumber.isFinite(\"25\") // false\n\nisNaN(NaN) // true\nisNaN(\"NaN\") // true\nNumber.isNaN(NaN) // true\nNumber.isNaN(\"NaN\") // false\nNumber.isNaN(1) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Number.parseInt(), Number.parseFloat()\n\nES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。\n\n// ES5的写法\nparseInt('12.34') // 12\nparseFloat('123.45#') // 123.45\n\n// ES6的写法\nNumber.parseInt('12.34') // 12\nNumber.parseFloat('123.45#') // 123.45\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。\n\nNumber.parseInt === parseInt // true\nNumber.parseFloat === parseFloat // true\n\n\n1\n2\n\n\n\n# Number.isInteger() 是否为整数\n\nNumber.isInteger()用来判断一个数值是否为整数。\n\nNumber.isInteger(25) // true\nNumber.isInteger(25.1) // false\n\n\n1\n2\n\n\nJavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。\n\nNumber.isInteger(25) // true\nNumber.isInteger(25.0) // true\n\n\n1\n2\n\n\n如果参数不是数值，Number.isInteger返回false。\n\nNumber.isInteger() // false\nNumber.isInteger(null) // false\nNumber.isInteger('15') // false\nNumber.isInteger(true) // false\n\n\n1\n2\n3\n4\n\n\n注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。\n\nNumber.isInteger(3.0000000000000002) // true\n\n\n1\n\n\n上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。\n\n类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。\n\nNumber.isInteger(5E-324) // false\nNumber.isInteger(5E-325) // true\n\n\n1\n2\n\n\n上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。\n\n总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。\n\n\n# Number.EPSILON 用于浮点数误差检查\n\nES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。\n\n对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。\n\nNumber.EPSILON === Math.pow(2, -52)\n// true\nNumber.EPSILON\n// 2.220446049250313e-16\nNumber.EPSILON.toFixed(20)\n// \"0.00000000000000022204\"\n\n\n1\n2\n3\n4\n5\n6\n\n\nNumber.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。\n\n引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。\n\n0.1 + 0.2\n// 0.30000000000000004\n\n0.1 + 0.2 - 0.3\n// 5.551115123125783e-17\n\n5.551115123125783e-17.toFixed(20)\n// '0.00000000000000005551'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。\n\n0.1 + 0.2 === 0.3 // false\n\n\n1\n\n\nNumber.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。\n\n5.551115123125783e-17 < Number.EPSILON * Math.pow(2, 2)\n// true\n\n\n1\n2\n\n\n因此，Number.EPSILON的实质是一个可以接受的最小误差范围。\n\nfunction withinErrorMargin (left, right) {\n  return Math.abs(left - right) < Number.EPSILON * Math.pow(2, 2);\n}\n\n0.1 + 0.2 === 0.3 // false\nwithinErrorMargin(0.1 + 0.2, 0.3) // true\n\n1.1 + 1.3 === 2.4 // false\nwithinErrorMargin(1.1 + 1.3, 2.4) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的代码为浮点数运算，部署了一个误差检查函数。\n\n\n# 安全整数和 Number.isSafeInteger()\n\nJavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。\n\nMath.pow(2, 53) // 9007199254740992\n\n9007199254740992  // 9007199254740992\n9007199254740993  // 9007199254740992\n\nMath.pow(2, 53) === Math.pow(2, 53) + 1\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，超出 2 的 53 次方之后，一个数就不精确了。\n\nES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。\n\nNumber.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1\n// true\nNumber.MAX_SAFE_INTEGER === 9007199254740991\n// true\n\nNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER\n// true\nNumber.MIN_SAFE_INTEGER === -9007199254740991\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，可以看到 JavaScript 能够精确表示的极限。\n\nNumber.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。\n\nNumber.isSafeInteger('a') // false\nNumber.isSafeInteger(null) // false\nNumber.isSafeInteger(NaN) // false\nNumber.isSafeInteger(Infinity) // false\nNumber.isSafeInteger(-Infinity) // false\n\nNumber.isSafeInteger(3) // true\nNumber.isSafeInteger(1.2) // false\nNumber.isSafeInteger(9007199254740990) // true\nNumber.isSafeInteger(9007199254740992) // false\n\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // true\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // true\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。\n\nNumber.isSafeInteger = function (n) {\n  return (typeof n === 'number' &&\n    Math.round(n) === n &&\n    Number.MIN_SAFE_INTEGER <= n &&\n    n <= Number.MAX_SAFE_INTEGER);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。\n\nNumber.isSafeInteger(9007199254740993)\n// false\nNumber.isSafeInteger(990)\n// true\nNumber.isSafeInteger(9007199254740993 - 990)\n// true\n9007199254740993 - 990\n// 返回结果 9007199254740002\n// 正确答案应该是 9007199254740003\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。\n\n9007199254740993 === 9007199254740992\n// true\n\n\n1\n2\n\n\n所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。\n\nfunction trusty (left, right, result) {\n  if (\n    Number.isSafeInteger(left) &&\n    Number.isSafeInteger(right) &&\n    Number.isSafeInteger(result)\n  ) {\n    return result;\n  }\n  throw new RangeError('Operation cannot be trusted!');\n}\n\ntrusty(9007199254740993, 990, 9007199254740993 - 990)\n// RangeError: Operation cannot be trusted!\n\ntrusty(1, 2, 3)\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Math 对象的扩展\n\nES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。\n\n\n# Math.trunc() 去除一个数的小数部分，返回整数部分\n\nMath.trunc方法用于去除一个数的小数部分，返回整数部分。\n\nMath.trunc(4.1) // 4\nMath.trunc(4.9) // 4\nMath.trunc(-4.1) // -4\nMath.trunc(-4.9) // -4\nMath.trunc(-0.1234) // -0\n\n\n1\n2\n3\n4\n5\n\n\n对于非数值，Math.trunc内部使用Number方法将其先转为数值。\n\nMath.trunc('123.456') // 123\nMath.trunc(true) //1\nMath.trunc(false) // 0\nMath.trunc(null) // 0\n\n\n1\n2\n3\n4\n\n\n对于空值和无法截取整数的值，返回NaN。\n\nMath.trunc(NaN);      // NaN\nMath.trunc('foo');    // NaN\nMath.trunc();         // NaN\nMath.trunc(undefined) // NaN\n\n\n1\n2\n3\n4\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nMath.trunc = Math.trunc || function(x) {\n  return x < 0 ? Math.ceil(x) : Math.floor(x);\n};\n\n\n1\n2\n3\n\n\n\n# Math.sign() 判断一个数是正数、负数、还是零\n\nMath.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。\n\n它会返回五种值。\n\n * 参数为正数，返回+1；\n * 参数为负数，返回-1；\n * 参数为 0，返回0；\n * 参数为-0，返回-0;\n * 其他值，返回NaN。\n\nMath.sign(-5) // -1\nMath.sign(5) // +1\nMath.sign(0) // +0\nMath.sign(-0) // -0\nMath.sign(NaN) // NaN\n\n\n1\n2\n3\n4\n5\n\n\n如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。\n\nMath.sign('')  // 0\nMath.sign(true)  // +1\nMath.sign(false)  // 0\nMath.sign(null)  // 0\nMath.sign('9')  // +1\nMath.sign('foo')  // NaN\nMath.sign()  // NaN\nMath.sign(undefined)  // NaN\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nMath.sign = Math.sign || function(x) {\n  x = +x; // convert to a number\n  if (x === 0 || isNaN(x)) {\n    return x;\n  }\n  return x > 0 ? 1 : -1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Math.cbrt() 计算一个数的立方根\n\nMath.cbrt方法用于计算一个数的立方根。\n\nMath.cbrt(-1) // -1\nMath.cbrt(0)  // 0\nMath.cbrt(1)  // 1\nMath.cbrt(2)  // 1.2599210498948734\n\n\n1\n2\n3\n4\n\n\n对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。\n\nMath.cbrt('8') // 2\nMath.cbrt('hello') // NaN\n\n\n1\n2\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nMath.cbrt = Math.cbrt || function(x) {\n  var y = Math.pow(Math.abs(x), 1/3);\n  return x < 0 ? -y : y;\n};\n\n\n1\n2\n3\n4\n\n\n\n# Math.clz32()\n\nMath.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。\n\nMath.clz32(0) // 32\nMath.clz32(1) // 31\nMath.clz32(1000) // 22\nMath.clz32(0b01000000000000000000000000000000) // 1\nMath.clz32(0b00100000000000000000000000000000) // 2\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。\n\nclz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。\n\n左移运算符（<<）与Math.clz32方法直接相关。\n\nMath.clz32(0) // 32\nMath.clz32(1) // 31\nMath.clz32(1 << 1) // 30\nMath.clz32(1 << 2) // 29\nMath.clz32(1 << 29) // 2\n\n\n1\n2\n3\n4\n5\n\n\n对于小数，Math.clz32方法只考虑整数部分。\n\nMath.clz32(3.2) // 30\nMath.clz32(3.9) // 30\n\n\n1\n2\n\n\n对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。\n\nMath.clz32() // 32\nMath.clz32(NaN) // 32\nMath.clz32(Infinity) // 32\nMath.clz32(null) // 32\nMath.clz32('foo') // 32\nMath.clz32([]) // 32\nMath.clz32({}) // 32\nMath.clz32(true) // 31\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Math.imul()\n\nMath.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。\n\nMath.imul(2, 4)   // 8\nMath.imul(-1, 8)  // -8\nMath.imul(-2, -2) // 4\n\n\n1\n2\n3\n\n\n如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与a * b的结果是相同的，即该方法等同于(a * b)|0的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。\n\n(0x7fffffff * 0x7fffffff)|0 // 0\n\n\n1\n\n\n上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul方法可以返回正确的值 1。\n\nMath.imul(0x7fffffff, 0x7fffffff) // 1\n\n\n1\n\n\n\n# Math.fround()\n\nMath.fround方法返回一个数的32位单精度浮点数形式。\n\n对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。\n\nMath.fround(0)   // 0\nMath.fround(1)   // 1\nMath.fround(2 ** 24 - 1)   // 16777215\n\n\n1\n2\n3\n\n\n如果参数的绝对值大于 224，返回的结果便开始丢失精度。\n\nMath.fround(2 ** 24)       // 16777216\nMath.fround(2 ** 24 + 1)   // 16777216\n\n\n1\n2\n\n\nMath.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。\n\n// 未丢失有效精度\nMath.fround(1.125) // 1.125\nMath.fround(7.25)  // 7.25\n\n// 丢失精度\nMath.fround(0.3)   // 0.30000001192092896\nMath.fround(0.7)   // 0.699999988079071\nMath.fround(1.0000000123) // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于 NaN 和 Infinity，此方法返回原值。对于其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数。\n\nMath.fround(NaN)      // NaN\nMath.fround(Infinity) // Infinity\n\nMath.fround('5')      // 5\nMath.fround(true)     // 1\nMath.fround(null)     // 0\nMath.fround([])       // 0\nMath.fround({})       // NaN\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nMath.fround = Math.fround || function (x) {\n  return new Float32Array([x])[0];\n};\n\n\n1\n2\n3\n\n\n\n# Math.hypot()\n\nMath.hypot方法返回所有参数的平方和的平方根。\n\nMath.hypot(3, 4);        // 5\nMath.hypot(3, 4, 5);     // 7.0710678118654755\nMath.hypot();            // 0\nMath.hypot(NaN);         // NaN\nMath.hypot(3, 4, 'foo'); // NaN\nMath.hypot(3, 4, '5');   // 7.0710678118654755\nMath.hypot(-3);          // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，3 的平方加上 4 的平方，等于 5 的平方。\n\n如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。\n\n\n# 对数方法\n\nES6 新增了 4 个对数相关方法。\n\n（1） Math.expm1()\n\nMath.expm1(x)返回 ex - 1，即Math.exp(x) - 1。\n\nMath.expm1(-1) // -0.6321205588285577\nMath.expm1(0)  // 0\nMath.expm1(1)  // 1.718281828459045\n\n\n1\n2\n3\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nMath.expm1 = Math.expm1 || function(x) {\n  return Math.exp(x) - 1;\n};\n\n\n1\n2\n3\n\n\n（2）Math.log1p()\n\nMath.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。\n\nMath.log1p(1)  // 0.6931471805599453\nMath.log1p(0)  // 0\nMath.log1p(-1) // -Infinity\nMath.log1p(-2) // NaN\n\n\n1\n2\n3\n4\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nMath.log1p = Math.log1p || function(x) {\n  return Math.log(1 + x);\n};\n\n\n1\n2\n3\n\n\n（3）Math.log10()\n\nMath.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。\n\nMath.log10(2)      // 0.3010299956639812\nMath.log10(1)      // 0\nMath.log10(0)      // -Infinity\nMath.log10(-2)     // NaN\nMath.log10(100000) // 5\n\n\n1\n2\n3\n4\n5\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nMath.log10 = Math.log10 || function(x) {\n  return Math.log(x) / Math.LN10;\n};\n\n\n1\n2\n3\n\n\n（4）Math.log2()\n\nMath.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。\n\nMath.log2(3)       // 1.584962500721156\nMath.log2(2)       // 1\nMath.log2(1)       // 0\nMath.log2(0)       // -Infinity\nMath.log2(-2)      // NaN\nMath.log2(1024)    // 10\nMath.log2(1 << 29) // 29\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nMath.log2 = Math.log2 || function(x) {\n  return Math.log(x) / Math.LN2;\n};\n\n\n1\n2\n3\n\n\n\n# 双曲函数方法\n\nES6 新增了 6 个双曲函数方法。\n\n * Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）\n * Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）\n * Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）\n * Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）\n * Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）\n * Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）\n\n\n# 指数运算符\n\nES2016 新增了一个指数运算符（**）。\n\n2 ** 2 // 4\n2 ** 3 // 8\n\n\n1\n2\n\n\n这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。\n\n// 相当于 2 ** (3 ** 2)\n2 ** 3 ** 2\n// 512\n\n\n1\n2\n3\n\n\n上面代码中，首先计算的是第二个指数运算符，而不是第一个。\n\n指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。\n\nlet a = 1.5;\na **= 2;\n// 等同于 a = a * a;\n\nlet b = 4;\nb **= 3;\n// 等同于 b = b * b * b;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，V8 引擎的指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。\n\nMath.pow(99, 99)\n// 3.697296376497263e+197\n\n99 ** 99\n// 3.697296376497268e+197\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，两个运算结果的最后一位有效数字是有差异的。\n\n\n# BigInt 数据类型\n\n\n# 简介\n\nJavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。\n\n// 超过 53 个二进制位的数值，无法保持精度\nMath.pow(2, 53) === Math.pow(2, 53) + 1 // true\n\n// 超过 2 的 1024 次方的数值，无法表示\nMath.pow(2, 1024) // Infinity\n\n\n1\n2\n3\n4\n5\n\n\nES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。\n\nconst a = 2172141653n;\nconst b = 15346349309n;\n\n// BigInt 可以保持精度\na * b // 33334444555566667777n\n\n// 普通整数无法保持精度\nNumber(a) * Number(b) // 33334444555566670000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n。\n\n1234 // 普通整数\n1234n // BigInt\n\n// BigInt 的运算\n1n + 2n // 3n\n\n\n1\n2\n3\n4\n5\n\n\nBigInt 同样可以使用各种进制表示，都要加上后缀n。\n\n0b1101n // 二进制\n0o777n // 八进制\n0xFFn // 十六进制\n\n\n1\n2\n3\n\n\nBigInt 与普通整数是两种值，它们之间并不相等。\n\n42n === 42 // false\n\n\n1\n\n\ntypeof运算符对于 BigInt 类型的数据返回bigint。\n\ntypeof 123n // 'bigint'\n\n\n1\n\n\nBigInt 可以使用负号（-），但是不能使用正号（+），因为会与 asm.js 冲突。\n\n-42n // 正确\n+42n // 报错\n\n\n1\n2\n\n\nJavaScript 以前不能计算70的阶乘（即70!），因为超出了可以表示的精度。\n\nlet p = 1;\nfor (let i = 1; i <= 70; i++) {\n  p *= i;\n}\nconsole.log(p); // 1.197857166996989e+100\n\n\n1\n2\n3\n4\n5\n\n\n现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。\n\nlet p = 1n;\nfor (let i = 1n; i <= 70n; i++) {\n  p *= i;\n}\nconsole.log(p); // 11978571...00000000n\n\n\n1\n2\n3\n4\n5\n\n\n\n# BigInt 对象\n\nJavaScript 原生提供BigInt对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与Number()一致，将其他类型的值转为 BigInt。\n\nBigInt(123) // 123n\nBigInt('123') // 123n\nBigInt(false) // 0n\nBigInt(true) // 1n\n\n\n1\n2\n3\n4\n\n\nBigInt()构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。\n\nnew BigInt() // TypeError\nBigInt(undefined) //TypeError\nBigInt(null) // TypeError\nBigInt('123n') // SyntaxError\nBigInt('abc') // SyntaxError\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，尤其值得注意字符串123n无法解析成 Number 类型，所以会报错。\n\n参数如果是小数，也会报错。\n\nBigInt(1.5) // RangeError\nBigInt('1.5') // SyntaxError\n\n\n1\n2\n\n\nBigInt 对象继承了 Object 对象的两个实例方法。\n\n * BigInt.prototype.toString()\n * BigInt.prototype.valueOf()\n\n它还继承了 Number 对象的一个实例方法。\n\n * BigInt.prototype.toLocaleString()\n\n此外，还提供了三个静态方法。\n\n * BigInt.asUintN(width, BigInt)： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。\n * BigInt.asIntN(width, BigInt)：给定的 BigInt 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。\n * BigInt.parseInt(string[, radix])：近似于Number.parseInt()，将一个字符串转换成指定进制的 BigInt。\n\nconst max = 2n ** (64n - 1n) - 1n;\n\nBigInt.asIntN(64, max)\n// 9223372036854775807n\nBigInt.asIntN(64, max + 1n)\n// -9223372036854775808n\nBigInt.asUintN(64, max + 1n)\n// 9223372036854775808n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，max是64位带符号的 BigInt 所能表示的最大值。如果对这个值加1n，BigInt.asIntN()将会返回一个负值，因为这时新增的一位将被解释为符号位。而BigInt.asUintN()方法由于不存在符号位，所以可以正确返回结果。\n\n如果BigInt.asIntN()和BigInt.asUintN()指定的位数，小于数值本身的位数，那么头部的位将被舍弃。\n\nconst max = 2n ** (64n - 1n) - 1n;\n\nBigInt.asIntN(32, max) // -1n\nBigInt.asUintN(32, max) // 4294967295n\n\n\n1\n2\n3\n4\n\n\n上面代码中，max是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃。\n\n下面是BigInt.parseInt()的例子。\n\n// Number.parseInt() 与 BigInt.parseInt() 的对比\nNumber.parseInt('9007199254740993', 10)\n// 9007199254740992\nBigInt.parseInt('9007199254740993', 10)\n// 9007199254740993n\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，由于有效数字超出了最大限度，Number.parseInt方法返回的结果是不精确的，而BigInt.parseInt方法正确返回了对应的 BigInt。\n\n对于二进制数组，BigInt 新增了两个类型BigUint64Array和BigInt64Array，这两种数据类型返回的都是64位 BigInt。DataView对象的实例方法DataView.prototype.getBigInt64()和DataView.prototype.getBigUint64()，返回的也是 BigInt。\n\n\n# 转换规则\n\n可以使用Boolean()、Number()和String()这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。\n\nBoolean(0n) // false\nBoolean(1n) // true\nNumber(1n)  // 1\nString(1n)  // \"1\"\n\n\n1\n2\n3\n4\n\n\n上面代码中，注意最后一个例子，转为字符串时后缀n会消失。\n\n另外，取反运算符（!）也可以将 BigInt 转为布尔值。\n\n!0n // true\n!1n // false\n\n\n1\n2\n\n\n\n# 数学运算\n\n数学运算方面，BigInt 类型的+、-、*和**这四个二元运算符，与 Number 类型的行为一致。除法运算/会舍去小数部分，返回一个整数。\n\n9n / 5n\n// 1n\n\n\n1\n2\n\n\n几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。\n\n * 不带符号的右移位运算符>>>\n * 一元的求正运算符+\n\n上面两个运算符用在 BigInt 会报错。前者是因为>>>运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符>>。后者是因为一元运算符+在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定+1n会报错。\n\nBigInt 不能与普通数值进行混合运算。\n\n1n + 1.3 // 报错\n\n\n1\n\n\n上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如(2n**53n + 1n) + 0.5这个表达式，如果返回 BigInt 类型，0.5这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。\n\n同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。\n\n// 错误的写法\nMath.sqrt(4n) // 报错\n\n// 正确的写法\nMath.sqrt(Number(4n)) // 2\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，Math.sqrt的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用Number方法转一下类型，才能进行计算。\n\nasm.js 里面，|0跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与|0进行运算会报错。\n\n1n | 0 // 报错\n\n\n1\n\n\n\n# 其他运算\n\nBigInt 对应的布尔值，与 Number 类型一致，即0n会转为false，其他值转为true。\n\nif (0n) {\n  console.log('if');\n} else {\n  console.log('else');\n}\n// else\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，0n对应false，所以会进入else子句。\n\n比较运算符（比如>）和相等运算符（==）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。\n\n0n < 1 // true\n0n < true // true\n0n == 0 // true\n0n == false // true\n0n === 0 // false\n\n\n1\n2\n3\n4\n5\n\n\nBigInt 与字符串混合运算时，会先转为字符串，再进行运算。\n\n'' + 123n // \"123\"\n\n\n1\n",normalizedContent:"# 数值的扩展\n\n\n# 二进制和八进制表示法\n\nes6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0b）和0o（或0o）表示。\n\n0b111110111 === 503 // true\n0o767 === 503 // true\n\n\n1\n2\n\n\n从 es5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，es6 进一步明确，要使用前缀0o表示。\n\n// 非严格模式\n(function(){\n  console.log(0o11 === 011);\n})() // true\n\n// 严格模式\n(function(){\n  'use strict';\n  console.log(0o11 === 011);\n})() // uncaught syntaxerror: octal literals are not allowed in strict mode.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果要将0b和0o前缀的字符串数值转为十进制，要使用number方法。\n\nnumber('0b111')  // 7\nnumber('0o10')  // 8\n\n\n1\n2\n\n\n\n# number.isfinite() 是否为有限, number.isnan() 是否为nan\n\nes6 在number对象上，新提供了number.isfinite()和number.isnan()两个方法。\n\nnumber.isfinite()用来检查一个数值是否为有限的（finite），即不是infinity。\n\nnumber.isfinite(15); // true\nnumber.isfinite(0.8); // true\nnumber.isfinite(nan); // false\nnumber.isfinite(infinity); // false\nnumber.isfinite(-infinity); // false\nnumber.isfinite('foo'); // false\nnumber.isfinite('15'); // false\nnumber.isfinite(true); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意，如果参数类型不是数值，number.isfinite一律返回false。\n\nnumber.isnan()用来检查一个值是否为nan。\n\nnumber.isnan(nan) // true\nnumber.isnan(15) // false\nnumber.isnan('15') // false\nnumber.isnan(true) // false\nnumber.isnan(9/nan) // true\nnumber.isnan('true' / 0) // true\nnumber.isnan('true' / 'true') // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果参数类型不是nan，number.isnan一律返回false。\n\n它们与传统的全局方法isfinite()和isnan()的区别在于，传统方法先调用number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，number.isfinite()对于非数值一律返回false, number.isnan()只有对于nan才返回true，非nan一律返回false。\n\nisfinite(25) // true\nisfinite(\"25\") // true\nnumber.isfinite(25) // true\nnumber.isfinite(\"25\") // false\n\nisnan(nan) // true\nisnan(\"nan\") // true\nnumber.isnan(nan) // true\nnumber.isnan(\"nan\") // false\nnumber.isnan(1) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# number.parseint(), number.parsefloat()\n\nes6 将全局方法parseint()和parsefloat()，移植到number对象上面，行为完全保持不变。\n\n// es5的写法\nparseint('12.34') // 12\nparsefloat('123.45#') // 123.45\n\n// es6的写法\nnumber.parseint('12.34') // 12\nnumber.parsefloat('123.45#') // 123.45\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。\n\nnumber.parseint === parseint // true\nnumber.parsefloat === parsefloat // true\n\n\n1\n2\n\n\n\n# number.isinteger() 是否为整数\n\nnumber.isinteger()用来判断一个数值是否为整数。\n\nnumber.isinteger(25) // true\nnumber.isinteger(25.1) // false\n\n\n1\n2\n\n\njavascript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。\n\nnumber.isinteger(25) // true\nnumber.isinteger(25.0) // true\n\n\n1\n2\n\n\n如果参数不是数值，number.isinteger返回false。\n\nnumber.isinteger() // false\nnumber.isinteger(null) // false\nnumber.isinteger('15') // false\nnumber.isinteger(true) // false\n\n\n1\n2\n3\n4\n\n\n注意，由于 javascript 采用 ieee 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，number.isinteger可能会误判。\n\nnumber.isinteger(3.0000000000000002) // true\n\n\n1\n\n\n上面代码中，number.isinteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。\n\n类似的情况还有，如果一个数值的绝对值小于number.min_value（5e-324），即小于 javascript 能够分辨的最小值，会被自动转为 0。这时，number.isinteger也会误判。\n\nnumber.isinteger(5e-324) // false\nnumber.isinteger(5e-325) // true\n\n\n1\n2\n\n\n上面代码中，5e-325由于值太小，会被自动转为0，因此返回true。\n\n总之，如果对数据精度的要求较高，不建议使用number.isinteger()判断一个数值是否为整数。\n\n\n# number.epsilon 用于浮点数误差检查\n\nes6 在number对象上面，新增一个极小的常量number.epsilon。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。\n\n对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。\n\nnumber.epsilon === math.pow(2, -52)\n// true\nnumber.epsilon\n// 2.220446049250313e-16\nnumber.epsilon.tofixed(20)\n// \"0.00000000000000022204\"\n\n\n1\n2\n3\n4\n5\n6\n\n\nnumber.epsilon实际上是 javascript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。\n\n引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。\n\n0.1 + 0.2\n// 0.30000000000000004\n\n0.1 + 0.2 - 0.3\n// 5.551115123125783e-17\n\n5.551115123125783e-17.tofixed(20)\n// '0.00000000000000005551'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。\n\n0.1 + 0.2 === 0.3 // false\n\n\n1\n\n\nnumber.epsilon可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即number.epsilon * math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。\n\n5.551115123125783e-17 < number.epsilon * math.pow(2, 2)\n// true\n\n\n1\n2\n\n\n因此，number.epsilon的实质是一个可以接受的最小误差范围。\n\nfunction withinerrormargin (left, right) {\n  return math.abs(left - right) < number.epsilon * math.pow(2, 2);\n}\n\n0.1 + 0.2 === 0.3 // false\nwithinerrormargin(0.1 + 0.2, 0.3) // true\n\n1.1 + 1.3 === 2.4 // false\nwithinerrormargin(1.1 + 1.3, 2.4) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的代码为浮点数运算，部署了一个误差检查函数。\n\n\n# 安全整数和 number.issafeinteger()\n\njavascript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。\n\nmath.pow(2, 53) // 9007199254740992\n\n9007199254740992  // 9007199254740992\n9007199254740993  // 9007199254740992\n\nmath.pow(2, 53) === math.pow(2, 53) + 1\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，超出 2 的 53 次方之后，一个数就不精确了。\n\nes6 引入了number.max_safe_integer和number.min_safe_integer这两个常量，用来表示这个范围的上下限。\n\nnumber.max_safe_integer === math.pow(2, 53) - 1\n// true\nnumber.max_safe_integer === 9007199254740991\n// true\n\nnumber.min_safe_integer === -number.max_safe_integer\n// true\nnumber.min_safe_integer === -9007199254740991\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，可以看到 javascript 能够精确表示的极限。\n\nnumber.issafeinteger()则是用来判断一个整数是否落在这个范围之内。\n\nnumber.issafeinteger('a') // false\nnumber.issafeinteger(null) // false\nnumber.issafeinteger(nan) // false\nnumber.issafeinteger(infinity) // false\nnumber.issafeinteger(-infinity) // false\n\nnumber.issafeinteger(3) // true\nnumber.issafeinteger(1.2) // false\nnumber.issafeinteger(9007199254740990) // true\nnumber.issafeinteger(9007199254740992) // false\n\nnumber.issafeinteger(number.min_safe_integer - 1) // false\nnumber.issafeinteger(number.min_safe_integer) // true\nnumber.issafeinteger(number.max_safe_integer) // true\nnumber.issafeinteger(number.max_safe_integer + 1) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。\n\nnumber.issafeinteger = function (n) {\n  return (typeof n === 'number' &&\n    math.round(n) === n &&\n    number.min_safe_integer <= n &&\n    n <= number.max_safe_integer);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。\n\nnumber.issafeinteger(9007199254740993)\n// false\nnumber.issafeinteger(990)\n// true\nnumber.issafeinteger(9007199254740993 - 990)\n// true\n9007199254740993 - 990\n// 返回结果 9007199254740002\n// 正确答案应该是 9007199254740003\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，9007199254740993不是一个安全整数，但是number.issafeinteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。\n\n9007199254740993 === 9007199254740992\n// true\n\n\n1\n2\n\n\n所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。\n\nfunction trusty (left, right, result) {\n  if (\n    number.issafeinteger(left) &&\n    number.issafeinteger(right) &&\n    number.issafeinteger(result)\n  ) {\n    return result;\n  }\n  throw new rangeerror('operation cannot be trusted!');\n}\n\ntrusty(9007199254740993, 990, 9007199254740993 - 990)\n// rangeerror: operation cannot be trusted!\n\ntrusty(1, 2, 3)\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# math 对象的扩展\n\nes6 在 math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 math 对象上调用。\n\n\n# math.trunc() 去除一个数的小数部分，返回整数部分\n\nmath.trunc方法用于去除一个数的小数部分，返回整数部分。\n\nmath.trunc(4.1) // 4\nmath.trunc(4.9) // 4\nmath.trunc(-4.1) // -4\nmath.trunc(-4.9) // -4\nmath.trunc(-0.1234) // -0\n\n\n1\n2\n3\n4\n5\n\n\n对于非数值，math.trunc内部使用number方法将其先转为数值。\n\nmath.trunc('123.456') // 123\nmath.trunc(true) //1\nmath.trunc(false) // 0\nmath.trunc(null) // 0\n\n\n1\n2\n3\n4\n\n\n对于空值和无法截取整数的值，返回nan。\n\nmath.trunc(nan);      // nan\nmath.trunc('foo');    // nan\nmath.trunc();         // nan\nmath.trunc(undefined) // nan\n\n\n1\n2\n3\n4\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nmath.trunc = math.trunc || function(x) {\n  return x < 0 ? math.ceil(x) : math.floor(x);\n};\n\n\n1\n2\n3\n\n\n\n# math.sign() 判断一个数是正数、负数、还是零\n\nmath.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。\n\n它会返回五种值。\n\n * 参数为正数，返回+1；\n * 参数为负数，返回-1；\n * 参数为 0，返回0；\n * 参数为-0，返回-0;\n * 其他值，返回nan。\n\nmath.sign(-5) // -1\nmath.sign(5) // +1\nmath.sign(0) // +0\nmath.sign(-0) // -0\nmath.sign(nan) // nan\n\n\n1\n2\n3\n4\n5\n\n\n如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回nan。\n\nmath.sign('')  // 0\nmath.sign(true)  // +1\nmath.sign(false)  // 0\nmath.sign(null)  // 0\nmath.sign('9')  // +1\nmath.sign('foo')  // nan\nmath.sign()  // nan\nmath.sign(undefined)  // nan\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nmath.sign = math.sign || function(x) {\n  x = +x; // convert to a number\n  if (x === 0 || isnan(x)) {\n    return x;\n  }\n  return x > 0 ? 1 : -1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# math.cbrt() 计算一个数的立方根\n\nmath.cbrt方法用于计算一个数的立方根。\n\nmath.cbrt(-1) // -1\nmath.cbrt(0)  // 0\nmath.cbrt(1)  // 1\nmath.cbrt(2)  // 1.2599210498948734\n\n\n1\n2\n3\n4\n\n\n对于非数值，math.cbrt方法内部也是先使用number方法将其转为数值。\n\nmath.cbrt('8') // 2\nmath.cbrt('hello') // nan\n\n\n1\n2\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nmath.cbrt = math.cbrt || function(x) {\n  var y = math.pow(math.abs(x), 1/3);\n  return x < 0 ? -y : y;\n};\n\n\n1\n2\n3\n4\n\n\n\n# math.clz32()\n\nmath.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。\n\nmath.clz32(0) // 32\nmath.clz32(1) // 31\nmath.clz32(1000) // 22\nmath.clz32(0b01000000000000000000000000000000) // 1\nmath.clz32(0b00100000000000000000000000000000) // 2\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。\n\nclz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。\n\n左移运算符（<<）与math.clz32方法直接相关。\n\nmath.clz32(0) // 32\nmath.clz32(1) // 31\nmath.clz32(1 << 1) // 30\nmath.clz32(1 << 2) // 29\nmath.clz32(1 << 29) // 2\n\n\n1\n2\n3\n4\n5\n\n\n对于小数，math.clz32方法只考虑整数部分。\n\nmath.clz32(3.2) // 30\nmath.clz32(3.9) // 30\n\n\n1\n2\n\n\n对于空值或其他类型的值，math.clz32方法会将它们先转为数值，然后再计算。\n\nmath.clz32() // 32\nmath.clz32(nan) // 32\nmath.clz32(infinity) // 32\nmath.clz32(null) // 32\nmath.clz32('foo') // 32\nmath.clz32([]) // 32\nmath.clz32({}) // 32\nmath.clz32(true) // 31\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# math.imul()\n\nmath.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。\n\nmath.imul(2, 4)   // 8\nmath.imul(-1, 8)  // -8\nmath.imul(-2, -2) // 4\n\n\n1\n2\n3\n\n\n如果只考虑最后 32 位，大多数情况下，math.imul(a, b)与a * b的结果是相同的，即该方法等同于(a * b)|0的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 javascript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，math.imul方法可以返回正确的低位数值。\n\n(0x7fffffff * 0x7fffffff)|0 // 0\n\n\n1\n\n\n上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，javascript 无法保存额外的精度，就把低位的值都变成了 0。math.imul方法可以返回正确的值 1。\n\nmath.imul(0x7fffffff, 0x7fffffff) // 1\n\n\n1\n\n\n\n# math.fround()\n\nmath.fround方法返回一个数的32位单精度浮点数形式。\n\n对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。\n\nmath.fround(0)   // 0\nmath.fround(1)   // 1\nmath.fround(2 ** 24 - 1)   // 16777215\n\n\n1\n2\n3\n\n\n如果参数的绝对值大于 224，返回的结果便开始丢失精度。\n\nmath.fround(2 ** 24)       // 16777216\nmath.fround(2 ** 24 + 1)   // 16777216\n\n\n1\n2\n\n\nmath.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。\n\n// 未丢失有效精度\nmath.fround(1.125) // 1.125\nmath.fround(7.25)  // 7.25\n\n// 丢失精度\nmath.fround(0.3)   // 0.30000001192092896\nmath.fround(0.7)   // 0.699999988079071\nmath.fround(1.0000000123) // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于 nan 和 infinity，此方法返回原值。对于其它类型的非数值，math.fround 方法会先将其转为数值，再返回单精度浮点数。\n\nmath.fround(nan)      // nan\nmath.fround(infinity) // infinity\n\nmath.fround('5')      // 5\nmath.fround(true)     // 1\nmath.fround(null)     // 0\nmath.fround([])       // 0\nmath.fround({})       // nan\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nmath.fround = math.fround || function (x) {\n  return new float32array([x])[0];\n};\n\n\n1\n2\n3\n\n\n\n# math.hypot()\n\nmath.hypot方法返回所有参数的平方和的平方根。\n\nmath.hypot(3, 4);        // 5\nmath.hypot(3, 4, 5);     // 7.0710678118654755\nmath.hypot();            // 0\nmath.hypot(nan);         // nan\nmath.hypot(3, 4, 'foo'); // nan\nmath.hypot(3, 4, '5');   // 7.0710678118654755\nmath.hypot(-3);          // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，3 的平方加上 4 的平方，等于 5 的平方。\n\n如果参数不是数值，math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 nan。\n\n\n# 对数方法\n\nes6 新增了 4 个对数相关方法。\n\n（1） math.expm1()\n\nmath.expm1(x)返回 ex - 1，即math.exp(x) - 1。\n\nmath.expm1(-1) // -0.6321205588285577\nmath.expm1(0)  // 0\nmath.expm1(1)  // 1.718281828459045\n\n\n1\n2\n3\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nmath.expm1 = math.expm1 || function(x) {\n  return math.exp(x) - 1;\n};\n\n\n1\n2\n3\n\n\n（2）math.log1p()\n\nmath.log1p(x)方法返回1 + x的自然对数，即math.log(1 + x)。如果x小于-1，返回nan。\n\nmath.log1p(1)  // 0.6931471805599453\nmath.log1p(0)  // 0\nmath.log1p(-1) // -infinity\nmath.log1p(-2) // nan\n\n\n1\n2\n3\n4\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nmath.log1p = math.log1p || function(x) {\n  return math.log(1 + x);\n};\n\n\n1\n2\n3\n\n\n（3）math.log10()\n\nmath.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 nan。\n\nmath.log10(2)      // 0.3010299956639812\nmath.log10(1)      // 0\nmath.log10(0)      // -infinity\nmath.log10(-2)     // nan\nmath.log10(100000) // 5\n\n\n1\n2\n3\n4\n5\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nmath.log10 = math.log10 || function(x) {\n  return math.log(x) / math.ln10;\n};\n\n\n1\n2\n3\n\n\n（4）math.log2()\n\nmath.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 nan。\n\nmath.log2(3)       // 1.584962500721156\nmath.log2(2)       // 1\nmath.log2(1)       // 0\nmath.log2(0)       // -infinity\nmath.log2(-2)      // nan\nmath.log2(1024)    // 10\nmath.log2(1 << 29) // 29\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\nmath.log2 = math.log2 || function(x) {\n  return math.log(x) / math.ln2;\n};\n\n\n1\n2\n3\n\n\n\n# 双曲函数方法\n\nes6 新增了 6 个双曲函数方法。\n\n * math.sinh(x) 返回x的双曲正弦（hyperbolic sine）\n * math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）\n * math.tanh(x) 返回x的双曲正切（hyperbolic tangent）\n * math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）\n * math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）\n * math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）\n\n\n# 指数运算符\n\nes2016 新增了一个指数运算符（**）。\n\n2 ** 2 // 4\n2 ** 3 // 8\n\n\n1\n2\n\n\n这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。\n\n// 相当于 2 ** (3 ** 2)\n2 ** 3 ** 2\n// 512\n\n\n1\n2\n3\n\n\n上面代码中，首先计算的是第二个指数运算符，而不是第一个。\n\n指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。\n\nlet a = 1.5;\na **= 2;\n// 等同于 a = a * a;\n\nlet b = 4;\nb **= 3;\n// 等同于 b = b * b * b;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，v8 引擎的指数运算符与math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。\n\nmath.pow(99, 99)\n// 3.697296376497263e+197\n\n99 ** 99\n// 3.697296376497268e+197\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，两个运算结果的最后一位有效数字是有差异的。\n\n\n# bigint 数据类型\n\n\n# 简介\n\njavascript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，javascript 是无法精确表示的，这使得 javascript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，javascript 无法表示，会返回infinity。\n\n// 超过 53 个二进制位的数值，无法保持精度\nmath.pow(2, 53) === math.pow(2, 53) + 1 // true\n\n// 超过 2 的 1024 次方的数值，无法表示\nmath.pow(2, 1024) // infinity\n\n\n1\n2\n3\n4\n5\n\n\nes2020 引入了一种新的数据类型 bigint（大整数），来解决这个问题。bigint 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。\n\nconst a = 2172141653n;\nconst b = 15346349309n;\n\n// bigint 可以保持精度\na * b // 33334444555566667777n\n\n// 普通整数无法保持精度\nnumber(a) * number(b) // 33334444555566670000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n为了与 number 类型区别，bigint 类型的数据必须添加后缀n。\n\n1234 // 普通整数\n1234n // bigint\n\n// bigint 的运算\n1n + 2n // 3n\n\n\n1\n2\n3\n4\n5\n\n\nbigint 同样可以使用各种进制表示，都要加上后缀n。\n\n0b1101n // 二进制\n0o777n // 八进制\n0xffn // 十六进制\n\n\n1\n2\n3\n\n\nbigint 与普通整数是两种值，它们之间并不相等。\n\n42n === 42 // false\n\n\n1\n\n\ntypeof运算符对于 bigint 类型的数据返回bigint。\n\ntypeof 123n // 'bigint'\n\n\n1\n\n\nbigint 可以使用负号（-），但是不能使用正号（+），因为会与 asm.js 冲突。\n\n-42n // 正确\n+42n // 报错\n\n\n1\n2\n\n\njavascript 以前不能计算70的阶乘（即70!），因为超出了可以表示的精度。\n\nlet p = 1;\nfor (let i = 1; i <= 70; i++) {\n  p *= i;\n}\nconsole.log(p); // 1.197857166996989e+100\n\n\n1\n2\n3\n4\n5\n\n\n现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就ok。\n\nlet p = 1n;\nfor (let i = 1n; i <= 70n; i++) {\n  p *= i;\n}\nconsole.log(p); // 11978571...00000000n\n\n\n1\n2\n3\n4\n5\n\n\n\n# bigint 对象\n\njavascript 原生提供bigint对象，可以用作构造函数生成 bigint 类型的数值。转换规则基本与number()一致，将其他类型的值转为 bigint。\n\nbigint(123) // 123n\nbigint('123') // 123n\nbigint(false) // 0n\nbigint(true) // 1n\n\n\n1\n2\n3\n4\n\n\nbigint()构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。\n\nnew bigint() // typeerror\nbigint(undefined) //typeerror\nbigint(null) // typeerror\nbigint('123n') // syntaxerror\nbigint('abc') // syntaxerror\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，尤其值得注意字符串123n无法解析成 number 类型，所以会报错。\n\n参数如果是小数，也会报错。\n\nbigint(1.5) // rangeerror\nbigint('1.5') // syntaxerror\n\n\n1\n2\n\n\nbigint 对象继承了 object 对象的两个实例方法。\n\n * bigint.prototype.tostring()\n * bigint.prototype.valueof()\n\n它还继承了 number 对象的一个实例方法。\n\n * bigint.prototype.tolocalestring()\n\n此外，还提供了三个静态方法。\n\n * bigint.asuintn(width, bigint)： 给定的 bigint 转为 0 到 2width - 1 之间对应的值。\n * bigint.asintn(width, bigint)：给定的 bigint 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。\n * bigint.parseint(string[, radix])：近似于number.parseint()，将一个字符串转换成指定进制的 bigint。\n\nconst max = 2n ** (64n - 1n) - 1n;\n\nbigint.asintn(64, max)\n// 9223372036854775807n\nbigint.asintn(64, max + 1n)\n// -9223372036854775808n\nbigint.asuintn(64, max + 1n)\n// 9223372036854775808n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，max是64位带符号的 bigint 所能表示的最大值。如果对这个值加1n，bigint.asintn()将会返回一个负值，因为这时新增的一位将被解释为符号位。而bigint.asuintn()方法由于不存在符号位，所以可以正确返回结果。\n\n如果bigint.asintn()和bigint.asuintn()指定的位数，小于数值本身的位数，那么头部的位将被舍弃。\n\nconst max = 2n ** (64n - 1n) - 1n;\n\nbigint.asintn(32, max) // -1n\nbigint.asuintn(32, max) // 4294967295n\n\n\n1\n2\n3\n4\n\n\n上面代码中，max是一个64位的 bigint，如果转为32位，前面的32位都会被舍弃。\n\n下面是bigint.parseint()的例子。\n\n// number.parseint() 与 bigint.parseint() 的对比\nnumber.parseint('9007199254740993', 10)\n// 9007199254740992\nbigint.parseint('9007199254740993', 10)\n// 9007199254740993n\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，由于有效数字超出了最大限度，number.parseint方法返回的结果是不精确的，而bigint.parseint方法正确返回了对应的 bigint。\n\n对于二进制数组，bigint 新增了两个类型biguint64array和bigint64array，这两种数据类型返回的都是64位 bigint。dataview对象的实例方法dataview.prototype.getbigint64()和dataview.prototype.getbiguint64()，返回的也是 bigint。\n\n\n# 转换规则\n\n可以使用boolean()、number()和string()这三个方法，将 bigint 可以转为布尔值、数值和字符串类型。\n\nboolean(0n) // false\nboolean(1n) // true\nnumber(1n)  // 1\nstring(1n)  // \"1\"\n\n\n1\n2\n3\n4\n\n\n上面代码中，注意最后一个例子，转为字符串时后缀n会消失。\n\n另外，取反运算符（!）也可以将 bigint 转为布尔值。\n\n!0n // true\n!1n // false\n\n\n1\n2\n\n\n\n# 数学运算\n\n数学运算方面，bigint 类型的+、-、*和**这四个二元运算符，与 number 类型的行为一致。除法运算/会舍去小数部分，返回一个整数。\n\n9n / 5n\n// 1n\n\n\n1\n2\n\n\n几乎所有的数值运算符都可以用在 bigint，但是有两个例外。\n\n * 不带符号的右移位运算符>>>\n * 一元的求正运算符+\n\n上面两个运算符用在 bigint 会报错。前者是因为>>>运算符是不带符号的，但是 bigint 总是带有符号的，导致该运算无意义，完全等同于右移运算符>>。后者是因为一元运算符+在 asm.js 里面总是返回 number 类型，为了不破坏 asm.js 就规定+1n会报错。\n\nbigint 不能与普通数值进行混合运算。\n\n1n + 1.3 // 报错\n\n\n1\n\n\n上面代码报错是因为无论返回的是 bigint 或 number，都会导致丢失精度信息。比如(2n**53n + 1n) + 0.5这个表达式，如果返回 bigint 类型，0.5这个小数部分会丢失；如果返回 number 类型，有效精度只能保持 53 位，导致精度下降。\n\n同样的原因，如果一个标准库函数的参数预期是 number 类型，但是得到的是一个 bigint，就会报错。\n\n// 错误的写法\nmath.sqrt(4n) // 报错\n\n// 正确的写法\nmath.sqrt(number(4n)) // 2\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，math.sqrt的参数预期是 number 类型，如果是 bigint 就会报错，必须先用number方法转一下类型，才能进行计算。\n\nasm.js 里面，|0跟在一个数值的后面会返回一个32位整数。根据不能与 number 类型混合运算的规则，bigint 如果与|0进行运算会报错。\n\n1n | 0 // 报错\n\n\n1\n\n\n\n# 其他运算\n\nbigint 对应的布尔值，与 number 类型一致，即0n会转为false，其他值转为true。\n\nif (0n) {\n  console.log('if');\n} else {\n  console.log('else');\n}\n// else\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，0n对应false，所以会进入else子句。\n\n比较运算符（比如>）和相等运算符（==）允许 bigint 与其他类型的值混合计算，因为这样做不会损失精度。\n\n0n < 1 // true\n0n < true // true\n0n == 0 // true\n0n == false // true\n0n === 0 // false\n\n\n1\n2\n3\n4\n5\n\n\nbigint 与字符串混合运算时，会先转为字符串，再进行运算。\n\n'' + 123n // \"123\"\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"函数的扩展",frontmatter:{title:"函数的扩展",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/8ed309d668b20264",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/08.%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html",relativePath:"《ES6 教程》笔记/08.函数的扩展.md",key:"v-d6f05d32",path:"/pages/8ed309d668b20264/",headers:[{level:2,title:"函数参数的默认值",slug:"函数参数的默认值",normalizedTitle:"函数参数的默认值",charIndex:12},{level:3,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:25},{level:3,title:"与解构赋值默认值结合使用",slug:"与解构赋值默认值结合使用",normalizedTitle:"与解构赋值默认值结合使用",charIndex:1543},{level:3,title:"参数默认值的位置",slug:"参数默认值的位置",normalizedTitle:"参数默认值的位置",charIndex:3183},{level:3,title:"函数的 length 属性",slug:"函数的-length-属性",normalizedTitle:"函数的 length 属性",charIndex:3874},{level:3,title:"作用域",slug:"作用域",normalizedTitle:"作用域",charIndex:4439},{level:3,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:6230},{level:2,title:"rest 参数",slug:"rest-参数",normalizedTitle:"rest 参数",charIndex:4243},{level:2,title:"严格模式",slug:"严格模式",normalizedTitle:"严格模式",charIndex:7903},{level:2,title:"name 属性",slug:"name-属性",normalizedTitle:"name 属性",charIndex:9120},{level:2,title:"箭头函数",slug:"箭头函数",normalizedTitle:"箭头函数",charIndex:9824},{level:3,title:"基本用法",slug:"基本用法-2",normalizedTitle:"基本用法",charIndex:25},{level:3,title:"使用注意点",slug:"使用注意点",normalizedTitle:"使用注意点",charIndex:11526},{level:3,title:"不适用场合",slug:"不适用场合",normalizedTitle:"不适用场合",charIndex:14619},{level:3,title:"嵌套的箭头函数",slug:"嵌套的箭头函数",normalizedTitle:"嵌套的箭头函数",charIndex:15264},{level:2,title:"尾调用优化",slug:"尾调用优化",normalizedTitle:"尾调用优化",charIndex:16453},{level:3,title:"什么是尾调用？",slug:"什么是尾调用",normalizedTitle:"什么是尾调用？",charIndex:16463},{level:3,title:"尾调用优化",slug:"尾调用优化-2",normalizedTitle:"尾调用优化",charIndex:16453},{level:3,title:"尾递归",slug:"尾递归",normalizedTitle:"尾递归",charIndex:18046},{level:3,title:"递归函数的改写",slug:"递归函数的改写",normalizedTitle:"递归函数的改写",charIndex:19198},{level:3,title:"严格模式",slug:"严格模式-2",normalizedTitle:"严格模式",charIndex:7903},{level:3,title:"尾递归优化的实现",slug:"尾递归优化的实现",normalizedTitle:"尾递归优化的实现",charIndex:20764},{level:2,title:"函数参数的尾逗号",slug:"函数参数的尾逗号",normalizedTitle:"函数参数的尾逗号",charIndex:22545},{level:2,title:"Function.prototype.toString()",slug:"function-prototype-tostring",normalizedTitle:"function.prototype.tostring()",charIndex:23110},{level:2,title:"catch 命令的参数省略",slug:"catch-命令的参数省略",normalizedTitle:"catch 命令的参数省略",charIndex:23500}],excerpt:'<h1 id="函数的扩展"><a class="header-anchor" href="#函数的扩展">#</a> 函数的扩展</h1>\n<h2 id="函数参数的默认值"><a class="header-anchor" href="#函数参数的默认值">#</a> 函数参数的默认值</h2>\n<h3 id="基本用法"><a class="header-anchor" href="#基本用法">#</a> 基本用法</h3>\n<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\n\x3c!--beforebegin--\x3e<div class="language-javascript line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  y <span class="token operator">=</span> y <span class="token operator">||</span> <span class="token string">\'World\'</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Hello\'</span><span class="token punctuation">)</span> <span class="token comment">// Hello World</span>\n<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Hello\'</span><span class="token punctuation">,</span> <span class="token string">\'China\'</span><span class="token punctuation">)</span> <span class="token comment">// Hello China</span>\n<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Hello\'</span><span class="token punctuation">,</span> <span class="token string">\'\'</span><span class="token punctuation">)</span> <span class="token comment">// Hello World</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"函数参数的默认值 基本用法 与解构赋值默认值结合使用 参数默认值的位置 函数的 length 属性 作用域 应用 rest 参数 严格模式 name 属性 箭头函数 基本用法 使用注意点 不适用场合 嵌套的箭头函数 尾调用优化 什么是尾调用？ 尾调用优化 尾递归 递归函数的改写 严格模式 尾递归优化的实现 函数参数的尾逗号 Function.prototype.toString() catch 命令的参数省略",content:"# 函数的扩展\n\n\n# 函数参数的默认值\n\n\n# 基本用法\n\nES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\n\nfunction log(x, y) {\n  y = y || 'World';\n  console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello World\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。\n\n为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。\n\nif (typeof y === 'undefined') {\n  y = 'World';\n}\n\n\n1\n2\n3\n\n\nES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。\n\nfunction log(x, y = 'World') {\n  console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。\n\nfunction Point(x = 0, y = 0) {\n  this.x = x;\n  this.y = y;\n}\n\nconst p = new Point();\np // { x: 0, y: 0 }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。\n\n参数变量是默认声明的，所以不能用let或const再次声明。\n\nfunction foo(x = 5) {\n  let x = 1; // error\n  const x = 2; // error\n}\n\n\n1\n2\n3\n4\n\n\n上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。\n\n使用参数默认值时，函数不能有同名参数。\n\n// 不报错\nfunction foo(x, x, y) {\n  // ...\n}\n\n// 报错\nfunction foo(x, x, y = 1) {\n  // ...\n}\n// SyntaxError: Duplicate parameter name not allowed in this context\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。\n\nlet x = 99;\nfunction foo(p = x + 1) {\n  console.log(p);\n}\n\nfoo() // 100\n\nx = 100;\nfoo() // 101\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。\n\n\n# 与解构赋值默认值结合使用\n\n参数默认值可以与解构赋值的默认值，结合起来使用。\n\nfunction foo({x, y = 5}) {\n  console.log(x, y);\n}\n\nfoo({}) // undefined 5\nfoo({x: 1}) // 1 5\nfoo({x: 1, y: 2}) // 1 2\nfoo() // TypeError: Cannot read property 'x' of undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。\n\nfunction foo({x, y = 5} = {}) {\n  console.log(x, y);\n}\n\nfoo() // undefined 5\n\n\n1\n2\n3\n4\n5\n\n\n上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。\n\n下面是另一个解构赋值默认值的例子。\n\nfunction fetch(url, { body = '', method = 'GET', headers = {} }) {\n  console.log(method);\n}\n\nfetch('http://example.com', {})\n// \"GET\"\n\nfetch('http://example.com')\n// 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。\n\nfunction fetch(url, { body = '', method = 'GET', headers = {} } = {}) {\n  console.log(method);\n}\n\nfetch('http://example.com')\n// \"GET\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。\n\n作为练习，请问下面两种写法有什么差别？\n\n// 写法一\nfunction m1({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\n// 写法二\nfunction m2({x, y} = { x: 0, y: 0 }) {\n  return [x, y];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。\n\n// 函数没有参数的情况\nm1() // [0, 0]\nm2() // [0, 0]\n\n// x 和 y 都有值的情况\nm1({x: 3, y: 8}) // [3, 8]\nm2({x: 3, y: 8}) // [3, 8]\n\n// x 有值，y 无值的情况\nm1({x: 3}) // [3, 0]\nm2({x: 3}) // [3, undefined]\n\n// x 和 y 都无值的情况\nm1({}) // [0, 0];\nm2({}) // [undefined, undefined]\n\nm1({z: 3}) // [0, 0]\nm2({z: 3}) // [undefined, undefined]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 参数默认值的位置\n\n通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。\n\n// 例一\nfunction f(x = 1, y) {\n  return [x, y];\n}\n\nf() // [1, undefined]\nf(2) // [2, undefined])\nf(, 1) // 报错\nf(undefined, 1) // [1, 1]\n\n// 例二\nfunction f(x, y = 5, z) {\n  return [x, y, z];\n}\n\nf() // [undefined, 5, undefined]\nf(1) // [1, 5, undefined]\nf(1, ,2) // 报错\nf(1, undefined, 2) // [1, 5, 2]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。\n\n如果传入undefined，将触发该参数等于默认值，null则没有这个效果。\n\nfunction foo(x = 5, y = 6) {\n  console.log(x, y);\n}\n\nfoo(undefined, null)\n// 5 null\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。\n\n\n# 函数的 length 属性\n\n指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。\n\n(function (a) {}).length // 1\n(function (a = 5) {}).length // 0\n(function (a, b, c = 5) {}).length // 2\n\n\n1\n2\n3\n\n\n上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。\n\n这是因为**length属性的含义是，该函数预期传入的参数个数**。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。\n\n(function(...args) {}).length // 0\n\n\n1\n\n\n如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。\n\n(function (a = 0, b, c) {}).length // 0\n(function (a, b = 1, c) {}).length // 1\n\n\n1\n2\n\n\n\n# 作用域\n\n一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。\n\nvar x = 1;\n\nfunction f(x, y = x) {\n  console.log(y);\n}\n\nf(2) // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。\n\n再看下面的例子。\n\nlet x = 1;\n\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\n\nf() // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。\n\n如果此时，全局变量x不存在，就会报错。\n\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\n\nf() // ReferenceError: x is not defined\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面这样写，也会报错。\n\nvar x = 1;\n\nfunction foo(x = x) {\n  // ...\n}\n\nfoo() // ReferenceError: x is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。\n\n如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。\n\nlet foo = 'outer';\n\nfunction bar(func = () => foo) {\n  let foo = 'inner';\n  console.log(func());\n}\n\nbar(); // outer\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。\n\n如果写成下面这样，就会报错。\n\nfunction bar(func = () => foo) {\n  let foo = 'inner';\n  console.log(func());\n}\n\nbar() // ReferenceError: foo is not defined\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。\n\n下面是一个更复杂的例子。\n\nvar x = 1;\nfunction foo(x, y = function() { x = 2; }) {\n  var x = 3;\n  y();\n  console.log(x);\n}\n\nfoo() // 3\nx // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。\n\n如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。\n\nvar x = 1;\nfunction foo(x, y = function() { x = 2; }) {\n  x = 3;\n  y();\n  console.log(x);\n}\n\nfoo() // 2\nx // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 应用\n\n利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。\n\nfunction throwIfMissing() {\n  throw new Error('Missing parameter');\n}\n\nfunction foo(mustBeProvided = throwIfMissing()) {\n  return mustBeProvided;\n}\n\nfoo()\n// Error: Missing parameter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。\n\n从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。\n\n另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。\n\nfunction foo(optional = undefined) { ··· }\n\n\n1\n\n\n\n# rest 参数\n\nES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n\nfunction add(...values) { // values是一个数组，该变量将多余的参数放入数组中\n  let sum = 0;\n\n  for (var val of values) {\n    sum += val;\n  }\n\n  return sum;\n}\n\nadd(2, 5, 3) // 10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。\n\n下面是一个 rest 参数代替arguments变量的例子。\n\n// arguments变量的写法\nfunction sortNumbers() {\n  return Array.prototype.slice.call(arguments).sort();\n}\n\n// rest参数的写法\nconst sortNumbers = (...numbers) => numbers.sort();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。\n\narguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。\n\nfunction push(array, ...items) {\n  items.forEach(function(item) {\n    array.push(item);\n    console.log(item);\n  });\n}\n\nvar a = [];\npush(a, 1, 2, 3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。\n\n// 报错\nfunction f(a, ...b, c) {\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\n函数的length属性，不包括 rest 参数。\n\n(function(a) {}).length  // 1\n(function(...a) {}).length  // 0\n(function(a, ...b) {}).length  // 1\n\n\n1\n2\n3\n\n\n\n# 严格模式\n\n从 ES5 开始，函数内部可以设定为严格模式。\n\nfunction doSomething(a, b) {\n  'use strict';\n  // code\n}\n\n\n1\n2\n3\n4\n\n\nES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。\n\n// 报错\nfunction doSomething(a, b = a) {\n  'use strict';\n  // code\n}\n\n// 报错\nconst doSomething = function ({a, b}) {\n  'use strict';\n  // code\n};\n\n// 报错\nconst doSomething = (...a) => {\n  'use strict';\n  // code\n};\n\nconst obj = {\n  // 报错\n  doSomething({a, b}) {\n    'use strict';\n    // code\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。\n\n// 报错\nfunction doSomething(value = 070) {\n  'use strict';\n  return value;\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。\n\n虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。\n\n两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。\n\n'use strict';\n\nfunction doSomething(a, b = a) {\n  // code\n}\n\n\n1\n2\n3\n4\n5\n\n\n第二种是把函数包在一个无参数的立即执行函数里面。\n\nconst doSomething = (function () {\n  'use strict';\n  return function(value = 42) {\n    return value;\n  };\n}());\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# name 属性\n\n函数的name属性，返回该函数的函数名。\n\nfunction foo() {}\nfoo.name // \"foo\"\n\n\n1\n2\n\n\n这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。\n\n需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。\n\nvar f = function () {};\n\n// ES5\nf.name // \"\"\n\n// ES6\nf.name // \"f\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量f等于一个匿名函数，ES5 和 ES6 的name属性返回的值不一样。\n\n如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。\n\nconst bar = function baz() {};\n\n// ES5\nbar.name // \"baz\"\n\n// ES6\nbar.name // \"baz\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nFunction构造函数返回的函数实例，name属性的值为anonymous。\n\n(new Function).name // \"anonymous\"\n\n\n1\n\n\nbind返回的函数，name属性值会加上bound前缀。\n\nfunction foo() {};\nfoo.bind({}).name // \"bound foo\"\n\n(function(){}).bind({}).name // \"bound \"\n\n\n1\n2\n3\n4\n\n\n\n# 箭头函数\n\n\n# 基本用法\n\nES6 允许使用“箭头”（=>）定义函数。\n\nvar f = v => v;\n\n// 等同于\nvar f = function (v) {\n  return v;\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。\n\nvar f = () => 5;\n// 等同于\nvar f = function () { return 5 };\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n  return num1 + num2;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。\n\nvar sum = (num1, num2) => { return num1 + num2; }\n\n\n1\n\n\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\n\n// 报错\nlet getTempItem = id => { id: id, name: \"Temp\" };\n\n// 不报错\nlet getTempItem = id => ({ id: id, name: \"Temp\" });\n\n\n1\n2\n3\n4\n5\n\n\n下面是一种特殊情况，虽然可以运行，但会得到错误的结果。\n\nlet foo = () => { a: 1 };\nfoo() // undefined\n\n\n1\n2\n\n\n上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。\n\n如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。\n\nlet fn = () => void doesNotReturn();\n\n\n1\n\n\n箭头函数可以与变量解构结合使用。\n\nconst full = ({ first, last }) => first + ' ' + last;\n\n// 等同于\nfunction full(person) {\n  return person.first + ' ' + person.last;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n箭头函数使得表达更加简洁。\n\nconst isEven = n => n % 2 === 0;\nconst square = n => n * n;\n\n\n1\n2\n\n\n上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。\n\n箭头函数的一个用处是简化回调函数。\n\n// 正常函数写法\n[1,2,3].map(function (x) {\n  return x * x;\n});\n\n// 箭头函数写法\n[1,2,3].map(x => x * x);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n另一个例子是\n\n// 正常函数写法\nvar result = values.sort(function (a, b) {\n  return a - b;\n});\n\n// 箭头函数写法\nvar result = values.sort((a, b) => a - b);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n下面是 rest 参数与箭头函数结合的例子。\n\nconst numbers = (...nums) => nums;\n\nnumbers(1, 2, 3, 4, 5)\n// [1,2,3,4,5]\n\nconst headAndTail = (head, ...tail) => [head, tail];\n\nheadAndTail(1, 2, 3, 4, 5)\n// [1,[2,3,4,5]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 使用注意点\n\n箭头函数有几个使用注意点。\n\n（1）函数体内的**this对象**，就是定义时所在的对象，而不是使用时所在的对象。\n\n（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n\n（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n\n（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。\n\n上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。\n\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\nvar id = 21;\n\nfoo.call({ id: 42 });\n// id: 42\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。\n\n箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。\n\nfunction Timer() {\n  this.s1 = 0;\n  this.s2 = 0;\n  // 箭头函数\n  setInterval(() => this.s1++, 1000);\n  // 普通函数\n  setInterval(function () {\n    this.s2++;\n  }, 1000);\n}\n\nvar timer = new Timer();\n\nsetTimeout(() => console.log('s1: ', timer.s1), 3100);\nsetTimeout(() => console.log('s2: ', timer.s2), 3100);\n// s1: 3\n// s2: 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。\n\n箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。\n\nvar handler = {\n  id: '123456',\n\n  init: function() { // 注意这里不是使用箭头函数，如这里使用箭头函数将时this指向全局对象\n    document.addEventListener('click',\n      event => this.doSomething(event.type), false);\n  },\n\n  doSomething: function(type) {\n    console.log('Handling ' + type  + ' for ' + this.id);\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。\n\nthis指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。\n\n所以，箭头函数转成 ES5 的代码如下。\n\n// ES6\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\n// ES5\nfunction foo() {\n  var _this = this;\n\n  setTimeout(function () {\n    console.log('id:', _this.id);\n  }, 100);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。\n\n请问下面的代码之中有几个this？\n\nfunction foo() {\n  return () => {\n    return () => {\n      return () => {\n        console.log('id:', this.id);\n      };\n    };\n  };\n}\n\nvar f = foo.call({id: 1});\n\nvar t1 = f.call({id: 2})()(); // id: 1\nvar t2 = f().call({id: 3})(); // id: 1\nvar t3 = f()().call({id: 4}); // id: 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。\n\n除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。\n\nfunction foo() {\n  setTimeout(() => {\n    console.log('args:', arguments);\n  }, 100);\n}\n\nfoo(2, 4, 6, 8)\n// args: [2, 4, 6, 8]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。\n\n另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。\n\n(function() {\n  return [\n    (() => this.x).bind({ x: 'inner' })()\n  ];\n}).call({ x: 'outer' });\n// ['outer']\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。\n\n长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。\n\n\n# 不适用场合\n\n由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。\n\n第一个场合是定义对象的方法，且该方法内部包括this。\n\nconst cat = {\n  lives: 9,\n  jumps: () => {\n    this.lives--;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。\n\n第二个场合是需要动态this的时候，也不应使用箭头函数。\n\nvar button = document.getElementById('press');\nbutton.addEventListener('click', () => {\n  this.classList.toggle('on');\n});\n\n\n1\n2\n3\n4\n\n\n上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。\n\n另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。\n\n\n# 嵌套的箭头函数\n\n箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。\n\nfunction insert(value) {\n  return {into: function (array) {\n    return {after: function (afterValue) {\n      array.splice(array.indexOf(afterValue) + 1, 0, value);\n      return array;\n    }};\n  }};\n}\n\ninsert(2).into([1, 3]).after(1); //[1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面这个函数，可以使用箭头函数改写。\n\nlet insert = (value) => ({into: (array) => ({after: (afterValue) => {\n  array.splice(array.indexOf(afterValue) + 1, 0, value);\n  return array;\n}})});\n\ninsert(2).into([1, 3]).after(1); //[1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。\n\nconst pipeline = (...funcs) =>\n  val => funcs.reduce((a, b) => b(a), val);\n\nconst plus1 = a => a + 1;\nconst mult2 = a => a * 2;\nconst addThenMult = pipeline(plus1, mult2);\n\naddThenMult(5)\n// 12\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果觉得上面的写法可读性比较差，也可以采用下面的写法。\n\nconst plus1 = a => a + 1;\nconst mult2 = a => a * 2;\n\nmult2(plus1(5))\n// 12\n\n\n1\n2\n3\n4\n5\n\n\n箭头函数还有一个功能，就是可以很方便地改写 λ 演算。\n\n// λ演算的写法\nfix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))\n\n// ES6的写法\nvar fix = f => (x => f(v => x(x)(v)))\n               (x => f(v => x(x)(v)));\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。\n\n\n# 尾调用优化\n\n\n# 什么是尾调用？\n\n尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\n\nfunction f(x){\n  return g(x);\n}\n\n\n1\n2\n3\n\n\n上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。\n\n以下三种情况，都不属于尾调用。\n\n// 情况一\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 情况二\nfunction f(x){\n  return g(x) + 1;\n}\n\n// 情况三\nfunction f(x){\n  g(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。\n\nfunction f(x){\n  g(x);\n  return undefined;\n}\n\n\n1\n2\n3\n4\n\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可。\n\nfunction f(x) {\n  if (x > 0) {\n    return m(x)\n  }\n  return n(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。\n\n\n# 尾调用优化\n\n尾调用之所以与其他调用不同，就在于它的特殊的调用位置。\n\n我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。\n\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n\nfunction f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n\n// 等同于\ng(3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。\n\n这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。\n\n注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。\n\nfunction addOne(a){\n  var one = 1;\n  function inner(b){\n    return b + one;\n  }\n  return inner(a);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。\n\n注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。\n\n\n# 尾递归\n\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n\nfunction factorial(n) {\n  if (n === 1) return 1;\n  return n * factorial(n - 1);\n}\n\nfactorial(5) // 120\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。\n\n如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\n\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5, 1) // 120\n\n\n1\n2\n3\n4\n5\n6\n\n\n还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。\n\n非尾递归的 Fibonacci 数列实现如下。\n\nfunction Fibonacci (n) {\n  if ( n <= 1 ) {return 1};\n\n  return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nFibonacci(10) // 89\nFibonacci(100) // 超时\nFibonacci(500) // 超时\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n尾递归优化过的 Fibonacci 数列实现如下。\n\nfunction Fibonacci2 (n , ac1 = 1 , ac2 = 1) {\n  if( n <= 1 ) {return ac2};\n\n  return Fibonacci2 (n - 1, ac2, ac1 + ac2);\n}\n\nFibonacci2(100) // 573147844013817200000\nFibonacci2(1000) // 7.0330367711422765e+208\nFibonacci2(10000) // Infinity\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。\n\n\n# 递归函数的改写\n\n尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？\n\n两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。\n\nfunction tailFactorial(n, total) {\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n}\n\nfunction factorial(n) {\n  return tailFactorial(n, 1);\n}\n\nfactorial(5) // 120\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。\n\n函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。\n\nfunction currying(fn, n) {\n  return function (m) {\n    return fn.call(this, m, n);\n  };\n}\n\nfunction tailFactorial(n, total) {\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n}\n\nconst factorial = currying(tailFactorial, 1);\n\nfactorial(5) // 120\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码通过柯里化，将尾递归函数tailFactorial变为只接受一个参数的factorial。\n\n第二种方法就简单多了，就是采用 ES6 的函数默认值。\n\nfunction factorial(n, total = 1) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5) // 120\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，参数total有默认值1，所以调用时不用提供这个值。\n\n总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。\n\n\n# 严格模式\n\nES6 的尾调用优化只在严格模式下开启，正常模式是无效的。\n\n这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。\n\n * func.arguments：返回调用时函数的参数。\n * func.caller：返回调用当前函数的那个函数。\n\n尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。\n\nfunction restricted() {\n  'use strict';\n  restricted.caller;    // 报错\n  restricted.arguments; // 报错\n}\nrestricted();\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 尾递归优化的实现\n\n尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。\n\n它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。\n\n下面是一个正常的递归函数。\n\nfunction sum(x, y) {\n  if (y > 0) {\n    return sum(x + 1, y - 1);\n  } else {\n    return x;\n  }\n}\n\nsum(1, 100000)\n// Uncaught RangeError: Maximum call stack size exceeded(…)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。\n\n蹦床函数（trampoline）可以将递归执行转为循环执行。\n\nfunction trampoline(f) {\n  while (f && f instanceof Function) {\n    f = f();\n  }\n  return f;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。\n\n然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。\n\nfunction sum(x, y) {\n  if (y > 0) {\n    return sum.bind(null, x + 1, y - 1);\n  } else {\n    return x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，sum函数的每次执行，都会返回自身的另一个版本。\n\n现在，使用蹦床函数执行sum，就不会发生调用栈溢出。\n\ntrampoline(sum(1, 100000))\n// 100001\n\n\n1\n2\n\n\n蹦床函数并不是真正的尾递归优化，下面的实现才是。\n\nfunction tco(f) {\n  var value;\n  var active = false;\n  var accumulated = [];\n\n  return function accumulator() {\n    accumulated.push(arguments);\n    if (!active) {\n      active = true;\n      while (accumulated.length) {\n        value = f.apply(this, accumulated.shift());\n      }\n      active = false;\n      return value;\n    }\n  };\n}\n\nvar sum = tco(function(x, y) {\n  if (y > 0) {\n    return sum(x + 1, y - 1)\n  }\n  else {\n    return x\n  }\n});\n\nsum(1, 100000)\n// 100001\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。\n\n\n# 函数参数的尾逗号\n\nES2017 允许函数的最后一个参数有尾逗号（trailing comma）。\n\n此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。\n\nfunction clownsEverywhere(\n  param1,\n  param2\n) { /* ... */ }\n\nclownsEverywhere(\n  'foo',\n  'bar'\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，如果在param2或bar后面加一个逗号，就会报错。\n\n如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数clownsEverywhere添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。\n\nfunction clownsEverywhere(\n  param1,\n  param2,\n) { /* ... */ }\n\nclownsEverywhere(\n  'foo',\n  'bar',\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。\n\n\n# Function.prototype.toString()\n\nES2019 对函数实例的toString()方法做出了修改。\n\ntoString()方法返回函数代码本身，以前会省略注释和空格。\n\nfunction /* foo comment */ foo () {}\n\nfoo.toString()\n// function foo() {}\n\n\n1\n2\n3\n4\n\n\n上面代码中，函数foo的原始代码包含注释，函数名foo和圆括号之间有空格，但是toString()方法都把它们省略了。\n\n修改后的toString()方法，明确要求返回一模一样的原始代码。\n\nfunction /* foo comment */ foo () {}\n\nfoo.toString()\n// \"function /* foo comment */ foo () {}\"\n\n\n1\n2\n3\n4\n\n\n\n# catch 命令的参数省略\n\nJavaScript 语言的try...catch结构，以前明确要求catch命令后面必须跟参数，接受try代码块抛出的错误对象。\n\ntry {\n  // ...\n} catch (err) {\n  // 处理错误\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，catch命令后面带有参数err。\n\n很多时候，catch代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。ES2019 做出了改变，允许catch语句省略参数。\n\ntry {\n  // ...\n} catch {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n",normalizedContent:"# 函数的扩展\n\n\n# 函数参数的默认值\n\n\n# 基本用法\n\nes6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\n\nfunction log(x, y) {\n  y = y || 'world';\n  console.log(x, y);\n}\n\nlog('hello') // hello world\nlog('hello', 'china') // hello china\nlog('hello', '') // hello world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为world。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。\n\n为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。\n\nif (typeof y === 'undefined') {\n  y = 'world';\n}\n\n\n1\n2\n3\n\n\nes6 允许为函数的参数设置默认值，即直接写在参数定义的后面。\n\nfunction log(x, y = 'world') {\n  console.log(x, y);\n}\n\nlog('hello') // hello world\nlog('hello', 'china') // hello china\nlog('hello', '') // hello\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看到，es6 的写法比 es5 简洁许多，而且非常自然。下面是另一个例子。\n\nfunction point(x = 0, y = 0) {\n  this.x = x;\n  this.y = y;\n}\n\nconst p = new point();\np // { x: 0, y: 0 }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n除了简洁，es6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。\n\n参数变量是默认声明的，所以不能用let或const再次声明。\n\nfunction foo(x = 5) {\n  let x = 1; // error\n  const x = 2; // error\n}\n\n\n1\n2\n3\n4\n\n\n上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。\n\n使用参数默认值时，函数不能有同名参数。\n\n// 不报错\nfunction foo(x, x, y) {\n  // ...\n}\n\n// 报错\nfunction foo(x, x, y = 1) {\n  // ...\n}\n// syntaxerror: duplicate parameter name not allowed in this context\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。\n\nlet x = 99;\nfunction foo(p = x + 1) {\n  console.log(p);\n}\n\nfoo() // 100\n\nx = 100;\nfoo() // 101\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。\n\n\n# 与解构赋值默认值结合使用\n\n参数默认值可以与解构赋值的默认值，结合起来使用。\n\nfunction foo({x, y = 5}) {\n  console.log(x, y);\n}\n\nfoo({}) // undefined 5\nfoo({x: 1}) // 1 5\nfoo({x: 1, y: 2}) // 1 2\nfoo() // typeerror: cannot read property 'x' of undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。\n\nfunction foo({x, y = 5} = {}) {\n  console.log(x, y);\n}\n\nfoo() // undefined 5\n\n\n1\n2\n3\n4\n5\n\n\n上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。\n\n下面是另一个解构赋值默认值的例子。\n\nfunction fetch(url, { body = '', method = 'get', headers = {} }) {\n  console.log(method);\n}\n\nfetch('http://example.com', {})\n// \"get\"\n\nfetch('http://example.com')\n// 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。\n\nfunction fetch(url, { body = '', method = 'get', headers = {} } = {}) {\n  console.log(method);\n}\n\nfetch('http://example.com')\n// \"get\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值get。\n\n作为练习，请问下面两种写法有什么差别？\n\n// 写法一\nfunction m1({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\n// 写法二\nfunction m2({x, y} = { x: 0, y: 0 }) {\n  return [x, y];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。\n\n// 函数没有参数的情况\nm1() // [0, 0]\nm2() // [0, 0]\n\n// x 和 y 都有值的情况\nm1({x: 3, y: 8}) // [3, 8]\nm2({x: 3, y: 8}) // [3, 8]\n\n// x 有值，y 无值的情况\nm1({x: 3}) // [3, 0]\nm2({x: 3}) // [3, undefined]\n\n// x 和 y 都无值的情况\nm1({}) // [0, 0];\nm2({}) // [undefined, undefined]\n\nm1({z: 3}) // [0, 0]\nm2({z: 3}) // [undefined, undefined]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 参数默认值的位置\n\n通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。\n\n// 例一\nfunction f(x = 1, y) {\n  return [x, y];\n}\n\nf() // [1, undefined]\nf(2) // [2, undefined])\nf(, 1) // 报错\nf(undefined, 1) // [1, 1]\n\n// 例二\nfunction f(x, y = 5, z) {\n  return [x, y, z];\n}\n\nf() // [undefined, 5, undefined]\nf(1) // [1, 5, undefined]\nf(1, ,2) // 报错\nf(1, undefined, 2) // [1, 5, 2]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。\n\n如果传入undefined，将触发该参数等于默认值，null则没有这个效果。\n\nfunction foo(x = 5, y = 6) {\n  console.log(x, y);\n}\n\nfoo(undefined, null)\n// 5 null\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。\n\n\n# 函数的 length 属性\n\n指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。\n\n(function (a) {}).length // 1\n(function (a = 5) {}).length // 0\n(function (a, b, c = 5) {}).length // 2\n\n\n1\n2\n3\n\n\n上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。\n\n这是因为**length属性的含义是，该函数预期传入的参数个数**。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。\n\n(function(...args) {}).length // 0\n\n\n1\n\n\n如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。\n\n(function (a = 0, b, c) {}).length // 0\n(function (a, b = 1, c) {}).length // 1\n\n\n1\n2\n\n\n\n# 作用域\n\n一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。\n\nvar x = 1;\n\nfunction f(x, y = x) {\n  console.log(y);\n}\n\nf(2) // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。\n\n再看下面的例子。\n\nlet x = 1;\n\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\n\nf() // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。\n\n如果此时，全局变量x不存在，就会报错。\n\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\n\nf() // referenceerror: x is not defined\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面这样写，也会报错。\n\nvar x = 1;\n\nfunction foo(x = x) {\n  // ...\n}\n\nfoo() // referenceerror: x is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。\n\n如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。\n\nlet foo = 'outer';\n\nfunction bar(func = () => foo) {\n  let foo = 'inner';\n  console.log(func());\n}\n\nbar(); // outer\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。\n\n如果写成下面这样，就会报错。\n\nfunction bar(func = () => foo) {\n  let foo = 'inner';\n  console.log(func());\n}\n\nbar() // referenceerror: foo is not defined\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。\n\n下面是一个更复杂的例子。\n\nvar x = 1;\nfunction foo(x, y = function() { x = 2; }) {\n  var x = 3;\n  y();\n  console.log(x);\n}\n\nfoo() // 3\nx // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。\n\n如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。\n\nvar x = 1;\nfunction foo(x, y = function() { x = 2; }) {\n  x = 3;\n  y();\n  console.log(x);\n}\n\nfoo() // 2\nx // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 应用\n\n利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。\n\nfunction throwifmissing() {\n  throw new error('missing parameter');\n}\n\nfunction foo(mustbeprovided = throwifmissing()) {\n  return mustbeprovided;\n}\n\nfoo()\n// error: missing parameter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwifmissing函数，从而抛出一个错误。\n\n从上面代码还可以看到，参数mustbeprovided的默认值等于throwifmissing函数的运行结果（注意函数名throwifmissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。\n\n另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。\n\nfunction foo(optional = undefined) { ··· }\n\n\n1\n\n\n\n# rest 参数\n\nes6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n\nfunction add(...values) { // values是一个数组，该变量将多余的参数放入数组中\n  let sum = 0;\n\n  for (var val of values) {\n    sum += val;\n  }\n\n  return sum;\n}\n\nadd(2, 5, 3) // 10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。\n\n下面是一个 rest 参数代替arguments变量的例子。\n\n// arguments变量的写法\nfunction sortnumbers() {\n  return array.prototype.slice.call(arguments).sort();\n}\n\n// rest参数的写法\nconst sortnumbers = (...numbers) => numbers.sort();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。\n\narguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。\n\nfunction push(array, ...items) {\n  items.foreach(function(item) {\n    array.push(item);\n    console.log(item);\n  });\n}\n\nvar a = [];\npush(a, 1, 2, 3)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。\n\n// 报错\nfunction f(a, ...b, c) {\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\n函数的length属性，不包括 rest 参数。\n\n(function(a) {}).length  // 1\n(function(...a) {}).length  // 0\n(function(a, ...b) {}).length  // 1\n\n\n1\n2\n3\n\n\n\n# 严格模式\n\n从 es5 开始，函数内部可以设定为严格模式。\n\nfunction dosomething(a, b) {\n  'use strict';\n  // code\n}\n\n\n1\n2\n3\n4\n\n\nes2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。\n\n// 报错\nfunction dosomething(a, b = a) {\n  'use strict';\n  // code\n}\n\n// 报错\nconst dosomething = function ({a, b}) {\n  'use strict';\n  // code\n};\n\n// 报错\nconst dosomething = (...a) => {\n  'use strict';\n  // code\n};\n\nconst obj = {\n  // 报错\n  dosomething({a, b}) {\n    'use strict';\n    // code\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。\n\n// 报错\nfunction dosomething(value = 070) {\n  'use strict';\n  return value;\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，javascript 引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。\n\n虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。\n\n两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。\n\n'use strict';\n\nfunction dosomething(a, b = a) {\n  // code\n}\n\n\n1\n2\n3\n4\n5\n\n\n第二种是把函数包在一个无参数的立即执行函数里面。\n\nconst dosomething = (function () {\n  'use strict';\n  return function(value = 42) {\n    return value;\n  };\n}());\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# name 属性\n\n函数的name属性，返回该函数的函数名。\n\nfunction foo() {}\nfoo.name // \"foo\"\n\n\n1\n2\n\n\n这个属性早就被浏览器广泛支持，但是直到 es6，才将其写入了标准。\n\n需要注意的是，es6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，es5 的name属性，会返回空字符串，而 es6 的name属性会返回实际的函数名。\n\nvar f = function () {};\n\n// es5\nf.name // \"\"\n\n// es6\nf.name // \"f\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量f等于一个匿名函数，es5 和 es6 的name属性返回的值不一样。\n\n如果将一个具名函数赋值给一个变量，则 es5 和 es6 的name属性都返回这个具名函数原本的名字。\n\nconst bar = function baz() {};\n\n// es5\nbar.name // \"baz\"\n\n// es6\nbar.name // \"baz\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nfunction构造函数返回的函数实例，name属性的值为anonymous。\n\n(new function).name // \"anonymous\"\n\n\n1\n\n\nbind返回的函数，name属性值会加上bound前缀。\n\nfunction foo() {};\nfoo.bind({}).name // \"bound foo\"\n\n(function(){}).bind({}).name // \"bound \"\n\n\n1\n2\n3\n4\n\n\n\n# 箭头函数\n\n\n# 基本用法\n\nes6 允许使用“箭头”（=>）定义函数。\n\nvar f = v => v;\n\n// 等同于\nvar f = function (v) {\n  return v;\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。\n\nvar f = () => 5;\n// 等同于\nvar f = function () { return 5 };\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n  return num1 + num2;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。\n\nvar sum = (num1, num2) => { return num1 + num2; }\n\n\n1\n\n\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\n\n// 报错\nlet gettempitem = id => { id: id, name: \"temp\" };\n\n// 不报错\nlet gettempitem = id => ({ id: id, name: \"temp\" });\n\n\n1\n2\n3\n4\n5\n\n\n下面是一种特殊情况，虽然可以运行，但会得到错误的结果。\n\nlet foo = () => { a: 1 };\nfoo() // undefined\n\n\n1\n2\n\n\n上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。\n\n如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。\n\nlet fn = () => void doesnotreturn();\n\n\n1\n\n\n箭头函数可以与变量解构结合使用。\n\nconst full = ({ first, last }) => first + ' ' + last;\n\n// 等同于\nfunction full(person) {\n  return person.first + ' ' + person.last;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n箭头函数使得表达更加简洁。\n\nconst iseven = n => n % 2 === 0;\nconst square = n => n * n;\n\n\n1\n2\n\n\n上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。\n\n箭头函数的一个用处是简化回调函数。\n\n// 正常函数写法\n[1,2,3].map(function (x) {\n  return x * x;\n});\n\n// 箭头函数写法\n[1,2,3].map(x => x * x);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n另一个例子是\n\n// 正常函数写法\nvar result = values.sort(function (a, b) {\n  return a - b;\n});\n\n// 箭头函数写法\nvar result = values.sort((a, b) => a - b);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n下面是 rest 参数与箭头函数结合的例子。\n\nconst numbers = (...nums) => nums;\n\nnumbers(1, 2, 3, 4, 5)\n// [1,2,3,4,5]\n\nconst headandtail = (head, ...tail) => [head, tail];\n\nheadandtail(1, 2, 3, 4, 5)\n// [1,[2,3,4,5]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 使用注意点\n\n箭头函数有几个使用注意点。\n\n（1）函数体内的**this对象**，就是定义时所在的对象，而不是使用时所在的对象。\n\n（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n\n（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n\n（4）不可以使用yield命令，因此箭头函数不能用作 generator 函数。\n\n上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。\n\nfunction foo() {\n  settimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\nvar id = 21;\n\nfoo.call({ id: 42 });\n// id: 42\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，settimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。\n\n箭头函数可以让settimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。\n\nfunction timer() {\n  this.s1 = 0;\n  this.s2 = 0;\n  // 箭头函数\n  setinterval(() => this.s1++, 1000);\n  // 普通函数\n  setinterval(function () {\n    this.s2++;\n  }, 1000);\n}\n\nvar timer = new timer();\n\nsettimeout(() => console.log('s1: ', timer.s1), 3100);\nsettimeout(() => console.log('s2: ', timer.s2), 3100);\n// s1: 3\n// s2: 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。\n\n箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，dom 事件的回调函数封装在一个对象里面。\n\nvar handler = {\n  id: '123456',\n\n  init: function() { // 注意这里不是使用箭头函数，如这里使用箭头函数将时this指向全局对象\n    document.addeventlistener('click',\n      event => this.dosomething(event.type), false);\n  },\n\n  dosomething: function(type) {\n    console.log('handling ' + type  + ' for ' + this.id);\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.dosomething这一行会报错，因为此时this指向document对象。\n\nthis指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。\n\n所以，箭头函数转成 es5 的代码如下。\n\n// es6\nfunction foo() {\n  settimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\n// es5\nfunction foo() {\n  var _this = this;\n\n  settimeout(function () {\n    console.log('id:', _this.id);\n  }, 100);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，转换后的 es5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。\n\n请问下面的代码之中有几个this？\n\nfunction foo() {\n  return () => {\n    return () => {\n      return () => {\n        console.log('id:', this.id);\n      };\n    };\n  };\n}\n\nvar f = foo.call({id: 1});\n\nvar t1 = f.call({id: 2})()(); // id: 1\nvar t2 = f().call({id: 3})(); // id: 1\nvar t3 = f()().call({id: 4}); // id: 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。\n\n除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。\n\nfunction foo() {\n  settimeout(() => {\n    console.log('args:', arguments);\n  }, 100);\n}\n\nfoo(2, 4, 6, 8)\n// args: [2, 4, 6, 8]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。\n\n另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。\n\n(function() {\n  return [\n    (() => this.x).bind({ x: 'inner' })()\n  ];\n}).call({ x: 'outer' });\n// ['outer']\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。\n\n长期以来，javascript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。\n\n\n# 不适用场合\n\n由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。\n\n第一个场合是定义对象的方法，且该方法内部包括this。\n\nconst cat = {\n  lives: 9,\n  jumps: () => {\n    this.lives--;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。\n\n第二个场合是需要动态this的时候，也不应使用箭头函数。\n\nvar button = document.getelementbyid('press');\nbutton.addeventlistener('click', () => {\n  this.classlist.toggle('on');\n});\n\n\n1\n2\n3\n4\n\n\n上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。\n\n另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。\n\n\n# 嵌套的箭头函数\n\n箭头函数内部，还可以再使用箭头函数。下面是一个 es5 语法的多重嵌套函数。\n\nfunction insert(value) {\n  return {into: function (array) {\n    return {after: function (aftervalue) {\n      array.splice(array.indexof(aftervalue) + 1, 0, value);\n      return array;\n    }};\n  }};\n}\n\ninsert(2).into([1, 3]).after(1); //[1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面这个函数，可以使用箭头函数改写。\n\nlet insert = (value) => ({into: (array) => ({after: (aftervalue) => {\n  array.splice(array.indexof(aftervalue) + 1, 0, value);\n  return array;\n}})});\n\ninsert(2).into([1, 3]).after(1); //[1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。\n\nconst pipeline = (...funcs) =>\n  val => funcs.reduce((a, b) => b(a), val);\n\nconst plus1 = a => a + 1;\nconst mult2 = a => a * 2;\nconst addthenmult = pipeline(plus1, mult2);\n\naddthenmult(5)\n// 12\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果觉得上面的写法可读性比较差，也可以采用下面的写法。\n\nconst plus1 = a => a + 1;\nconst mult2 = a => a * 2;\n\nmult2(plus1(5))\n// 12\n\n\n1\n2\n3\n4\n5\n\n\n箭头函数还有一个功能，就是可以很方便地改写 λ 演算。\n\n// λ演算的写法\nfix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))\n\n// es6的写法\nvar fix = f => (x => f(v => x(x)(v)))\n               (x => f(v => x(x)(v)));\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 es6 作为替代工具，探索计算机科学。\n\n\n# 尾调用优化\n\n\n# 什么是尾调用？\n\n尾调用（tail call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\n\nfunction f(x){\n  return g(x);\n}\n\n\n1\n2\n3\n\n\n上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。\n\n以下三种情况，都不属于尾调用。\n\n// 情况一\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 情况二\nfunction f(x){\n  return g(x) + 1;\n}\n\n// 情况三\nfunction f(x){\n  g(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。\n\nfunction f(x){\n  g(x);\n  return undefined;\n}\n\n\n1\n2\n3\n4\n\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可。\n\nfunction f(x) {\n  if (x > 0) {\n    return m(x)\n  }\n  return n(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。\n\n\n# 尾调用优化\n\n尾调用之所以与其他调用不同，就在于它的特殊的调用位置。\n\n我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数a的内部调用函数b，那么在a的调用帧上方，还会形成一个b的调用帧。等到b运行结束，将结果返回到a，b的调用帧才会消失。如果函数b内部还调用函数c，那就还有一个c的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。\n\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n\nfunction f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n\n// 等同于\ng(3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。\n\n这就叫做“尾调用优化”（tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。\n\n注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。\n\nfunction addone(a){\n  var one = 1;\n  function inner(b){\n    return b + one;\n  }\n  return inner(a);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addone的内部变量one。\n\n注意，目前只有 safari 浏览器支持尾调用优化，chrome 和 firefox 都不支持。\n\n\n# 尾递归\n\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n\nfunction factorial(n) {\n  if (n === 1) return 1;\n  return n * factorial(n - 1);\n}\n\nfactorial(5) // 120\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 o(n) 。\n\n如果改写成尾递归，只保留一个调用记录，复杂度 o(1) 。\n\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5, 1) // 120\n\n\n1\n2\n3\n4\n5\n6\n\n\n还有一个比较著名的例子，就是计算 fibonacci 数列，也能充分说明尾递归优化的重要性。\n\n非尾递归的 fibonacci 数列实现如下。\n\nfunction fibonacci (n) {\n  if ( n <= 1 ) {return 1};\n\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nfibonacci(10) // 89\nfibonacci(100) // 超时\nfibonacci(500) // 超时\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n尾递归优化过的 fibonacci 数列实现如下。\n\nfunction fibonacci2 (n , ac1 = 1 , ac2 = 1) {\n  if( n <= 1 ) {return ac2};\n\n  return fibonacci2 (n - 1, ac2, ac1 + ac2);\n}\n\nfibonacci2(100) // 573147844013817200000\nfibonacci2(1000) // 7.0330367711422765e+208\nfibonacci2(10000) // infinity\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。es6 亦是如此，第一次明确规定，所有 ecmascript 的实现，都必须部署“尾调用优化”。这就是说，es6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。\n\n\n# 递归函数的改写\n\n尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？\n\n两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。\n\nfunction tailfactorial(n, total) {\n  if (n === 1) return total;\n  return tailfactorial(n - 1, n * total);\n}\n\nfunction factorial(n) {\n  return tailfactorial(n, 1);\n}\n\nfactorial(5) // 120\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailfactorial，看起来就正常多了。\n\n函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。\n\nfunction currying(fn, n) {\n  return function (m) {\n    return fn.call(this, m, n);\n  };\n}\n\nfunction tailfactorial(n, total) {\n  if (n === 1) return total;\n  return tailfactorial(n - 1, n * total);\n}\n\nconst factorial = currying(tailfactorial, 1);\n\nfactorial(5) // 120\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码通过柯里化，将尾递归函数tailfactorial变为只接受一个参数的factorial。\n\n第二种方法就简单多了，就是采用 es6 的函数默认值。\n\nfunction factorial(n, total = 1) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5) // 120\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，参数total有默认值1，所以调用时不用提供这个值。\n\n总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 lua，es6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。\n\n\n# 严格模式\n\nes6 的尾调用优化只在严格模式下开启，正常模式是无效的。\n\n这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。\n\n * func.arguments：返回调用时函数的参数。\n * func.caller：返回调用当前函数的那个函数。\n\n尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。\n\nfunction restricted() {\n  'use strict';\n  restricted.caller;    // 报错\n  restricted.arguments; // 报错\n}\nrestricted();\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 尾递归优化的实现\n\n尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。\n\n它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。\n\n下面是一个正常的递归函数。\n\nfunction sum(x, y) {\n  if (y > 0) {\n    return sum(x + 1, y - 1);\n  } else {\n    return x;\n  }\n}\n\nsum(1, 100000)\n// uncaught rangeerror: maximum call stack size exceeded(…)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。\n\n蹦床函数（trampoline）可以将递归执行转为循环执行。\n\nfunction trampoline(f) {\n  while (f && f instanceof function) {\n    f = f();\n  }\n  return f;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。\n\n然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。\n\nfunction sum(x, y) {\n  if (y > 0) {\n    return sum.bind(null, x + 1, y - 1);\n  } else {\n    return x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，sum函数的每次执行，都会返回自身的另一个版本。\n\n现在，使用蹦床函数执行sum，就不会发生调用栈溢出。\n\ntrampoline(sum(1, 100000))\n// 100001\n\n\n1\n2\n\n\n蹦床函数并不是真正的尾递归优化，下面的实现才是。\n\nfunction tco(f) {\n  var value;\n  var active = false;\n  var accumulated = [];\n\n  return function accumulator() {\n    accumulated.push(arguments);\n    if (!active) {\n      active = true;\n      while (accumulated.length) {\n        value = f.apply(this, accumulated.shift());\n      }\n      active = false;\n      return value;\n    }\n  };\n}\n\nvar sum = tco(function(x, y) {\n  if (y > 0) {\n    return sum(x + 1, y - 1)\n  }\n  else {\n    return x\n  }\n});\n\nsum(1, 100000)\n// 100001\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。\n\n\n# 函数参数的尾逗号\n\nes2017 允许函数的最后一个参数有尾逗号（trailing comma）。\n\n此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。\n\nfunction clownseverywhere(\n  param1,\n  param2\n) { /* ... */ }\n\nclownseverywhere(\n  'foo',\n  'bar'\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，如果在param2或bar后面加一个逗号，就会报错。\n\n如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数clownseverywhere添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。\n\nfunction clownseverywhere(\n  param1,\n  param2,\n) { /* ... */ }\n\nclownseverywhere(\n  'foo',\n  'bar',\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。\n\n\n# function.prototype.tostring()\n\nes2019 对函数实例的tostring()方法做出了修改。\n\ntostring()方法返回函数代码本身，以前会省略注释和空格。\n\nfunction /* foo comment */ foo () {}\n\nfoo.tostring()\n// function foo() {}\n\n\n1\n2\n3\n4\n\n\n上面代码中，函数foo的原始代码包含注释，函数名foo和圆括号之间有空格，但是tostring()方法都把它们省略了。\n\n修改后的tostring()方法，明确要求返回一模一样的原始代码。\n\nfunction /* foo comment */ foo () {}\n\nfoo.tostring()\n// \"function /* foo comment */ foo () {}\"\n\n\n1\n2\n3\n4\n\n\n\n# catch 命令的参数省略\n\njavascript 语言的try...catch结构，以前明确要求catch命令后面必须跟参数，接受try代码块抛出的错误对象。\n\ntry {\n  // ...\n} catch (err) {\n  // 处理错误\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，catch命令后面带有参数err。\n\n很多时候，catch代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。es2019 做出了改变，允许catch语句省略参数。\n\ntry {\n  // ...\n} catch {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"数组的扩展",frontmatter:{title:"数组的扩展",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/e34009d60d8bc4b2",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/09.%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95.html",relativePath:"《ES6 教程》笔记/09.数组的扩展.md",key:"v-1f0d05a1",path:"/pages/e34009d60d8bc4b2/",headers:[{level:2,title:"扩展运算符",slug:"扩展运算符",normalizedTitle:"扩展运算符",charIndex:12},{level:3,title:"含义",slug:"含义",normalizedTitle:"含义",charIndex:22},{level:3,title:"替代函数的 apply 方法",slug:"替代函数的-apply-方法",normalizedTitle:"替代函数的 apply 方法",charIndex:1036},{level:3,title:"扩展运算符的应用",slug:"扩展运算符的应用",normalizedTitle:"扩展运算符的应用",charIndex:2002},{level:2,title:"Array.from()",slug:"array-from",normalizedTitle:"array.from()",charIndex:5585},{level:2,title:"Array.of() 总是返回参数值组成的数组",slug:"array-of-总是返回参数值组成的数组",normalizedTitle:"array.of() 总是返回参数值组成的数组",charIndex:8479},{level:2,title:"数组实例的 copyWithin()",slug:"数组实例的-copywithin",normalizedTitle:"数组实例的 copywithin()",charIndex:9153},{level:2,title:"数组实例的 find() 和 findIndex()",slug:"数组实例的-find-和-findindex",normalizedTitle:"数组实例的 find() 和 findindex()",charIndex:10190},{level:2,title:"数组实例的 fill()",slug:"数组实例的-fill",normalizedTitle:"数组实例的 fill()",charIndex:11109},{level:2,title:"数组实例的 entries()，keys() 和 values()",slug:"数组实例的-entries-keys-和-values",normalizedTitle:"数组实例的 entries()，keys() 和 values()",charIndex:11674},{level:2,title:"数组实例的 includes()",slug:"数组实例的-includes",normalizedTitle:"数组实例的 includes()",charIndex:12418},{level:2,title:"数组实例的 flat()，flatMap()",slug:"数组实例的-flat-flatmap",normalizedTitle:"数组实例的 flat()，flatmap()",charIndex:13583},{level:2,title:"数组的空位",slug:"数组的空位",normalizedTitle:"数组的空位",charIndex:14764},{level:2,title:"Array.prototype.sort() 的排序稳定性",slug:"array-prototype-sort-的排序稳定性",normalizedTitle:"array.prototype.sort() 的排序稳定性",charIndex:16595}],excerpt:'<h1 id="数组的扩展"><a class="header-anchor" href="#数组的扩展">#</a> 数组的扩展</h1>\n<h2 id="扩展运算符"><a class="header-anchor" href="#扩展运算符">#</a> 扩展运算符</h2>\n<h3 id="含义"><a class="header-anchor" href="#含义">#</a> 含义</h3>\n<p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p>\n\x3c!--beforebegin--\x3e<div class="language-javascript line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token comment">// 1 2 3</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>\n<span class="token comment">// 1 2 3 4 5</span>\n\n<span class="token punctuation">[</span><span class="token operator">...</span>document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>\n<span class="token comment">// [&lt;div>, &lt;div>, &lt;div>]</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"扩展运算符 含义 替代函数的 apply 方法 扩展运算符的应用 Array.from() Array.of() 总是返回参数值组成的数组 数组实例的 copyWithin() 数组实例的 find() 和 findIndex() 数组实例的 fill() 数组实例的 entries()，keys() 和 values() 数组实例的 includes() 数组实例的 flat()，flatMap() 数组的空位 Array.prototype.sort() 的排序稳定性",content:"# 数组的扩展\n\n\n# 扩展运算符\n\n\n# 含义\n\n扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\n\nconsole.log(...[1, 2, 3])\n// 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5)\n// 1 2 3 4 5\n\n[...document.querySelectorAll('div')]\n// [<div>, <div>, <div>]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n该运算符主要用于函数调用。\n\nfunction push(array, ...items) {\n  array.push(...items);\n}\n\nfunction add(x, y) {\n  return x + y;\n}\n\nconst numbers = [4, 38];\nadd(...numbers) // 42\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，array.push(...items)和add(...numbers)这两行，都是函数的调用，它们都使用了扩展运算符。该运算符将一个数组，变为参数序列。\n\n扩展运算符与正常的函数参数可以结合使用，非常灵活。\n\nfunction f(v, w, x, y, z) { }\nconst args = [0, 1];\nf(-1, ...args, 2, ...[3]);\n\n\n1\n2\n3\n\n\n扩展运算符后面还可以放置表达式。\n\nconst arr = [\n  ...(x > 0 ? ['a'] : []),\n  'b',\n];\n\n\n1\n2\n3\n4\n\n\n如果扩展运算符后面是一个空数组，则不产生任何效果。\n\n[...[], 1]\n// [1]\n\n\n1\n2\n\n\n注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。\n\n(...[1, 2])\n// Uncaught SyntaxError: Unexpected number\n\nconsole.log((...[1, 2]))\n// Uncaught SyntaxError: Unexpected number\n\nconsole.log(...[1, 2])\n// 1 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。\n\n\n# 替代函数的 apply 方法\n\n由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。\n\n// ES5 的写法\nfunction f(x, y, z) {\n  // ...\n}\nvar args = [0, 1, 2];\nf.apply(null, args);\n\n// ES6的写法\nfunction f(x, y, z) {\n  // ...\n}\nlet args = [0, 1, 2];\nf(...args);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。\n\n// ES5 的写法\nMath.max.apply(null, [14, 3, 77])\n\n// ES6 的写法\nMath.max(...[14, 3, 77])\n\n// 等同于\nMath.max(14, 3, 77);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。\n\n另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。\n\n// ES5的 写法\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nArray.prototype.push.apply(arr1, arr2);\n\n// ES6 的写法\nlet arr1 = [0, 1, 2];\nlet arr2 = [3, 4, 5];\narr1.push(...arr2);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。\n\n下面是另外一个例子。\n\n// ES5\nnew (Date.bind.apply(Date, [null, 2015, 1, 1]))\n// ES6\nnew Date(...[2015, 1, 1]);\n\n\n1\n2\n3\n4\n\n\n\n# 扩展运算符的应用\n\n（1）复制数组\n\n数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。\n\nconst a1 = [1, 2];\nconst a2 = a1;\n\na2[0] = 2;\na1 // [2, 2]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。\n\nES5 只能用变通方法来复制数组。\n\nconst a1 = [1, 2];\nconst a2 = a1.concat();\n\na2[0] = 2;\na1 // [1, 2]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。\n\n扩展运算符提供了复制数组的简便写法。\n\nconst a1 = [1, 2];\n// 写法一\nconst a2 = [...a1];\n// 写法二\nconst [...a2] = a1;\n\n\n1\n2\n3\n4\n5\n\n\n上面的两种写法，a2都是a1的克隆。\n\n（2）合并数组\n\n扩展运算符提供了数组合并的新写法。\n\nconst arr1 = ['a', 'b'];\nconst arr2 = ['c'];\nconst arr3 = ['d', 'e'];\n\n// ES5 的合并数组\narr1.concat(arr2, arr3);\n// [ 'a', 'b', 'c', 'd', 'e' ]\n\n// ES6 的合并数组\n[...arr1, ...arr2, ...arr3]\n// [ 'a', 'b', 'c', 'd', 'e' ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n不过，这两种方法都是浅拷贝，使用的时候需要注意。\n\nconst a1 = [{ foo: 1 }];\nconst a2 = [{ bar: 2 }];\n\nconst a3 = a1.concat(a2);\nconst a4 = [...a1, ...a2];\n\na3[0] === a1[0] // true\na4[0] === a1[0] // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。\n\n（3）与解构赋值结合\n\n扩展运算符可以与解构赋值结合起来，用于生成数组。\n\n// ES5\na = list[0], rest = list.slice(1)\n// ES6\n[a, ...rest] = list\n\n\n1\n2\n3\n4\n\n\n下面是另外一些例子。\n\nconst [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest  // [2, 3, 4, 5]\n\nconst [first, ...rest] = [];\nfirst // undefined\nrest  // []\n\nconst [first, ...rest] = [\"foo\"];\nfirst  // \"foo\"\nrest   // []\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。\n\nconst [...butLast, last] = [1, 2, 3, 4, 5];\n// 报错\n\nconst [first, ...middle, last] = [1, 2, 3, 4, 5];\n// 报错\n\n\n1\n2\n3\n4\n5\n\n\n（4）字符串\n\n扩展运算符还可以将字符串转为真正的数组。\n\n[...'hello']\n// [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n\n\n1\n2\n\n\n上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。\n\n'x\\uD83D\\uDE80y'.length // 4\n[...'x\\uD83D\\uDE80y'].length // 3\n\n\n1\n2\n\n\n上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。\n\nfunction length(str) {\n  return [...str].length;\n}\n\nlength('x\\uD83D\\uDE80y') // 3\n\n\n1\n2\n3\n4\n5\n\n\n凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。\n\nlet str = 'x\\uD83D\\uDE80y';\n\nstr.split('').reverse().join('')\n// 'y\\uDE80\\uD83Dx'\n\n[...str].reverse().join('')\n// 'y\\uD83D\\uDE80x'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。\n\n（5）实现了 Iterator 接口的对象\n\n任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。\n\nlet nodeList = document.querySelectorAll('div');\nlet array = [...nodeList];\n\n\n1\n2\n\n\n上面代码中，querySelectorAll方法返回的是一个NodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。\n\nNumber.prototype[Symbol.iterator] = function*() {\n  let i = 0;\n  let num = this.valueOf();\n  while (i < num) {\n    yield i++;\n  }\n}\n\nconsole.log([...5]) // [0, 1, 2, 3, 4]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，先定义了Number对象的遍历器接口，扩展运算符将5自动转成Number实例以后，就会调用这个接口，就会返回自定义的结果。\n\n对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。\n\nlet arrayLike = {\n  '0': 'a',\n  '1': 'b',\n  '2': 'c',\n  length: 3\n};\n\n// TypeError: Cannot spread non-iterable object.\nlet arr = [...arrayLike];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。\n\n（6）Map 和 Set 结构，Generator 函数\n\n扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。\n\nlet map = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nlet arr = [...map.keys()]; // [1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nGenerator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。\n\nconst go = function*(){\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...go()] // [1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。\n\n如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。\n\nconst obj = {a: 1, b: 2};\nlet arr = [...obj]; // TypeError: Cannot spread non-iterable object\n\n\n1\n2\n\n\n\n# Array.from()\n\nArray.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。\n\n下面是一个类似数组的对象，Array.from将它转为真正的数组。\n\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。\n\n// NodeList对象\nlet ps = document.querySelectorAll('p');\nArray.from(ps).filter(p => {\n  return p.textContent.length > 100;\n});\n\n// arguments对象\nfunction foo() {\n  var args = Array.from(arguments);\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用filter方法。\n\n只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。\n\nArray.from('hello')\n// ['h', 'e', 'l', 'l', 'o']\n\nlet namesSet = new Set(['a', 'b'])\nArray.from(namesSet) // ['a', 'b']\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。\n\n如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。\n\nArray.from([1, 2, 3])\n// [1, 2, 3]\n\n\n1\n2\n\n\n值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。\n\n// arguments对象\nfunction foo() {\n  const args = [...arguments];\n}\n\n// NodeList对象\n[...document.querySelectorAll('div')]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。\n\nArray.from({ length: 3 });\n// [ undefined, undefined, undefined ]\n\n\n1\n2\n\n\n上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。\n\n对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。\n\nconst toArray = (() =>\n  Array.from ? Array.from : obj => [].slice.call(obj)\n)();\n\n\n1\n2\n3\n\n\nArray.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\n\nArray.from(arrayLike, x => x * x);\n// 等同于\nArray.from(arrayLike).map(x => x * x);\n\nArray.from([1, 2, 3], (x) => x * x)\n// [1, 4, 9]\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面的例子是取出一组 DOM 节点的文本内容。\n\nlet spans = document.querySelectorAll('span.name');\n\n// map()\nlet names1 = Array.prototype.map.call(spans, s => s.textContent);\n\n// Array.from()\nlet names2 = Array.from(spans, s => s.textContent)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n下面的例子将数组中布尔值为false的成员转为0。\n\nArray.from([1, , 2, , 3], (n) => n || 0)\n// [1, 0, 2, 0, 3]\n\n\n1\n2\n\n\n另一个例子是返回各种数据的类型。\n\nfunction typesOf () {\n  return Array.from(arguments, value => typeof value)\n}\ntypesOf(null, [], NaN)\n// ['object', 'object', 'number']\n\n\n1\n2\n3\n4\n5\n\n\n如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。\n\nArray.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。\n\nArray.from({ length: 2 }, () => 'jack')\n// ['jack', 'jack']\n\n\n1\n2\n\n\n上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。\n\nArray.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\\uFFFF的 Unicode 字符，算作两个字符的 bug。\n\nfunction countSymbols(string) {\n  return Array.from(string).length;\n}\n\n\n1\n2\n3\n\n\n\n# Array.of() 总是返回参数值组成的数组\n\nArray.of方法用于将一组值，转换为数组。\n\nArray.of(3, 11, 8) // [3,11,8]\nArray.of(3) // [3]\nArray.of(3).length // 1\n\n\n1\n2\n3\n\n\n这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。\n\nArray() // []\nArray(3) // [, , ,]\nArray(3, 11, 8) // [3, 11, 8]\n\n\n1\n2\n3\n\n\n上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。\n\nArray.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。\n\nArray.of() // []\nArray.of(undefined) // [undefined]\nArray.of(1) // [1]\nArray.of(1, 2) // [1, 2]\n\n\n1\n2\n3\n4\n\n\nArray.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。\n\nArray.of方法可以用下面的代码模拟实现。\n\nfunction ArrayOf(){\n  return [].slice.call(arguments);\n}\n\n\n1\n2\n3\n\n\n\n# 数组实例的 copyWithin()\n\n数组实例的copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。\n\nArray.prototype.copyWithin(target, start = 0, end = this.length)\n\n\n1\n\n\n它接受三个参数。\n\n * target（必需）：从该位置开始替换数据。如果为负值，表示倒数。\n * start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。\n * end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。\n\n这三个参数都应该是数值，如果不是，会自动转为数值。\n\n[1, 2, 3, 4, 5].copyWithin(0, 3)\n// [4, 5, 3, 4, 5]\n\n\n1\n2\n\n\n上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。\n\n下面是更多例子。\n\n// 将3号位复制到0号位\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4)\n// [4, 2, 3, 4, 5]\n\n// -2相当于3号位，-1相当于4号位\n[1, 2, 3, 4, 5].copyWithin(0, -2, -1)\n// [4, 2, 3, 4, 5]\n\n// 将3号位复制到0号位\n[].copyWithin.call({length: 5, 3: 1}, 0, 3)\n// {0: 1, 3: 1, length: 5}\n\n// 将2号位到数组结束，复制到0号位\nlet i32a = new Int32Array([1, 2, 3, 4, 5]);\ni32a.copyWithin(0, 2);\n// Int32Array [3, 4, 5, 4, 5]\n\n// 对于没有部署 TypedArray 的 copyWithin 方法的平台\n// 需要采用下面的写法\n[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);\n// Int32Array [4, 2, 3, 4, 5]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 数组实例的 find() 和 findIndex()\n\n数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。\n\n[1, 4, -5, 10].find((n) => n < 0)\n// -5\n\n\n1\n2\n\n\n上面代码找出数组中第一个小于 0 的成员。\n\n[1, 5, 10, 15].find(function(value, index, arr) {\n  return value > 9;\n}) // 10\n\n\n1\n2\n3\n\n\n上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。\n\n数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。\n\n[1, 5, 10, 15].findIndex(function(value, index, arr) {\n  return value > 9;\n}) // 2\n\n\n1\n2\n3\n\n\n这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。\n\nfunction f(v){\n  return v > this.age;\n}\nlet person = {name: 'John', age: 20};\n[10, 12, 26, 15].find(f, person);    // 26\n\n\n1\n2\n3\n4\n5\n\n\n上面的代码中，find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。\n\n另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。\n\n[NaN].indexOf(NaN)\n// -1\n\n[NaN].findIndex(y => Object.is(NaN, y))\n// 0\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。\n\n\n# 数组实例的 fill()\n\nfill方法使用给定值，填充一个数组。\n\n['a', 'b', 'c'].fill(7)\n// [7, 7, 7]\n\nnew Array(3).fill(7)\n// [7, 7, 7]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。\n\nfill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。\n\n['a', 'b', 'c'].fill(7, 1, 2)\n// ['a', 7, 'c']\n\n\n1\n2\n\n\n上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。\n\n注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。\n\nlet arr = new Array(3).fill({name: \"Mike\"});\narr[0].name = \"Ben\";\narr\n// [{name: \"Ben\"}, {name: \"Ben\"}, {name: \"Ben\"}]\n\nlet arr = new Array(3).fill([]);\narr[0].push(5);\narr\n// [[5], [5], [5]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 数组实例的 entries()，keys() 和 values()\n\nES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。\n\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。\n\nlet letter = ['a', 'b', 'c'];\nlet entries = letter.entries();\nconsole.log(entries.next().value); // [0, 'a']\nconsole.log(entries.next().value); // [1, 'b']\nconsole.log(entries.next().value); // [2, 'c']\n\n\n1\n2\n3\n4\n5\n\n\n\n# 数组实例的 includes()\n\nArray.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。\n\n[1, 2, 3].includes(2)     // true\n[1, 2, 3].includes(4)     // false\n[1, 2, NaN].includes(NaN) // true\n\n\n1\n2\n3\n\n\n该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。\n\n[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n\n\n1\n2\n\n\n没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。\n\nif (arr.indexOf(el) !== -1) {\n  // ...\n}\n\n\n1\n2\n3\n\n\nindexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。\n\n[NaN].indexOf(NaN)\n// -1\n\n\n1\n2\n\n\nincludes使用的是不一样的判断算法，就没有这个问题。\n\n[NaN].includes(NaN)\n// true\n\n\n1\n2\n\n\n下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。\n\nconst contains = (() =>\n  Array.prototype.includes\n    ? (arr, value) => arr.includes(value)\n    : (arr, value) => arr.some(el => el === value)\n)();\ncontains(['foo', 'bar'], 'baz'); // => false\n\n\n1\n2\n3\n4\n5\n6\n\n\n另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。\n\n * Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。\n * Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。\n\n\n# 数组实例的 flat()，flatMap()\n\n数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。\n\n[1, 2, [3, 4]].flat()\n// [1, 2, 3, 4]\n\n\n1\n2\n\n\n上面代码中，原数组的成员里面有一个数组，flat()方法将子数组的成员取出来，添加在原来的位置。\n\nflat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。\n\n[1, 2, [3, [4, 5]]].flat()\n// [1, 2, 3, [4, 5]]\n\n[1, 2, [3, [4, 5]]].flat(2)\n// [1, 2, 3, 4, 5]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，flat()的参数为2，表示要“拉平”两层的嵌套数组。\n\n如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。\n\n[1, [2, [3]]].flat(Infinity)\n// [1, 2, 3]\n\n\n1\n2\n\n\n如果原数组有空位，flat()方法会跳过空位。\n\n[1, 2, , 4, 5].flat()\n// [1, 2, 4, 5]\n\n\n1\n2\n\n\nflatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。\n\n// 相当于 [2, 3, 4].map(x => [x, x*2]).flat()\n[2, 3, 4].flatMap((x) => [x, x * 2])\n// [2, 4, 3, 6, 4, 8]\n\n\n1\n2\n3\n\n\nflatMap()只能展开一层数组。\n\n// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()\n[1, 2, 3, 4].flatMap(x => [[x * 2]])\n// [[2], [4], [6], [8]]\n\n\n1\n2\n3\n\n\n上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此flatMap()返回的还是一个嵌套数组。\n\nflatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。\n\narr.flatMap(function callback(currentValue[, index[, array]]) {\n  // ...\n}[, thisArg])\n\n\n1\n2\n3\n\n\nflatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。\n\n\n# 数组的空位\n\n数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。\n\nArray(3) // [, , ,]\n\n\n1\n\n\n上面代码中，Array(3)返回一个具有 3 个空位的数组。\n\n注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。\n\n0 in [undefined, undefined, undefined] // true\n0 in [, , ,] // false\n\n\n1\n2\n\n\n上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。\n\nES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。\n\n * forEach(), filter(), reduce(), every() 和some()都会跳过空位。\n * map()会跳过空位，但会保留这个值\n * join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。\n\n// forEach方法\n[,'a'].forEach((x,i) => console.log(i)); // 1\n\n// filter方法\n['a',,'b'].filter(x => true) // ['a','b']\n\n// every方法\n[,'a'].every(x => x==='a') // true\n\n// reduce方法\n[1,,2].reduce((x,y) => x+y) // 3\n\n// some方法\n[,'a'].some(x => x !== 'a') // false\n\n// map方法\n[,'a'].map(x => 1) // [,1]\n\n// join方法\n[,'a',undefined,null].join('#') // \"#a##\"\n\n// toString方法\n[,'a',undefined,null].toString() // \",a,,\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nES6 则是明确将空位转为undefined。\n\nArray.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。\n\nArray.from(['a',,'b'])\n// [ \"a\", undefined, \"b\" ]\n\n\n1\n2\n\n\n扩展运算符（...）也会将空位转为undefined。\n\n[...['a',,'b']]\n// [ \"a\", undefined, \"b\" ]\n\n\n1\n2\n\n\ncopyWithin()会连空位一起拷贝。\n\n[,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"]\n\n\n1\n\n\nfill()会将空位视为正常的数组位置。\n\nnew Array(3).fill('a') // [\"a\",\"a\",\"a\"]\n\n\n1\n\n\nfor...of循环也会遍历空位。\n\nlet arr = [, ,];\nfor (let i of arr) {\n  console.log(1);\n}\n// 1\n// 1\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。\n\nentries()、keys()、values()、find()和findIndex()会将空位处理成undefined。\n\n// entries()\n[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]\n\n// keys()\n[...[,'a'].keys()] // [0,1]\n\n// values()\n[...[,'a'].values()] // [undefined,\"a\"]\n\n// find()\n[,'a'].find(x => true) // undefined\n\n// findIndex()\n[,'a'].findIndex(x => true) // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n由于空位的处理规则非常不统一，所以建议避免出现空位。\n\n\n# Array.prototype.sort() 的排序稳定性\n\n排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。\n\nconst arr = [\n  'peach',\n  'straw',\n  'apple',\n  'spork'\n];\n\nconst stableSorting = (s1, s2) => {\n  if (s1[0] < s2[0]) return -1;\n  return 1;\n};\n\narr.sort(stableSorting)\n// [\"apple\", \"peach\", \"straw\", \"spork\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码对数组arr按照首字母进行排序。排序结果中，straw在spork的前面，跟原始顺序一致，所以排序算法stableSorting是稳定排序。\n\nconst unstableSorting = (s1, s2) => {\n  if (s1[0] <= s2[0]) return -1;\n  return 1;\n};\n\narr.sort(unstableSorting)\n// [\"apple\", \"peach\", \"spork\", \"straw\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，排序结果是spork在straw前面，跟原始顺序相反，所以排序算法unstableSorting是不稳定的。\n\n常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。\n\n早先的 ECMAScript 没有规定，Array.prototype.sort()的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。ES2019 明确规定，Array.prototype.sort()的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。",normalizedContent:"# 数组的扩展\n\n\n# 扩展运算符\n\n\n# 含义\n\n扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\n\nconsole.log(...[1, 2, 3])\n// 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5)\n// 1 2 3 4 5\n\n[...document.queryselectorall('div')]\n// [<div>, <div>, <div>]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n该运算符主要用于函数调用。\n\nfunction push(array, ...items) {\n  array.push(...items);\n}\n\nfunction add(x, y) {\n  return x + y;\n}\n\nconst numbers = [4, 38];\nadd(...numbers) // 42\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，array.push(...items)和add(...numbers)这两行，都是函数的调用，它们都使用了扩展运算符。该运算符将一个数组，变为参数序列。\n\n扩展运算符与正常的函数参数可以结合使用，非常灵活。\n\nfunction f(v, w, x, y, z) { }\nconst args = [0, 1];\nf(-1, ...args, 2, ...[3]);\n\n\n1\n2\n3\n\n\n扩展运算符后面还可以放置表达式。\n\nconst arr = [\n  ...(x > 0 ? ['a'] : []),\n  'b',\n];\n\n\n1\n2\n3\n4\n\n\n如果扩展运算符后面是一个空数组，则不产生任何效果。\n\n[...[], 1]\n// [1]\n\n\n1\n2\n\n\n注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。\n\n(...[1, 2])\n// uncaught syntaxerror: unexpected number\n\nconsole.log((...[1, 2]))\n// uncaught syntaxerror: unexpected number\n\nconsole.log(...[1, 2])\n// 1 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。\n\n\n# 替代函数的 apply 方法\n\n由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。\n\n// es5 的写法\nfunction f(x, y, z) {\n  // ...\n}\nvar args = [0, 1, 2];\nf.apply(null, args);\n\n// es6的写法\nfunction f(x, y, z) {\n  // ...\n}\nlet args = [0, 1, 2];\nf(...args);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n下面是扩展运算符取代apply方法的一个实际的例子，应用math.max方法，简化求出一个数组最大元素的写法。\n\n// es5 的写法\nmath.max.apply(null, [14, 3, 77])\n\n// es6 的写法\nmath.max(...[14, 3, 77])\n\n// 等同于\nmath.max(14, 3, 77);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，由于 javascript 不提供求数组最大元素的函数，所以只能套用math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用math.max了。\n\n另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。\n\n// es5的 写法\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narray.prototype.push.apply(arr1, arr2);\n\n// es6 的写法\nlet arr1 = [0, 1, 2];\nlet arr2 = [3, 4, 5];\narr1.push(...arr2);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码的 es5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。\n\n下面是另外一个例子。\n\n// es5\nnew (date.bind.apply(date, [null, 2015, 1, 1]))\n// es6\nnew date(...[2015, 1, 1]);\n\n\n1\n2\n3\n4\n\n\n\n# 扩展运算符的应用\n\n（1）复制数组\n\n数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。\n\nconst a1 = [1, 2];\nconst a2 = a1;\n\na2[0] = 2;\na1 // [2, 2]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。\n\nes5 只能用变通方法来复制数组。\n\nconst a1 = [1, 2];\nconst a2 = a1.concat();\n\na2[0] = 2;\na1 // [1, 2]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。\n\n扩展运算符提供了复制数组的简便写法。\n\nconst a1 = [1, 2];\n// 写法一\nconst a2 = [...a1];\n// 写法二\nconst [...a2] = a1;\n\n\n1\n2\n3\n4\n5\n\n\n上面的两种写法，a2都是a1的克隆。\n\n（2）合并数组\n\n扩展运算符提供了数组合并的新写法。\n\nconst arr1 = ['a', 'b'];\nconst arr2 = ['c'];\nconst arr3 = ['d', 'e'];\n\n// es5 的合并数组\narr1.concat(arr2, arr3);\n// [ 'a', 'b', 'c', 'd', 'e' ]\n\n// es6 的合并数组\n[...arr1, ...arr2, ...arr3]\n// [ 'a', 'b', 'c', 'd', 'e' ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n不过，这两种方法都是浅拷贝，使用的时候需要注意。\n\nconst a1 = [{ foo: 1 }];\nconst a2 = [{ bar: 2 }];\n\nconst a3 = a1.concat(a2);\nconst a4 = [...a1, ...a2];\n\na3[0] === a1[0] // true\na4[0] === a1[0] // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。\n\n（3）与解构赋值结合\n\n扩展运算符可以与解构赋值结合起来，用于生成数组。\n\n// es5\na = list[0], rest = list.slice(1)\n// es6\n[a, ...rest] = list\n\n\n1\n2\n3\n4\n\n\n下面是另外一些例子。\n\nconst [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest  // [2, 3, 4, 5]\n\nconst [first, ...rest] = [];\nfirst // undefined\nrest  // []\n\nconst [first, ...rest] = [\"foo\"];\nfirst  // \"foo\"\nrest   // []\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。\n\nconst [...butlast, last] = [1, 2, 3, 4, 5];\n// 报错\n\nconst [first, ...middle, last] = [1, 2, 3, 4, 5];\n// 报错\n\n\n1\n2\n3\n4\n5\n\n\n（4）字符串\n\n扩展运算符还可以将字符串转为真正的数组。\n\n[...'hello']\n// [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n\n\n1\n2\n\n\n上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 unicode 字符。\n\n'x\\ud83d\\ude80y'.length // 4\n[...'x\\ud83d\\ude80y'].length // 3\n\n\n1\n2\n\n\n上面代码的第一种写法，javascript 会将四个字节的 unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。\n\nfunction length(str) {\n  return [...str].length;\n}\n\nlength('x\\ud83d\\ude80y') // 3\n\n\n1\n2\n3\n4\n5\n\n\n凡是涉及到操作四个字节的 unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。\n\nlet str = 'x\\ud83d\\ude80y';\n\nstr.split('').reverse().join('')\n// 'y\\ude80\\ud83dx'\n\n[...str].reverse().join('')\n// 'y\\ud83d\\ude80x'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。\n\n（5）实现了 iterator 接口的对象\n\n任何定义了遍历器（iterator）接口的对象（参阅 iterator 一章），都可以用扩展运算符转为真正的数组。\n\nlet nodelist = document.queryselectorall('div');\nlet array = [...nodelist];\n\n\n1\n2\n\n\n上面代码中，queryselectorall方法返回的是一个nodelist对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于nodelist对象实现了 iterator 。\n\nnumber.prototype[symbol.iterator] = function*() {\n  let i = 0;\n  let num = this.valueof();\n  while (i < num) {\n    yield i++;\n  }\n}\n\nconsole.log([...5]) // [0, 1, 2, 3, 4]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，先定义了number对象的遍历器接口，扩展运算符将5自动转成number实例以后，就会调用这个接口，就会返回自定义的结果。\n\n对于那些没有部署 iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。\n\nlet arraylike = {\n  '0': 'a',\n  '1': 'b',\n  '2': 'c',\n  length: 3\n};\n\n// typeerror: cannot spread non-iterable object.\nlet arr = [...arraylike];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，arraylike是一个类似数组的对象，但是没有部署 iterator 接口，扩展运算符就会报错。这时，可以改为使用array.from方法将arraylike转为真正的数组。\n\n（6）map 和 set 结构，generator 函数\n\n扩展运算符内部调用的是数据结构的 iterator 接口，因此只要具有 iterator 接口的对象，都可以使用扩展运算符，比如 map 结构。\n\nlet map = new map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nlet arr = [...map.keys()]; // [1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ngenerator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。\n\nconst go = function*(){\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...go()] // [1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量go是一个 generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。\n\n如果对没有 iterator 接口的对象，使用扩展运算符，将会报错。\n\nconst obj = {a: 1, b: 2};\nlet arr = [...obj]; // typeerror: cannot spread non-iterable object\n\n\n1\n2\n\n\n\n# array.from()\n\narray.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 es6 新增的数据结构 set 和 map）。\n\n下面是一个类似数组的对象，array.from将它转为真正的数组。\n\nlet arraylike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// es5的写法\nvar arr1 = [].slice.call(arraylike); // ['a', 'b', 'c']\n\n// es6的写法\nlet arr2 = array.from(arraylike); // ['a', 'b', 'c']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n实际应用中，常见的类似数组的对象是 dom 操作返回的 nodelist 集合，以及函数内部的arguments对象。array.from都可以将它们转为真正的数组。\n\n// nodelist对象\nlet ps = document.queryselectorall('p');\narray.from(ps).filter(p => {\n  return p.textcontent.length > 100;\n});\n\n// arguments对象\nfunction foo() {\n  var args = array.from(arguments);\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，queryselectorall方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用filter方法。\n\n只要是部署了 iterator 接口的数据结构，array.from都能将其转为数组。\n\narray.from('hello')\n// ['h', 'e', 'l', 'l', 'o']\n\nlet namesset = new set(['a', 'b'])\narray.from(namesset) // ['a', 'b']\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，字符串和 set 结构都具有 iterator 接口，因此可以被array.from转为真正的数组。\n\n如果参数是一个真正的数组，array.from会返回一个一模一样的新数组。\n\narray.from([1, 2, 3])\n// [1, 2, 3]\n\n\n1\n2\n\n\n值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。\n\n// arguments对象\nfunction foo() {\n  const args = [...arguments];\n}\n\n// nodelist对象\n[...document.queryselectorall('div')]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n扩展运算符背后调用的是遍历器接口（symbol.iterator），如果一个对象没有部署这个接口，就无法转换。array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过array.from方法转为数组，而此时扩展运算符就无法转换。\n\narray.from({ length: 3 });\n// [ undefined, undefined, undefined ]\n\n\n1\n2\n\n\n上面代码中，array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。\n\n对于还没有部署该方法的浏览器，可以用array.prototype.slice方法替代。\n\nconst toarray = (() =>\n  array.from ? array.from : obj => [].slice.call(obj)\n)();\n\n\n1\n2\n3\n\n\narray.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\n\narray.from(arraylike, x => x * x);\n// 等同于\narray.from(arraylike).map(x => x * x);\n\narray.from([1, 2, 3], (x) => x * x)\n// [1, 4, 9]\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面的例子是取出一组 dom 节点的文本内容。\n\nlet spans = document.queryselectorall('span.name');\n\n// map()\nlet names1 = array.prototype.map.call(spans, s => s.textcontent);\n\n// array.from()\nlet names2 = array.from(spans, s => s.textcontent)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n下面的例子将数组中布尔值为false的成员转为0。\n\narray.from([1, , 2, , 3], (n) => n || 0)\n// [1, 0, 2, 0, 3]\n\n\n1\n2\n\n\n另一个例子是返回各种数据的类型。\n\nfunction typesof () {\n  return array.from(arguments, value => typeof value)\n}\ntypesof(null, [], nan)\n// ['object', 'object', 'number']\n\n\n1\n2\n3\n4\n5\n\n\n如果map函数里面用到了this关键字，还可以传入array.from的第三个参数，用来绑定this。\n\narray.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。\n\narray.from({ length: 2 }, () => 'jack')\n// ['jack', 'jack']\n\n\n1\n2\n\n\n上面代码中，array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。\n\narray.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 unicode 字符，可以避免 javascript 将大于\\uffff的 unicode 字符，算作两个字符的 bug。\n\nfunction countsymbols(string) {\n  return array.from(string).length;\n}\n\n\n1\n2\n3\n\n\n\n# array.of() 总是返回参数值组成的数组\n\narray.of方法用于将一组值，转换为数组。\n\narray.of(3, 11, 8) // [3,11,8]\narray.of(3) // [3]\narray.of(3).length // 1\n\n\n1\n2\n3\n\n\n这个方法的主要目的，是弥补数组构造函数array()的不足。因为参数个数的不同，会导致array()的行为有差异。\n\narray() // []\narray(3) // [, , ,]\narray(3, 11, 8) // [3, 11, 8]\n\n\n1\n2\n3\n\n\n上面代码中，array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。\n\narray.of基本上可以用来替代array()或new array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。\n\narray.of() // []\narray.of(undefined) // [undefined]\narray.of(1) // [1]\narray.of(1, 2) // [1, 2]\n\n\n1\n2\n3\n4\n\n\narray.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。\n\narray.of方法可以用下面的代码模拟实现。\n\nfunction arrayof(){\n  return [].slice.call(arguments);\n}\n\n\n1\n2\n3\n\n\n\n# 数组实例的 copywithin()\n\n数组实例的copywithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。\n\narray.prototype.copywithin(target, start = 0, end = this.length)\n\n\n1\n\n\n它接受三个参数。\n\n * target（必需）：从该位置开始替换数据。如果为负值，表示倒数。\n * start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。\n * end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。\n\n这三个参数都应该是数值，如果不是，会自动转为数值。\n\n[1, 2, 3, 4, 5].copywithin(0, 3)\n// [4, 5, 3, 4, 5]\n\n\n1\n2\n\n\n上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。\n\n下面是更多例子。\n\n// 将3号位复制到0号位\n[1, 2, 3, 4, 5].copywithin(0, 3, 4)\n// [4, 2, 3, 4, 5]\n\n// -2相当于3号位，-1相当于4号位\n[1, 2, 3, 4, 5].copywithin(0, -2, -1)\n// [4, 2, 3, 4, 5]\n\n// 将3号位复制到0号位\n[].copywithin.call({length: 5, 3: 1}, 0, 3)\n// {0: 1, 3: 1, length: 5}\n\n// 将2号位到数组结束，复制到0号位\nlet i32a = new int32array([1, 2, 3, 4, 5]);\ni32a.copywithin(0, 2);\n// int32array [3, 4, 5, 4, 5]\n\n// 对于没有部署 typedarray 的 copywithin 方法的平台\n// 需要采用下面的写法\n[].copywithin.call(new int32array([1, 2, 3, 4, 5]), 0, 3, 4);\n// int32array [4, 2, 3, 4, 5]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 数组实例的 find() 和 findindex()\n\n数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。\n\n[1, 4, -5, 10].find((n) => n < 0)\n// -5\n\n\n1\n2\n\n\n上面代码找出数组中第一个小于 0 的成员。\n\n[1, 5, 10, 15].find(function(value, index, arr) {\n  return value > 9;\n}) // 10\n\n\n1\n2\n3\n\n\n上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。\n\n数组实例的findindex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。\n\n[1, 5, 10, 15].findindex(function(value, index, arr) {\n  return value > 9;\n}) // 2\n\n\n1\n2\n3\n\n\n这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。\n\nfunction f(v){\n  return v > this.age;\n}\nlet person = {name: 'john', age: 20};\n[10, 12, 26, 15].find(f, person);    // 26\n\n\n1\n2\n3\n4\n5\n\n\n上面的代码中，find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。\n\n另外，这两个方法都可以发现nan，弥补了数组的indexof方法的不足。\n\n[nan].indexof(nan)\n// -1\n\n[nan].findindex(y => object.is(nan, y))\n// 0\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，indexof方法无法识别数组的nan成员，但是findindex方法可以借助object.is方法做到。\n\n\n# 数组实例的 fill()\n\nfill方法使用给定值，填充一个数组。\n\n['a', 'b', 'c'].fill(7)\n// [7, 7, 7]\n\nnew array(3).fill(7)\n// [7, 7, 7]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。\n\nfill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。\n\n['a', 'b', 'c'].fill(7, 1, 2)\n// ['a', 7, 'c']\n\n\n1\n2\n\n\n上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。\n\n注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。\n\nlet arr = new array(3).fill({name: \"mike\"});\narr[0].name = \"ben\";\narr\n// [{name: \"ben\"}, {name: \"ben\"}, {name: \"ben\"}]\n\nlet arr = new array(3).fill([]);\narr[0].push(5);\narr\n// [[5], [5], [5]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 数组实例的 entries()，keys() 和 values()\n\nes6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。\n\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。\n\nlet letter = ['a', 'b', 'c'];\nlet entries = letter.entries();\nconsole.log(entries.next().value); // [0, 'a']\nconsole.log(entries.next().value); // [1, 'b']\nconsole.log(entries.next().value); // [2, 'c']\n\n\n1\n2\n3\n4\n5\n\n\n\n# 数组实例的 includes()\n\narray.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。es2016 引入了该方法。\n\n[1, 2, 3].includes(2)     // true\n[1, 2, 3].includes(4)     // false\n[1, 2, nan].includes(nan) // true\n\n\n1\n2\n3\n\n\n该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。\n\n[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n\n\n1\n2\n\n\n没有该方法之前，我们通常使用数组的indexof方法，检查是否包含某个值。\n\nif (arr.indexof(el) !== -1) {\n  // ...\n}\n\n\n1\n2\n3\n\n\nindexof方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对nan的误判。\n\n[nan].indexof(nan)\n// -1\n\n\n1\n2\n\n\nincludes使用的是不一样的判断算法，就没有这个问题。\n\n[nan].includes(nan)\n// true\n\n\n1\n2\n\n\n下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。\n\nconst contains = (() =>\n  array.prototype.includes\n    ? (arr, value) => arr.includes(value)\n    : (arr, value) => arr.some(el => el === value)\n)();\ncontains(['foo', 'bar'], 'baz'); // => false\n\n\n1\n2\n3\n4\n5\n6\n\n\n另外，map 和 set 数据结构有一个has方法，需要注意与includes区分。\n\n * map 结构的has方法，是用来查找键名的，比如map.prototype.has(key)、weakmap.prototype.has(key)、reflect.has(target, propertykey)。\n * set 结构的has方法，是用来查找值的，比如set.prototype.has(value)、weakset.prototype.has(value)。\n\n\n# 数组实例的 flat()，flatmap()\n\n数组的成员有时还是数组，array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。\n\n[1, 2, [3, 4]].flat()\n// [1, 2, 3, 4]\n\n\n1\n2\n\n\n上面代码中，原数组的成员里面有一个数组，flat()方法将子数组的成员取出来，添加在原来的位置。\n\nflat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。\n\n[1, 2, [3, [4, 5]]].flat()\n// [1, 2, 3, [4, 5]]\n\n[1, 2, [3, [4, 5]]].flat(2)\n// [1, 2, 3, 4, 5]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，flat()的参数为2，表示要“拉平”两层的嵌套数组。\n\n如果不管有多少层嵌套，都要转成一维数组，可以用infinity关键字作为参数。\n\n[1, [2, [3]]].flat(infinity)\n// [1, 2, 3]\n\n\n1\n2\n\n\n如果原数组有空位，flat()方法会跳过空位。\n\n[1, 2, , 4, 5].flat()\n// [1, 2, 4, 5]\n\n\n1\n2\n\n\nflatmap()方法对原数组的每个成员执行一个函数（相当于执行array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。\n\n// 相当于 [2, 3, 4].map(x => [x, x*2]).flat()\n[2, 3, 4].flatmap((x) => [x, x * 2])\n// [2, 4, 3, 6, 4, 8]\n\n\n1\n2\n3\n\n\nflatmap()只能展开一层数组。\n\n// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()\n[1, 2, 3, 4].flatmap(x => [[x * 2]])\n// [[2], [4], [6], [8]]\n\n\n1\n2\n3\n\n\n上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此flatmap()返回的还是一个嵌套数组。\n\nflatmap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。\n\narr.flatmap(function callback(currentvalue[, index[, array]]) {\n  // ...\n}[, thisarg])\n\n\n1\n2\n3\n\n\nflatmap()方法还可以有第二个参数，用来绑定遍历函数里面的this。\n\n\n# 数组的空位\n\n数组的空位指，数组的某一个位置没有任何值。比如，array构造函数返回的数组都是空位。\n\narray(3) // [, , ,]\n\n\n1\n\n\n上面代码中，array(3)返回一个具有 3 个空位的数组。\n\n注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。\n\n0 in [undefined, undefined, undefined] // true\n0 in [, , ,] // false\n\n\n1\n2\n\n\n上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。\n\nes5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。\n\n * foreach(), filter(), reduce(), every() 和some()都会跳过空位。\n * map()会跳过空位，但会保留这个值\n * join()和tostring()会将空位视为undefined，而undefined和null会被处理成空字符串。\n\n// foreach方法\n[,'a'].foreach((x,i) => console.log(i)); // 1\n\n// filter方法\n['a',,'b'].filter(x => true) // ['a','b']\n\n// every方法\n[,'a'].every(x => x==='a') // true\n\n// reduce方法\n[1,,2].reduce((x,y) => x+y) // 3\n\n// some方法\n[,'a'].some(x => x !== 'a') // false\n\n// map方法\n[,'a'].map(x => 1) // [,1]\n\n// join方法\n[,'a',undefined,null].join('#') // \"#a##\"\n\n// tostring方法\n[,'a',undefined,null].tostring() // \",a,,\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nes6 则是明确将空位转为undefined。\n\narray.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。\n\narray.from(['a',,'b'])\n// [ \"a\", undefined, \"b\" ]\n\n\n1\n2\n\n\n扩展运算符（...）也会将空位转为undefined。\n\n[...['a',,'b']]\n// [ \"a\", undefined, \"b\" ]\n\n\n1\n2\n\n\ncopywithin()会连空位一起拷贝。\n\n[,'a','b',,].copywithin(2,0) // [,\"a\",,\"a\"]\n\n\n1\n\n\nfill()会将空位视为正常的数组位置。\n\nnew array(3).fill('a') // [\"a\",\"a\",\"a\"]\n\n\n1\n\n\nfor...of循环也会遍历空位。\n\nlet arr = [, ,];\nfor (let i of arr) {\n  console.log(1);\n}\n// 1\n// 1\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。\n\nentries()、keys()、values()、find()和findindex()会将空位处理成undefined。\n\n// entries()\n[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]\n\n// keys()\n[...[,'a'].keys()] // [0,1]\n\n// values()\n[...[,'a'].values()] // [undefined,\"a\"]\n\n// find()\n[,'a'].find(x => true) // undefined\n\n// findindex()\n[,'a'].findindex(x => true) // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n由于空位的处理规则非常不统一，所以建议避免出现空位。\n\n\n# array.prototype.sort() 的排序稳定性\n\n排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。\n\nconst arr = [\n  'peach',\n  'straw',\n  'apple',\n  'spork'\n];\n\nconst stablesorting = (s1, s2) => {\n  if (s1[0] < s2[0]) return -1;\n  return 1;\n};\n\narr.sort(stablesorting)\n// [\"apple\", \"peach\", \"straw\", \"spork\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码对数组arr按照首字母进行排序。排序结果中，straw在spork的前面，跟原始顺序一致，所以排序算法stablesorting是稳定排序。\n\nconst unstablesorting = (s1, s2) => {\n  if (s1[0] <= s2[0]) return -1;\n  return 1;\n};\n\narr.sort(unstablesorting)\n// [\"apple\", \"peach\", \"spork\", \"straw\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，排序结果是spork在straw前面，跟原始顺序相反，所以排序算法unstablesorting是不稳定的。\n\n常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。\n\n早先的 ecmascript 没有规定，array.prototype.sort()的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。es2019 明确规定，array.prototype.sort()的默认排序算法必须稳定。这个规定已经做到了，现在 javascript 各个主要实现的默认排序算法都是稳定的。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"对象的扩展",frontmatter:{title:"对象的扩展",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/b5e3e0a0ff6e9c25",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/10.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html",relativePath:"《ES6 教程》笔记/10.对象的扩展.md",key:"v-c1496618",path:"/pages/b5e3e0a0ff6e9c25/",headers:[{level:2,title:"属性的简洁表示法",slug:"属性的简洁表示法",normalizedTitle:"属性的简洁表示法",charIndex:93},{level:2,title:"属性名表达式",slug:"属性名表达式",normalizedTitle:"属性名表达式",charIndex:2152},{level:2,title:"方法的 name 属性",slug:"方法的-name-属性",normalizedTitle:"方法的 name 属性",charIndex:3364},{level:2,title:"属性的可枚举性和遍历",slug:"属性的可枚举性和遍历",normalizedTitle:"属性的可枚举性和遍历",charIndex:4433},{level:3,title:"可枚举性",slug:"可枚举性",normalizedTitle:"可枚举性",charIndex:4436},{level:3,title:"属性的遍历",slug:"属性的遍历",normalizedTitle:"属性的遍历",charIndex:5669},{level:2,title:"super 关键字",slug:"super-关键字",normalizedTitle:"super 关键字",charIndex:6448},{level:2,title:"对象的扩展运算符",slug:"对象的扩展运算符",normalizedTitle:"对象的扩展运算符",charIndex:7595},{level:3,title:"解构赋值",slug:"解构赋值",normalizedTitle:"解构赋值",charIndex:7656},{level:3,title:"扩展运算符",slug:"扩展运算符",normalizedTitle:"扩展运算符",charIndex:7598},{level:2,title:"链判断运算符",slug:"链判断运算符",normalizedTitle:"链判断运算符",charIndex:11842},{level:2,title:"Null 判断运算符",slug:"null-判断运算符",normalizedTitle:"null 判断运算符",charIndex:14050}],excerpt:'<h1 id="对象的扩展"><a class="header-anchor" href="#对象的扩展">#</a> 对象的扩展</h1>\n<p>对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍<code>Object</code>对象的新增方法。</p>\n',headersStr:"属性的简洁表示法 属性名表达式 方法的 name 属性 属性的可枚举性和遍历 可枚举性 属性的遍历 super 关键字 对象的扩展运算符 解构赋值 扩展运算符 链判断运算符 Null 判断运算符",content:"# 对象的扩展\n\n对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍Object对象的新增方法。\n\n\n# 属性的简洁表示法\n\nES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\n\nconst foo = 'bar';\nconst baz = {foo};\nbaz // {foo: \"bar\"}\n\n// 等同于\nconst baz = {foo: foo};\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，变量foo直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。\n\nfunction f(x, y) {\n  return {x, y};\n}\n\n// 等同于\n\nfunction f(x, y) {\n  return {x: x, y: y};\n}\n\nf(1, 2) // Object {x: 1, y: 2}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n除了属性简写，方法也可以简写。\n\nconst o = {\n  method() {\n    return \"Hello!\";\n  }\n};\n\n// 等同于\n\nconst o = {\n  method: function() {\n    return \"Hello!\";\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n下面是一个实际的例子。\n\nlet birth = '2000/01/01';\n\nconst Person = {\n\n  name: '张三',\n\n  //等同于birth: birth\n  birth,\n\n  // 等同于hello: function ()...\n  hello() { console.log('我的名字是', this.name); }\n\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这种写法用于函数的返回值，将会非常方便。\n\nfunction getPoint() {\n  const x = 1;\n  const y = 10;\n  return {x, y};\n}\n\ngetPoint()\n// {x:1, y:10}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nCommonJS 模块输出一组变量，就非常合适使用简洁写法。\n\nlet ms = {};\n\nfunction getItem (key) {\n  return key in ms ? ms[key] : null;\n}\n\nfunction setItem (key, value) {\n  ms[key] = value;\n}\n\nfunction clear () {\n  ms = {};\n}\n\nmodule.exports = { getItem, setItem, clear };\n// 等同于\nmodule.exports = {\n  getItem: getItem,\n  setItem: setItem,\n  clear: clear\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。\n\nconst cart = {\n  _wheels: 4,\n\n  get wheels () {\n    return this._wheels;\n  },\n\n  set wheels (value) {\n    if (value < this._wheels) {\n      throw new Error('数值太小了！');\n    }\n    this._wheels = value;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n简洁写法在打印对象时也很有用。\n\nlet user = {\n  name: 'test'\n};\n\nlet foo = {\n  bar: 'baz'\n};\n\nconsole.log(user, foo)\n// {name: \"test\"} {bar: \"baz\"}\nconsole.log({user, foo})\n// {user: {name: \"test\"}, foo: {bar: \"baz\"}}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，console.log直接输出user和foo两个对象时，就是两组键值对，可能会混淆。把它们放在大括号里面输出，就变成了对象的简洁表示法，每组键值对前面会打印对象名，这样就比较清晰了。\n\n注意，简写的对象方法不能用作构造函数，会报错。\n\nconst obj = {\n  f() {\n    this.foo = 'bar';\n  }\n};\n\nnew obj.f() // 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，f是一个简写的对象方法，所以obj.f不能当作构造函数使用。\n\n\n# 属性名表达式\n\nJavaScript 定义对象的属性，有两种方法。\n\n// 方法一\nobj.foo = true;\n\n// 方法二\nobj['a' + 'bc'] = 123;\n\n\n1\n2\n3\n4\n5\n\n\n上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。\n\n但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。\n\nvar obj = {\n  foo: true,\n  abc: 123\n};\n\n\n1\n2\n3\n4\n\n\nES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。\n\nlet propKey = 'foo';\n\nlet obj = {\n  [propKey]: true,\n  ['a' + 'bc']: 123\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面是另一个例子。\n\nlet lastWord = 'last word';\n\nconst a = {\n  'first word': 'hello',\n  [lastWord]: 'world'\n};\n\na['first word'] // \"hello\"\na[lastWord] // \"world\"\na['last word'] // \"world\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n表达式还可以用于定义方法名。\n\nlet obj = {\n  ['h' + 'ello']() {\n    return 'hi';\n  }\n};\n\nobj.hello() // hi\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，属性名表达式与简洁表示法，不能同时使用，会报错。\n\n// 报错\nconst foo = 'bar';\nconst bar = 'abc';\nconst baz = { [foo] };\n\n// 正确\nconst foo = 'bar';\nconst baz = { [foo]: 'abc'};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。\n\nconst keyA = {a: 1};\nconst keyB = {b: 2};\n\nconst myObject = {\n  [keyA]: 'valueA',\n  [keyB]: 'valueB'\n};\n\nmyObject // Object {[object Object]: \"valueB\"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。\n\n\n# 方法的 name 属性\n\n函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。\n\nconst person = {\n  sayName() {\n    console.log('hello!');\n  },\n};\n\nperson.sayName.name   // \"sayName\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，方法的name属性返回函数名（即方法名）。\n\n如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。\n\nconst obj = {\n  get foo() {},\n  set foo(x) {}\n};\n\nobj.foo.name\n// TypeError: Cannot read property 'name' of undefined\n\nconst descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');\n\ndescriptor.get.name // \"get foo\"\ndescriptor.set.name // \"set foo\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。\n\n(new Function()).name // \"anonymous\"\n\nvar doSomething = function() {\n  // ...\n};\ndoSomething.bind().name // \"bound doSomething\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。\n\nconst key1 = Symbol('description');\nconst key2 = Symbol();\nlet obj = {\n  [key1]() {},\n  [key2]() {},\n};\nobj[key1].name // \"[description]\"\nobj[key2].name // \"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，key1对应的 Symbol 值有描述，key2没有。\n\n\n# 属性的可枚举性和遍历\n\n\n# 可枚举性\n\n对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。\n\nlet obj = { foo: 123 };\nObject.getOwnPropertyDescriptor(obj, 'foo')\n//  {\n//    value: 123,\n//    writable: true,\n//    enumerable: true,\n//    configurable: true\n//  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。\n\n目前，有四个操作会忽略enumerable为false的属性。\n\n * for...in循环：只遍历对象自身的和继承的可枚举的属性。\n * Object.keys()：返回对象自身的所有可枚举的属性的键名。\n * JSON.stringify()：只串行化对象自身的可枚举的属性。\n * Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。\n\n这四个操作之中，前三个是 ES5 就有的，最后一个Object.assign()是 ES6 新增的。其中，只有for...in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for...in遍历到。\n\nObject.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable\n// false\n\nObject.getOwnPropertyDescriptor([], 'length').enumerable\n// false\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，toString和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的属性。\n\n另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。\n\nObject.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable\n// false\n\n\n1\n2\n\n\n总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。\n\n\n# 属性的遍历\n\nES6 一共有 5 种方法可以遍历对象的属性。\n\n（1）for...in\n\nfor...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。\n\n（2）Object.keys(obj)\n\nObject.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。\n\n（3）Object.getOwnPropertyNames(obj)\n\nObject.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。\n\n（4）Object.getOwnPropertySymbols(obj)\n\nObject.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。\n\n（5）Reflect.ownKeys(obj)\n\nReflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。\n\n以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。\n\n * 首先遍历所有数值键，按照数值升序排列。\n * 其次遍历所有字符串键，按照加入时间升序排列。\n * 最后遍历所有 Symbol 键，按照加入时间升序排列。\n\nReflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })\n// ['2', '10', 'b', 'a', Symbol()]\n\n\n1\n2\n\n\n上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。\n\n\n# super 关键字\n\n我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。\n\nconst proto = {\n  foo: 'hello'\n};\n\nconst obj = {\n  foo: 'world',\n  find() {\n    return super.foo;\n  }\n};\n\nObject.setPrototypeOf(obj, proto);\nobj.find() // \"hello\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，对象obj.find()方法之中，通过super.foo引用了原型对象proto的foo属性。\n\n注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。\n\n// 报错\nconst obj = {\n  foo: super.foo\n}\n\n// 报错\nconst obj = {\n  foo: () => super.foo\n}\n\n// 报错\nconst obj = {\n  foo: function () {\n    return super.foo\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。\n\nJavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。\n\nconst proto = {\n  x: 'hello',\n  foo() {\n    console.log(this.x);\n  },\n};\n\nconst obj = {\n  x: 'world',\n  foo() {\n    super.foo();\n  }\n}\n\nObject.setPrototypeOf(obj, proto);\n\nobj.foo() // \"world\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。\n\n\n# 对象的扩展运算符\n\n《数组的扩展》一章中，已经介绍过扩展运算符（...）。ES2018 将这个运算符引入了对象。\n\n\n# 解构赋值\n\n对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。\n\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nx // 1\ny // 2\nz // { a: 3, b: 4 }\n\n\n1\n2\n3\n4\n\n\n上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。\n\n由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。\n\nlet { ...z } = null; // 运行时错误\nlet { ...z } = undefined; // 运行时错误\n\n\n1\n2\n\n\n解构赋值必须是最后一个参数，否则会报错。\n\nlet { ...x, y, z } = someObject; // 句法错误\nlet { x, ...y, ...z } = someObject; // 句法错误\n\n\n1\n2\n\n\n上面代码中，解构赋值不是最后一个参数，所以会报错。\n\n注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。\n\nlet obj = { a: { b: 1 } };\nlet { ...x } = obj;\nobj.a.b = 2;\nx.a.b // 2\n\n\n1\n2\n3\n4\n\n\n上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。\n\n另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。\n\nlet o1 = { a: 1 };\nlet o2 = { b: 2 };\no2.__proto__ = o1;\nlet { ...o3 } = o2;\no3 // { b: 2 }\no3.a // undefined\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，对象o3复制了o2，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。\n\n下面是另一个例子。\n\nconst o = Object.create({ x: 1, y: 2 });\no.z = 3;\n\nlet { x, ...newObj } = o;\nlet { y, z } = newObj;\nx // 1\ny // undefined\nz // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，变量x是单纯的解构赋值，所以可以读取对象o继承的属性；变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性，所以变量z可以赋值成功，变量y取不到值。ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量newObj，如果写成下面这样会报错。\n\nlet { x, ...{ y, z } } = o;\n// SyntaxError: ... must be followed by an identifier in declaration contexts\n\n\n1\n2\n\n\n解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。\n\nfunction baseFunction({ a, b }) {\n  // ...\n}\nfunction wrapperFunction({ x, y, ...restConfig }) {\n  // 使用 x 和 y 参数进行操作\n  // 其余参数传给原始函数\n  return baseFunction(restConfig);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，原始函数baseFunction接受a和b作为参数，函数wrapperFunction在baseFunction的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。\n\n\n# 扩展运算符\n\n对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n\nlet z = { a: 3, b: 4 };\nlet n = { ...z };\nn // { a: 3, b: 4 }\n\n\n1\n2\n3\n\n\n由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。\n\nlet foo = { ...['a', 'b', 'c'] };\nfoo\n// {0: \"a\", 1: \"b\", 2: \"c\"}\n\n\n1\n2\n3\n\n\n如果扩展运算符后面是一个空对象，则没有任何效果。\n\n{...{}, a: 1}\n// { a: 1 }\n\n\n1\n2\n\n\n如果扩展运算符后面不是对象，则会自动将其转为对象。\n\n// 等同于 {...Object(1)}\n{...1} // {}\n\n\n1\n2\n\n\n上面代码中，扩展运算符后面是整数1，会自动转为数值的包装对象Number{1}。由于该对象没有自身属性，所以返回一个空对象。\n\n下面的例子都是类似的道理。\n\n// 等同于 {...Object(true)}\n{...true} // {}\n\n// 等同于 {...Object(undefined)}\n{...undefined} // {}\n\n// 等同于 {...Object(null)}\n{...null} // {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。\n\n{...'hello'}\n// {0: \"h\", 1: \"e\", 2: \"l\", 3: \"l\", 4: \"o\"}\n\n\n1\n2\n\n\n对象的扩展运算符等同于使用Object.assign()方法。\n\nlet aClone = { ...a };\n// 等同于\nlet aClone = Object.assign({}, a);\n\n\n1\n2\n3\n\n\n上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。\n\n// 写法一\nconst clone1 = {\n  __proto__: Object.getPrototypeOf(obj),\n  ...obj\n};\n\n// 写法二\nconst clone2 = Object.assign(\n  Object.create(Object.getPrototypeOf(obj)),\n  obj\n);\n\n// 写法三\nconst clone3 = Object.create(\n  Object.getPrototypeOf(obj),\n  Object.getOwnPropertyDescriptors(obj)\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，写法一的__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。\n\n扩展运算符可以用于合并两个对象。\n\nlet ab = { ...a, ...b };\n// 等同于\nlet ab = Object.assign({}, a, b);\n\n\n1\n2\n3\n\n\n如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。\n\nlet aWithOverrides = { ...a, x: 1, y: 2 };\n// 等同于\nlet aWithOverrides = { ...a, ...{ x: 1, y: 2 } };\n// 等同于\nlet x = 1, y = 2, aWithOverrides = { ...a, x, y };\n// 等同于\nlet aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。\n\n这用来修改现有对象部分的属性就很方便了。\n\nlet newVersion = {\n  ...previousVersion,\n  name: 'New Name' // Override the name property\n};\n\n\n1\n2\n3\n4\n\n\n上面代码中，newVersion对象自定义了name属性，其他属性全部复制自previousVersion对象。\n\n如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。\n\nlet aWithDefaults = { x: 1, y: 2, ...a };\n// 等同于\nlet aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);\n// 等同于\nlet aWithDefaults = Object.assign({ x: 1, y: 2 }, a);\n\n\n1\n2\n3\n4\n5\n\n\n与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。\n\nconst obj = {\n  ...(x > 1 ? {a: 1} : {}),\n  b: 2,\n};\n\n\n1\n2\n3\n4\n\n\n扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。\n\n// 并不会抛出错误，因为 x 属性只是被定义，但没执行\nlet aWithXGetter = {\n  ...a,\n  get x() {\n    throw new Error('not throw yet');\n  }\n};\n\n// 会抛出错误，因为 x 属性被执行了\nlet runtimeError = {\n  ...a,\n  ...{\n    get x() {\n      throw new Error('throw now');\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 链判断运算符\n\n编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取message.body.user.firstName，安全的写法是写成下面这样。\n\nconst firstName = (message\n  && message.body\n  && message.body.user\n  && message.body.user.firstName) || 'default';\n\n\n1\n2\n3\n4\n\n\n或者使用三元运算符?:，判断一个对象是否存在。\n\nconst fooInput = myForm.querySelector('input[name=foo]')\nconst fooValue = fooInput ? fooInput.value : undefined\n\n\n1\n2\n\n\n这样的层层判断非常麻烦，因此 ES2020 引入了“链判断运算符”（optional chaining operator）?.，简化上面的写法。\n\nconst firstName = message?.body?.user?.firstName || 'default';\nconst fooValue = myForm.querySelector('input[name=foo]')?.value\n\n\n1\n2\n\n\n上面代码使用了?.运算符，直接在链式调用的时候判断，左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined。\n\n链判断运算符有三种用法。\n\n * obj?.prop // 对象属性\n * obj?.[expr] // 同上\n * func?.(...args) // 函数或对象方法的调用\n\n下面是判断对象方法是否存在，如果存在就立即执行的例子。\n\niterator.return?.()\n\n\n1\n\n\n上面代码中，iterator.return如果有定义，就会调用该方法，否则直接返回undefined。\n\n对于那些可能没有实现的方法，这个运算符尤其有用。\n\nif (myForm.checkValidity?.() === false) {\n  // 表单校验失败\n  return;\n}\n\n\n1\n2\n3\n4\n\n\n上面代码中，老式浏览器的表单可能没有checkValidity这个方法，这时?.运算符就会返回undefined，判断语句就变成了undefined === false，所以就会跳过下面的代码。\n\n下面是这个运算符常见的使用形式，以及不使用该运算符时的等价形式。\n\na?.b\n// 等同于\na == null ? undefined : a.b\n\na?.[x]\n// 等同于\na == null ? undefined : a[x]\n\na?.b()\n// 等同于\na == null ? undefined : a.b()\n\na?.()\n// 等同于\na == null ? undefined : a()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，特别注意后两种形式，如果a?.b()里面的a.b不是函数，不可调用，那么a?.b()是会报错的。a?.()也是如此，如果a不是null或undefined，但也不是函数，那么a?.()会报错。\n\n使用这个运算符，有几个注意点。\n\n（1）短路机制\n\na?.[++x]\n// 等同于\na == null ? undefined : a[++x]\n\n\n1\n2\n3\n\n\n上面代码中，如果a是undefined或null，那么x不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。\n\n（2）delete 运算符\n\ndelete a?.b\n// 等同于\na == null ? undefined : delete a.b\n\n\n1\n2\n3\n\n\n上面代码中，如果a是undefined或null，会直接返回undefined，而不会进行delete运算。\n\n（3）括号的影响\n\n如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。\n\n(a?.b).c\n// 等价于\n(a == null ? undefined : a.b).c\n\n\n1\n2\n3\n\n\n上面代码中，?.对圆括号外部没有影响，不管a对象是否存在，圆括号后面的.c总是会执行。\n\n一般来说，使用?.运算符的场合，不应该使用圆括号。\n\n（4）报错场合\n\n以下写法是禁止的，会报错。\n\n// 构造函数\nnew a?.()\nnew a?.b()\n\n// 链判断运算符的右侧有模板字符串\na?.`{b}`\na?.b`{c}`\n\n// 链判断运算符的左侧是 super\nsuper?.()\nsuper?.foo\n\n// 链运算符用于赋值运算符左侧\na?.b = c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n（5）右侧不得为十进制数值\n\n为了保证兼容以前的代码，允许foo?.3:0被解析成foo ? .3 : 0，因此规定如果?.后面紧跟一个十进制数字，那么?.不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。\n\n\n# Null 判断运算符\n\n读取对象属性的时候，如果某个属性的值是null或undefined，有时候需要为它们指定默认值。常见做法是通过||运算符指定默认值。\n\nconst headerText = response.settings.headerText || 'Hello, world!';\nconst animationDuration = response.settings.animationDuration || 300;\nconst showSplashScreen = response.settings.showSplashScreen || true;\n\n\n1\n2\n3\n\n\n上面的三行代码都通过||运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为null或undefined，默认值就会生效，但是属性的值如果为空字符串或false或0，默认值也会生效。\n\n为了避免这种情况，ES2020 引入了一个新的 Null 判断运算符??。它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。\n\nconst headerText = response.settings.headerText ?? 'Hello, world!';\nconst animationDuration = response.settings.animationDuration ?? 300;\nconst showSplashScreen = response.settings.showSplashScreen ?? true;\n\n\n1\n2\n3\n\n\n上面代码中，默认值只有在属性值为null或undefined时，才会生效。\n\n这个运算符的一个目的，就是跟链判断运算符?.配合使用，为null或undefined的值设置默认值。\n\nconst animationDuration = response.settings?.animationDuration ?? 300;\n\n\n1\n\n\n上面代码中，response.settings如果是null或undefined，就会返回默认值300。\n\n这个运算符很适合判断函数参数是否赋值。\n\nfunction Component(props) {\n  const enable = props.enabled ?? true;\n  // …\n}\n\n\n1\n2\n3\n4\n\n\n上面代码判断props参数的enabled属性是否赋值，等同于下面的写法。\n\nfunction Component(props) {\n  const {\n    enabled: enable = true,\n  } = props;\n  // …\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n??有一个运算优先级问题，它与&&和||的优先级孰高孰低。现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。\n\n// 报错\nlhs && middle ?? rhs\nlhs ?? middle && rhs\nlhs || middle ?? rhs\nlhs ?? middle || rhs\n\n\n1\n2\n3\n4\n5\n\n\n上面四个表达式都会报错，必须加入表明优先级的括号。\n\n(lhs && middle) ?? rhs;\nlhs && (middle ?? rhs);\n\n(lhs ?? middle) && rhs;\nlhs ?? (middle && rhs);\n\n(lhs || middle) ?? rhs;\nlhs || (middle ?? rhs);\n\n(lhs ?? middle) || rhs;\nlhs ?? (middle || rhs);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",normalizedContent:"# 对象的扩展\n\n对象（object）是 javascript 最重要的数据结构。es6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍object对象的新增方法。\n\n\n# 属性的简洁表示法\n\nes6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\n\nconst foo = 'bar';\nconst baz = {foo};\nbaz // {foo: \"bar\"}\n\n// 等同于\nconst baz = {foo: foo};\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，变量foo直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。\n\nfunction f(x, y) {\n  return {x, y};\n}\n\n// 等同于\n\nfunction f(x, y) {\n  return {x: x, y: y};\n}\n\nf(1, 2) // object {x: 1, y: 2}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n除了属性简写，方法也可以简写。\n\nconst o = {\n  method() {\n    return \"hello!\";\n  }\n};\n\n// 等同于\n\nconst o = {\n  method: function() {\n    return \"hello!\";\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n下面是一个实际的例子。\n\nlet birth = '2000/01/01';\n\nconst person = {\n\n  name: '张三',\n\n  //等同于birth: birth\n  birth,\n\n  // 等同于hello: function ()...\n  hello() { console.log('我的名字是', this.name); }\n\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这种写法用于函数的返回值，将会非常方便。\n\nfunction getpoint() {\n  const x = 1;\n  const y = 10;\n  return {x, y};\n}\n\ngetpoint()\n// {x:1, y:10}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ncommonjs 模块输出一组变量，就非常合适使用简洁写法。\n\nlet ms = {};\n\nfunction getitem (key) {\n  return key in ms ? ms[key] : null;\n}\n\nfunction setitem (key, value) {\n  ms[key] = value;\n}\n\nfunction clear () {\n  ms = {};\n}\n\nmodule.exports = { getitem, setitem, clear };\n// 等同于\nmodule.exports = {\n  getitem: getitem,\n  setitem: setitem,\n  clear: clear\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。\n\nconst cart = {\n  _wheels: 4,\n\n  get wheels () {\n    return this._wheels;\n  },\n\n  set wheels (value) {\n    if (value < this._wheels) {\n      throw new error('数值太小了！');\n    }\n    this._wheels = value;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n简洁写法在打印对象时也很有用。\n\nlet user = {\n  name: 'test'\n};\n\nlet foo = {\n  bar: 'baz'\n};\n\nconsole.log(user, foo)\n// {name: \"test\"} {bar: \"baz\"}\nconsole.log({user, foo})\n// {user: {name: \"test\"}, foo: {bar: \"baz\"}}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，console.log直接输出user和foo两个对象时，就是两组键值对，可能会混淆。把它们放在大括号里面输出，就变成了对象的简洁表示法，每组键值对前面会打印对象名，这样就比较清晰了。\n\n注意，简写的对象方法不能用作构造函数，会报错。\n\nconst obj = {\n  f() {\n    this.foo = 'bar';\n  }\n};\n\nnew obj.f() // 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，f是一个简写的对象方法，所以obj.f不能当作构造函数使用。\n\n\n# 属性名表达式\n\njavascript 定义对象的属性，有两种方法。\n\n// 方法一\nobj.foo = true;\n\n// 方法二\nobj['a' + 'bc'] = 123;\n\n\n1\n2\n3\n4\n5\n\n\n上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。\n\n但是，如果使用字面量方式定义对象（使用大括号），在 es5 中只能使用方法一（标识符）定义属性。\n\nvar obj = {\n  foo: true,\n  abc: 123\n};\n\n\n1\n2\n3\n4\n\n\nes6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。\n\nlet propkey = 'foo';\n\nlet obj = {\n  [propkey]: true,\n  ['a' + 'bc']: 123\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面是另一个例子。\n\nlet lastword = 'last word';\n\nconst a = {\n  'first word': 'hello',\n  [lastword]: 'world'\n};\n\na['first word'] // \"hello\"\na[lastword] // \"world\"\na['last word'] // \"world\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n表达式还可以用于定义方法名。\n\nlet obj = {\n  ['h' + 'ello']() {\n    return 'hi';\n  }\n};\n\nobj.hello() // hi\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，属性名表达式与简洁表示法，不能同时使用，会报错。\n\n// 报错\nconst foo = 'bar';\nconst bar = 'abc';\nconst baz = { [foo] };\n\n// 正确\nconst foo = 'bar';\nconst baz = { [foo]: 'abc'};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object object]，这一点要特别小心。\n\nconst keya = {a: 1};\nconst keyb = {b: 2};\n\nconst myobject = {\n  [keya]: 'valuea',\n  [keyb]: 'valueb'\n};\n\nmyobject // object {[object object]: \"valueb\"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，[keya]和[keyb]得到的都是[object object]，所以[keyb]会把[keya]覆盖掉，而myobject最后只有一个[object object]属性。\n\n\n# 方法的 name 属性\n\n函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。\n\nconst person = {\n  sayname() {\n    console.log('hello!');\n  },\n};\n\nperson.sayname.name   // \"sayname\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，方法的name属性返回函数名（即方法名）。\n\n如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。\n\nconst obj = {\n  get foo() {},\n  set foo(x) {}\n};\n\nobj.foo.name\n// typeerror: cannot read property 'name' of undefined\n\nconst descriptor = object.getownpropertydescriptor(obj, 'foo');\n\ndescriptor.get.name // \"get foo\"\ndescriptor.set.name // \"set foo\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；function构造函数创造的函数，name属性返回anonymous。\n\n(new function()).name // \"anonymous\"\n\nvar dosomething = function() {\n  // ...\n};\ndosomething.bind().name // \"bound dosomething\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果对象的方法是一个 symbol 值，那么name属性返回的是这个 symbol 值的描述。\n\nconst key1 = symbol('description');\nconst key2 = symbol();\nlet obj = {\n  [key1]() {},\n  [key2]() {},\n};\nobj[key1].name // \"[description]\"\nobj[key2].name // \"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，key1对应的 symbol 值有描述，key2没有。\n\n\n# 属性的可枚举性和遍历\n\n\n# 可枚举性\n\n对象的每个属性都有一个描述对象（descriptor），用来控制该属性的行为。object.getownpropertydescriptor方法可以获取该属性的描述对象。\n\nlet obj = { foo: 123 };\nobject.getownpropertydescriptor(obj, 'foo')\n//  {\n//    value: 123,\n//    writable: true,\n//    enumerable: true,\n//    configurable: true\n//  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。\n\n目前，有四个操作会忽略enumerable为false的属性。\n\n * for...in循环：只遍历对象自身的和继承的可枚举的属性。\n * object.keys()：返回对象自身的所有可枚举的属性的键名。\n * json.stringify()：只串行化对象自身的可枚举的属性。\n * object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。\n\n这四个操作之中，前三个是 es5 就有的，最后一个object.assign()是 es6 新增的。其中，只有for...in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的tostring方法，以及数组的length属性，就通过“可枚举性”，从而避免被for...in遍历到。\n\nobject.getownpropertydescriptor(object.prototype, 'tostring').enumerable\n// false\n\nobject.getownpropertydescriptor([], 'length').enumerable\n// false\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，tostring和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的属性。\n\n另外，es6 规定，所有 class 的原型的方法都是不可枚举的。\n\nobject.getownpropertydescriptor(class {foo() {}}.prototype, 'foo').enumerable\n// false\n\n\n1\n2\n\n\n总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用object.keys()代替。\n\n\n# 属性的遍历\n\nes6 一共有 5 种方法可以遍历对象的属性。\n\n（1）for...in\n\nfor...in循环遍历对象自身的和继承的可枚举属性（不含 symbol 属性）。\n\n（2）object.keys(obj)\n\nobject.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 symbol 属性）的键名。\n\n（3）object.getownpropertynames(obj)\n\nobject.getownpropertynames返回一个数组，包含对象自身的所有属性（不含 symbol 属性，但是包括不可枚举属性）的键名。\n\n（4）object.getownpropertysymbols(obj)\n\nobject.getownpropertysymbols返回一个数组，包含对象自身的所有 symbol 属性的键名。\n\n（5）reflect.ownkeys(obj)\n\nreflect.ownkeys返回一个数组，包含对象自身的所有键名，不管键名是 symbol 或字符串，也不管是否可枚举。\n\n以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。\n\n * 首先遍历所有数值键，按照数值升序排列。\n * 其次遍历所有字符串键，按照加入时间升序排列。\n * 最后遍历所有 symbol 键，按照加入时间升序排列。\n\nreflect.ownkeys({ [symbol()]:0, b:0, 10:0, 2:0, a:0 })\n// ['2', '10', 'b', 'a', symbol()]\n\n\n1\n2\n\n\n上面代码中，reflect.ownkeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 symbol 属性。\n\n\n# super 关键字\n\n我们知道，this关键字总是指向函数所在的当前对象，es6 又新增了另一个类似的关键字super，指向当前对象的原型对象。\n\nconst proto = {\n  foo: 'hello'\n};\n\nconst obj = {\n  foo: 'world',\n  find() {\n    return super.foo;\n  }\n};\n\nobject.setprototypeof(obj, proto);\nobj.find() // \"hello\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，对象obj.find()方法之中，通过super.foo引用了原型对象proto的foo属性。\n\n注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。\n\n// 报错\nconst obj = {\n  foo: super.foo\n}\n\n// 报错\nconst obj = {\n  foo: () => super.foo\n}\n\n// 报错\nconst obj = {\n  foo: function () {\n    return super.foo\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面三种super的用法都会报错，因为对于 javascript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 javascript 引擎确认，定义的是对象的方法。\n\njavascript 引擎内部，super.foo等同于object.getprototypeof(this).foo（属性）或object.getprototypeof(this).foo.call(this)（方法）。\n\nconst proto = {\n  x: 'hello',\n  foo() {\n    console.log(this.x);\n  },\n};\n\nconst obj = {\n  x: 'world',\n  foo() {\n    super.foo();\n  }\n}\n\nobject.setprototypeof(obj, proto);\n\nobj.foo() // \"world\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。\n\n\n# 对象的扩展运算符\n\n《数组的扩展》一章中，已经介绍过扩展运算符（...）。es2018 将这个运算符引入了对象。\n\n\n# 解构赋值\n\n对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。\n\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nx // 1\ny // 2\nz // { a: 3, b: 4 }\n\n\n1\n2\n3\n4\n\n\n上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。\n\n由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。\n\nlet { ...z } = null; // 运行时错误\nlet { ...z } = undefined; // 运行时错误\n\n\n1\n2\n\n\n解构赋值必须是最后一个参数，否则会报错。\n\nlet { ...x, y, z } = someobject; // 句法错误\nlet { x, ...y, ...z } = someobject; // 句法错误\n\n\n1\n2\n\n\n上面代码中，解构赋值不是最后一个参数，所以会报错。\n\n注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。\n\nlet obj = { a: { b: 1 } };\nlet { ...x } = obj;\nobj.a.b = 2;\nx.a.b // 2\n\n\n1\n2\n3\n4\n\n\n上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。\n\n另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。\n\nlet o1 = { a: 1 };\nlet o2 = { b: 2 };\no2.__proto__ = o1;\nlet { ...o3 } = o2;\no3 // { b: 2 }\no3.a // undefined\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，对象o3复制了o2，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。\n\n下面是另一个例子。\n\nconst o = object.create({ x: 1, y: 2 });\no.z = 3;\n\nlet { x, ...newobj } = o;\nlet { y, z } = newobj;\nx // 1\ny // undefined\nz // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，变量x是单纯的解构赋值，所以可以读取对象o继承的属性；变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性，所以变量z可以赋值成功，变量y取不到值。es6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量newobj，如果写成下面这样会报错。\n\nlet { x, ...{ y, z } } = o;\n// syntaxerror: ... must be followed by an identifier in declaration contexts\n\n\n1\n2\n\n\n解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。\n\nfunction basefunction({ a, b }) {\n  // ...\n}\nfunction wrapperfunction({ x, y, ...restconfig }) {\n  // 使用 x 和 y 参数进行操作\n  // 其余参数传给原始函数\n  return basefunction(restconfig);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，原始函数basefunction接受a和b作为参数，函数wrapperfunction在basefunction的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。\n\n\n# 扩展运算符\n\n对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n\nlet z = { a: 3, b: 4 };\nlet n = { ...z };\nn // { a: 3, b: 4 }\n\n\n1\n2\n3\n\n\n由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。\n\nlet foo = { ...['a', 'b', 'c'] };\nfoo\n// {0: \"a\", 1: \"b\", 2: \"c\"}\n\n\n1\n2\n3\n\n\n如果扩展运算符后面是一个空对象，则没有任何效果。\n\n{...{}, a: 1}\n// { a: 1 }\n\n\n1\n2\n\n\n如果扩展运算符后面不是对象，则会自动将其转为对象。\n\n// 等同于 {...object(1)}\n{...1} // {}\n\n\n1\n2\n\n\n上面代码中，扩展运算符后面是整数1，会自动转为数值的包装对象number{1}。由于该对象没有自身属性，所以返回一个空对象。\n\n下面的例子都是类似的道理。\n\n// 等同于 {...object(true)}\n{...true} // {}\n\n// 等同于 {...object(undefined)}\n{...undefined} // {}\n\n// 等同于 {...object(null)}\n{...null} // {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。\n\n{...'hello'}\n// {0: \"h\", 1: \"e\", 2: \"l\", 3: \"l\", 4: \"o\"}\n\n\n1\n2\n\n\n对象的扩展运算符等同于使用object.assign()方法。\n\nlet aclone = { ...a };\n// 等同于\nlet aclone = object.assign({}, a);\n\n\n1\n2\n3\n\n\n上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。\n\n// 写法一\nconst clone1 = {\n  __proto__: object.getprototypeof(obj),\n  ...obj\n};\n\n// 写法二\nconst clone2 = object.assign(\n  object.create(object.getprototypeof(obj)),\n  obj\n);\n\n// 写法三\nconst clone3 = object.create(\n  object.getprototypeof(obj),\n  object.getownpropertydescriptors(obj)\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，写法一的__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。\n\n扩展运算符可以用于合并两个对象。\n\nlet ab = { ...a, ...b };\n// 等同于\nlet ab = object.assign({}, a, b);\n\n\n1\n2\n3\n\n\n如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。\n\nlet awithoverrides = { ...a, x: 1, y: 2 };\n// 等同于\nlet awithoverrides = { ...a, ...{ x: 1, y: 2 } };\n// 等同于\nlet x = 1, y = 2, awithoverrides = { ...a, x, y };\n// 等同于\nlet awithoverrides = object.assign({}, a, { x: 1, y: 2 });\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。\n\n这用来修改现有对象部分的属性就很方便了。\n\nlet newversion = {\n  ...previousversion,\n  name: 'new name' // override the name property\n};\n\n\n1\n2\n3\n4\n\n\n上面代码中，newversion对象自定义了name属性，其他属性全部复制自previousversion对象。\n\n如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。\n\nlet awithdefaults = { x: 1, y: 2, ...a };\n// 等同于\nlet awithdefaults = object.assign({}, { x: 1, y: 2 }, a);\n// 等同于\nlet awithdefaults = object.assign({ x: 1, y: 2 }, a);\n\n\n1\n2\n3\n4\n5\n\n\n与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。\n\nconst obj = {\n  ...(x > 1 ? {a: 1} : {}),\n  b: 2,\n};\n\n\n1\n2\n3\n4\n\n\n扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。\n\n// 并不会抛出错误，因为 x 属性只是被定义，但没执行\nlet awithxgetter = {\n  ...a,\n  get x() {\n    throw new error('not throw yet');\n  }\n};\n\n// 会抛出错误，因为 x 属性被执行了\nlet runtimeerror = {\n  ...a,\n  ...{\n    get x() {\n      throw new error('throw now');\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 链判断运算符\n\n编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取message.body.user.firstname，安全的写法是写成下面这样。\n\nconst firstname = (message\n  && message.body\n  && message.body.user\n  && message.body.user.firstname) || 'default';\n\n\n1\n2\n3\n4\n\n\n或者使用三元运算符?:，判断一个对象是否存在。\n\nconst fooinput = myform.queryselector('input[name=foo]')\nconst foovalue = fooinput ? fooinput.value : undefined\n\n\n1\n2\n\n\n这样的层层判断非常麻烦，因此 es2020 引入了“链判断运算符”（optional chaining operator）?.，简化上面的写法。\n\nconst firstname = message?.body?.user?.firstname || 'default';\nconst foovalue = myform.queryselector('input[name=foo]')?.value\n\n\n1\n2\n\n\n上面代码使用了?.运算符，直接在链式调用的时候判断，左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined。\n\n链判断运算符有三种用法。\n\n * obj?.prop // 对象属性\n * obj?.[expr] // 同上\n * func?.(...args) // 函数或对象方法的调用\n\n下面是判断对象方法是否存在，如果存在就立即执行的例子。\n\niterator.return?.()\n\n\n1\n\n\n上面代码中，iterator.return如果有定义，就会调用该方法，否则直接返回undefined。\n\n对于那些可能没有实现的方法，这个运算符尤其有用。\n\nif (myform.checkvalidity?.() === false) {\n  // 表单校验失败\n  return;\n}\n\n\n1\n2\n3\n4\n\n\n上面代码中，老式浏览器的表单可能没有checkvalidity这个方法，这时?.运算符就会返回undefined，判断语句就变成了undefined === false，所以就会跳过下面的代码。\n\n下面是这个运算符常见的使用形式，以及不使用该运算符时的等价形式。\n\na?.b\n// 等同于\na == null ? undefined : a.b\n\na?.[x]\n// 等同于\na == null ? undefined : a[x]\n\na?.b()\n// 等同于\na == null ? undefined : a.b()\n\na?.()\n// 等同于\na == null ? undefined : a()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，特别注意后两种形式，如果a?.b()里面的a.b不是函数，不可调用，那么a?.b()是会报错的。a?.()也是如此，如果a不是null或undefined，但也不是函数，那么a?.()会报错。\n\n使用这个运算符，有几个注意点。\n\n（1）短路机制\n\na?.[++x]\n// 等同于\na == null ? undefined : a[++x]\n\n\n1\n2\n3\n\n\n上面代码中，如果a是undefined或null，那么x不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。\n\n（2）delete 运算符\n\ndelete a?.b\n// 等同于\na == null ? undefined : delete a.b\n\n\n1\n2\n3\n\n\n上面代码中，如果a是undefined或null，会直接返回undefined，而不会进行delete运算。\n\n（3）括号的影响\n\n如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。\n\n(a?.b).c\n// 等价于\n(a == null ? undefined : a.b).c\n\n\n1\n2\n3\n\n\n上面代码中，?.对圆括号外部没有影响，不管a对象是否存在，圆括号后面的.c总是会执行。\n\n一般来说，使用?.运算符的场合，不应该使用圆括号。\n\n（4）报错场合\n\n以下写法是禁止的，会报错。\n\n// 构造函数\nnew a?.()\nnew a?.b()\n\n// 链判断运算符的右侧有模板字符串\na?.`{b}`\na?.b`{c}`\n\n// 链判断运算符的左侧是 super\nsuper?.()\nsuper?.foo\n\n// 链运算符用于赋值运算符左侧\na?.b = c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n（5）右侧不得为十进制数值\n\n为了保证兼容以前的代码，允许foo?.3:0被解析成foo ? .3 : 0，因此规定如果?.后面紧跟一个十进制数字，那么?.不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。\n\n\n# null 判断运算符\n\n读取对象属性的时候，如果某个属性的值是null或undefined，有时候需要为它们指定默认值。常见做法是通过||运算符指定默认值。\n\nconst headertext = response.settings.headertext || 'hello, world!';\nconst animationduration = response.settings.animationduration || 300;\nconst showsplashscreen = response.settings.showsplashscreen || true;\n\n\n1\n2\n3\n\n\n上面的三行代码都通过||运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为null或undefined，默认值就会生效，但是属性的值如果为空字符串或false或0，默认值也会生效。\n\n为了避免这种情况，es2020 引入了一个新的 null 判断运算符??。它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。\n\nconst headertext = response.settings.headertext ?? 'hello, world!';\nconst animationduration = response.settings.animationduration ?? 300;\nconst showsplashscreen = response.settings.showsplashscreen ?? true;\n\n\n1\n2\n3\n\n\n上面代码中，默认值只有在属性值为null或undefined时，才会生效。\n\n这个运算符的一个目的，就是跟链判断运算符?.配合使用，为null或undefined的值设置默认值。\n\nconst animationduration = response.settings?.animationduration ?? 300;\n\n\n1\n\n\n上面代码中，response.settings如果是null或undefined，就会返回默认值300。\n\n这个运算符很适合判断函数参数是否赋值。\n\nfunction component(props) {\n  const enable = props.enabled ?? true;\n  // …\n}\n\n\n1\n2\n3\n4\n\n\n上面代码判断props参数的enabled属性是否赋值，等同于下面的写法。\n\nfunction component(props) {\n  const {\n    enabled: enable = true,\n  } = props;\n  // …\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n??有一个运算优先级问题，它与&&和||的优先级孰高孰低。现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。\n\n// 报错\nlhs && middle ?? rhs\nlhs ?? middle && rhs\nlhs || middle ?? rhs\nlhs ?? middle || rhs\n\n\n1\n2\n3\n4\n5\n\n\n上面四个表达式都会报错，必须加入表明优先级的括号。\n\n(lhs && middle) ?? rhs;\nlhs && (middle ?? rhs);\n\n(lhs ?? middle) && rhs;\nlhs ?? (middle && rhs);\n\n(lhs || middle) ?? rhs;\nlhs || (middle ?? rhs);\n\n(lhs ?? middle) || rhs;\nlhs ?? (middle || rhs);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"对象的新增方法",frontmatter:{title:"对象的新增方法",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/e85e68947502cf90",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/11.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.html",relativePath:"《ES6 教程》笔记/11.对象的新增方法.md",key:"v-2b833066",path:"/pages/e85e68947502cf90/",headers:[{level:2,title:"Object.is()",slug:"object-is",normalizedTitle:"object.is()",charIndex:36},{level:2,title:"Object.assign()",slug:"object-assign",normalizedTitle:"object.assign()",charIndex:829},{level:3,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:849},{level:3,title:"注意点",slug:"注意点",normalizedTitle:"注意点",charIndex:2867},{level:3,title:"常见用途",slug:"常见用途",normalizedTitle:"常见用途",charIndex:3937},{level:2,title:"Object.getOwnPropertyDescriptors()",slug:"object-getownpropertydescriptors",normalizedTitle:"object.getownpropertydescriptors()",charIndex:5719},{level:2,title:"__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()",slug:"proto-属性-object-setprototypeof-object-getprototypeof",normalizedTitle:"__proto__属性，object.setprototypeof()，object.getprototypeof()",charIndex:9059},{level:3,title:"__proto__属性",slug:"proto-属性",normalizedTitle:"__proto__属性",charIndex:9059},{level:3,title:"Object.setPrototypeOf()",slug:"object-setprototypeof",normalizedTitle:"object.setprototypeof()",charIndex:9071},{level:3,title:"Object.getPrototypeOf()",slug:"object-getprototypeof",normalizedTitle:"object.getprototypeof()",charIndex:9095},{level:2,title:"Object.keys()，Object.values()，Object.entries()",slug:"object-keys-object-values-object-entries",normalizedTitle:"object.keys()，object.values()，object.entries()",charIndex:12688},{level:3,title:"Object.keys()",slug:"object-keys",normalizedTitle:"object.keys()",charIndex:12688},{level:3,title:"Object.values()",slug:"object-values",normalizedTitle:"object.values()",charIndex:12702},{level:3,title:"Object.entries()",slug:"object-entries",normalizedTitle:"object.entries()",charIndex:12718},{level:2,title:"Object.fromEntries()",slug:"object-fromentries",normalizedTitle:"object.fromentries()",charIndex:15639}],excerpt:'<h1 id="对象的新增方法"><a class="header-anchor" href="#对象的新增方法">#</a> 对象的新增方法</h1>\n<p>本章介绍 Object 对象的新增方法。</p>\n<h2 id="object-is"><a class="header-anchor" href="#object-is">#</a> Object.is()</h2>\n<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\n<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\n',headersStr:"Object.is() Object.assign() 基本用法 注意点 常见用途 Object.getOwnPropertyDescriptors() __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf() __proto__属性 Object.setPrototypeOf() Object.getPrototypeOf() Object.keys()，Object.values()，Object.entries() Object.keys() Object.values() Object.entries() Object.fromEntries()",content:"# 对象的新增方法\n\n本章介绍 Object 对象的新增方法。\n\n\n# Object.is()\n\nES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\n\nES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\n\nObject.is('foo', 'foo')\n// true\nObject.is({}, {})\n// false\n\n\n1\n2\n3\n4\n\n\n不同之处只有两个：一是+0不等于-0，二是NaN等于自身。\n\n+0 === -0 //true\nNaN === NaN // false\n\nObject.is(+0, -0) // false\nObject.is(NaN, NaN) // true\n\n\n1\n2\n3\n4\n5\n\n\nES5 可以通过下面的代码，部署Object.is。\n\nObject.defineProperty(Object, 'is', {\n  value: function(x, y) {\n    if (x === y) {\n      // 针对+0 不等于 -0的情况\n      return x !== 0 || 1 / x === 1 / y;\n    }\n    // 针对NaN的情况\n    return x !== x && y !== y;\n  },\n  configurable: true,\n  enumerable: false,\n  writable: true\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Object.assign()\n\n\n# 基本用法\n\nObject.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\n\nconst target = { a: 1 };\n\nconst source1 = { b: 2 };\nconst source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nObject.assign方法的第一个参数是目标对象，后面的参数都是源对象。\n\n注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n\nconst target = { a: 1, b: 1 };\n\nconst source1 = { b: 2, c: 2 };\nconst source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果只有一个参数，Object.assign会直接返回该参数。\n\nconst obj = {a: 1};\nObject.assign(obj) === obj // true\n\n\n1\n2\n\n\n如果该参数不是对象，则会先转成对象，然后返回。\n\ntypeof Object.assign(2) // \"object\"\n\n\n1\n\n\n由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。\n\nObject.assign(undefined) // 报错\nObject.assign(null) // 报错\n\n\n1\n2\n\n\n如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。\n\nlet obj = {a: 1};\nObject.assign(obj, undefined) === obj // true\nObject.assign(obj, null) === obj // true\n\n\n1\n2\n3\n\n\n其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。\n\nconst v1 = 'abc';\nconst v2 = true;\nconst v3 = 10;\n\nconst obj = Object.assign({}, v1, v2, v3);\nconsole.log(obj); // { \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" }\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。\n\nObject(true) // {[[PrimitiveValue]]: true}\nObject(10)  //  {[[PrimitiveValue]]: 10}\nObject('abc') // {0: \"a\", 1: \"b\", 2: \"c\", length: 3, [[PrimitiveValue]]: \"abc\"}\n\n\n1\n2\n3\n\n\n上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被Object.assign拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。\n\nObject.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。\n\nObject.assign({b: 'c'},\n  Object.defineProperty({}, 'invisible', {\n    enumerable: false,\n    value: 'hello'\n  })\n)\n// { b: 'c' }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。\n\n属性名为 Symbol 值的属性，也会被Object.assign拷贝。\n\nObject.assign({ a: 'b' }, { [Symbol('c')]: 'd' })\n// { a: 'b', Symbol(c): 'd' }\n\n\n1\n2\n\n\n\n# 注意点\n\n（1）浅拷贝\n\nObject.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。\n\nconst obj1 = {a: {b: 1}};\nconst obj2 = Object.assign({}, obj1);\n\nobj1.a.b = 2;\nobj2.a.b // 2\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。\n\n（2）同名属性的替换\n\n对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。\n\nconst target = { a: { b: 'c', d: 'e' } }\nconst source = { a: { b: 'hello' } }\nObject.assign(target, source)\n// { a: { b: 'hello' } }\n\n\n1\n2\n3\n4\n\n\n上面代码中，target对象的a属性被source对象的a属性整个替换掉了，而不会得到{ a: { b: 'hello', d: 'e' } }的结果。这通常不是开发者想要的，需要特别小心。\n\n一些函数库提供Object.assign的定制版本（比如 Lodash 的_.defaultsDeep方法），可以得到深拷贝的合并。\n\n（3）数组的处理\n\nObject.assign可以用来处理数组，但是会把数组视为对象。\n\nObject.assign([1, 2, 3], [4, 5])\n// [4, 5, 3]\n\n\n1\n2\n\n\n上面代码中，Object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。\n\n（4）取值函数的处理\n\nObject.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。\n\nconst source = {\n  get foo() { return 1 }\n};\nconst target = {};\n\nObject.assign(target, source)\n// { foo: 1 }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，source对象的foo属性是一个取值函数，Object.assign不会复制这个取值函数，只会拿到值以后，将这个值复制过去。\n\n\n# 常见用途\n\nObject.assign方法有很多用处。\n\n（1）为对象添加属性\n\nclass Point {\n  constructor(x, y) {\n    Object.assign(this, {x, y});\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。\n\n（2）为对象添加方法\n\nObject.assign(SomeClass.prototype, {\n  someMethod(arg1, arg2) {\n    ···\n  },\n  anotherMethod() {\n    ···\n  }\n});\n\n// 等同于下面的写法\nSomeClass.prototype.someMethod = function (arg1, arg2) {\n  ···\n};\nSomeClass.prototype.anotherMethod = function () {\n  ···\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。\n\n（3）克隆对象\n\nfunction clone(origin) {\n  return Object.assign({}, origin);\n}\n\n\n1\n2\n3\n\n\n上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。\n\n不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。\n\nfunction clone(origin) {\n  let originProto = Object.getPrototypeOf(origin);\n  return Object.assign(Object.create(originProto), origin);\n}\n\n\n1\n2\n3\n4\n\n\n（4）合并多个对象\n\n将多个对象合并到某个对象。\n\nconst merge =\n  (target, ...sources) => Object.assign(target, ...sources);\n\n\n1\n2\n\n\n如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。\n\nconst merge =\n  (...sources) => Object.assign({}, ...sources);\n\n\n1\n2\n\n\n（5）为属性指定默认值\n\nconst DEFAULTS = {\n  logLevel: 0,\n  outputFormat: 'html'\n};\n\nfunction processContent(options) {\n  options = Object.assign({}, DEFAULTS, options);\n  console.log(options);\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则options的属性值会覆盖DEFAULTS的属性值。\n\n注意，由于存在浅拷贝的问题，DEFAULTS对象和options对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS对象的该属性很可能不起作用。\n\nconst DEFAULTS = {\n  url: {\n    host: 'example.com',\n    port: 7070\n  },\n};\n\nprocessContent({ url: {port: 8000} })\n// {\n//   url: {port: 8000}\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码的原意是将url.port改成 8000，url.host不变。实际结果却是options.url覆盖掉DEFAULTS.url，所以url.host就不存在了。\n\n\n# Object.getOwnPropertyDescriptors()\n\nES5 的Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。\n\nconst obj = {\n  foo: 123,\n  get bar() { return 'abc' }\n};\n\nObject.getOwnPropertyDescriptors(obj)\n// { foo:\n//    { value: 123,\n//      writable: true,\n//      enumerable: true,\n//      configurable: true },\n//   bar:\n//    { get: [Function: get bar],\n//      set: undefined,\n//      enumerable: true,\n//      configurable: true } }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，Object.getOwnPropertyDescriptors()方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。\n\n该方法的实现非常容易。\n\nfunction getOwnPropertyDescriptors(obj) {\n  const result = {};\n  for (let key of Reflect.ownKeys(obj)) {\n    result[key] = Object.getOwnPropertyDescriptor(obj, key);\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。\n\nconst source = {\n  set foo(value) {\n    console.log(value);\n  }\n};\n\nconst target1 = {};\nObject.assign(target1, source);\n\nObject.getOwnPropertyDescriptor(target1, 'foo')\n// { value: undefined,\n//   writable: true,\n//   enumerable: true,\n//   configurable: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，source对象的foo属性的值是一个赋值函数，Object.assign方法将这个属性拷贝给target1对象，结果该属性的值变成了undefined。这是因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。\n\n这时，Object.getOwnPropertyDescriptors()方法配合Object.defineProperties()方法，就可以实现正确拷贝。\n\nconst source = {\n  set foo(value) {\n    console.log(value);\n  }\n};\n\nconst target2 = {};\nObject.defineProperties(target2, Object.getOwnPropertyDescriptors(source));\nObject.getOwnPropertyDescriptor(target2, 'foo')\n// { get: undefined,\n//   set: [Function: set foo],\n//   enumerable: true,\n//   configurable: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，两个对象合并的逻辑可以写成一个函数。\n\nconst shallowMerge = (target, source) => Object.defineProperties(\n  target,\n  Object.getOwnPropertyDescriptors(source)\n);\n\n\n1\n2\n3\n4\n\n\nObject.getOwnPropertyDescriptors()方法的另一个用处，是配合Object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝。\n\nconst clone = Object.create(Object.getPrototypeOf(obj),\n  Object.getOwnPropertyDescriptors(obj));\n\n// 或者\n\nconst shallowClone = (obj) => Object.create(\n  Object.getPrototypeOf(obj),\n  Object.getOwnPropertyDescriptors(obj)\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码会克隆对象obj。\n\n另外，Object.getOwnPropertyDescriptors()方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。\n\nconst obj = {\n  __proto__: prot,\n  foo: 123,\n};\n\n\n1\n2\n3\n4\n\n\nES6 规定__proto__只有浏览器要部署，其他环境不用部署。如果去除__proto__，上面代码就要改成下面这样。\n\nconst obj = Object.create(prot);\nobj.foo = 123;\n\n// 或者\n\nconst obj = Object.assign(\n  Object.create(prot),\n  {\n    foo: 123,\n  }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n有了Object.getOwnPropertyDescriptors()，我们就有了另一种写法。\n\nconst obj = Object.create(\n  prot,\n  Object.getOwnPropertyDescriptors({\n    foo: 123,\n  })\n);\n\n\n1\n2\n3\n4\n5\n6\n\n\nObject.getOwnPropertyDescriptors()也可以用来实现 Mixin（混入）模式。\n\nlet mix = (object) => ({\n  with: (...mixins) => mixins.reduce(\n    (c, mixin) => Object.create(\n      c, Object.getOwnPropertyDescriptors(mixin)\n    ), object)\n});\n\n// multiple mixins example\nlet a = {a: 'a'};\nlet b = {b: 'b'};\nlet c = {c: 'c'};\nlet d = mix(c).with(a, b);\n\nd.c // \"c\"\nd.b // \"b\"\nd.a // \"a\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码返回一个新的对象d，代表了对象a和b被混入了对象c的操作。\n\n出于完整性的考虑，Object.getOwnPropertyDescriptors()进入标准以后，以后还会新增Reflect.getOwnPropertyDescriptors()方法。\n\n\n# __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()\n\nJavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。\n\n\n# __proto__属性\n\n__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。\n\n// es5 的写法\nconst obj = {\n  method: function() { ... }\n};\nobj.__proto__ = someOtherObj;\n\n// es6 的写法\nvar obj = Object.create(someOtherObj);\nobj.method = function() { ... };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n该属性没有写入 ES6 的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。\n\n实现上，__proto__调用的是Object.prototype.__proto__，具体实现如下。\n\nObject.defineProperty(Object.prototype, '__proto__', {\n  get() {\n    let _thisObj = Object(this);\n    return Object.getPrototypeOf(_thisObj);\n  },\n  set(proto) {\n    if (this === undefined || this === null) {\n      throw new TypeError();\n    }\n    if (!isObject(this)) {\n      return undefined;\n    }\n    if (!isObject(proto)) {\n      return undefined;\n    }\n    let status = Reflect.setPrototypeOf(this, proto);\n    if (!status) {\n      throw new TypeError();\n    }\n  },\n});\n\nfunction isObject(value) {\n  return Object(value) === value;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n如果一个对象本身部署了__proto__属性，该属性的值就是对象的原型。\n\nObject.getPrototypeOf({ __proto__: null })\n// null\n\n\n1\n2\n\n\n\n# Object.setPrototypeOf()\n\nObject.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。\n\n// 格式\nObject.setPrototypeOf(object, prototype)\n\n// 用法\nconst o = Object.setPrototypeOf({}, null);\n\n\n1\n2\n3\n4\n5\n\n\n该方法等同于下面的函数。\n\nfunction setPrototypeOf(obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n\n\n1\n2\n3\n4\n\n\n下面是一个例子。\n\nlet proto = {};\nlet obj = { x: 10 };\nObject.setPrototypeOf(obj, proto);\n\nproto.y = 20;\nproto.z = 40;\n\nobj.x // 10\nobj.y // 20\nobj.z // 40\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。\n\n如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。\n\nObject.setPrototypeOf(1, {}) === 1 // true\nObject.setPrototypeOf('foo', {}) === 'foo' // true\nObject.setPrototypeOf(true, {}) === true // true\n\n\n1\n2\n3\n\n\n由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。\n\nObject.setPrototypeOf(undefined, {})\n// TypeError: Object.setPrototypeOf called on null or undefined\n\nObject.setPrototypeOf(null, {})\n// TypeError: Object.setPrototypeOf called on null or undefined\n\n\n1\n2\n3\n4\n5\n\n\n\n# Object.getPrototypeOf()\n\n该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。\n\nObject.getPrototypeOf(obj);\n\n\n1\n\n\n下面是一个例子。\n\nfunction Rectangle() {\n  // ...\n}\n\nconst rec = new Rectangle();\n\nObject.getPrototypeOf(rec) === Rectangle.prototype\n// true\n\nObject.setPrototypeOf(rec, Object.prototype);\nObject.getPrototypeOf(rec) === Rectangle.prototype\n// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果参数不是对象，会被自动转为对象。\n\n// 等同于 Object.getPrototypeOf(Number(1))\nObject.getPrototypeOf(1)\n// Number {[[PrimitiveValue]]: 0}\n\n// 等同于 Object.getPrototypeOf(String('foo'))\nObject.getPrototypeOf('foo')\n// String {length: 0, [[PrimitiveValue]]: \"\"}\n\n// 等同于 Object.getPrototypeOf(Boolean(true))\nObject.getPrototypeOf(true)\n// Boolean {[[PrimitiveValue]]: false}\n\nObject.getPrototypeOf(1) === Number.prototype // true\nObject.getPrototypeOf('foo') === String.prototype // true\nObject.getPrototypeOf(true) === Boolean.prototype // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果参数是undefined或null，它们无法转为对象，所以会报错。\n\nObject.getPrototypeOf(null)\n// TypeError: Cannot convert undefined or null to object\n\nObject.getPrototypeOf(undefined)\n// TypeError: Cannot convert undefined or null to object\n\n\n1\n2\n3\n4\n5\n\n\n\n# Object.keys()，Object.values()，Object.entries()\n\n\n# Object.keys()\n\nES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。\n\nvar obj = { foo: 'bar', baz: 42 };\nObject.keys(obj)\n// [\"foo\", \"baz\"]\n\n\n1\n2\n3\n\n\nES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。\n\nlet {keys, values, entries} = Object;\nlet obj = { a: 1, b: 2, c: 3 };\n\nfor (let key of keys(obj)) {\n  console.log(key); // 'a', 'b', 'c'\n}\n\nfor (let value of values(obj)) {\n  console.log(value); // 1, 2, 3\n}\n\nfor (let [key, value] of entries(obj)) {\n  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Object.values()\n\nObject.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。\n\nconst obj = { foo: 'bar', baz: 42 };\nObject.values(obj)\n// [\"bar\", 42]\n\n\n1\n2\n3\n\n\n返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。\n\nconst obj = { 100: 'a', 2: 'b', 7: 'c' };\nObject.values(obj)\n// [\"b\", \"c\", \"a\"]\n\n\n1\n2\n3\n\n\n上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。\n\nObject.values只返回对象自身的可遍历属性。\n\nconst obj = Object.create({}, {p: {value: 42}});\nObject.values(obj) // []\n\n\n1\n2\n\n\n上面代码中，Object.create方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的enumerable默认是false，Object.values不会返回这个属性。只要把enumerable改成true，Object.values就会返回属性p的值。\n\nconst obj = Object.create({}, {p:\n  {\n    value: 42,\n    enumerable: true\n  }\n});\nObject.values(obj) // [42]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nObject.values会过滤属性名为 Symbol 值的属性。\n\nObject.values({ [Symbol()]: 123, foo: 'abc' });\n// ['abc']\n\n\n1\n2\n\n\n如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。\n\nObject.values('foo')\n// ['f', 'o', 'o']\n\n\n1\n2\n\n\n上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，Object.values返回每个属性的键值，就是各个字符组成的一个数组。\n\n如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。\n\nObject.values(42) // []\nObject.values(true) // []\n\n\n1\n2\n\n\n\n# Object.entries()\n\nObject.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。\n\nconst obj = { foo: 'bar', baz: 42 };\nObject.entries(obj)\n// [ [\"foo\", \"bar\"], [\"baz\", 42] ]\n\n\n1\n2\n3\n\n\n除了返回值不一样，该方法的行为与Object.values基本一致。\n\n如果原对象的属性名是一个 Symbol 值，该属性会被忽略。\n\nObject.entries({ [Symbol()]: 123, foo: 'abc' });\n// [ [ 'foo', 'abc' ] ]\n\n\n1\n2\n\n\n上面代码中，原对象有两个属性，Object.entries只输出属性名非 Symbol 值的属性。将来可能会有Reflect.ownEntries()方法，返回对象自身的所有属性。\n\nObject.entries的基本用途是遍历对象的属性。\n\nlet obj = { one: 1, two: 2 };\nfor (let [k, v] of Object.entries(obj)) {\n  console.log(\n    `${JSON.stringify(k)}: ${JSON.stringify(v)}`\n  );\n}\n// \"one\": 1\n// \"two\": 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nObject.entries方法的另一个用处是，将对象转为真正的Map结构。\n\nconst obj = { foo: 'bar', baz: 42 };\nconst map = new Map(Object.entries(obj));\nmap // Map { foo: \"bar\", baz: 42 }\n\n\n1\n2\n3\n\n\n自己实现Object.entries方法，非常简单。\n\n// Generator函数的版本\nfunction* entries(obj) {\n  for (let key of Object.keys(obj)) {\n    yield [key, obj[key]];\n  }\n}\n\n// 非Generator函数的版本\nfunction entries(obj) {\n  let arr = [];\n  for (let key of Object.keys(obj)) {\n    arr.push([key, obj[key]]);\n  }\n  return arr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Object.fromEntries()\n\nObject.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。\n\nObject.fromEntries([\n  ['foo', 'bar'],\n  ['baz', 42]\n])\n// { foo: \"bar\", baz: 42 }\n\n\n1\n2\n3\n4\n5\n\n\n该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。\n\n// 例一\nconst entries = new Map([\n  ['foo', 'bar'],\n  ['baz', 42]\n]);\n\nObject.fromEntries(entries)\n// { foo: \"bar\", baz: 42 }\n\n// 例二\nconst map = new Map().set('foo', true).set('bar', false);\nObject.fromEntries(map)\n// { foo: true, bar: false }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n该方法的一个用处是配合URLSearchParams对象，将查询字符串转为对象。\n\nObject.fromEntries(new URLSearchParams('foo=bar&baz=qux'))\n// { foo: \"bar\", baz: \"qux\" }\n\n\n1\n2\n",normalizedContent:"# 对象的新增方法\n\n本章介绍 object 对象的新增方法。\n\n\n# object.is()\n\nes5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的nan不等于自身，以及+0等于-0。javascript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\n\nes6 提出“same-value equality”（同值相等）算法，用来解决这个问题。object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\n\nobject.is('foo', 'foo')\n// true\nobject.is({}, {})\n// false\n\n\n1\n2\n3\n4\n\n\n不同之处只有两个：一是+0不等于-0，二是nan等于自身。\n\n+0 === -0 //true\nnan === nan // false\n\nobject.is(+0, -0) // false\nobject.is(nan, nan) // true\n\n\n1\n2\n3\n4\n5\n\n\nes5 可以通过下面的代码，部署object.is。\n\nobject.defineproperty(object, 'is', {\n  value: function(x, y) {\n    if (x === y) {\n      // 针对+0 不等于 -0的情况\n      return x !== 0 || 1 / x === 1 / y;\n    }\n    // 针对nan的情况\n    return x !== x && y !== y;\n  },\n  configurable: true,\n  enumerable: false,\n  writable: true\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# object.assign()\n\n\n# 基本用法\n\nobject.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\n\nconst target = { a: 1 };\n\nconst source1 = { b: 2 };\nconst source2 = { c: 3 };\n\nobject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nobject.assign方法的第一个参数是目标对象，后面的参数都是源对象。\n\n注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n\nconst target = { a: 1, b: 1 };\n\nconst source1 = { b: 2, c: 2 };\nconst source2 = { c: 3 };\n\nobject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果只有一个参数，object.assign会直接返回该参数。\n\nconst obj = {a: 1};\nobject.assign(obj) === obj // true\n\n\n1\n2\n\n\n如果该参数不是对象，则会先转成对象，然后返回。\n\ntypeof object.assign(2) // \"object\"\n\n\n1\n\n\n由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。\n\nobject.assign(undefined) // 报错\nobject.assign(null) // 报错\n\n\n1\n2\n\n\n如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。\n\nlet obj = {a: 1};\nobject.assign(obj, undefined) === obj // true\nobject.assign(obj, null) === obj // true\n\n\n1\n2\n3\n\n\n其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。\n\nconst v1 = 'abc';\nconst v2 = true;\nconst v3 = 10;\n\nconst obj = object.assign({}, v1, v2, v3);\nconsole.log(obj); // { \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" }\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。\n\nobject(true) // {[[primitivevalue]]: true}\nobject(10)  //  {[[primitivevalue]]: 10}\nobject('abc') // {0: \"a\", 1: \"b\", 2: \"c\", length: 3, [[primitivevalue]]: \"abc\"}\n\n\n1\n2\n3\n\n\n上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[primitivevalue]]上面，这个属性是不会被object.assign拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。\n\nobject.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。\n\nobject.assign({b: 'c'},\n  object.defineproperty({}, 'invisible', {\n    enumerable: false,\n    value: 'hello'\n  })\n)\n// { b: 'c' }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。\n\n属性名为 symbol 值的属性，也会被object.assign拷贝。\n\nobject.assign({ a: 'b' }, { [symbol('c')]: 'd' })\n// { a: 'b', symbol(c): 'd' }\n\n\n1\n2\n\n\n\n# 注意点\n\n（1）浅拷贝\n\nobject.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。\n\nconst obj1 = {a: {b: 1}};\nconst obj2 = object.assign({}, obj1);\n\nobj1.a.b = 2;\nobj2.a.b // 2\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，源对象obj1的a属性的值是一个对象，object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。\n\n（2）同名属性的替换\n\n对于这种嵌套的对象，一旦遇到同名属性，object.assign的处理方法是替换，而不是添加。\n\nconst target = { a: { b: 'c', d: 'e' } }\nconst source = { a: { b: 'hello' } }\nobject.assign(target, source)\n// { a: { b: 'hello' } }\n\n\n1\n2\n3\n4\n\n\n上面代码中，target对象的a属性被source对象的a属性整个替换掉了，而不会得到{ a: { b: 'hello', d: 'e' } }的结果。这通常不是开发者想要的，需要特别小心。\n\n一些函数库提供object.assign的定制版本（比如 lodash 的_.defaultsdeep方法），可以得到深拷贝的合并。\n\n（3）数组的处理\n\nobject.assign可以用来处理数组，但是会把数组视为对象。\n\nobject.assign([1, 2, 3], [4, 5])\n// [4, 5, 3]\n\n\n1\n2\n\n\n上面代码中，object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。\n\n（4）取值函数的处理\n\nobject.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。\n\nconst source = {\n  get foo() { return 1 }\n};\nconst target = {};\n\nobject.assign(target, source)\n// { foo: 1 }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，source对象的foo属性是一个取值函数，object.assign不会复制这个取值函数，只会拿到值以后，将这个值复制过去。\n\n\n# 常见用途\n\nobject.assign方法有很多用处。\n\n（1）为对象添加属性\n\nclass point {\n  constructor(x, y) {\n    object.assign(this, {x, y});\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面方法通过object.assign方法，将x属性和y属性添加到point类的对象实例。\n\n（2）为对象添加方法\n\nobject.assign(someclass.prototype, {\n  somemethod(arg1, arg2) {\n    ···\n  },\n  anothermethod() {\n    ···\n  }\n});\n\n// 等同于下面的写法\nsomeclass.prototype.somemethod = function (arg1, arg2) {\n  ···\n};\nsomeclass.prototype.anothermethod = function () {\n  ···\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到someclass.prototype之中。\n\n（3）克隆对象\n\nfunction clone(origin) {\n  return object.assign({}, origin);\n}\n\n\n1\n2\n3\n\n\n上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。\n\n不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。\n\nfunction clone(origin) {\n  let originproto = object.getprototypeof(origin);\n  return object.assign(object.create(originproto), origin);\n}\n\n\n1\n2\n3\n4\n\n\n（4）合并多个对象\n\n将多个对象合并到某个对象。\n\nconst merge =\n  (target, ...sources) => object.assign(target, ...sources);\n\n\n1\n2\n\n\n如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。\n\nconst merge =\n  (...sources) => object.assign({}, ...sources);\n\n\n1\n2\n\n\n（5）为属性指定默认值\n\nconst defaults = {\n  loglevel: 0,\n  outputformat: 'html'\n};\n\nfunction processcontent(options) {\n  options = object.assign({}, defaults, options);\n  console.log(options);\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，defaults对象是默认值，options对象是用户提供的参数。object.assign方法将defaults和options合并成一个新对象，如果两者有同名属性，则options的属性值会覆盖defaults的属性值。\n\n注意，由于存在浅拷贝的问题，defaults对象和options对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，defaults对象的该属性很可能不起作用。\n\nconst defaults = {\n  url: {\n    host: 'example.com',\n    port: 7070\n  },\n};\n\nprocesscontent({ url: {port: 8000} })\n// {\n//   url: {port: 8000}\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码的原意是将url.port改成 8000，url.host不变。实际结果却是options.url覆盖掉defaults.url，所以url.host就不存在了。\n\n\n# object.getownpropertydescriptors()\n\nes5 的object.getownpropertydescriptor()方法会返回某个对象属性的描述对象（descriptor）。es2017 引入了object.getownpropertydescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。\n\nconst obj = {\n  foo: 123,\n  get bar() { return 'abc' }\n};\n\nobject.getownpropertydescriptors(obj)\n// { foo:\n//    { value: 123,\n//      writable: true,\n//      enumerable: true,\n//      configurable: true },\n//   bar:\n//    { get: [function: get bar],\n//      set: undefined,\n//      enumerable: true,\n//      configurable: true } }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，object.getownpropertydescriptors()方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。\n\n该方法的实现非常容易。\n\nfunction getownpropertydescriptors(obj) {\n  const result = {};\n  for (let key of reflect.ownkeys(obj)) {\n    result[key] = object.getownpropertydescriptor(obj, key);\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n该方法的引入目的，主要是为了解决object.assign()无法正确拷贝get属性和set属性的问题。\n\nconst source = {\n  set foo(value) {\n    console.log(value);\n  }\n};\n\nconst target1 = {};\nobject.assign(target1, source);\n\nobject.getownpropertydescriptor(target1, 'foo')\n// { value: undefined,\n//   writable: true,\n//   enumerable: true,\n//   configurable: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，source对象的foo属性的值是一个赋值函数，object.assign方法将这个属性拷贝给target1对象，结果该属性的值变成了undefined。这是因为object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。\n\n这时，object.getownpropertydescriptors()方法配合object.defineproperties()方法，就可以实现正确拷贝。\n\nconst source = {\n  set foo(value) {\n    console.log(value);\n  }\n};\n\nconst target2 = {};\nobject.defineproperties(target2, object.getownpropertydescriptors(source));\nobject.getownpropertydescriptor(target2, 'foo')\n// { get: undefined,\n//   set: [function: set foo],\n//   enumerable: true,\n//   configurable: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，两个对象合并的逻辑可以写成一个函数。\n\nconst shallowmerge = (target, source) => object.defineproperties(\n  target,\n  object.getownpropertydescriptors(source)\n);\n\n\n1\n2\n3\n4\n\n\nobject.getownpropertydescriptors()方法的另一个用处，是配合object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝。\n\nconst clone = object.create(object.getprototypeof(obj),\n  object.getownpropertydescriptors(obj));\n\n// 或者\n\nconst shallowclone = (obj) => object.create(\n  object.getprototypeof(obj),\n  object.getownpropertydescriptors(obj)\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码会克隆对象obj。\n\n另外，object.getownpropertydescriptors()方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。\n\nconst obj = {\n  __proto__: prot,\n  foo: 123,\n};\n\n\n1\n2\n3\n4\n\n\nes6 规定__proto__只有浏览器要部署，其他环境不用部署。如果去除__proto__，上面代码就要改成下面这样。\n\nconst obj = object.create(prot);\nobj.foo = 123;\n\n// 或者\n\nconst obj = object.assign(\n  object.create(prot),\n  {\n    foo: 123,\n  }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n有了object.getownpropertydescriptors()，我们就有了另一种写法。\n\nconst obj = object.create(\n  prot,\n  object.getownpropertydescriptors({\n    foo: 123,\n  })\n);\n\n\n1\n2\n3\n4\n5\n6\n\n\nobject.getownpropertydescriptors()也可以用来实现 mixin（混入）模式。\n\nlet mix = (object) => ({\n  with: (...mixins) => mixins.reduce(\n    (c, mixin) => object.create(\n      c, object.getownpropertydescriptors(mixin)\n    ), object)\n});\n\n// multiple mixins example\nlet a = {a: 'a'};\nlet b = {b: 'b'};\nlet c = {c: 'c'};\nlet d = mix(c).with(a, b);\n\nd.c // \"c\"\nd.b // \"b\"\nd.a // \"a\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码返回一个新的对象d，代表了对象a和b被混入了对象c的操作。\n\n出于完整性的考虑，object.getownpropertydescriptors()进入标准以后，以后还会新增reflect.getownpropertydescriptors()方法。\n\n\n# __proto__属性，object.setprototypeof()，object.getprototypeof()\n\njavascript 语言的对象继承是通过原型链实现的。es6 提供了更多原型对象的操作方法。\n\n\n# __proto__属性\n\n__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 ie11）都部署了这个属性。\n\n// es5 的写法\nconst obj = {\n  method: function() { ... }\n};\nobj.__proto__ = someotherobj;\n\n// es6 的写法\nvar obj = object.create(someotherobj);\nobj.method = function() { ... };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n该属性没有写入 es6 的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 api，只是由于浏览器广泛支持，才被加入了 es6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的object.setprototypeof()（写操作）、object.getprototypeof()（读操作）、object.create()（生成操作）代替。\n\n实现上，__proto__调用的是object.prototype.__proto__，具体实现如下。\n\nobject.defineproperty(object.prototype, '__proto__', {\n  get() {\n    let _thisobj = object(this);\n    return object.getprototypeof(_thisobj);\n  },\n  set(proto) {\n    if (this === undefined || this === null) {\n      throw new typeerror();\n    }\n    if (!isobject(this)) {\n      return undefined;\n    }\n    if (!isobject(proto)) {\n      return undefined;\n    }\n    let status = reflect.setprototypeof(this, proto);\n    if (!status) {\n      throw new typeerror();\n    }\n  },\n});\n\nfunction isobject(value) {\n  return object(value) === value;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n如果一个对象本身部署了__proto__属性，该属性的值就是对象的原型。\n\nobject.getprototypeof({ __proto__: null })\n// null\n\n\n1\n2\n\n\n\n# object.setprototypeof()\n\nobject.setprototypeof方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 es6 正式推荐的设置原型对象的方法。\n\n// 格式\nobject.setprototypeof(object, prototype)\n\n// 用法\nconst o = object.setprototypeof({}, null);\n\n\n1\n2\n3\n4\n5\n\n\n该方法等同于下面的函数。\n\nfunction setprototypeof(obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n\n\n1\n2\n3\n4\n\n\n下面是一个例子。\n\nlet proto = {};\nlet obj = { x: 10 };\nobject.setprototypeof(obj, proto);\n\nproto.y = 20;\nproto.z = 40;\n\nobj.x // 10\nobj.y // 20\nobj.z // 40\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。\n\n如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。\n\nobject.setprototypeof(1, {}) === 1 // true\nobject.setprototypeof('foo', {}) === 'foo' // true\nobject.setprototypeof(true, {}) === true // true\n\n\n1\n2\n3\n\n\n由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。\n\nobject.setprototypeof(undefined, {})\n// typeerror: object.setprototypeof called on null or undefined\n\nobject.setprototypeof(null, {})\n// typeerror: object.setprototypeof called on null or undefined\n\n\n1\n2\n3\n4\n5\n\n\n\n# object.getprototypeof()\n\n该方法与object.setprototypeof方法配套，用于读取一个对象的原型对象。\n\nobject.getprototypeof(obj);\n\n\n1\n\n\n下面是一个例子。\n\nfunction rectangle() {\n  // ...\n}\n\nconst rec = new rectangle();\n\nobject.getprototypeof(rec) === rectangle.prototype\n// true\n\nobject.setprototypeof(rec, object.prototype);\nobject.getprototypeof(rec) === rectangle.prototype\n// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果参数不是对象，会被自动转为对象。\n\n// 等同于 object.getprototypeof(number(1))\nobject.getprototypeof(1)\n// number {[[primitivevalue]]: 0}\n\n// 等同于 object.getprototypeof(string('foo'))\nobject.getprototypeof('foo')\n// string {length: 0, [[primitivevalue]]: \"\"}\n\n// 等同于 object.getprototypeof(boolean(true))\nobject.getprototypeof(true)\n// boolean {[[primitivevalue]]: false}\n\nobject.getprototypeof(1) === number.prototype // true\nobject.getprototypeof('foo') === string.prototype // true\nobject.getprototypeof(true) === boolean.prototype // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果参数是undefined或null，它们无法转为对象，所以会报错。\n\nobject.getprototypeof(null)\n// typeerror: cannot convert undefined or null to object\n\nobject.getprototypeof(undefined)\n// typeerror: cannot convert undefined or null to object\n\n\n1\n2\n3\n4\n5\n\n\n\n# object.keys()，object.values()，object.entries()\n\n\n# object.keys()\n\nes5 引入了object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。\n\nvar obj = { foo: 'bar', baz: 42 };\nobject.keys(obj)\n// [\"foo\", \"baz\"]\n\n\n1\n2\n3\n\n\nes2017 引入了跟object.keys配套的object.values和object.entries，作为遍历一个对象的补充手段，供for...of循环使用。\n\nlet {keys, values, entries} = object;\nlet obj = { a: 1, b: 2, c: 3 };\n\nfor (let key of keys(obj)) {\n  console.log(key); // 'a', 'b', 'c'\n}\n\nfor (let value of values(obj)) {\n  console.log(value); // 1, 2, 3\n}\n\nfor (let [key, value] of entries(obj)) {\n  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# object.values()\n\nobject.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。\n\nconst obj = { foo: 'bar', baz: 42 };\nobject.values(obj)\n// [\"bar\", 42]\n\n\n1\n2\n3\n\n\n返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。\n\nconst obj = { 100: 'a', 2: 'b', 7: 'c' };\nobject.values(obj)\n// [\"b\", \"c\", \"a\"]\n\n\n1\n2\n3\n\n\n上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。\n\nobject.values只返回对象自身的可遍历属性。\n\nconst obj = object.create({}, {p: {value: 42}});\nobject.values(obj) // []\n\n\n1\n2\n\n\n上面代码中，object.create方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的enumerable默认是false，object.values不会返回这个属性。只要把enumerable改成true，object.values就会返回属性p的值。\n\nconst obj = object.create({}, {p:\n  {\n    value: 42,\n    enumerable: true\n  }\n});\nobject.values(obj) // [42]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nobject.values会过滤属性名为 symbol 值的属性。\n\nobject.values({ [symbol()]: 123, foo: 'abc' });\n// ['abc']\n\n\n1\n2\n\n\n如果object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。\n\nobject.values('foo')\n// ['f', 'o', 'o']\n\n\n1\n2\n\n\n上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，object.values返回每个属性的键值，就是各个字符组成的一个数组。\n\n如果参数不是对象，object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，object.values会返回空数组。\n\nobject.values(42) // []\nobject.values(true) // []\n\n\n1\n2\n\n\n\n# object.entries()\n\nobject.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。\n\nconst obj = { foo: 'bar', baz: 42 };\nobject.entries(obj)\n// [ [\"foo\", \"bar\"], [\"baz\", 42] ]\n\n\n1\n2\n3\n\n\n除了返回值不一样，该方法的行为与object.values基本一致。\n\n如果原对象的属性名是一个 symbol 值，该属性会被忽略。\n\nobject.entries({ [symbol()]: 123, foo: 'abc' });\n// [ [ 'foo', 'abc' ] ]\n\n\n1\n2\n\n\n上面代码中，原对象有两个属性，object.entries只输出属性名非 symbol 值的属性。将来可能会有reflect.ownentries()方法，返回对象自身的所有属性。\n\nobject.entries的基本用途是遍历对象的属性。\n\nlet obj = { one: 1, two: 2 };\nfor (let [k, v] of object.entries(obj)) {\n  console.log(\n    `${json.stringify(k)}: ${json.stringify(v)}`\n  );\n}\n// \"one\": 1\n// \"two\": 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nobject.entries方法的另一个用处是，将对象转为真正的map结构。\n\nconst obj = { foo: 'bar', baz: 42 };\nconst map = new map(object.entries(obj));\nmap // map { foo: \"bar\", baz: 42 }\n\n\n1\n2\n3\n\n\n自己实现object.entries方法，非常简单。\n\n// generator函数的版本\nfunction* entries(obj) {\n  for (let key of object.keys(obj)) {\n    yield [key, obj[key]];\n  }\n}\n\n// 非generator函数的版本\nfunction entries(obj) {\n  let arr = [];\n  for (let key of object.keys(obj)) {\n    arr.push([key, obj[key]]);\n  }\n  return arr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# object.fromentries()\n\nobject.fromentries()方法是object.entries()的逆操作，用于将一个键值对数组转为对象。\n\nobject.fromentries([\n  ['foo', 'bar'],\n  ['baz', 42]\n])\n// { foo: \"bar\", baz: 42 }\n\n\n1\n2\n3\n4\n5\n\n\n该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 map 结构转为对象。\n\n// 例一\nconst entries = new map([\n  ['foo', 'bar'],\n  ['baz', 42]\n]);\n\nobject.fromentries(entries)\n// { foo: \"bar\", baz: 42 }\n\n// 例二\nconst map = new map().set('foo', true).set('bar', false);\nobject.fromentries(map)\n// { foo: true, bar: false }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n该方法的一个用处是配合urlsearchparams对象，将查询字符串转为对象。\n\nobject.fromentries(new urlsearchparams('foo=bar&baz=qux'))\n// { foo: \"bar\", baz: \"qux\" }\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"字符串的扩展",frontmatter:{title:"字符串的扩展",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/ca89eca8adeba5f4",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/04.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95.html",relativePath:"《ES6 教程》笔记/04.字符串的扩展.md",key:"v-0a300e27",path:"/pages/ca89eca8adeba5f4/",headers:[{level:2,title:"字符的 Unicode 表示法",slug:"字符的-unicode-表示法",normalizedTitle:"字符的 unicode 表示法",charIndex:51},{level:2,title:"字符串的遍历器接口",slug:"字符串的遍历器接口",normalizedTitle:"字符串的遍历器接口",charIndex:786},{level:2,title:"直接输入 U+2028 和 U+2029",slug:"直接输入-u-2028-和-u-2029",normalizedTitle:"直接输入 u+2028 和 u+2029",charIndex:1281},{level:2,title:"JSON.stringify() 的改造",slug:"json-stringify-的改造",normalizedTitle:"json.stringify() 的改造",charIndex:2078},{level:2,title:"模板字符串",slug:"模板字符串",normalizedTitle:"模板字符串",charIndex:1998},{level:2,title:"实例：模板编译",slug:"实例-模板编译",normalizedTitle:"实例：模板编译",charIndex:5433},{level:2,title:"标签模板",slug:"标签模板",normalizedTitle:"标签模板",charIndex:7163},{level:2,title:"模板字符串的限制",slug:"模板字符串的限制",normalizedTitle:"模板字符串的限制",charIndex:11475}],excerpt:'<h1 id="字符串的扩展"><a class="header-anchor" href="#字符串的扩展">#</a> 字符串的扩展</h1>\n<p>本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。</p>\n<h2 id="字符的-unicode-表示法"><a class="header-anchor" href="#字符的-unicode-表示法">#</a> 字符的 Unicode 表示法</h2>\n<p>ES6 加强了对 Unicode 的支持，允许采用<code>\\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>\n\x3c!--beforebegin--\x3e<div class="language-javascript line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-javascript"><code><span class="token string">"\\u0061"</span>\n<span class="token comment">// "a"</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"字符的 Unicode 表示法 字符串的遍历器接口 直接输入 U+2028 和 U+2029 JSON.stringify() 的改造 模板字符串 实例：模板编译 标签模板 模板字符串的限制",content:"# 字符串的扩展\n\n本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。\n\n\n# 字符的 Unicode 表示法\n\nES6 加强了对 Unicode 的支持，允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。\n\n\"\\u0061\"\n// \"a\"\n\n\n1\n2\n\n\n但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\n\n\"\\uD842\\uDFB7\"\n// \"𠮷\"\n\n\"\\u20BB7\"\n// \" 7\"\n\n\n1\n2\n3\n4\n5\n\n\n上面代码表示，如果直接在\\u后面跟上超过0xFFFF的数值（比如\\u20BB7），JavaScript 会理解成\\u20BB+7。由于\\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。\n\nES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。\n\n\"\\u{20BB7}\"\n// \"𠮷\"\n\n\"\\u{41}\\u{42}\\u{43}\"\n// \"ABC\"\n\nlet hello = 123;\nhell\\u{6F} // 123\n\n'\\u{1F680}' === '\\uD83D\\uDE80'\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。\n\n有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。\n\n'\\z' === 'z'  // true\n'\\172' === 'z' // true\n'\\x7A' === 'z' // true\n'\\u007A' === 'z' // true\n'\\u{7A}' === 'z' // true\n\n\n1\n2\n3\n4\n5\n\n\n\n# 字符串的遍历器接口\n\nES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历。\n\nfor (let codePoint of 'foo') {\n  console.log(codePoint)\n}\n// \"f\"\n// \"o\"\n// \"o\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。\n\nlet text = String.fromCodePoint(0x20BB7);\n\nfor (let i = 0; i < text.length; i++) {\n  console.log(text[i]);\n}\n// \" \"\n// \" \"\n\nfor (let i of text) {\n  console.log(i);\n}\n// \"𠮷\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for...of循环会正确识别出这一个字符。\n\n\n# 直接输入 U+2028 和 U+2029\n\nJavaScript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，“中”的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式\\u4e2d，两者是等价的。\n\n'中' === '\\u4e2d' // true\n\n\n1\n\n\n但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。\n\n * U+005C：反斜杠（reverse solidus)\n * U+000D：回车（carriage return）\n * U+2028：行分隔符（line separator）\n * U+2029：段分隔符（paragraph separator）\n * U+000A：换行符（line feed）\n\n举例来说，字符串里面不能直接包含反斜杠，一定要转义写成\\\\或者\\u005c。\n\n这个规定本身没有问题，麻烦在于 JSON 格式允许字符串里面直接使用 U+2028（行分隔符）和 U+2029（段分隔符）。这样一来，服务器输出的 JSON 被JSON.parse解析，就有可能直接报错。\n\nconst json = '\"\\u2028\"';\nJSON.parse(json); // 可能报错\n\n\n1\n2\n\n\nJSON 格式已经冻结（RFC 7159），没法修改了。为了消除这个报错，ES2019 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。\n\nconst PS = eval(\"'\\u2029'\");\n\n\n1\n\n\n根据这个提案，上面的代码不会报错。\n\n注意，模板字符串现在就允许直接输入这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为 JSON 本来就不允许直接包含正则表达式。\n\n\n# JSON.stringify() 的改造\n\n根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的JSON.stringify()方法有可能返回不符合 UTF-8 标准的字符串。\n\n具体来说，UTF-8 标准规定，0xD800到0xDFFF之间的码点，不能单独使用，必须配对使用。比如，\\uD834\\uDF06是两个码点，但是必须放在一起配对使用，代表字符𝌆。这是为了表示码点大于0xFFFF的字符的一种变通方法。单独使用\\uD834和\\uDFO6这两个码点是不合法的，或者颠倒顺序也不行，因为\\uDF06\\uD834并没有对应的字符。\n\nJSON.stringify()的问题在于，它可能返回0xD800到0xDFFF之间的单个码点。\n\nJSON.stringify('\\u{D834}') // \"\\u{D834}\"\n\n\n1\n\n\n为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。\n\nJSON.stringify('\\u{D834}') // \"\"\\\\uD834\"\"\nJSON.stringify('\\uDF06\\uD834') // \"\"\\\\udf06\\\\ud834\"\"\n\n\n1\n2\n\n\n\n# 模板字符串\n\n传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。\n\n$('#result').append(\n  'There are <b>' + basket.count + '</b> ' +\n  'items in your basket, ' +\n  '<em>' + basket.onSale +\n  '</em> are on sale!'\n);\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。\n\n$('#result').append(`\n  There are <b>${basket.count}</b> items\n   in your basket, <em>${basket.onSale}</em>\n  are on sale!\n`);\n\n\n1\n2\n3\n4\n5\n\n\n模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\n\n// 普通字符串\n`In JavaScript '\\n' is a line-feed.`\n\n// 多行字符串\n`In JavaScript this is\n not legal.`\n\nconsole.log(`string text line 1\nstring text line 2`);\n\n// 字符串中嵌入变量\nlet name = \"Bob\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。\n\nlet greeting = `\\`Yo\\` World!`;\n\n\n1\n\n\n如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。\n\n$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`);\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。\n\n$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`.trim());\n\n\n1\n2\n3\n4\n5\n6\n\n\n模板字符串中嵌入变量，需要将变量名写在${}之中。\n\nfunction authorize(user, action) {\n  if (!user.hasPrivilege(action)) {\n    throw new Error(\n      // 传统写法为\n      // 'User '\n      // + user.name\n      // + ' is not authorized to do '\n      // + action\n      // + '.'\n      `User ${user.name} is not authorized to do ${action}.`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。\n\nlet x = 1;\nlet y = 2;\n\n`${x} + ${y} = ${x + y}`\n// \"1 + 2 = 3\"\n\n`${x} + ${y * 2} = ${x + y * 2}`\n// \"1 + 4 = 5\"\n\nlet obj = {x: 1, y: 2};\n`${obj.x + obj.y}`\n// \"3\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n模板字符串之中还能调用函数。\n\nfunction fn() {\n  return \"Hello World\";\n}\n\n`foo ${fn()} bar`\n// foo Hello World bar\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。\n\n如果模板字符串中的变量没有声明，将报错。\n\n// 变量place没有声明\nlet msg = `Hello, ${place}`;\n// 报错\n\n\n1\n2\n3\n\n\n由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。\n\n`Hello ${'World'}`\n// \"Hello World\"\n\n\n1\n2\n\n\n模板字符串甚至还能嵌套。\n\nconst tmpl = addrs => `\n  <table>\n  ${addrs.map(addr => `\n    <tr><td>${addr.first}</td></tr>\n    <tr><td>${addr.last}</td></tr>\n  `).join('')}\n  </table>\n`;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。\n\nconst data = [\n    { first: '<Jane>', last: 'Bond' },\n    { first: 'Lars', last: '<Croft>' },\n];\n\nconsole.log(tmpl(data));\n// <table>\n//\n//   <tr><td><Jane></td></tr>\n//   <tr><td>Bond</td></tr>\n//\n//   <tr><td>Lars</td></tr>\n//   <tr><td><Croft></td></tr>\n//\n// </table>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果需要引用模板字符串本身，在需要时执行，可以写成函数。\n\nlet func = (name) => `Hello ${name}!`;\nfunc('Jack') // \"Hello Jack!\"\n\n\n1\n2\n\n\n上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。\n\n\n# 实例：模板编译\n\n下面，我们来看一个通过模板字符串，生成正式模板的实例。\n\nlet template = `\n<ul>\n  <% for(let i=0; i < data.supplies.length; i++) { %>\n    <li><%= data.supplies[i] %></li>\n  <% } %>\n</ul>\n`;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码在模板字符串之中，放置了一个常规模板。该模板使用<%...%>放置 JavaScript 代码，使用<%= ... %>输出 JavaScript 表达式。\n\n怎么编译这个模板字符串呢？\n\n一种思路是将其转换为 JavaScript 表达式字符串。\n\necho('<ul>');\nfor(let i=0; i < data.supplies.length; i++) {\n  echo('<li>');\n  echo(data.supplies[i]);\n  echo('</li>');\n};\necho('</ul>');\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这个转换使用正则表达式就行了。\n\nlet evalExpr = /<%=(.+?)%>/g;\nlet expr = /<%([\\s\\S]+?)%>/g;\n\ntemplate = template\n  .replace(evalExpr, '`); \\n  echo( $1 ); \\n  echo(`')\n  .replace(expr, '`); \\n $1 \\n  echo(`');\n\ntemplate = 'echo(`' + template + '`);';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n然后，将template封装在一个函数里面返回，就可以了。\n\nlet script =\n`(function parse(data){\n  let output = \"\";\n\n  function echo(html){\n    output += html;\n  }\n\n  ${ template }\n\n  return output;\n})`;\n\nreturn script;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n将上面的内容拼装成一个模板编译函数compile。\n\nfunction compile(template){\n  const evalExpr = /<%=(.+?)%>/g;\n  const expr = /<%([\\s\\S]+?)%>/g;\n\n  template = template\n    .replace(evalExpr, '`); \\n  echo( $1 ); \\n  echo(`')\n    .replace(expr, '`); \\n $1 \\n  echo(`');\n\n  template = 'echo(`' + template + '`);';\n\n  let script =\n  `(function parse(data){\n    let output = \"\";\n\n    function echo(html){\n      output += html;\n    }\n\n    ${ template }\n\n    return output;\n  })`;\n\n  return script;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\ncompile函数的用法如下。\n\nlet parse = eval(compile(template));\ndiv.innerHTML = parse({ supplies: [ \"broom\", \"mop\", \"cleaner\" ] });\n//   <ul>\n//     <li>broom</li>\n//     <li>mop</li>\n//     <li>cleaner</li>\n//   </ul>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 标签模板\n\n模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。\n\nalert`123`\n// 等同于\nalert(123)\n\n\n1\n2\n3\n\n\n标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。\n\n但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。\n\nlet a = 5;\nlet b = 10;\n\ntag`Hello ${ a + b } world ${ a * b }`;\n// 等同于\ntag(['Hello ', ' world ', ''], 15, 50);\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。\n\n函数tag依次会接收到多个参数。\n\nfunction tag(stringArr, value1, value2){\n  // ...\n}\n\n// 等同于\n\nfunction tag(stringArr, ...values){\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ntag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。\n\ntag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。\n\ntag函数所有参数的实际值如下。\n\n * 第一个参数：['Hello ', ' world ', '']\n * 第二个参数: 15\n * 第三个参数：50\n\n也就是说，tag函数实际上以下面的形式调用。\n\ntag(['Hello ', ' world ', ''], 15, 50)\n\n\n1\n\n\n我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。\n\nlet a = 5;\nlet b = 10;\n\nfunction tag(s, v1, v2) {\n  console.log(s[0]);\n  console.log(s[1]);\n  console.log(s[2]);\n  console.log(v1);\n  console.log(v2);\n\n  return \"OK\";\n}\n\ntag`Hello ${ a + b } world ${ a * b}`;\n// \"Hello \"\n// \" world \"\n// \"\"\n// 15\n// 50\n// \"OK\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n下面是一个更复杂的例子。\n\nlet total = 30;\nlet msg = passthru`The total is ${total} (${total*1.05} with tax)`;\n\nfunction passthru(literals) {\n  let result = '';\n  let i = 0;\n\n  while (i < literals.length) {\n    result += literals[i++];\n    if (i < arguments.length) {\n      result += arguments[i];\n    }\n  }\n\n  return result;\n}\n\nmsg // \"The total is 30 (31.5 with tax)\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。\n\npassthru函数采用 rest 参数的写法如下。\n\nfunction passthru(literals, ...values) {\n  let output = \"\";\n  let index;\n  for (index = 0; index < values.length; index++) {\n    output += literals[index] + values[index];\n  }\n\n  output += literals[index]\n  return output;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。\n\nlet message =\n  SaferHTML`<p>${sender} has sent you a message.</p>`;\n\nfunction SaferHTML(templateData) {\n  let s = templateData[0];\n  for (let i = 1; i < arguments.length; i++) {\n    let arg = String(arguments[i]);\n\n    // Escape special characters in the substitution.\n    s += arg.replace(/&/g, \"&amp;\")\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\");\n\n    // Don't escape special characters in the template.\n    s += templateData[i];\n  }\n  return s;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。\n\nlet sender = '<script>alert(\"abc\")<\/script>'; // 恶意代码\nlet message = SaferHTML`<p>${sender} has sent you a message.</p>`;\n\nmessage\n// <p>&lt;script&gt;alert(\"abc\")&lt;/script&gt; has sent you a message.</p>\n\n\n1\n2\n3\n4\n5\n\n\n标签模板的另一个应用，就是多语言转换（国际化处理）。\n\ni18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`\n// \"欢迎访问xxx，您是第xxxx位访问者！\"\n\n\n1\n2\n\n\n模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。\n\n// 下面的hashTemplate函数\n// 是一个自定义的模板处理函数\nlet libraryHtml = hashTemplate`\n  <ul>\n    #for book in ${myBooks}\n      <li><i>#{book.title}</i> by #{book.author}</li>\n    #end\n  </ul>\n`;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。\n\njsx`\n  <div>\n    <input\n      ref='input'\n      onChange='${this.handleChange}'\n      defaultValue='${this.state.value}' />\n      ${this.state.value}\n   </div>\n`\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的代码通过jsx函数，将一个 DOM 字符串转为 React 对象。你可以在 GitHub 找到jsx函数的具体实现。\n\n下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。\n\njava`\nclass HelloWorldApp {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World!\"); // Display the string.\n  }\n}\n`\nHelloWorldApp.main();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。\n\nconsole.log`123`\n// [\"123\", raw: Array[1]]\n\n\n1\n2\n\n\n上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。\n\n请看下面的例子。\n\ntag`First line\\nSecond line`\n\nfunction tag(strings) {\n  console.log(strings.raw[0]);\n  // strings.raw[0] 为 \"First line\\\\nSecond line\"\n  // 打印输出 \"First line\\nSecond line\"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[\"First line\\nSecond line\"]，那么strings.raw数组就是[\"First line\\\\nSecond line\"]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\\n视为\\\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。\n\n\n# 模板字符串的限制\n\n前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。\n\n举例来说，标签模板里面可以嵌入 LaTEX 语言。\n\nfunction latex(strings) {\n  // ...\n}\n\nlet document = latex`\n\\newcommand{\\fun}{\\textbf{Fun!}}  // 正常工作\n\\newcommand{\\unicode}{\\textbf{Unicode!}} // 报错\n\\newcommand{\\xerxes}{\\textbf{King!}} // 报错\n\nBreve over the h goes \\u{h}ere // 报错\n`\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，变量document内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。\n\n模板字符串会将\\u00FF和\\u{42}当作 Unicode 字符进行转义，所以\\unicode解析时报错；而\\x56会被当作十六进制字符串转义，所以\\xerxes会报错。也就是说，\\u和\\x在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。\n\n为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。\n\nfunction tag(strs) {\n  strs[0] === undefined\n  strs.raw[0] === \"\\\\unicode and \\\\u{55}\";\n}\ntag`\\unicode and \\u{55}`\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为undefined，但是raw属性依然可以得到原始字符串，因此tag函数还是可以对原字符串进行处理。\n\n注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。\n\nlet bad = `bad escape sequence: \\unicode`; // 报错\n\n\n1\n",normalizedContent:"# 字符串的扩展\n\n本章介绍 es6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。\n\n\n# 字符的 unicode 表示法\n\nes6 加强了对 unicode 的支持，允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 unicode 码点。\n\n\"\\u0061\"\n// \"a\"\n\n\n1\n2\n\n\n但是，这种表示法只限于码点在\\u0000~\\uffff之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\n\n\"\\ud842\\udfb7\"\n// \"𠮷\"\n\n\"\\u20bb7\"\n// \" 7\"\n\n\n1\n2\n3\n4\n5\n\n\n上面代码表示，如果直接在\\u后面跟上超过0xffff的数值（比如\\u20bb7），javascript 会理解成\\u20bb+7。由于\\u20bb是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。\n\nes6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。\n\n\"\\u{20bb7}\"\n// \"𠮷\"\n\n\"\\u{41}\\u{42}\\u{43}\"\n// \"abc\"\n\nlet hello = 123;\nhell\\u{6f} // 123\n\n'\\u{1f680}' === '\\ud83d\\ude80'\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，最后一个例子表明，大括号表示法与四字节的 utf-16 编码是等价的。\n\n有了这种表示法之后，javascript 共有 6 种方法可以表示一个字符。\n\n'\\z' === 'z'  // true\n'\\172' === 'z' // true\n'\\x7a' === 'z' // true\n'\\u007a' === 'z' // true\n'\\u{7a}' === 'z' // true\n\n\n1\n2\n3\n4\n5\n\n\n\n# 字符串的遍历器接口\n\nes6 为字符串添加了遍历器接口（详见《iterator》一章），使得字符串可以被for...of循环遍历。\n\nfor (let codepoint of 'foo') {\n  console.log(codepoint)\n}\n// \"f\"\n// \"o\"\n// \"o\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n除了遍历字符串，这个遍历器最大的优点是可以识别大于0xffff的码点，传统的for循环无法识别这样的码点。\n\nlet text = string.fromcodepoint(0x20bb7);\n\nfor (let i = 0; i < text.length; i++) {\n  console.log(text[i]);\n}\n// \" \"\n// \" \"\n\nfor (let i of text) {\n  console.log(i);\n}\n// \"𠮷\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for...of循环会正确识别出这一个字符。\n\n\n# 直接输入 u+2028 和 u+2029\n\njavascript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，“中”的 unicode 码点是 u+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式\\u4e2d，两者是等价的。\n\n'中' === '\\u4e2d' // true\n\n\n1\n\n\n但是，javascript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。\n\n * u+005c：反斜杠（reverse solidus)\n * u+000d：回车（carriage return）\n * u+2028：行分隔符（line separator）\n * u+2029：段分隔符（paragraph separator）\n * u+000a：换行符（line feed）\n\n举例来说，字符串里面不能直接包含反斜杠，一定要转义写成\\\\或者\\u005c。\n\n这个规定本身没有问题，麻烦在于 json 格式允许字符串里面直接使用 u+2028（行分隔符）和 u+2029（段分隔符）。这样一来，服务器输出的 json 被json.parse解析，就有可能直接报错。\n\nconst json = '\"\\u2028\"';\njson.parse(json); // 可能报错\n\n\n1\n2\n\n\njson 格式已经冻结（rfc 7159），没法修改了。为了消除这个报错，es2019 允许 javascript 字符串直接输入 u+2028（行分隔符）和 u+2029（段分隔符）。\n\nconst ps = eval(\"'\\u2029'\");\n\n\n1\n\n\n根据这个提案，上面的代码不会报错。\n\n注意，模板字符串现在就允许直接输入这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为 json 本来就不允许直接包含正则表达式。\n\n\n# json.stringify() 的改造\n\n根据标准，json 数据必须是 utf-8 编码。但是，现在的json.stringify()方法有可能返回不符合 utf-8 标准的字符串。\n\n具体来说，utf-8 标准规定，0xd800到0xdfff之间的码点，不能单独使用，必须配对使用。比如，\\ud834\\udf06是两个码点，但是必须放在一起配对使用，代表字符𝌆。这是为了表示码点大于0xffff的字符的一种变通方法。单独使用\\ud834和\\udfo6这两个码点是不合法的，或者颠倒顺序也不行，因为\\udf06\\ud834并没有对应的字符。\n\njson.stringify()的问题在于，它可能返回0xd800到0xdfff之间的单个码点。\n\njson.stringify('\\u{d834}') // \"\\u{d834}\"\n\n\n1\n\n\n为了确保返回的是合法的 utf-8 字符，es2019 改变了json.stringify()的行为。如果遇到0xd800到0xdfff之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。\n\njson.stringify('\\u{d834}') // \"\"\\\\ud834\"\"\njson.stringify('\\udf06\\ud834') // \"\"\\\\udf06\\\\ud834\"\"\n\n\n1\n2\n\n\n\n# 模板字符串\n\n传统的 javascript 语言，输出模板通常是这样写的（下面使用了 jquery 的方法）。\n\n$('#result').append(\n  'there are <b>' + basket.count + '</b> ' +\n  'items in your basket, ' +\n  '<em>' + basket.onsale +\n  '</em> are on sale!'\n);\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面这种写法相当繁琐不方便，es6 引入了模板字符串解决这个问题。\n\n$('#result').append(`\n  there are <b>${basket.count}</b> items\n   in your basket, <em>${basket.onsale}</em>\n  are on sale!\n`);\n\n\n1\n2\n3\n4\n5\n\n\n模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\n\n// 普通字符串\n`in javascript '\\n' is a line-feed.`\n\n// 多行字符串\n`in javascript this is\n not legal.`\n\nconsole.log(`string text line 1\nstring text line 2`);\n\n// 字符串中嵌入变量\nlet name = \"bob\", time = \"today\";\n`hello ${name}, how are you ${time}?`\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。\n\nlet greeting = `\\`yo\\` world!`;\n\n\n1\n\n\n如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。\n\n$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`);\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。\n\n$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`.trim());\n\n\n1\n2\n3\n4\n5\n6\n\n\n模板字符串中嵌入变量，需要将变量名写在${}之中。\n\nfunction authorize(user, action) {\n  if (!user.hasprivilege(action)) {\n    throw new error(\n      // 传统写法为\n      // 'user '\n      // + user.name\n      // + ' is not authorized to do '\n      // + action\n      // + '.'\n      `user ${user.name} is not authorized to do ${action}.`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n大括号内部可以放入任意的 javascript 表达式，可以进行运算，以及引用对象属性。\n\nlet x = 1;\nlet y = 2;\n\n`${x} + ${y} = ${x + y}`\n// \"1 + 2 = 3\"\n\n`${x} + ${y * 2} = ${x + y * 2}`\n// \"1 + 4 = 5\"\n\nlet obj = {x: 1, y: 2};\n`${obj.x + obj.y}`\n// \"3\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n模板字符串之中还能调用函数。\n\nfunction fn() {\n  return \"hello world\";\n}\n\n`foo ${fn()} bar`\n// foo hello world bar\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的tostring方法。\n\n如果模板字符串中的变量没有声明，将报错。\n\n// 变量place没有声明\nlet msg = `hello, ${place}`;\n// 报错\n\n\n1\n2\n3\n\n\n由于模板字符串的大括号内部，就是执行 javascript 代码，因此如果大括号内部是一个字符串，将会原样输出。\n\n`hello ${'world'}`\n// \"hello world\"\n\n\n1\n2\n\n\n模板字符串甚至还能嵌套。\n\nconst tmpl = addrs => `\n  <table>\n  ${addrs.map(addr => `\n    <tr><td>${addr.first}</td></tr>\n    <tr><td>${addr.last}</td></tr>\n  `).join('')}\n  </table>\n`;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。\n\nconst data = [\n    { first: '<jane>', last: 'bond' },\n    { first: 'lars', last: '<croft>' },\n];\n\nconsole.log(tmpl(data));\n// <table>\n//\n//   <tr><td><jane></td></tr>\n//   <tr><td>bond</td></tr>\n//\n//   <tr><td>lars</td></tr>\n//   <tr><td><croft></td></tr>\n//\n// </table>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果需要引用模板字符串本身，在需要时执行，可以写成函数。\n\nlet func = (name) => `hello ${name}!`;\nfunc('jack') // \"hello jack!\"\n\n\n1\n2\n\n\n上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。\n\n\n# 实例：模板编译\n\n下面，我们来看一个通过模板字符串，生成正式模板的实例。\n\nlet template = `\n<ul>\n  <% for(let i=0; i < data.supplies.length; i++) { %>\n    <li><%= data.supplies[i] %></li>\n  <% } %>\n</ul>\n`;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码在模板字符串之中，放置了一个常规模板。该模板使用<%...%>放置 javascript 代码，使用<%= ... %>输出 javascript 表达式。\n\n怎么编译这个模板字符串呢？\n\n一种思路是将其转换为 javascript 表达式字符串。\n\necho('<ul>');\nfor(let i=0; i < data.supplies.length; i++) {\n  echo('<li>');\n  echo(data.supplies[i]);\n  echo('</li>');\n};\necho('</ul>');\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这个转换使用正则表达式就行了。\n\nlet evalexpr = /<%=(.+?)%>/g;\nlet expr = /<%([\\s\\s]+?)%>/g;\n\ntemplate = template\n  .replace(evalexpr, '`); \\n  echo( $1 ); \\n  echo(`')\n  .replace(expr, '`); \\n $1 \\n  echo(`');\n\ntemplate = 'echo(`' + template + '`);';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n然后，将template封装在一个函数里面返回，就可以了。\n\nlet script =\n`(function parse(data){\n  let output = \"\";\n\n  function echo(html){\n    output += html;\n  }\n\n  ${ template }\n\n  return output;\n})`;\n\nreturn script;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n将上面的内容拼装成一个模板编译函数compile。\n\nfunction compile(template){\n  const evalexpr = /<%=(.+?)%>/g;\n  const expr = /<%([\\s\\s]+?)%>/g;\n\n  template = template\n    .replace(evalexpr, '`); \\n  echo( $1 ); \\n  echo(`')\n    .replace(expr, '`); \\n $1 \\n  echo(`');\n\n  template = 'echo(`' + template + '`);';\n\n  let script =\n  `(function parse(data){\n    let output = \"\";\n\n    function echo(html){\n      output += html;\n    }\n\n    ${ template }\n\n    return output;\n  })`;\n\n  return script;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\ncompile函数的用法如下。\n\nlet parse = eval(compile(template));\ndiv.innerhtml = parse({ supplies: [ \"broom\", \"mop\", \"cleaner\" ] });\n//   <ul>\n//     <li>broom</li>\n//     <li>mop</li>\n//     <li>cleaner</li>\n//   </ul>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 标签模板\n\n模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。\n\nalert`123`\n// 等同于\nalert(123)\n\n\n1\n2\n3\n\n\n标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。\n\n但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。\n\nlet a = 5;\nlet b = 10;\n\ntag`hello ${ a + b } world ${ a * b }`;\n// 等同于\ntag(['hello ', ' world ', ''], 15, 50);\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。\n\n函数tag依次会接收到多个参数。\n\nfunction tag(stringarr, value1, value2){\n  // ...\n}\n\n// 等同于\n\nfunction tag(stringarr, ...values){\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ntag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。\n\ntag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。\n\ntag函数所有参数的实际值如下。\n\n * 第一个参数：['hello ', ' world ', '']\n * 第二个参数: 15\n * 第三个参数：50\n\n也就是说，tag函数实际上以下面的形式调用。\n\ntag(['hello ', ' world ', ''], 15, 50)\n\n\n1\n\n\n我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。\n\nlet a = 5;\nlet b = 10;\n\nfunction tag(s, v1, v2) {\n  console.log(s[0]);\n  console.log(s[1]);\n  console.log(s[2]);\n  console.log(v1);\n  console.log(v2);\n\n  return \"ok\";\n}\n\ntag`hello ${ a + b } world ${ a * b}`;\n// \"hello \"\n// \" world \"\n// \"\"\n// 15\n// 50\n// \"ok\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n下面是一个更复杂的例子。\n\nlet total = 30;\nlet msg = passthru`the total is ${total} (${total*1.05} with tax)`;\n\nfunction passthru(literals) {\n  let result = '';\n  let i = 0;\n\n  while (i < literals.length) {\n    result += literals[i++];\n    if (i < arguments.length) {\n      result += arguments[i];\n    }\n  }\n\n  return result;\n}\n\nmsg // \"the total is 30 (31.5 with tax)\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。\n\npassthru函数采用 rest 参数的写法如下。\n\nfunction passthru(literals, ...values) {\n  let output = \"\";\n  let index;\n  for (index = 0; index < values.length; index++) {\n    output += literals[index] + values[index];\n  }\n\n  output += literals[index]\n  return output;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n“标签模板”的一个重要应用，就是过滤 html 字符串，防止用户输入恶意内容。\n\nlet message =\n  saferhtml`<p>${sender} has sent you a message.</p>`;\n\nfunction saferhtml(templatedata) {\n  let s = templatedata[0];\n  for (let i = 1; i < arguments.length; i++) {\n    let arg = string(arguments[i]);\n\n    // escape special characters in the substitution.\n    s += arg.replace(/&/g, \"&amp;\")\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\");\n\n    // don't escape special characters in the template.\n    s += templatedata[i];\n  }\n  return s;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码中，sender变量往往是用户提供的，经过saferhtml函数处理，里面的特殊字符都会被转义。\n\nlet sender = '<script>alert(\"abc\")<\/script>'; // 恶意代码\nlet message = saferhtml`<p>${sender} has sent you a message.</p>`;\n\nmessage\n// <p>&lt;script&gt;alert(\"abc\")&lt;/script&gt; has sent you a message.</p>\n\n\n1\n2\n3\n4\n5\n\n\n标签模板的另一个应用，就是多语言转换（国际化处理）。\n\ni18n`welcome to ${sitename}, you are visitor number ${visitornumber}!`\n// \"欢迎访问xxx，您是第xxxx位访问者！\"\n\n\n1\n2\n\n\n模板字符串本身并不能取代 mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。\n\n// 下面的hashtemplate函数\n// 是一个自定义的模板处理函数\nlet libraryhtml = hashtemplate`\n  <ul>\n    #for book in ${mybooks}\n      <li><i>#{book.title}</i> by #{book.author}</li>\n    #end\n  </ul>\n`;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n除此之外，你甚至可以使用标签模板，在 javascript 语言之中嵌入其他语言。\n\njsx`\n  <div>\n    <input\n      ref='input'\n      onchange='${this.handlechange}'\n      defaultvalue='${this.state.value}' />\n      ${this.state.value}\n   </div>\n`\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的代码通过jsx函数，将一个 dom 字符串转为 react 对象。你可以在 github 找到jsx函数的具体实现。\n\n下面则是一个假想的例子，通过java函数，在 javascript 代码之中运行 java 代码。\n\njava`\nclass helloworldapp {\n  public static void main(string[] args) {\n    system.out.println(\"hello world!\"); // display the string.\n  }\n}\n`\nhelloworldapp.main();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。\n\nconsole.log`123`\n// [\"123\", raw: array[1]]\n\n\n1\n2\n\n\n上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。\n\n请看下面的例子。\n\ntag`first line\\nsecond line`\n\nfunction tag(strings) {\n  console.log(strings.raw[0]);\n  // strings.raw[0] 为 \"first line\\\\nsecond line\"\n  // 打印输出 \"first line\\nsecond line\"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[\"first line\\nsecond line\"]，那么strings.raw数组就是[\"first line\\\\nsecond line\"]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\\n视为\\\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。\n\n\n# 模板字符串的限制\n\n前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。\n\n举例来说，标签模板里面可以嵌入 latex 语言。\n\nfunction latex(strings) {\n  // ...\n}\n\nlet document = latex`\n\\newcommand{\\fun}{\\textbf{fun!}}  // 正常工作\n\\newcommand{\\unicode}{\\textbf{unicode!}} // 报错\n\\newcommand{\\xerxes}{\\textbf{king!}} // 报错\n\nbreve over the h goes \\u{h}ere // 报错\n`\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，变量document内嵌的模板字符串，对于 latex 语言来说完全是合法的，但是 javascript 引擎会报错。原因就在于字符串的转义。\n\n模板字符串会将\\u00ff和\\u{42}当作 unicode 字符进行转义，所以\\unicode解析时报错；而\\x56会被当作十六进制字符串转义，所以\\xerxes会报错。也就是说，\\u和\\x在 latex 里面有特殊含义，但是 javascript 将它们转义了。\n\n为了解决这个问题，es2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。\n\nfunction tag(strs) {\n  strs[0] === undefined\n  strs.raw[0] === \"\\\\unicode and \\\\u{55}\";\n}\ntag`\\unicode and \\u{55}`\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，javascript 引擎将第一个字符设置为undefined，但是raw属性依然可以得到原始字符串，因此tag函数还是可以对原字符串进行处理。\n\n注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。\n\nlet bad = `bad escape sequence: \\unicode`; // 报错\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Symbol",frontmatter:{title:"Symbol",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/02c86eb2792f3262",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/12.Symbol.html",relativePath:"《ES6 教程》笔记/12.Symbol.md",key:"v-1f5f8d8a",path:"/pages/02c86eb2792f3262/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:13},{level:2,title:"Symbol.prototype.description",slug:"symbol-prototype-description",normalizedTitle:"symbol.prototype.description",charIndex:1989},{level:2,title:"作为属性名的 Symbol",slug:"作为属性名的-symbol",normalizedTitle:"作为属性名的 symbol",charIndex:2361},{level:2,title:"实例：消除魔术字符串",slug:"实例-消除魔术字符串",normalizedTitle:"实例：消除魔术字符串",charIndex:4025},{level:2,title:"属性名的遍历",slug:"属性名的遍历",normalizedTitle:"属性名的遍历",charIndex:5150},{level:2,title:"Symbol.for()，Symbol.keyFor()",slug:"symbol-for-symbol-keyfor",normalizedTitle:"symbol.for()，symbol.keyfor()",charIndex:6973},{level:2,title:"实例：模块的 Singleton 模式",slug:"实例-模块的-singleton-模式",normalizedTitle:"实例：模块的 singleton 模式",charIndex:8487},{level:2,title:"内置的 Symbol 值",slug:"内置的-symbol-值",normalizedTitle:"内置的 symbol 值",charIndex:9655},{level:3,title:"Symbol.hasInstance",slug:"symbol-hasinstance",normalizedTitle:"symbol.hasinstance",charIndex:9733},{level:3,title:"Symbol.isConcatSpreadable",slug:"symbol-isconcatspreadable",normalizedTitle:"symbol.isconcatspreadable",charIndex:10473},{level:3,title:"Symbol.species",slug:"symbol-species",normalizedTitle:"symbol.species",charIndex:11782},{level:3,title:"Symbol.match",slug:"symbol-match",normalizedTitle:"symbol.match",charIndex:13261},{level:3,title:"Symbol.replace",slug:"symbol-replace",normalizedTitle:"symbol.replace",charIndex:13572},{level:3,title:"Symbol.search",slug:"symbol-search",normalizedTitle:"symbol.search",charIndex:13999},{level:3,title:"Symbol.split",slug:"symbol-split",normalizedTitle:"symbol.split",charIndex:14375},{level:3,title:"Symbol.iterator",slug:"symbol-iterator",normalizedTitle:"symbol.iterator",charIndex:15135},{level:3,title:"Symbol.toPrimitive",slug:"symbol-toprimitive",normalizedTitle:"symbol.toprimitive",charIndex:15768},{level:3,title:"Symbol.toStringTag",slug:"symbol-tostringtag",normalizedTitle:"symbol.tostringtag",charIndex:16374},{level:3,title:"Symbol.unscopables",slug:"symbol-unscopables",normalizedTitle:"symbol.unscopables",charIndex:17756}],excerpt:'<h1 id="symbol"><a class="header-anchor" href="#symbol">#</a> Symbol</h1>\n<h2 id="概述"><a class="header-anchor" href="#概述">#</a> 概述</h2>\n<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，<strong>保证每个属性的名字都是独一无二</strong>的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>\n',headersStr:"概述 Symbol.prototype.description 作为属性名的 Symbol 实例：消除魔术字符串 属性名的遍历 Symbol.for()，Symbol.keyFor() 实例：模块的 Singleton 模式 内置的 Symbol 值 Symbol.hasInstance Symbol.isConcatSpreadable Symbol.species Symbol.match Symbol.replace Symbol.search Symbol.split Symbol.iterator Symbol.toPrimitive Symbol.toStringTag Symbol.unscopables",content:"# Symbol\n\n\n# 概述\n\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。\n\nES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\n\nSymbol 值通过Symbol函数生成。这就是说，**对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。**凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n\nlet s = Symbol();\n\ntypeof s\n// \"symbol\"\n\n\n1\n2\n3\n4\n\n\n上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。\n\n注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。\n\nSymbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\n\nlet s1 = Symbol('foo');\nlet s2 = Symbol('bar');\n\ns1 // Symbol(foo)\ns2 // Symbol(bar)\n\ns1.toString() // \"Symbol(foo)\"\ns2.toString() // \"Symbol(bar)\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。\n\n如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。\n\nconst obj = {\n  toString() {\n    return 'abc';\n  }\n};\nconst sym = Symbol(obj);\nsym // Symbol(abc)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。\n\n// 没有参数的情况\nlet s1 = Symbol();\nlet s2 = Symbol();\n\ns1 === s2 // false\n\n// 有参数的情况\nlet s1 = Symbol('foo');\nlet s2 = Symbol('foo');\n\ns1 === s2 // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。\n\nSymbol 值不能与其他类型的值进行运算，会报错。\n\nlet sym = Symbol('My symbol');\n\n\"your symbol is \" + sym\n// TypeError: can't convert symbol to string\n`your symbol is ${sym}`\n// TypeError: can't convert symbol to string\n\n\n1\n2\n3\n4\n5\n6\n\n\n但是，Symbol 值可以显式转为字符串。\n\nlet sym = Symbol('My symbol');\n\nString(sym) // 'Symbol(My symbol)'\nsym.toString() // 'Symbol(My symbol)'\n\n\n1\n2\n3\n4\n\n\n另外，Symbol 值也可以转为布尔值，但是不能转为数值。\n\nlet sym = Symbol();\nBoolean(sym) // true\n!sym  // false\n\nif (sym) {\n  // ...\n}\n\nNumber(sym) // TypeError\nsym + 2 // TypeError\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Symbol.prototype.description\n\n创建 Symbol 的时候，可以添加一个描述。\n\nconst sym = Symbol('foo');\n\n\n1\n\n\n上面代码中，sym的描述就是字符串foo。\n\n但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。\n\nconst sym = Symbol('foo');\n\nString(sym) // \"Symbol(foo)\"\nsym.toString() // \"Symbol(foo)\"\n\n\n1\n2\n3\n4\n\n\n上面的用法不是很方便。ES2019 提供了一个实例属性description，直接返回 Symbol 的描述。\n\nconst sym = Symbol('foo');\n\nsym.description // \"foo\"\n\n\n1\n2\n3\n\n\n\n# 作为属性名的 Symbol\n\n由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。\n\nlet mySymbol = Symbol();\n\n// 第一种写法\nlet a = {};\na[mySymbol] = 'Hello!';\n\n// 第二种写法\nlet a = {\n  [mySymbol]: 'Hello!'\n};\n\n// 第三种写法\nlet a = {};\nObject.defineProperty(a, mySymbol, { value: 'Hello!' });\n\n// 以上写法都得到同样结果\na[mySymbol] // \"Hello!\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值。\n\n注意，Symbol 值作为对象属性名时，不能用点运算符。\n\nconst mySymbol = Symbol();\nconst a = {};\n\na.mySymbol = 'Hello!';\na[mySymbol] // undefined\na['mySymbol'] // \"Hello!\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。\n\n同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。\n\nlet s = Symbol();\n\nlet obj = {\n  [s]: function (arg) { ... }\n};\n\nobj[s](123);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个 Symbol 值。\n\n采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。\n\nlet obj = {\n  [s](arg) { ... }\n};\n\n\n1\n2\n3\n\n\nSymbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。\n\nconst log = {};\n\nlog.levels = {\n  DEBUG: Symbol('debug'),\n  INFO: Symbol('info'),\n  WARN: Symbol('warn')\n};\nconsole.log(log.levels.DEBUG, 'debug message');\nconsole.log(log.levels.INFO, 'info message');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n下面是另外一个例子。\n\nconst COLOR_RED    = Symbol();\nconst COLOR_GREEN  = Symbol();\n\nfunction getComplement(color) {\n  switch (color) {\n    case COLOR_RED:\n      return COLOR_GREEN;\n    case COLOR_GREEN:\n      return COLOR_RED;\n    default:\n      throw new Error('Undefined color');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。\n\n还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。\n\n\n# 实例：消除魔术字符串\n\n魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。\n\nfunction getArea(shape, options) {\n  let area = 0;\n\n  switch (shape) {\n    case 'Triangle': // 魔术字符串\n      area = .5 * options.width * options.height;\n      break;\n    /* ... more code ... */\n  }\n\n  return area;\n}\n\ngetArea('Triangle', { width: 100, height: 100 }); // 魔术字符串\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，字符串Triangle就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。\n\n> 笔记：\n> \n> Triangle字符串在代码中出现多次，如果后期想修改这个字符串需要修改很多处，不利于维护。\n\n常用的消除魔术字符串的方法，就是把它写成一个变量。\n\nconst shapeType = {\n  triangle: 'Triangle'\n};\n\nfunction getArea(shape, options) {\n  let area = 0;\n  switch (shape) {\n    case shapeType.triangle:\n      area = .5 * options.width * options.height;\n      break;\n  }\n  return area;\n}\n\ngetArea(shapeType.triangle, { width: 100, height: 100 });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，我们把Triangle写成shapeType对象的triangle属性，这样就消除了强耦合。\n\n如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用 Symbol 值。\n\nconst shapeType = {\n  triangle: Symbol()\n};\n\n\n1\n2\n3\n\n\n上面代码中，除了将shapeType.triangle的值设为一个 Symbol，其他地方都不用修改。\n\n\n# 属性名的遍历\n\nSymbol 作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。\n\n但是，它也不是私有属性，有一个**Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名**。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。\n\nconst obj = {};\nlet a = Symbol('a');\nlet b = Symbol('b');\n\nobj[a] = 'Hello';\nobj[b] = 'World';\n\nconst objectSymbols = Object.getOwnPropertySymbols(obj);\n\nobjectSymbols\n// [Symbol(a), Symbol(b)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码是Object.getOwnPropertySymbols()方法的示例，可以获取所有 Symbol 属性名。\n\n下面是另一个例子，Object.getOwnPropertySymbols()方法与for...in循环、Object.getOwnPropertyNames方法进行对比的例子。\n\nconst obj = {};\nconst foo = Symbol('foo');\n\nobj[foo] = 'bar';\n\nfor (let i in obj) {\n  console.log(i); // 无输出\n}\n\nObject.getOwnPropertyNames(obj) // []\nObject.getOwnPropertySymbols(obj) // [Symbol(foo)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，使用for...in循环和Object.getOwnPropertyNames()方法都得不到 Symbol 键名，需要使用Object.getOwnPropertySymbols()方法。\n\n另一个新的 API，Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。\n\nlet obj = {\n  [Symbol('my_key')]: 1,\n  enum: 2,\n  nonEnum: 3\n};\n\nReflect.ownKeys(obj)\n//  [\"enum\", \"nonEnum\", Symbol(my_key)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。\n\nlet size = Symbol('size');\n\nclass Collection {\n  constructor() {\n    this[size] = 0;\n  }\n\n  add(item) {\n    this[this[size]] = item;\n    this[size]++;\n  }\n\n  static sizeOf(instance) {\n    return instance[size];\n  }\n}\n\nlet x = new Collection();\nCollection.sizeOf(x) // 0\n\nx.add('foo');\nCollection.sizeOf(x) // 1\n\nObject.keys(x) // ['0']\nObject.getOwnPropertyNames(x) // ['0']\nObject.getOwnPropertySymbols(x) // [Symbol(size)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n上面代码中，对象x的size属性是一个 Symbol 值，所以Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。\n\n\n# Symbol.for()，Symbol.keyFor()\n\n有时，我们希望重新使用同一个 Symbol 值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。\n\nlet s1 = Symbol.for('foo');\nlet s2 = Symbol.for('foo');\n\ns1 === s2 // true\n\n\n1\n2\n3\n4\n\n\n上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。\n\nSymbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(\"cat\")30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(\"cat\")30 次，会返回 30 个不同的 Symbol 值。\n\nSymbol.for(\"bar\") === Symbol.for(\"bar\")\n// true\n\nSymbol(\"bar\") === Symbol(\"bar\")\n// false\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。\n\nSymbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。\n\nlet s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1) // \"foo\"\n\nlet s2 = Symbol(\"foo\");\nSymbol.keyFor(s2) // undefined\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。\n\n注意，Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。\n\nfunction foo() {\n  return Symbol.for('bar');\n}\n\nconst x = foo();\nconst y = Symbol.for('bar');\nconsole.log(x === y); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，Symbol.for('bar')是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行Symbol.for('bar')可以取到这个 Symbol 值。\n\nSymbol.for()的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。\n\niframe = document.createElement('iframe');\niframe.src = String(window.location);\ndocument.body.appendChild(iframe);\n\niframe.contentWindow.Symbol.for('foo') === Symbol.for('foo')\n// true\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。\n\n\n# 实例：模块的 Singleton 模式\n\nSingleton 模式指的是调用一个类，任何时候返回的都是同一个实例。\n\n对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？\n\n很容易想到，可以把实例放到顶层对象global。\n\n// mod.js\nfunction A() {\n  this.foo = 'hello';\n}\n\nif (!global._foo) {\n  global._foo = new A();\n}\n\nmodule.exports = global._foo;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n然后，加载上面的mod.js。\n\nconst a = require('./mod.js');\nconsole.log(a.foo);\n\n\n1\n2\n\n\n上面代码中，变量a任何时候加载的都是A的同一个实例。\n\n但是，这里有一个问题，全局变量global._foo是可写的，任何文件都可以修改。\n\nglobal._foo = { foo: 'world' };\n\nconst a = require('./mod.js');\nconsole.log(a.foo);\n\n\n1\n2\n3\n4\n\n\n上面的代码，会使得加载mod.js的脚本都失真。\n\n为了防止这种情况出现，我们就可以使用 Symbol。\n\n// mod.js\nconst FOO_KEY = Symbol.for('foo');\n\nfunction A() {\n  this.foo = 'hello';\n}\n\nif (!global[FOO_KEY]) {\n  global[FOO_KEY] = new A();\n}\n\nmodule.exports = global[FOO_KEY];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写。\n\nglobal[Symbol.for('foo')] = { foo: 'world' };\n\nconst a = require('./mod.js');\n\n\n1\n2\n3\n\n\n如果键名使用Symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。\n\n// mod.js\nconst FOO_KEY = Symbol('foo');\n\n// 后面代码相同 ……\n\n\n1\n2\n3\n4\n\n\n上面代码将导致其他脚本都无法引用FOO_KEY。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的FOO_KEY都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。\n\n\n# 内置的 Symbol 值\n\n除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。\n\n\n# Symbol.hasInstance\n\n对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。\n\nclass MyClass {\n  [Symbol.hasInstance](foo) {\n    return foo instanceof Array;\n  }\n}\n\n[1, 2, 3] instanceof new MyClass() // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，MyClass是一个类，new MyClass()会返回一个实例。该实例的Symbol.hasInstance方法，会在进行instanceof运算时自动调用，判断左侧的运算子是否为Array的实例。\n\n下面是另一个例子。\n\nclass Even {\n  static [Symbol.hasInstance](obj) {\n    return Number(obj) % 2 === 0;\n  }\n}\n\n// 等同于\nconst Even = {\n  [Symbol.hasInstance](obj) {\n    return Number(obj) % 2 === 0;\n  }\n};\n\n1 instanceof Even // false\n2 instanceof Even // true\n12345 instanceof Even // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Symbol.isConcatSpreadable\n\n对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。\n\nlet arr1 = ['c', 'd'];\n['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']\narr1[Symbol.isConcatSpreadable] // undefined\n\nlet arr2 = ['c', 'd'];\narr2[Symbol.isConcatSpreadable] = false;\n['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码说明，数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。\n\n类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。\n\nlet obj = {length: 2, 0: 'c', 1: 'd'};\n['a', 'b'].concat(obj, 'e') // ['a', 'b', obj, 'e']\n\nobj[Symbol.isConcatSpreadable] = true;\n['a', 'b'].concat(obj, 'e') // ['a', 'b', 'c', 'd', 'e']\n\n\n1\n2\n3\n4\n5\n\n\nSymbol.isConcatSpreadable属性也可以定义在类里面。\n\nclass A1 extends Array {\n  constructor(args) {\n    super(args);\n    this[Symbol.isConcatSpreadable] = true;\n  }\n}\nclass A2 extends Array {\n  constructor(args) {\n    super(args);\n  }\n  get [Symbol.isConcatSpreadable] () {\n    return false;\n  }\n}\nlet a1 = new A1();\na1[0] = 3;\na1[1] = 4;\nlet a2 = new A2();\na2[0] = 5;\na2[1] = 6;\n[1, 2].concat(a1).concat(a2)\n// [1, 2, 3, 4, [5, 6]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n上面代码中，类A1是可展开的，类A2是不可展开的，所以使用concat时有不一样的结果。\n\n注意，Symbol.isConcatSpreadable的位置差异，A1是定义在实例上，A2是定义在类本身，效果相同。\n\n\n# Symbol.species\n\n对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。\n\nclass MyArray extends Array {\n}\n\nconst a = new MyArray(1, 2, 3);\nconst b = a.map(x => x);\nconst c = a.filter(x => x > 1);\n\nb instanceof MyArray // true\nc instanceof MyArray // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，子类MyArray继承了父类Array，a是MyArray的实例，b和c是a的衍生对象。你可能会认为，b和c都是调用数组方法生成的，所以应该是数组（Array的实例），但实际上它们也是MyArray的实例。\n\nSymbol.species属性就是为了解决这个问题而提供的。现在，我们可以为MyArray设置Symbol.species属性。\n\nclass MyArray extends Array {\n  static get [Symbol.species]() { return Array; }\n}\n\n\n1\n2\n3\n\n\n上面代码中，由于定义了Symbol.species属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义Symbol.species属性要采用get取值器。默认的Symbol.species属性等同于下面的写法。\n\nstatic get [Symbol.species]() {\n  return this;\n}\n\n\n1\n2\n3\n\n\n现在，再来看前面的例子。\n\nclass MyArray extends Array {\n  static get [Symbol.species]() { return Array; }\n}\n\nconst a = new MyArray();\nconst b = a.map(x => x);\n\nb instanceof MyArray // false\nb instanceof Array // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，a.map(x => x)生成的衍生对象，就不是MyArray的实例，而直接就是Array的实例。\n\n再看一个例子。\n\nclass T1 extends Promise {\n}\n\nclass T2 extends Promise {\n  static get [Symbol.species]() {\n    return Promise;\n  }\n}\n\nnew T1(r => r()).then(v => v) instanceof T1 // true\nnew T2(r => r()).then(v => v) instanceof T2 // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，T2定义了Symbol.species属性，T1没有。结果就导致了创建衍生对象时（then方法），T1调用的是自身的构造方法，而T2调用的是Promise的构造方法。\n\n总之，Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。\n\n\n# Symbol.match\n\n对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。\n\nString.prototype.match(regexp)\n// 等同于\nregexp[Symbol.match](this)\n\nclass MyMatcher {\n  [Symbol.match](string) {\n    return 'hello world'.indexOf(string);\n  }\n}\n\n'e'.match(new MyMatcher()) // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Symbol.replace\n\n对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。\n\nString.prototype.replace(searchValue, replaceValue)\n// 等同于\nsearchValue[Symbol.replace](this, replaceValue)\n\n\n1\n2\n3\n\n\n下面是一个例子。\n\nconst x = {};\nx[Symbol.replace] = (...s) => console.log(s);\n\n'Hello'.replace(x, 'World') // [\"Hello\", \"World\"]\n\n\n1\n2\n3\n4\n\n\nSymbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象，上面例子是Hello，第二个参数是替换后的值，上面例子是World。\n\n\n# Symbol.search\n\n对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。\n\nString.prototype.search(regexp)\n// 等同于\nregexp[Symbol.search](this)\n\nclass MySearch {\n  constructor(value) {\n    this.value = value;\n  }\n  [Symbol.search](string) {\n    return string.indexOf(this.value);\n  }\n}\n'foobar'.search(new MySearch('foo')) // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Symbol.split\n\n对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。\n\nString.prototype.split(separator, limit)\n// 等同于\nseparator[Symbol.split](this, limit)\n\n\n1\n2\n3\n\n\n下面是一个例子。\n\nclass MySplitter {\n  constructor(value) {\n    this.value = value;\n  }\n  [Symbol.split](string) {\n    let index = string.indexOf(this.value);\n    if (index === -1) {\n      return string;\n    }\n    return [\n      string.substr(0, index),\n      string.substr(index + this.value.length)\n    ];\n  }\n}\n\n'foobar'.split(new MySplitter('foo'))\n// ['', 'bar']\n\n'foobar'.split(new MySplitter('bar'))\n// ['foo', '']\n\n'foobar'.split(new MySplitter('baz'))\n// 'foobar'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面方法使用Symbol.split方法，重新定义了字符串对象的split方法的行为，\n\n\n# Symbol.iterator\n\n对象的Symbol.iterator属性，指向该对象的默认遍历器方法。\n\nconst myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myIterable] // [1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for...of 循环》一章。\n\nclass Collection {\n  *[Symbol.iterator]() {\n    let i = 0;\n    while(this[i] !== undefined) {\n      yield this[i];\n      ++i;\n    }\n  }\n}\n\nlet myCollection = new Collection();\nmyCollection[0] = 1;\nmyCollection[1] = 2;\n\nfor(let value of myCollection) {\n  console.log(value);\n}\n// 1\n// 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Symbol.toPrimitive\n\n对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。\n\nSymbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。\n\n * Number：该场合需要转成数值\n * String：该场合需要转成字符串\n * Default：该场合可以转成数值，也可以转成字符串\n\nlet obj = {\n  [Symbol.toPrimitive](hint) {\n    switch (hint) {\n      case 'number':\n        return 123;\n      case 'string':\n        return 'str';\n      case 'default':\n        return 'default';\n      default:\n        throw new Error();\n     }\n   }\n};\n\n2 * obj // 246\n3 + obj // '3default'\nobj == 'default' // true\nString(obj) // 'str'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Symbol.toStringTag\n\n对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。\n\n// 例一\n({[Symbol.toStringTag]: 'Foo'}.toString())\n// \"[object Foo]\"\n\n// 例二\nclass Collection {\n  get [Symbol.toStringTag]() {\n    return 'xxx';\n  }\n}\nlet x = new Collection();\nObject.prototype.toString.call(x) // \"[object xxx]\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nES6 新增内置对象的Symbol.toStringTag属性值如下。\n\n * JSON[Symbol.toStringTag]：'JSON'\n * Math[Symbol.toStringTag]：'Math'\n * Module 对象M[Symbol.toStringTag]：'Module'\n * ArrayBuffer.prototype[Symbol.toStringTag]：'ArrayBuffer'\n * DataView.prototype[Symbol.toStringTag]：'DataView'\n * Map.prototype[Symbol.toStringTag]：'Map'\n * Promise.prototype[Symbol.toStringTag]：'Promise'\n * Set.prototype[Symbol.toStringTag]：'Set'\n * %TypedArray%.prototype[Symbol.toStringTag]：'Uint8Array'等\n * WeakMap.prototype[Symbol.toStringTag]：'WeakMap'\n * WeakSet.prototype[Symbol.toStringTag]：'WeakSet'\n * %MapIteratorPrototype%[Symbol.toStringTag]：'Map Iterator'\n * %SetIteratorPrototype%[Symbol.toStringTag]：'Set Iterator'\n * %StringIteratorPrototype%[Symbol.toStringTag]：'String Iterator'\n * Symbol.prototype[Symbol.toStringTag]：'Symbol'\n * Generator.prototype[Symbol.toStringTag]：'Generator'\n * GeneratorFunction.prototype[Symbol.toStringTag]：'GeneratorFunction'\n\n\n# Symbol.unscopables\n\n对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。\n\nArray.prototype[Symbol.unscopables]\n// {\n//   copyWithin: true,\n//   entries: true,\n//   fill: true,\n//   find: true,\n//   findIndex: true,\n//   includes: true,\n//   keys: true\n// }\n\nObject.keys(Array.prototype[Symbol.unscopables])\n// ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'includes', 'keys']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码说明，数组有 7 个属性，会被with命令排除。\n\n// 没有 unscopables 时\nclass MyClass {\n  foo() { return 1; }\n}\n\nvar foo = function () { return 2; };\n\nwith (MyClass.prototype) {\n  foo(); // 1\n}\n\n// 有 unscopables 时\nclass MyClass {\n  foo() { return 1; }\n  get [Symbol.unscopables]() {\n    return { foo: true };\n  }\n}\n\nvar foo = function () { return 2; };\n\nwith (MyClass.prototype) {\n  foo(); // 2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码通过指定Symbol.unscopables属性，使得with语法块不会在当前作用域寻找foo属性，即foo将指向外层作用域的变量。",normalizedContent:"# symbol\n\n\n# 概述\n\nes5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 es6 引入symbol的原因。\n\nes6 引入了一种新的原始数据类型symbol，表示独一无二的值。它是 javascript 语言的第七种数据类型，前六种是：undefined、null、布尔值（boolean）、字符串（string）、数值（number）、对象（object）。\n\nsymbol 值通过symbol函数生成。这就是说，**对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 symbol 类型。**凡是属性名属于 symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n\nlet s = symbol();\n\ntypeof s\n// \"symbol\"\n\n\n1\n2\n3\n4\n\n\n上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 symbol 数据类型，而不是字符串之类的其他类型。\n\n注意，symbol函数前不能使用new命令，否则会报错。这是因为生成的 symbol 是一个原始类型的值，不是对象。也就是说，由于 symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。\n\nsymbol函数可以接受一个字符串作为参数，表示对 symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\n\nlet s1 = symbol('foo');\nlet s2 = symbol('bar');\n\ns1 // symbol(foo)\ns2 // symbol(bar)\n\ns1.tostring() // \"symbol(foo)\"\ns2.tostring() // \"symbol(bar)\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，s1和s2是两个 symbol 值。如果不加参数，它们在控制台的输出都是symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。\n\n如果 symbol 的参数是一个对象，就会调用该对象的tostring方法，将其转为字符串，然后才生成一个 symbol 值。\n\nconst obj = {\n  tostring() {\n    return 'abc';\n  }\n};\nconst sym = symbol(obj);\nsym // symbol(abc)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，symbol函数的参数只是表示对当前 symbol 值的描述，因此相同参数的symbol函数的返回值是不相等的。\n\n// 没有参数的情况\nlet s1 = symbol();\nlet s2 = symbol();\n\ns1 === s2 // false\n\n// 有参数的情况\nlet s1 = symbol('foo');\nlet s2 = symbol('foo');\n\ns1 === s2 // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，s1和s2都是symbol函数的返回值，而且参数相同，但是它们是不相等的。\n\nsymbol 值不能与其他类型的值进行运算，会报错。\n\nlet sym = symbol('my symbol');\n\n\"your symbol is \" + sym\n// typeerror: can't convert symbol to string\n`your symbol is ${sym}`\n// typeerror: can't convert symbol to string\n\n\n1\n2\n3\n4\n5\n6\n\n\n但是，symbol 值可以显式转为字符串。\n\nlet sym = symbol('my symbol');\n\nstring(sym) // 'symbol(my symbol)'\nsym.tostring() // 'symbol(my symbol)'\n\n\n1\n2\n3\n4\n\n\n另外，symbol 值也可以转为布尔值，但是不能转为数值。\n\nlet sym = symbol();\nboolean(sym) // true\n!sym  // false\n\nif (sym) {\n  // ...\n}\n\nnumber(sym) // typeerror\nsym + 2 // typeerror\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# symbol.prototype.description\n\n创建 symbol 的时候，可以添加一个描述。\n\nconst sym = symbol('foo');\n\n\n1\n\n\n上面代码中，sym的描述就是字符串foo。\n\n但是，读取这个描述需要将 symbol 显式转为字符串，即下面的写法。\n\nconst sym = symbol('foo');\n\nstring(sym) // \"symbol(foo)\"\nsym.tostring() // \"symbol(foo)\"\n\n\n1\n2\n3\n4\n\n\n上面的用法不是很方便。es2019 提供了一个实例属性description，直接返回 symbol 的描述。\n\nconst sym = symbol('foo');\n\nsym.description // \"foo\"\n\n\n1\n2\n3\n\n\n\n# 作为属性名的 symbol\n\n由于每一个 symbol 值都是不相等的，这意味着 symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。\n\nlet mysymbol = symbol();\n\n// 第一种写法\nlet a = {};\na[mysymbol] = 'hello!';\n\n// 第二种写法\nlet a = {\n  [mysymbol]: 'hello!'\n};\n\n// 第三种写法\nlet a = {};\nobject.defineproperty(a, mysymbol, { value: 'hello!' });\n\n// 以上写法都得到同样结果\na[mysymbol] // \"hello!\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码通过方括号结构和object.defineproperty，将对象的属性名指定为一个 symbol 值。\n\n注意，symbol 值作为对象属性名时，不能用点运算符。\n\nconst mysymbol = symbol();\nconst a = {};\n\na.mysymbol = 'hello!';\na[mysymbol] // undefined\na['mysymbol'] // \"hello!\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，因为点运算符后面总是字符串，所以不会读取mysymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 symbol 值。\n\n同理，在对象的内部，使用 symbol 值定义属性时，symbol 值必须放在方括号之中。\n\nlet s = symbol();\n\nlet obj = {\n  [s]: function (arg) { ... }\n};\n\nobj[s](123);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个 symbol 值。\n\n采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。\n\nlet obj = {\n  [s](arg) { ... }\n};\n\n\n1\n2\n3\n\n\nsymbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。\n\nconst log = {};\n\nlog.levels = {\n  debug: symbol('debug'),\n  info: symbol('info'),\n  warn: symbol('warn')\n};\nconsole.log(log.levels.debug, 'debug message');\nconsole.log(log.levels.info, 'info message');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n下面是另外一个例子。\n\nconst color_red    = symbol();\nconst color_green  = symbol();\n\nfunction getcomplement(color) {\n  switch (color) {\n    case color_red:\n      return color_green;\n    case color_green:\n      return color_red;\n    default:\n      throw new error('undefined color');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n常量使用 symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。\n\n还有一点需要注意，symbol 值作为属性名时，该属性还是公开属性，不是私有属性。\n\n\n# 实例：消除魔术字符串\n\n魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。\n\nfunction getarea(shape, options) {\n  let area = 0;\n\n  switch (shape) {\n    case 'triangle': // 魔术字符串\n      area = .5 * options.width * options.height;\n      break;\n    /* ... more code ... */\n  }\n\n  return area;\n}\n\ngetarea('triangle', { width: 100, height: 100 }); // 魔术字符串\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，字符串triangle就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。\n\n> 笔记：\n> \n> triangle字符串在代码中出现多次，如果后期想修改这个字符串需要修改很多处，不利于维护。\n\n常用的消除魔术字符串的方法，就是把它写成一个变量。\n\nconst shapetype = {\n  triangle: 'triangle'\n};\n\nfunction getarea(shape, options) {\n  let area = 0;\n  switch (shape) {\n    case shapetype.triangle:\n      area = .5 * options.width * options.height;\n      break;\n  }\n  return area;\n}\n\ngetarea(shapetype.triangle, { width: 100, height: 100 });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，我们把triangle写成shapetype对象的triangle属性，这样就消除了强耦合。\n\n如果仔细分析，可以发现shapetype.triangle等于哪个值并不重要，只要确保不会跟其他shapetype属性的值冲突即可。因此，这里就很适合改用 symbol 值。\n\nconst shapetype = {\n  triangle: symbol()\n};\n\n\n1\n2\n3\n\n\n上面代码中，除了将shapetype.triangle的值设为一个 symbol，其他地方都不用修改。\n\n\n# 属性名的遍历\n\nsymbol 作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被object.keys()、object.getownpropertynames()、json.stringify()返回。\n\n但是，它也不是私有属性，有一个**object.getownpropertysymbols()方法，可以获取指定对象的所有 symbol 属性名**。该方法返回一个数组，成员是当前对象的所有用作属性名的 symbol 值。\n\nconst obj = {};\nlet a = symbol('a');\nlet b = symbol('b');\n\nobj[a] = 'hello';\nobj[b] = 'world';\n\nconst objectsymbols = object.getownpropertysymbols(obj);\n\nobjectsymbols\n// [symbol(a), symbol(b)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码是object.getownpropertysymbols()方法的示例，可以获取所有 symbol 属性名。\n\n下面是另一个例子，object.getownpropertysymbols()方法与for...in循环、object.getownpropertynames方法进行对比的例子。\n\nconst obj = {};\nconst foo = symbol('foo');\n\nobj[foo] = 'bar';\n\nfor (let i in obj) {\n  console.log(i); // 无输出\n}\n\nobject.getownpropertynames(obj) // []\nobject.getownpropertysymbols(obj) // [symbol(foo)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，使用for...in循环和object.getownpropertynames()方法都得不到 symbol 键名，需要使用object.getownpropertysymbols()方法。\n\n另一个新的 api，reflect.ownkeys()方法可以返回所有类型的键名，包括常规键名和 symbol 键名。\n\nlet obj = {\n  [symbol('my_key')]: 1,\n  enum: 2,\n  nonenum: 3\n};\n\nreflect.ownkeys(obj)\n//  [\"enum\", \"nonenum\", symbol(my_key)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n由于以 symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。\n\nlet size = symbol('size');\n\nclass collection {\n  constructor() {\n    this[size] = 0;\n  }\n\n  add(item) {\n    this[this[size]] = item;\n    this[size]++;\n  }\n\n  static sizeof(instance) {\n    return instance[size];\n  }\n}\n\nlet x = new collection();\ncollection.sizeof(x) // 0\n\nx.add('foo');\ncollection.sizeof(x) // 1\n\nobject.keys(x) // ['0']\nobject.getownpropertynames(x) // ['0']\nobject.getownpropertysymbols(x) // [symbol(size)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n上面代码中，对象x的size属性是一个 symbol 值，所以object.keys(x)、object.getownpropertynames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。\n\n\n# symbol.for()，symbol.keyfor()\n\n有时，我们希望重新使用同一个 symbol 值，symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 symbol 值。如果有，就返回这个 symbol 值，否则就新建一个以该字符串为名称的 symbol 值，并将其注册到全局。\n\nlet s1 = symbol.for('foo');\nlet s2 = symbol.for('foo');\n\ns1 === s2 // true\n\n\n1\n2\n3\n4\n\n\n上面代码中，s1和s2都是 symbol 值，但是它们都是同样参数的symbol.for方法生成的，所以实际上是同一个值。\n\nsymbol.for()与symbol()这两种写法，都会生成新的 symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。symbol.for()不会每次调用就返回一个新的 symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用symbol.for(\"cat\")30 次，每次都会返回同一个 symbol 值，但是调用symbol(\"cat\")30 次，会返回 30 个不同的 symbol 值。\n\nsymbol.for(\"bar\") === symbol.for(\"bar\")\n// true\n\nsymbol(\"bar\") === symbol(\"bar\")\n// false\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，由于symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。\n\nsymbol.keyfor()方法返回一个已登记的 symbol 类型值的key。\n\nlet s1 = symbol.for(\"foo\");\nsymbol.keyfor(s1) // \"foo\"\n\nlet s2 = symbol(\"foo\");\nsymbol.keyfor(s2) // undefined\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，变量s2属于未登记的 symbol 值，所以返回undefined。\n\n注意，symbol.for()为 symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。\n\nfunction foo() {\n  return symbol.for('bar');\n}\n\nconst x = foo();\nconst y = symbol.for('bar');\nconsole.log(x === y); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，symbol.for('bar')是函数内部运行的，但是生成的 symbol 值是登记在全局环境的。所以，第二次运行symbol.for('bar')可以取到这个 symbol 值。\n\nsymbol.for()的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。\n\niframe = document.createelement('iframe');\niframe.src = string(window.location);\ndocument.body.appendchild(iframe);\n\niframe.contentwindow.symbol.for('foo') === symbol.for('foo')\n// true\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，iframe 窗口生成的 symbol 值，可以在主页面得到。\n\n\n# 实例：模块的 singleton 模式\n\nsingleton 模式指的是调用一个类，任何时候返回的都是同一个实例。\n\n对于 node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？\n\n很容易想到，可以把实例放到顶层对象global。\n\n// mod.js\nfunction a() {\n  this.foo = 'hello';\n}\n\nif (!global._foo) {\n  global._foo = new a();\n}\n\nmodule.exports = global._foo;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n然后，加载上面的mod.js。\n\nconst a = require('./mod.js');\nconsole.log(a.foo);\n\n\n1\n2\n\n\n上面代码中，变量a任何时候加载的都是a的同一个实例。\n\n但是，这里有一个问题，全局变量global._foo是可写的，任何文件都可以修改。\n\nglobal._foo = { foo: 'world' };\n\nconst a = require('./mod.js');\nconsole.log(a.foo);\n\n\n1\n2\n3\n4\n\n\n上面的代码，会使得加载mod.js的脚本都失真。\n\n为了防止这种情况出现，我们就可以使用 symbol。\n\n// mod.js\nconst foo_key = symbol.for('foo');\n\nfunction a() {\n  this.foo = 'hello';\n}\n\nif (!global[foo_key]) {\n  global[foo_key] = new a();\n}\n\nmodule.exports = global[foo_key];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，可以保证global[foo_key]不会被无意间覆盖，但还是可以被改写。\n\nglobal[symbol.for('foo')] = { foo: 'world' };\n\nconst a = require('./mod.js');\n\n\n1\n2\n3\n\n\n如果键名使用symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。\n\n// mod.js\nconst foo_key = symbol('foo');\n\n// 后面代码相同 ……\n\n\n1\n2\n3\n4\n\n\n上面代码将导致其他脚本都无法引用foo_key。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的foo_key都是不一样的。虽然 node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。\n\n\n# 内置的 symbol 值\n\n除了定义自己使用的 symbol 值以外，es6 还提供了 11 个内置的 symbol 值，指向语言内部使用的方法。\n\n\n# symbol.hasinstance\n\n对象的symbol.hasinstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof foo在语言内部，实际调用的是foo[symbol.hasinstance](foo)。\n\nclass myclass {\n  [symbol.hasinstance](foo) {\n    return foo instanceof array;\n  }\n}\n\n[1, 2, 3] instanceof new myclass() // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，myclass是一个类，new myclass()会返回一个实例。该实例的symbol.hasinstance方法，会在进行instanceof运算时自动调用，判断左侧的运算子是否为array的实例。\n\n下面是另一个例子。\n\nclass even {\n  static [symbol.hasinstance](obj) {\n    return number(obj) % 2 === 0;\n  }\n}\n\n// 等同于\nconst even = {\n  [symbol.hasinstance](obj) {\n    return number(obj) % 2 === 0;\n  }\n};\n\n1 instanceof even // false\n2 instanceof even // true\n12345 instanceof even // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# symbol.isconcatspreadable\n\n对象的symbol.isconcatspreadable属性等于一个布尔值，表示该对象用于array.prototype.concat()时，是否可以展开。\n\nlet arr1 = ['c', 'd'];\n['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']\narr1[symbol.isconcatspreadable] // undefined\n\nlet arr2 = ['c', 'd'];\narr2[symbol.isconcatspreadable] = false;\n['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码说明，数组的默认行为是可以展开，symbol.isconcatspreadable默认等于undefined。该属性等于true时，也有展开的效果。\n\n类似数组的对象正好相反，默认不展开。它的symbol.isconcatspreadable属性设为true，才可以展开。\n\nlet obj = {length: 2, 0: 'c', 1: 'd'};\n['a', 'b'].concat(obj, 'e') // ['a', 'b', obj, 'e']\n\nobj[symbol.isconcatspreadable] = true;\n['a', 'b'].concat(obj, 'e') // ['a', 'b', 'c', 'd', 'e']\n\n\n1\n2\n3\n4\n5\n\n\nsymbol.isconcatspreadable属性也可以定义在类里面。\n\nclass a1 extends array {\n  constructor(args) {\n    super(args);\n    this[symbol.isconcatspreadable] = true;\n  }\n}\nclass a2 extends array {\n  constructor(args) {\n    super(args);\n  }\n  get [symbol.isconcatspreadable] () {\n    return false;\n  }\n}\nlet a1 = new a1();\na1[0] = 3;\na1[1] = 4;\nlet a2 = new a2();\na2[0] = 5;\na2[1] = 6;\n[1, 2].concat(a1).concat(a2)\n// [1, 2, 3, 4, [5, 6]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n上面代码中，类a1是可展开的，类a2是不可展开的，所以使用concat时有不一样的结果。\n\n注意，symbol.isconcatspreadable的位置差异，a1是定义在实例上，a2是定义在类本身，效果相同。\n\n\n# symbol.species\n\n对象的symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。\n\nclass myarray extends array {\n}\n\nconst a = new myarray(1, 2, 3);\nconst b = a.map(x => x);\nconst c = a.filter(x => x > 1);\n\nb instanceof myarray // true\nc instanceof myarray // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，子类myarray继承了父类array，a是myarray的实例，b和c是a的衍生对象。你可能会认为，b和c都是调用数组方法生成的，所以应该是数组（array的实例），但实际上它们也是myarray的实例。\n\nsymbol.species属性就是为了解决这个问题而提供的。现在，我们可以为myarray设置symbol.species属性。\n\nclass myarray extends array {\n  static get [symbol.species]() { return array; }\n}\n\n\n1\n2\n3\n\n\n上面代码中，由于定义了symbol.species属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义symbol.species属性要采用get取值器。默认的symbol.species属性等同于下面的写法。\n\nstatic get [symbol.species]() {\n  return this;\n}\n\n\n1\n2\n3\n\n\n现在，再来看前面的例子。\n\nclass myarray extends array {\n  static get [symbol.species]() { return array; }\n}\n\nconst a = new myarray();\nconst b = a.map(x => x);\n\nb instanceof myarray // false\nb instanceof array // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，a.map(x => x)生成的衍生对象，就不是myarray的实例，而直接就是array的实例。\n\n再看一个例子。\n\nclass t1 extends promise {\n}\n\nclass t2 extends promise {\n  static get [symbol.species]() {\n    return promise;\n  }\n}\n\nnew t1(r => r()).then(v => v) instanceof t1 // true\nnew t2(r => r()).then(v => v) instanceof t2 // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，t2定义了symbol.species属性，t1没有。结果就导致了创建衍生对象时（then方法），t1调用的是自身的构造方法，而t2调用的是promise的构造方法。\n\n总之，symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。\n\n\n# symbol.match\n\n对象的symbol.match属性，指向一个函数。当执行str.match(myobject)时，如果该属性存在，会调用它，返回该方法的返回值。\n\nstring.prototype.match(regexp)\n// 等同于\nregexp[symbol.match](this)\n\nclass mymatcher {\n  [symbol.match](string) {\n    return 'hello world'.indexof(string);\n  }\n}\n\n'e'.match(new mymatcher()) // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# symbol.replace\n\n对象的symbol.replace属性，指向一个方法，当该对象被string.prototype.replace方法调用时，会返回该方法的返回值。\n\nstring.prototype.replace(searchvalue, replacevalue)\n// 等同于\nsearchvalue[symbol.replace](this, replacevalue)\n\n\n1\n2\n3\n\n\n下面是一个例子。\n\nconst x = {};\nx[symbol.replace] = (...s) => console.log(s);\n\n'hello'.replace(x, 'world') // [\"hello\", \"world\"]\n\n\n1\n2\n3\n4\n\n\nsymbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象，上面例子是hello，第二个参数是替换后的值，上面例子是world。\n\n\n# symbol.search\n\n对象的symbol.search属性，指向一个方法，当该对象被string.prototype.search方法调用时，会返回该方法的返回值。\n\nstring.prototype.search(regexp)\n// 等同于\nregexp[symbol.search](this)\n\nclass mysearch {\n  constructor(value) {\n    this.value = value;\n  }\n  [symbol.search](string) {\n    return string.indexof(this.value);\n  }\n}\n'foobar'.search(new mysearch('foo')) // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# symbol.split\n\n对象的symbol.split属性，指向一个方法，当该对象被string.prototype.split方法调用时，会返回该方法的返回值。\n\nstring.prototype.split(separator, limit)\n// 等同于\nseparator[symbol.split](this, limit)\n\n\n1\n2\n3\n\n\n下面是一个例子。\n\nclass mysplitter {\n  constructor(value) {\n    this.value = value;\n  }\n  [symbol.split](string) {\n    let index = string.indexof(this.value);\n    if (index === -1) {\n      return string;\n    }\n    return [\n      string.substr(0, index),\n      string.substr(index + this.value.length)\n    ];\n  }\n}\n\n'foobar'.split(new mysplitter('foo'))\n// ['', 'bar']\n\n'foobar'.split(new mysplitter('bar'))\n// ['foo', '']\n\n'foobar'.split(new mysplitter('baz'))\n// 'foobar'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面方法使用symbol.split方法，重新定义了字符串对象的split方法的行为，\n\n\n# symbol.iterator\n\n对象的symbol.iterator属性，指向该对象的默认遍历器方法。\n\nconst myiterable = {};\nmyiterable[symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myiterable] // [1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对象进行for...of循环时，会调用symbol.iterator方法，返回该对象的默认遍历器，详细介绍参见《iterator 和 for...of 循环》一章。\n\nclass collection {\n  *[symbol.iterator]() {\n    let i = 0;\n    while(this[i] !== undefined) {\n      yield this[i];\n      ++i;\n    }\n  }\n}\n\nlet mycollection = new collection();\nmycollection[0] = 1;\nmycollection[1] = 2;\n\nfor(let value of mycollection) {\n  console.log(value);\n}\n// 1\n// 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# symbol.toprimitive\n\n对象的symbol.toprimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。\n\nsymbol.toprimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。\n\n * number：该场合需要转成数值\n * string：该场合需要转成字符串\n * default：该场合可以转成数值，也可以转成字符串\n\nlet obj = {\n  [symbol.toprimitive](hint) {\n    switch (hint) {\n      case 'number':\n        return 123;\n      case 'string':\n        return 'str';\n      case 'default':\n        return 'default';\n      default:\n        throw new error();\n     }\n   }\n};\n\n2 * obj // 246\n3 + obj // '3default'\nobj == 'default' // true\nstring(obj) // 'str'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# symbol.tostringtag\n\n对象的symbol.tostringtag属性，指向一个方法。在该对象上面调用object.prototype.tostring方法时，如果这个属性存在，它的返回值会出现在tostring方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object object]或[object array]中object后面的那个字符串。\n\n// 例一\n({[symbol.tostringtag]: 'foo'}.tostring())\n// \"[object foo]\"\n\n// 例二\nclass collection {\n  get [symbol.tostringtag]() {\n    return 'xxx';\n  }\n}\nlet x = new collection();\nobject.prototype.tostring.call(x) // \"[object xxx]\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nes6 新增内置对象的symbol.tostringtag属性值如下。\n\n * json[symbol.tostringtag]：'json'\n * math[symbol.tostringtag]：'math'\n * module 对象m[symbol.tostringtag]：'module'\n * arraybuffer.prototype[symbol.tostringtag]：'arraybuffer'\n * dataview.prototype[symbol.tostringtag]：'dataview'\n * map.prototype[symbol.tostringtag]：'map'\n * promise.prototype[symbol.tostringtag]：'promise'\n * set.prototype[symbol.tostringtag]：'set'\n * %typedarray%.prototype[symbol.tostringtag]：'uint8array'等\n * weakmap.prototype[symbol.tostringtag]：'weakmap'\n * weakset.prototype[symbol.tostringtag]：'weakset'\n * %mapiteratorprototype%[symbol.tostringtag]：'map iterator'\n * %setiteratorprototype%[symbol.tostringtag]：'set iterator'\n * %stringiteratorprototype%[symbol.tostringtag]：'string iterator'\n * symbol.prototype[symbol.tostringtag]：'symbol'\n * generator.prototype[symbol.tostringtag]：'generator'\n * generatorfunction.prototype[symbol.tostringtag]：'generatorfunction'\n\n\n# symbol.unscopables\n\n对象的symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。\n\narray.prototype[symbol.unscopables]\n// {\n//   copywithin: true,\n//   entries: true,\n//   fill: true,\n//   find: true,\n//   findindex: true,\n//   includes: true,\n//   keys: true\n// }\n\nobject.keys(array.prototype[symbol.unscopables])\n// ['copywithin', 'entries', 'fill', 'find', 'findindex', 'includes', 'keys']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码说明，数组有 7 个属性，会被with命令排除。\n\n// 没有 unscopables 时\nclass myclass {\n  foo() { return 1; }\n}\n\nvar foo = function () { return 2; };\n\nwith (myclass.prototype) {\n  foo(); // 1\n}\n\n// 有 unscopables 时\nclass myclass {\n  foo() { return 1; }\n  get [symbol.unscopables]() {\n    return { foo: true };\n  }\n}\n\nvar foo = function () { return 2; };\n\nwith (myclass.prototype) {\n  foo(); // 2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码通过指定symbol.unscopables属性，使得with语法块不会在当前作用域寻找foo属性，即foo将指向外层作用域的变量。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Set 和 Map 数据结构",frontmatter:{title:"Set 和 Map 数据结构",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/0c21dae358fca16b",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/13.Set%20%E5%92%8C%20Map%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",relativePath:"《ES6 教程》笔记/13.Set 和 Map 数据结构.md",key:"v-2ec63a50",path:"/pages/0c21dae358fca16b/",headers:[{level:2,title:"Set",slug:"set",normalizedTitle:"set",charIndex:2},{level:3,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:29},{level:3,title:"Set 实例的属性和方法",slug:"set-实例的属性和方法",normalizedTitle:"set 实例的属性和方法",charIndex:1372},{level:3,title:"遍历操作",slug:"遍历操作",normalizedTitle:"遍历操作",charIndex:2514},{level:2,title:"WeakSet",slug:"weakset",normalizedTitle:"weakset",charIndex:5255},{level:3,title:"含义",slug:"含义",normalizedTitle:"含义",charIndex:5267},{level:3,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:6044},{level:2,title:"Map",slug:"map",normalizedTitle:"map",charIndex:8},{level:3,title:"含义和基本用法",slug:"含义和基本用法",normalizedTitle:"含义和基本用法",charIndex:7722},{level:3,title:"实例的属性和操作方法",slug:"实例的属性和操作方法",normalizedTitle:"实例的属性和操作方法",charIndex:10533},{level:3,title:"遍历方法",slug:"遍历方法",normalizedTitle:"遍历方法",charIndex:1513},{level:3,title:"与其他数据结构的互相转换",slug:"与其他数据结构的互相转换",normalizedTitle:"与其他数据结构的互相转换",charIndex:14067},{level:2,title:"WeakMap",slug:"weakmap",normalizedTitle:"weakmap",charIndex:6028},{level:3,title:"含义",slug:"含义-2",normalizedTitle:"含义",charIndex:5267},{level:3,title:"WeakMap 的语法",slug:"weakmap-的语法",normalizedTitle:"weakmap 的语法",charIndex:18170},{level:3,title:"WeakMap 的示例",slug:"weakmap-的示例",normalizedTitle:"weakmap 的示例",charIndex:18571},{level:3,title:"WeakMap 的用途",slug:"weakmap-的用途",normalizedTitle:"weakmap 的用途",charIndex:19977}],excerpt:'<h1 id="set-和-map-数据结构"><a class="header-anchor" href="#set-和-map-数据结构">#</a> Set 和 Map 数据结构</h1>\n<h2 id="set"><a class="header-anchor" href="#set">#</a> Set</h2>\n<h3 id="基本用法"><a class="header-anchor" href="#基本用法">#</a> 基本用法</h3>\n<p>ES6 提供了新的数据结构 Set。它<strong>类似于数组，但是成员的值都是唯一的，没有重复的值</strong>。</p>\n<p><strong><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</strong>。</p>\n\x3c!--beforebegin--\x3e<div class="language-javascript line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-javascript"><code><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=></span> s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 2 3 5 4</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"Set 基本用法 Set 实例的属性和方法 遍历操作 WeakSet 含义 语法 Map 含义和基本用法 实例的属性和操作方法 遍历方法 与其他数据结构的互相转换 WeakMap 含义 WeakMap 的语法 WeakMap 的示例 WeakMap 的用途",content:"# Set 和 Map 数据结构\n\n\n# Set\n\n\n# 基本用法\n\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\nSet本身是一个构造函数，用来生成 Set 数据结构。\n\nconst s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\n\nSet函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。\n\n// 例一\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n\n// 例二\nconst items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size // 5\n\n// 例三\nconst set = new Set(document.querySelectorAll('div'));\nset.size // 56\n\n// 类似于\nconst set = new Set();\ndocument\n .querySelectorAll('div')\n .forEach(div => set.add(div));\nset.size // 56\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。\n\n上面代码也展示了一种去除数组重复成员的方法。\n\n// 去除数组的重复成员\n[...new Set(array)]\n\n\n1\n2\n\n\n上面的方法也可以用于，去除字符串里面的重复字符。\n\n[...new Set('ababbc')].join('')\n// \"abc\"\n\n\n1\n2\n\n\n向 Set 加入值的时候，不会发生类型转换，所以5和\"5\"是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。\n\nlet set = new Set();\nlet a = NaN;\nlet b = NaN;\nset.add(a);\nset.add(b);\nset // Set {NaN}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码向 Set 实例添加了两次NaN，但是只会加入一个。这表明，在 Set 内部，两个NaN是相等的。\n\n另外，两个对象总是不相等的。\n\nlet set = new Set();\n\nset.add({});\nset.size // 1\n\nset.add({});\nset.size // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码表示，由于两个空对象不相等，所以它们被视为两个值。\n\n\n# Set 实例的属性和方法\n\nSet 结构的实例有以下属性。\n\n * Set.prototype.constructor：构造函数，默认就是Set函数。\n * Set.prototype.size：返回Set实例的成员总数。\n\nSet 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。\n\n * Set.prototype.add(value)：添加某个值，返回 Set 结构本身。\n * Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。\n * Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。\n * Set.prototype.clear()：清除所有成员，没有返回值。\n\n上面这些属性和方法的实例如下。\n\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2);\ns.has(2) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n下面是一个对比，看看在判断是否包括一个键上面，Object结构和Set结构的写法不同。\n\n// 对象的写法\nconst properties = {\n  'width': 1,\n  'height': 1\n};\n\nif (properties[someName]) {\n  // do something\n}\n\n// Set的写法\nconst properties = new Set();\n\nproperties.add('width');\nproperties.add('height');\n\nif (properties.has(someName)) {\n  // do something\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nArray.from方法可以将 Set 结构转为数组。\n\nconst items = new Set([1, 2, 3, 4, 5]);\nconst array = Array.from(items);\n\n\n1\n2\n\n\n这就提供了去除数组重复成员的另一种方法。\n\nfunction dedupe(array) {\n  return Array.from(new Set(array));\n}\n\ndedupe([1, 1, 2, 3]) // [1, 2, 3]\n\n\n1\n2\n3\n4\n5\n\n\n\n# 遍历操作\n\nSet 结构的实例有四个遍历方法，可以用于遍历成员。\n\n * Set.prototype.keys()：返回键名的遍历器\n * Set.prototype.values()：返回键值的遍历器\n * Set.prototype.entries()：返回键值对的遍历器\n * Set.prototype.forEach()：使用回调函数遍历每个成员\n\n需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。\n\n（1）keys()，values()，entries()\n\nkeys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。\n\nlet set = new Set(['red', 'green', 'blue']);\n\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.entries()) {\n  console.log(item);\n}\n// [\"red\", \"red\"]\n// [\"green\", \"green\"]\n// [\"blue\", \"blue\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。\n\nSet 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。\n\nSet.prototype[Symbol.iterator] === Set.prototype.values\n// true\n\n\n1\n2\n\n\n这意味着，可以省略values方法，直接用for...of循环遍历 Set。\n\nlet set = new Set(['red', 'green', 'blue']);\n\nfor (let x of set) {\n  console.log(x);\n}\n// red\n// green\n// blue\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n（2）forEach()\n\nSet 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。\n\nlet set = new Set([1, 4, 9]);\nset.forEach((value, key) => console.log(key + ' : ' + value))\n// 1 : 1\n// 4 : 4\n// 9 : 9\n\n\n1\n2\n3\n4\n5\n\n\n上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。\n\n另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。\n\n（3）遍历的应用\n\n扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。\n\nlet set = new Set(['red', 'green', 'blue']);\nlet arr = [...set];\n// ['red', 'green', 'blue']\n\n\n1\n2\n3\n\n\n扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。\n\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\n\n\n1\n2\n3\n\n\n而且，数组的map和filter方法也可以间接用于 Set 了。\n\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(x => x * 2));\n// 返回Set结构：{2, 4, 6}\n\nlet set = new Set([1, 2, 3, 4, 5]);\nset = new Set([...set].filter(x => (x % 2) == 0));\n// 返回Set结构：{2, 4}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。\n\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// 差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。\n\n// 方法一\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(val => val * 2));\n// set的值是2, 4, 6\n\n// 方法二\nlet set = new Set([1, 2, 3]);\nset = new Set(Array.from(set, val => val * 2));\n// set的值是2, 4, 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。\n\n\n# WeakSet\n\n\n# 含义\n\nWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。\n\n首先，WeakSet 的成员只能是对象，而不能是其他类型的值。\n\nconst ws = new WeakSet();\nws.add(1)\n// TypeError: Invalid value used in weak set\nws.add(Symbol())\n// TypeError: invalid value used in weak set\n\n\n1\n2\n3\n4\n5\n\n\n上面代码试图向 WeakSet 添加一个数值和Symbol值，结果报错，因为 WeakSet 只能放置对象。\n\n其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。\n\n这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。\n\n由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。\n\n这些特点同样适用于本章后面要介绍的 WeakMap 结构。\n\n\n# 语法\n\nWeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。\n\nconst ws = new WeakSet();\n\n\n1\n\n\n作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。\n\nconst a = [[1, 2], [3, 4]];\nconst ws = new WeakSet(a);\n// WeakSet {[1, 2], [3, 4]}\n\n\n1\n2\n3\n\n\n上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为 WeakSet 构造函数的参数，a的成员会自动成为 WeakSet 的成员。\n\n注意，是a数组的成员成为 WeakSet 的成员，而不是a数组本身。这意味着，数组的成员只能是对象。\n\nconst b = [3, 4];\nconst ws = new WeakSet(b);\n// Uncaught TypeError: Invalid value used in weak set(…)\n\n\n1\n2\n3\n\n\n上面代码中，数组b的成员不是对象，加入 WeakSet 就会报错。\n\nWeakSet 结构有以下三个方法。\n\n * WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。\n * WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。\n * WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。\n\n下面是一个例子。\n\nconst ws = new WeakSet();\nconst obj = {};\nconst foo = {};\n\nws.add(window);\nws.add(obj);\n\nws.has(window); // true\nws.has(foo);    // false\n\nws.delete(window);\nws.has(window);    // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nWeakSet 没有size属性，没有办法遍历它的成员。\n\nws.size // undefined\nws.forEach // undefined\n\nws.forEach(function(item){ console.log('WeakSet has ' + item)})\n// TypeError: undefined is not a function\n\n\n1\n2\n3\n4\n5\n\n\n上面代码试图获取size和forEach属性，结果都不能成功。\n\nWeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。\n\n下面是 WeakSet 的另一个例子。\n\nconst foos = new WeakSet()\nclass Foo {\n  constructor() {\n    foos.add(this)\n  }\n  method () {\n    if (!foos.has(this)) {\n      throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用 WeakSet 的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。\n\n\n# Map\n\n\n# 含义和基本用法\n\nJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。\n\nconst data = {};\nconst element = document.getElementById('myDiv');\n\ndata[element] = 'metadata';\ndata['[object HTMLDivElement]'] // \"metadata\"\n\n\n1\n2\n3\n4\n5\n\n\n上面代码原意是将一个 DOM 节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。\n\n为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n\nconst m = new Map();\nconst o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。\n\n上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。\n\nconst map = new Map([\n  ['name', '张三'],\n  ['title', 'Author']\n]);\n\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // \"张三\"\nmap.has('title') // true\nmap.get('title') // \"Author\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码在新建 Map 实例时，就指定了两个键name和title。\n\nMap构造函数接受数组作为参数，实际上执行的是下面的算法。\n\nconst items = [\n  ['name', '张三'],\n  ['title', 'Author']\n];\n\nconst map = new Map();\n\nitems.forEach(\n  ([key, value]) => map.set(key, value)\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。\n\nconst set = new Set([\n  ['foo', 1],\n  ['bar', 2]\n]);\nconst m1 = new Map(set);\nm1.get('foo') // 1\n\nconst m2 = new Map([['baz', 3]]);\nconst m3 = new Map(m2);\nm3.get('baz') // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，我们分别使用 Set 对象和 Map 对象，当作Map构造函数的参数，结果都生成了新的 Map 对象。\n\n如果对同一个键多次赋值，后面的值将覆盖前面的值。\n\nconst map = new Map();\n\nmap\n.set(1, 'aaa')\n.set(1, 'bbb');\n\nmap.get(1) // \"bbb\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码对键1连续赋值两次，后一次的值覆盖前一次的值。\n\n如果读取一个未知的键，则返回undefined。\n\nnew Map().get('asfddfsasadf')\n// undefined\n\n\n1\n2\n\n\n注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。\n\nconst map = new Map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n\n\n1\n2\n3\n4\n\n\n上面代码的set和get方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键，返回undefined。\n\n同理，同样的值的两个实例，在 Map 结构中被视为两个键。\n\nconst map = new Map();\n\nconst k1 = ['a'];\nconst k2 = ['a'];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，变量k1和k2的值是一样的，但是它们在 Map 结构中被视为两个键。\n\n由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。\n\n如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。\n\nlet map = new Map();\n\nmap.set(-0, 123);\nmap.get(+0) // 123\n\nmap.set(true, 1);\nmap.set('true', 2);\nmap.get(true) // 1\n\nmap.set(undefined, 3);\nmap.set(null, 4);\nmap.get(undefined) // 3\n\nmap.set(NaN, 123);\nmap.get(NaN) // 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 实例的属性和操作方法\n\nMap 结构的实例有以下属性和操作方法。\n\n（1）size 属性\n\nsize属性返回 Map 结构的成员总数。\n\nconst map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\n\n\n1\n2\n3\n4\n5\n\n\n（2）Map.prototype.set(key, value)\n\nset方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。\n\nconst m = new Map();\n\nm.set('edition', 6)        // 键是字符串\nm.set(262, 'standard')     // 键是数值\nm.set(undefined, 'nah')    // 键是 undefined\n\n\n1\n2\n3\n4\n5\n\n\nset方法返回的是当前的Map对象，因此可以采用链式写法。\n\nlet map = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n\n\n1\n2\n3\n4\n\n\n（3）Map.prototype.get(key)\n\nget方法读取key对应的键值，如果找不到key，返回undefined。\n\nconst m = new Map();\n\nconst hello = function() {console.log('hello');};\nm.set(hello, 'Hello ES6!') // 键是函数\n\nm.get(hello)  // Hello ES6!\n\n\n1\n2\n3\n4\n5\n6\n\n\n（4）Map.prototype.has(key)\n\nhas方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。\n\nconst m = new Map();\n\nm.set('edition', 6);\nm.set(262, 'standard');\nm.set(undefined, 'nah');\n\nm.has('edition')     // true\nm.has('years')       // false\nm.has(262)           // true\nm.has(undefined)     // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n（5）Map.prototype.delete(key)\n\ndelete方法删除某个键，返回true。如果删除失败，返回false。\n\nconst m = new Map();\nm.set(undefined, 'nah');\nm.has(undefined)     // true\n\nm.delete(undefined)\nm.has(undefined)       // false\n\n\n1\n2\n3\n4\n5\n6\n\n\n（6）Map.prototype.clear()\n\nclear方法清除所有成员，没有返回值。\n\nlet map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\nmap.clear()\nmap.size // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 遍历方法\n\nMap 结构原生提供三个遍历器生成函数和一个遍历方法。\n\n * Map.prototype.keys()：返回键名的遍历器。\n * Map.prototype.values()：返回键值的遍历器。\n * Map.prototype.entries()：返回所有成员的遍历器。\n * Map.prototype.forEach()：遍历 Map 的所有成员。\n\n需要特别注意的是，Map 的遍历顺序就是插入顺序。\n\nconst map = new Map([\n  ['F', 'no'],\n  ['T',  'yes'],\n]);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n// \"F\"\n// \"T\"\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n// \"no\"\n// \"yes\"\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。\n\nmap[Symbol.iterator] === map.entries\n// true\n\n\n1\n2\n\n\nMap 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。\n\nconst map = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\n[...map.keys()]\n// [1, 2, 3]\n\n[...map.values()]\n// ['one', 'two', 'three']\n\n[...map.entries()]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n\n[...map]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。\n\nconst map0 = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n\nconst map1 = new Map(\n  [...map0].filter(([k, v]) => k < 3)\n);\n// 产生 Map 结构 {1 => 'a', 2 => 'b'}\n\nconst map2 = new Map(\n  [...map0].map(([k, v]) => [k * 2, '_' + v])\n    );\n// 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n此外，Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。\n\nmap.forEach(function(value, key, map) {\n  console.log(\"Key: %s, Value: %s\", key, value);\n});\n\n\n1\n2\n3\n\n\nforEach方法还可以接受第二个参数，用来绑定this。\n\nconst reporter = {\n  report: function(key, value) {\n    console.log(\"Key: %s, Value: %s\", key, value);\n  }\n};\n\nmap.forEach(function(value, key, map) {\n  this.report(key, value);\n}, reporter);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，forEach方法的回调函数的this，就指向reporter。\n\n\n# 与其他数据结构的互相转换\n\n（1）Map 转为数组\n\n前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（...）。\n\nconst myMap = new Map()\n  .set(true, 7)\n  .set({foo: 3}, ['abc']);\n[...myMap]\n// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\n\n\n1\n2\n3\n4\n5\n\n\n（2）数组 转为 Map\n\n将数组传入 Map 构造函数，就可以转为 Map。\n\nnew Map([\n  [true, 7],\n  [{foo: 3}, ['abc']]\n])\n// Map {\n//   true => 7,\n//   Object {foo: 3} => ['abc']\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n（3）Map 转为对象\n\n如果所有 Map 的键都是字符串，它可以无损地转为对象。\n\nfunction strMapToObj(strMap) {\n  let obj = Object.create(null);\n  for (let [k,v] of strMap) {\n    obj[k] = v;\n  }\n  return obj;\n}\n\nconst myMap = new Map()\n  .set('yes', true)\n  .set('no', false);\nstrMapToObj(myMap)\n// { yes: true, no: false }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\n\n（4）对象转为 Map\n\nfunction objToStrMap(obj) {\n  let strMap = new Map();\n  for (let k of Object.keys(obj)) {\n    strMap.set(k, obj[k]);\n  }\n  return strMap;\n}\n\nobjToStrMap({yes: true, no: false})\n// Map {\"yes\" => true, \"no\" => false}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n（5）Map 转为 JSON\n\nMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。\n\nfunction strMapToJson(strMap) {\n  return JSON.stringify(strMapToObj(strMap));\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToJson(myMap)\n// '{\"yes\":true,\"no\":false}'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。\n\nfunction mapToArrayJson(map) {\n  return JSON.stringify([...map]);\n}\n\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\nmapToArrayJson(myMap)\n// '[[true,7],[{\"foo\":3},[\"abc\"]]]'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（6）JSON 转为 Map\n\nJSON 转为 Map，正常情况下，所有键名都是字符串。\n\nfunction jsonToStrMap(jsonStr) {\n  return objToStrMap(JSON.parse(jsonStr));\n}\n\njsonToStrMap('{\"yes\": true, \"no\": false}')\n// Map {'yes' => true, 'no' => false}\n\n\n1\n2\n3\n4\n5\n6\n\n\n但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。\n\nfunction jsonToMap(jsonStr) {\n  return new Map(JSON.parse(jsonStr));\n}\n\njsonToMap('[[true,7],[{\"foo\":3},[\"abc\"]]]')\n// Map {true => 7, Object {foo: 3} => ['abc']}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# WeakMap\n\n\n# 含义\n\nWeakMap结构与Map结构类似，也是用于生成键值对的集合。\n\n// WeakMap 可以使用 set 方法添加成员\nconst wm1 = new WeakMap();\nconst key = {foo: 1};\nwm1.set(key, 2);\nwm1.get(key) // 2\n\n// WeakMap 也可以接受一个数组，\n// 作为构造函数的参数\nconst k1 = [1, 2, 3];\nconst k2 = [4, 5, 6];\nconst wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);\nwm2.get(k2) // \"bar\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nWeakMap与Map的区别有两点。\n\n首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。\n\nconst map = new WeakMap();\nmap.set(1, 2)\n// TypeError: 1 is not an object!\nmap.set(Symbol(), 2)\n// TypeError: Invalid value used as weak map key\nmap.set(null, 2)\n// TypeError: Invalid value used as weak map key\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，如果将数值1和Symbol值作为 WeakMap 的键名，都会报错。\n\n其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。\n\nWeakMap的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。\n\nconst e1 = document.getElementById('foo');\nconst e2 = document.getElementById('bar');\nconst arr = [\n  [e1, 'foo 元素'],\n  [e2, 'bar 元素'],\n];\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，e1和e2是两个对象，我们通过arr数组对这两个对象添加一些文字说明。这就形成了arr对e1和e2的引用。\n\n一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放e1和e2占用的内存。\n\n// 不需要 e1 和 e2 的时候\n// 必须手动删除引用\narr [0] = null;\narr [1] = null;\n\n\n1\n2\n3\n4\n\n\n上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。\n\nWeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。\n\n基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。\n\nconst wm = new WeakMap();\n\nconst element = document.getElementById('example');\n\nwm.set(element, 'some information');\nwm.get(element) // \"some information\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。\n\n也就是说，上面的 DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。\n\n总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。\n\n注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。\n\nconst wm = new WeakMap();\nlet key = {};\nlet obj = {foo: 1};\n\nwm.set(key, obj);\nobj = null;\nwm.get(key)\n// Object {foo: 1}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。\n\n\n# WeakMap 的语法\n\nWeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。\n\nconst wm = new WeakMap();\n\n// size、forEach、clear 方法都不存在\nwm.size // undefined\nwm.forEach // undefined\nwm.clear // undefined\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# WeakMap 的示例\n\nWeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。\n\n贺师俊老师提示，如果引用所指向的值占用特别多的内存，就可以通过 Node 的process.memoryUsage方法看出来。根据这个思路，网友vtxf补充了下面的例子。\n\n首先，打开 Node 命令行。\n\n$ node --expose-gc\n\n\n1\n\n\n上面代码中，--expose-gc参数表示允许手动执行垃圾回收机制。\n\n然后，执行下面的代码。\n\n// 手动执行一次垃圾回收，保证获取的内存使用状态准确\n> global.gc();\nundefined\n\n// 查看内存占用的初始状态，heapUsed 为 4M 左右\n> process.memoryUsage();\n{ rss: 21106688,\n  heapTotal: 7376896,\n  heapUsed: 4153936,\n  external: 9059 }\n\n> let wm = new WeakMap();\nundefined\n\n// 新建一个变量 key，指向一个 5*1024*1024 的数组\n> let key = new Array(5 * 1024 * 1024);\nundefined\n\n// 设置 WeakMap 实例的键名，也指向 key 数组\n// 这时，key 数组实际被引用了两次，\n// 变量 key 引用一次，WeakMap 的键名引用了第二次\n// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1\n> wm.set(key, 1);\nWeakMap {}\n\n> global.gc();\nundefined\n\n// 这时内存占用 heapUsed 增加到 45M 了\n> process.memoryUsage();\n{ rss: 67538944,\n  heapTotal: 7376896,\n  heapUsed: 45782816,\n  external: 8945 }\n\n// 清除变量 key 对数组的引用，\n// 但没有手动清除 WeakMap 实例的键名对数组的引用\n> key = null;\nnull\n\n// 再次执行垃圾回收\n> global.gc();\nundefined\n\n// 内存占用 heapUsed 变回 4M 左右，\n// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收\n> process.memoryUsage();\n{ rss: 20639744,\n  heapTotal: 8425472,\n  heapUsed: 3979792,\n  external: 8956 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。\n\n\n# WeakMap 的用途\n\n前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。\n\nlet myElement = document.getElementById('logo');\nlet myWeakmap = new WeakMap();\n\nmyWeakmap.set(myElement, {timesClicked: 0});\n\nmyElement.addEventListener('click', function() {\n  let logoData = myWeakmap.get(myElement);\n  logoData.timesClicked++;\n}, false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。\n\nWeakMap 的另一个用处是部署私有属性。\n\nconst _counter = new WeakMap();\nconst _action = new WeakMap();\n\nclass Countdown {\n  constructor(counter, action) {\n    _counter.set(this, counter);\n    _action.set(this, action);\n  }\n  dec() {\n    let counter = _counter.get(this);\n    if (counter < 1) return;\n    counter--;\n    _counter.set(this, counter);\n    if (counter === 0) {\n      _action.get(this)();\n    }\n  }\n}\n\nconst c = new Countdown(2, () => console.log('DONE'));\n\nc.dec()\nc.dec()\n// DONE\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码中，Countdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。",normalizedContent:"# set 和 map 数据结构\n\n\n# set\n\n\n# 基本用法\n\nes6 提供了新的数据结构 set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\nset本身是一个构造函数，用来生成 set 数据结构。\n\nconst s = new set();\n\n[2, 3, 5, 4, 5, 2, 2].foreach(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码通过add()方法向 set 结构加入成员，结果表明 set 结构不会添加重复的值。\n\nset函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。\n\n// 例一\nconst set = new set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n\n// 例二\nconst items = new set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size // 5\n\n// 例三\nconst set = new set(document.queryselectorall('div'));\nset.size // 56\n\n// 类似于\nconst set = new set();\ndocument\n .queryselectorall('div')\n .foreach(div => set.add(div));\nset.size // 56\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，例一和例二都是set函数接受数组作为参数，例三是接受类似数组的对象作为参数。\n\n上面代码也展示了一种去除数组重复成员的方法。\n\n// 去除数组的重复成员\n[...new set(array)]\n\n\n1\n2\n\n\n上面的方法也可以用于，去除字符串里面的重复字符。\n\n[...new set('ababbc')].join('')\n// \"abc\"\n\n\n1\n2\n\n\n向 set 加入值的时候，不会发生类型转换，所以5和\"5\"是两个不同的值。set 内部判断两个值是否不同，使用的算法叫做“same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 set 加入值时认为nan等于自身，而精确相等运算符认为nan不等于自身。\n\nlet set = new set();\nlet a = nan;\nlet b = nan;\nset.add(a);\nset.add(b);\nset // set {nan}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码向 set 实例添加了两次nan，但是只会加入一个。这表明，在 set 内部，两个nan是相等的。\n\n另外，两个对象总是不相等的。\n\nlet set = new set();\n\nset.add({});\nset.size // 1\n\nset.add({});\nset.size // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码表示，由于两个空对象不相等，所以它们被视为两个值。\n\n\n# set 实例的属性和方法\n\nset 结构的实例有以下属性。\n\n * set.prototype.constructor：构造函数，默认就是set函数。\n * set.prototype.size：返回set实例的成员总数。\n\nset 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。\n\n * set.prototype.add(value)：添加某个值，返回 set 结构本身。\n * set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。\n * set.prototype.has(value)：返回一个布尔值，表示该值是否为set的成员。\n * set.prototype.clear()：清除所有成员，没有返回值。\n\n上面这些属性和方法的实例如下。\n\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2);\ns.has(2) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n下面是一个对比，看看在判断是否包括一个键上面，object结构和set结构的写法不同。\n\n// 对象的写法\nconst properties = {\n  'width': 1,\n  'height': 1\n};\n\nif (properties[somename]) {\n  // do something\n}\n\n// set的写法\nconst properties = new set();\n\nproperties.add('width');\nproperties.add('height');\n\nif (properties.has(somename)) {\n  // do something\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\narray.from方法可以将 set 结构转为数组。\n\nconst items = new set([1, 2, 3, 4, 5]);\nconst array = array.from(items);\n\n\n1\n2\n\n\n这就提供了去除数组重复成员的另一种方法。\n\nfunction dedupe(array) {\n  return array.from(new set(array));\n}\n\ndedupe([1, 1, 2, 3]) // [1, 2, 3]\n\n\n1\n2\n3\n4\n5\n\n\n\n# 遍历操作\n\nset 结构的实例有四个遍历方法，可以用于遍历成员。\n\n * set.prototype.keys()：返回键名的遍历器\n * set.prototype.values()：返回键值的遍历器\n * set.prototype.entries()：返回键值对的遍历器\n * set.prototype.foreach()：使用回调函数遍历每个成员\n\n需要特别指出的是，set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。\n\n（1）keys()，values()，entries()\n\nkeys方法、values方法、entries方法返回的都是遍历器对象（详见《iterator 对象》一章）。由于 set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。\n\nlet set = new set(['red', 'green', 'blue']);\n\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.entries()) {\n  console.log(item);\n}\n// [\"red\", \"red\"]\n// [\"green\", \"green\"]\n// [\"blue\", \"blue\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。\n\nset 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。\n\nset.prototype[symbol.iterator] === set.prototype.values\n// true\n\n\n1\n2\n\n\n这意味着，可以省略values方法，直接用for...of循环遍历 set。\n\nlet set = new set(['red', 'green', 'blue']);\n\nfor (let x of set) {\n  console.log(x);\n}\n// red\n// green\n// blue\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n（2）foreach()\n\nset 结构的实例与数组一样，也拥有foreach方法，用于对每个成员执行某种操作，没有返回值。\n\nlet set = new set([1, 4, 9]);\nset.foreach((value, key) => console.log(key + ' : ' + value))\n// 1 : 1\n// 4 : 4\n// 9 : 9\n\n\n1\n2\n3\n4\n5\n\n\n上面代码说明，foreach方法的参数就是一个处理函数。该函数的参数与数组的foreach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。\n\n另外，foreach方法还可以有第二个参数，表示绑定处理函数内部的this对象。\n\n（3）遍历的应用\n\n扩展运算符（...）内部使用for...of循环，所以也可以用于 set 结构。\n\nlet set = new set(['red', 'green', 'blue']);\nlet arr = [...set];\n// ['red', 'green', 'blue']\n\n\n1\n2\n3\n\n\n扩展运算符和 set 结构相结合，就可以去除数组的重复成员。\n\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new set(arr)];\n// [3, 5, 2]\n\n\n1\n2\n3\n\n\n而且，数组的map和filter方法也可以间接用于 set 了。\n\nlet set = new set([1, 2, 3]);\nset = new set([...set].map(x => x * 2));\n// 返回set结构：{2, 4, 6}\n\nlet set = new set([1, 2, 3, 4, 5]);\nset = new set([...set].filter(x => (x % 2) == 0));\n// 返回set结构：{2, 4}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n因此使用 set 可以很容易地实现并集（union）、交集（intersect）和差集（difference）。\n\nlet a = new set([1, 2, 3]);\nlet b = new set([4, 3, 2]);\n\n// 并集\nlet union = new set([...a, ...b]);\n// set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// 差集\nlet difference = new set([...a].filter(x => !b.has(x)));\n// set {1}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果想在遍历操作中，同步改变原来的 set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 set 结构映射出一个新的结构，然后赋值给原来的 set 结构；另一种是利用array.from方法。\n\n// 方法一\nlet set = new set([1, 2, 3]);\nset = new set([...set].map(val => val * 2));\n// set的值是2, 4, 6\n\n// 方法二\nlet set = new set([1, 2, 3]);\nset = new set(array.from(set, val => val * 2));\n// set的值是2, 4, 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码提供了两种方法，直接在遍历操作中改变原来的 set 结构。\n\n\n# weakset\n\n\n# 含义\n\nweakset 结构与 set 类似，也是不重复的值的集合。但是，它与 set 有两个区别。\n\n首先，weakset 的成员只能是对象，而不能是其他类型的值。\n\nconst ws = new weakset();\nws.add(1)\n// typeerror: invalid value used in weak set\nws.add(symbol())\n// typeerror: invalid value used in weak set\n\n\n1\n2\n3\n4\n5\n\n\n上面代码试图向 weakset 添加一个数值和symbol值，结果报错，因为 weakset 只能放置对象。\n\n其次，weakset 中的对象都是弱引用，即垃圾回收机制不考虑 weakset 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 weakset 之中。\n\n这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。weakset 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，weakset 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 weakset 里面的引用就会自动消失。\n\n由于上面这个特点，weakset 的成员是不适合引用的，因为它会随时消失。另外，由于 weakset 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 es6 规定 weakset 不可遍历。\n\n这些特点同样适用于本章后面要介绍的 weakmap 结构。\n\n\n# 语法\n\nweakset 是一个构造函数，可以使用new命令，创建 weakset 数据结构。\n\nconst ws = new weakset();\n\n\n1\n\n\n作为构造函数，weakset 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 iterable 接口的对象，都可以作为 weakset 的参数。）该数组的所有成员，都会自动成为 weakset 实例对象的成员。\n\nconst a = [[1, 2], [3, 4]];\nconst ws = new weakset(a);\n// weakset {[1, 2], [3, 4]}\n\n\n1\n2\n3\n\n\n上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为 weakset 构造函数的参数，a的成员会自动成为 weakset 的成员。\n\n注意，是a数组的成员成为 weakset 的成员，而不是a数组本身。这意味着，数组的成员只能是对象。\n\nconst b = [3, 4];\nconst ws = new weakset(b);\n// uncaught typeerror: invalid value used in weak set(…)\n\n\n1\n2\n3\n\n\n上面代码中，数组b的成员不是对象，加入 weakset 就会报错。\n\nweakset 结构有以下三个方法。\n\n * weakset.prototype.add(value)：向 weakset 实例添加一个新成员。\n * weakset.prototype.delete(value)：清除 weakset 实例的指定成员。\n * weakset.prototype.has(value)：返回一个布尔值，表示某个值是否在 weakset 实例之中。\n\n下面是一个例子。\n\nconst ws = new weakset();\nconst obj = {};\nconst foo = {};\n\nws.add(window);\nws.add(obj);\n\nws.has(window); // true\nws.has(foo);    // false\n\nws.delete(window);\nws.has(window);    // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nweakset 没有size属性，没有办法遍历它的成员。\n\nws.size // undefined\nws.foreach // undefined\n\nws.foreach(function(item){ console.log('weakset has ' + item)})\n// typeerror: undefined is not a function\n\n\n1\n2\n3\n4\n5\n\n\n上面代码试图获取size和foreach属性，结果都不能成功。\n\nweakset 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。weakset 的一个用处，是储存 dom 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。\n\n下面是 weakset 的另一个例子。\n\nconst foos = new weakset()\nclass foo {\n  constructor() {\n    foos.add(this)\n  }\n  method () {\n    if (!foos.has(this)) {\n      throw new typeerror('foo.prototype.method 只能在foo的实例上调用！');\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码保证了foo的实例方法，只能在foo的实例上调用。这里使用 weakset 的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。\n\n\n# map\n\n\n# 含义和基本用法\n\njavascript 的对象（object），本质上是键值对的集合（hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。\n\nconst data = {};\nconst element = document.getelementbyid('mydiv');\n\ndata[element] = 'metadata';\ndata['[object htmldivelement]'] // \"metadata\"\n\n\n1\n2\n3\n4\n5\n\n\n上面代码原意是将一个 dom 节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object htmldivelement]。\n\n为了解决这个问题，es6 提供了 map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，object 结构提供了“字符串—值”的对应，map 结构提供了“值—值”的对应，是一种更完善的 hash 结构实现。如果你需要“键值对”的数据结构，map 比 object 更合适。\n\nconst m = new map();\nconst o = {p: 'hello world'};\n\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码使用 map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。\n\n上面的例子展示了如何向 map 添加成员。作为构造函数，map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。\n\nconst map = new map([\n  ['name', '张三'],\n  ['title', 'author']\n]);\n\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // \"张三\"\nmap.has('title') // true\nmap.get('title') // \"author\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码在新建 map 实例时，就指定了两个键name和title。\n\nmap构造函数接受数组作为参数，实际上执行的是下面的算法。\n\nconst items = [\n  ['name', '张三'],\n  ['title', 'author']\n];\n\nconst map = new map();\n\nitems.foreach(\n  ([key, value]) => map.set(key, value)\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n事实上，不仅仅是数组，任何具有 iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《iterator》一章）都可以当作map构造函数的参数。这就是说，set和map都可以用来生成新的 map。\n\nconst set = new set([\n  ['foo', 1],\n  ['bar', 2]\n]);\nconst m1 = new map(set);\nm1.get('foo') // 1\n\nconst m2 = new map([['baz', 3]]);\nconst m3 = new map(m2);\nm3.get('baz') // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，我们分别使用 set 对象和 map 对象，当作map构造函数的参数，结果都生成了新的 map 对象。\n\n如果对同一个键多次赋值，后面的值将覆盖前面的值。\n\nconst map = new map();\n\nmap\n.set(1, 'aaa')\n.set(1, 'bbb');\n\nmap.get(1) // \"bbb\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码对键1连续赋值两次，后一次的值覆盖前一次的值。\n\n如果读取一个未知的键，则返回undefined。\n\nnew map().get('asfddfsasadf')\n// undefined\n\n\n1\n2\n\n\n注意，只有对同一个对象的引用，map 结构才将其视为同一个键。这一点要非常小心。\n\nconst map = new map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n\n\n1\n2\n3\n4\n\n\n上面代码的set和get方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键，返回undefined。\n\n同理，同样的值的两个实例，在 map 结构中被视为两个键。\n\nconst map = new map();\n\nconst k1 = ['a'];\nconst k2 = ['a'];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，变量k1和k2的值是一样的，但是它们在 map 结构中被视为两个键。\n\n由上可知，map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。\n\n如果 map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然nan不严格相等于自身，但 map 将其视为同一个键。\n\nlet map = new map();\n\nmap.set(-0, 123);\nmap.get(+0) // 123\n\nmap.set(true, 1);\nmap.set('true', 2);\nmap.get(true) // 1\n\nmap.set(undefined, 3);\nmap.set(null, 4);\nmap.get(undefined) // 3\n\nmap.set(nan, 123);\nmap.get(nan) // 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 实例的属性和操作方法\n\nmap 结构的实例有以下属性和操作方法。\n\n（1）size 属性\n\nsize属性返回 map 结构的成员总数。\n\nconst map = new map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\n\n\n1\n2\n3\n4\n5\n\n\n（2）map.prototype.set(key, value)\n\nset方法设置键名key对应的键值为value，然后返回整个 map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。\n\nconst m = new map();\n\nm.set('edition', 6)        // 键是字符串\nm.set(262, 'standard')     // 键是数值\nm.set(undefined, 'nah')    // 键是 undefined\n\n\n1\n2\n3\n4\n5\n\n\nset方法返回的是当前的map对象，因此可以采用链式写法。\n\nlet map = new map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n\n\n1\n2\n3\n4\n\n\n（3）map.prototype.get(key)\n\nget方法读取key对应的键值，如果找不到key，返回undefined。\n\nconst m = new map();\n\nconst hello = function() {console.log('hello');};\nm.set(hello, 'hello es6!') // 键是函数\n\nm.get(hello)  // hello es6!\n\n\n1\n2\n3\n4\n5\n6\n\n\n（4）map.prototype.has(key)\n\nhas方法返回一个布尔值，表示某个键是否在当前 map 对象之中。\n\nconst m = new map();\n\nm.set('edition', 6);\nm.set(262, 'standard');\nm.set(undefined, 'nah');\n\nm.has('edition')     // true\nm.has('years')       // false\nm.has(262)           // true\nm.has(undefined)     // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n（5）map.prototype.delete(key)\n\ndelete方法删除某个键，返回true。如果删除失败，返回false。\n\nconst m = new map();\nm.set(undefined, 'nah');\nm.has(undefined)     // true\n\nm.delete(undefined)\nm.has(undefined)       // false\n\n\n1\n2\n3\n4\n5\n6\n\n\n（6）map.prototype.clear()\n\nclear方法清除所有成员，没有返回值。\n\nlet map = new map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\nmap.clear()\nmap.size // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 遍历方法\n\nmap 结构原生提供三个遍历器生成函数和一个遍历方法。\n\n * map.prototype.keys()：返回键名的遍历器。\n * map.prototype.values()：返回键值的遍历器。\n * map.prototype.entries()：返回所有成员的遍历器。\n * map.prototype.foreach()：遍历 map 的所有成员。\n\n需要特别注意的是，map 的遍历顺序就是插入顺序。\n\nconst map = new map([\n  ['f', 'no'],\n  ['t',  'yes'],\n]);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n// \"f\"\n// \"t\"\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n// \"no\"\n// \"yes\"\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// \"f\" \"no\"\n// \"t\" \"yes\"\n\n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// \"f\" \"no\"\n// \"t\" \"yes\"\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// \"f\" \"no\"\n// \"t\" \"yes\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n上面代码最后的那个例子，表示 map 结构的默认遍历器接口（symbol.iterator属性），就是entries方法。\n\nmap[symbol.iterator] === map.entries\n// true\n\n\n1\n2\n\n\nmap 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。\n\nconst map = new map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\n[...map.keys()]\n// [1, 2, 3]\n\n[...map.values()]\n// ['one', 'two', 'three']\n\n[...map.entries()]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n\n[...map]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n结合数组的map方法、filter方法，可以实现 map 的遍历和过滤（map 本身没有map和filter方法）。\n\nconst map0 = new map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n\nconst map1 = new map(\n  [...map0].filter(([k, v]) => k < 3)\n);\n// 产生 map 结构 {1 => 'a', 2 => 'b'}\n\nconst map2 = new map(\n  [...map0].map(([k, v]) => [k * 2, '_' + v])\n    );\n// 产生 map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n此外，map 还有一个foreach方法，与数组的foreach方法类似，也可以实现遍历。\n\nmap.foreach(function(value, key, map) {\n  console.log(\"key: %s, value: %s\", key, value);\n});\n\n\n1\n2\n3\n\n\nforeach方法还可以接受第二个参数，用来绑定this。\n\nconst reporter = {\n  report: function(key, value) {\n    console.log(\"key: %s, value: %s\", key, value);\n  }\n};\n\nmap.foreach(function(value, key, map) {\n  this.report(key, value);\n}, reporter);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，foreach方法的回调函数的this，就指向reporter。\n\n\n# 与其他数据结构的互相转换\n\n（1）map 转为数组\n\n前面已经提过，map 转为数组最方便的方法，就是使用扩展运算符（...）。\n\nconst mymap = new map()\n  .set(true, 7)\n  .set({foo: 3}, ['abc']);\n[...mymap]\n// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\n\n\n1\n2\n3\n4\n5\n\n\n（2）数组 转为 map\n\n将数组传入 map 构造函数，就可以转为 map。\n\nnew map([\n  [true, 7],\n  [{foo: 3}, ['abc']]\n])\n// map {\n//   true => 7,\n//   object {foo: 3} => ['abc']\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n（3）map 转为对象\n\n如果所有 map 的键都是字符串，它可以无损地转为对象。\n\nfunction strmaptoobj(strmap) {\n  let obj = object.create(null);\n  for (let [k,v] of strmap) {\n    obj[k] = v;\n  }\n  return obj;\n}\n\nconst mymap = new map()\n  .set('yes', true)\n  .set('no', false);\nstrmaptoobj(mymap)\n// { yes: true, no: false }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\n\n（4）对象转为 map\n\nfunction objtostrmap(obj) {\n  let strmap = new map();\n  for (let k of object.keys(obj)) {\n    strmap.set(k, obj[k]);\n  }\n  return strmap;\n}\n\nobjtostrmap({yes: true, no: false})\n// map {\"yes\" => true, \"no\" => false}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n（5）map 转为 json\n\nmap 转为 json 要区分两种情况。一种情况是，map 的键名都是字符串，这时可以选择转为对象 json。\n\nfunction strmaptojson(strmap) {\n  return json.stringify(strmaptoobj(strmap));\n}\n\nlet mymap = new map().set('yes', true).set('no', false);\nstrmaptojson(mymap)\n// '{\"yes\":true,\"no\":false}'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n另一种情况是，map 的键名有非字符串，这时可以选择转为数组 json。\n\nfunction maptoarrayjson(map) {\n  return json.stringify([...map]);\n}\n\nlet mymap = new map().set(true, 7).set({foo: 3}, ['abc']);\nmaptoarrayjson(mymap)\n// '[[true,7],[{\"foo\":3},[\"abc\"]]]'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（6）json 转为 map\n\njson 转为 map，正常情况下，所有键名都是字符串。\n\nfunction jsontostrmap(jsonstr) {\n  return objtostrmap(json.parse(jsonstr));\n}\n\njsontostrmap('{\"yes\": true, \"no\": false}')\n// map {'yes' => true, 'no' => false}\n\n\n1\n2\n3\n4\n5\n6\n\n\n但是，有一种特殊情况，整个 json 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 map。这往往是 map 转为数组 json 的逆操作。\n\nfunction jsontomap(jsonstr) {\n  return new map(json.parse(jsonstr));\n}\n\njsontomap('[[true,7],[{\"foo\":3},[\"abc\"]]]')\n// map {true => 7, object {foo: 3} => ['abc']}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# weakmap\n\n\n# 含义\n\nweakmap结构与map结构类似，也是用于生成键值对的集合。\n\n// weakmap 可以使用 set 方法添加成员\nconst wm1 = new weakmap();\nconst key = {foo: 1};\nwm1.set(key, 2);\nwm1.get(key) // 2\n\n// weakmap 也可以接受一个数组，\n// 作为构造函数的参数\nconst k1 = [1, 2, 3];\nconst k2 = [4, 5, 6];\nconst wm2 = new weakmap([[k1, 'foo'], [k2, 'bar']]);\nwm2.get(k2) // \"bar\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nweakmap与map的区别有两点。\n\n首先，weakmap只接受对象作为键名（null除外），不接受其他类型的值作为键名。\n\nconst map = new weakmap();\nmap.set(1, 2)\n// typeerror: 1 is not an object!\nmap.set(symbol(), 2)\n// typeerror: invalid value used as weak map key\nmap.set(null, 2)\n// typeerror: invalid value used as weak map key\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，如果将数值1和symbol值作为 weakmap 的键名，都会报错。\n\n其次，weakmap的键名所指向的对象，不计入垃圾回收机制。\n\nweakmap的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。\n\nconst e1 = document.getelementbyid('foo');\nconst e2 = document.getelementbyid('bar');\nconst arr = [\n  [e1, 'foo 元素'],\n  [e2, 'bar 元素'],\n];\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，e1和e2是两个对象，我们通过arr数组对这两个对象添加一些文字说明。这就形成了arr对e1和e2的引用。\n\n一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放e1和e2占用的内存。\n\n// 不需要 e1 和 e2 的时候\n// 必须手动删除引用\narr [0] = null;\narr [1] = null;\n\n\n1\n2\n3\n4\n\n\n上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。\n\nweakmap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，weakmap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。\n\n基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 weakmap。一个典型应用场景是，在网页的 dom 元素上添加数据，就可以使用weakmap结构。当该 dom 元素被清除，其所对应的weakmap记录就会自动被移除。\n\nconst wm = new weakmap();\n\nconst element = document.getelementbyid('example');\n\nwm.set(element, 'some information');\nwm.get(element) // \"some information\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，先新建一个 weakmap 实例。然后，将一个 dom 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 weakmap 里面。这时，weakmap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。\n\n也就是说，上面的 dom 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。weakmap 保存的这个键值对，也会自动消失。\n\n总之，weakmap的专用场合就是，它的键所对应的对象，可能会在将来消失。weakmap结构有助于防止内存泄漏。\n\n注意，weakmap 弱引用的只是键名，而不是键值。键值依然是正常引用。\n\nconst wm = new weakmap();\nlet key = {};\nlet obj = {foo: 1};\n\nwm.set(key, obj);\nobj = null;\nwm.get(key)\n// object {foo: 1}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，键值obj是正常引用。所以，即使在 weakmap 外部消除了obj的引用，weakmap 内部的引用依然存在。\n\n\n# weakmap 的语法\n\nweakmap 与 map 在 api 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。因此，weakmap只有四个方法可用：get()、set()、has()、delete()。\n\nconst wm = new weakmap();\n\n// size、foreach、clear 方法都不存在\nwm.size // undefined\nwm.foreach // undefined\nwm.clear // undefined\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# weakmap 的示例\n\nweakmap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 weakmap 的键名了，导致无法证实那个键名是不是存在。\n\n贺师俊老师提示，如果引用所指向的值占用特别多的内存，就可以通过 node 的process.memoryusage方法看出来。根据这个思路，网友vtxf补充了下面的例子。\n\n首先，打开 node 命令行。\n\n$ node --expose-gc\n\n\n1\n\n\n上面代码中，--expose-gc参数表示允许手动执行垃圾回收机制。\n\n然后，执行下面的代码。\n\n// 手动执行一次垃圾回收，保证获取的内存使用状态准确\n> global.gc();\nundefined\n\n// 查看内存占用的初始状态，heapused 为 4m 左右\n> process.memoryusage();\n{ rss: 21106688,\n  heaptotal: 7376896,\n  heapused: 4153936,\n  external: 9059 }\n\n> let wm = new weakmap();\nundefined\n\n// 新建一个变量 key，指向一个 5*1024*1024 的数组\n> let key = new array(5 * 1024 * 1024);\nundefined\n\n// 设置 weakmap 实例的键名，也指向 key 数组\n// 这时，key 数组实际被引用了两次，\n// 变量 key 引用一次，weakmap 的键名引用了第二次\n// 但是，weakmap 是弱引用，对于引擎来说，引用计数还是1\n> wm.set(key, 1);\nweakmap {}\n\n> global.gc();\nundefined\n\n// 这时内存占用 heapused 增加到 45m 了\n> process.memoryusage();\n{ rss: 67538944,\n  heaptotal: 7376896,\n  heapused: 45782816,\n  external: 8945 }\n\n// 清除变量 key 对数组的引用，\n// 但没有手动清除 weakmap 实例的键名对数组的引用\n> key = null;\nnull\n\n// 再次执行垃圾回收\n> global.gc();\nundefined\n\n// 内存占用 heapused 变回 4m 左右，\n// 可以看到 weakmap 的键名引用没有阻止 gc 对内存的回收\n> process.memoryusage();\n{ rss: 20639744,\n  heaptotal: 8425472,\n  heapused: 3979792,\n  external: 8956 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n上面代码中，只要外部的引用消失，weakmap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 weakmap 的帮助，解决内存泄漏就会简单很多。\n\n\n# weakmap 的用途\n\n前文说过，weakmap 应用的典型场合就是 dom 节点作为键名。下面是一个例子。\n\nlet myelement = document.getelementbyid('logo');\nlet myweakmap = new weakmap();\n\nmyweakmap.set(myelement, {timesclicked: 0});\n\nmyelement.addeventlistener('click', function() {\n  let logodata = myweakmap.get(myelement);\n  logodata.timesclicked++;\n}, false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，myelement是一个 dom 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 weakmap 里，对应的键名就是myelement。一旦这个 dom 节点删除，该状态就会自动消失，不存在内存泄漏风险。\n\nweakmap 的另一个用处是部署私有属性。\n\nconst _counter = new weakmap();\nconst _action = new weakmap();\n\nclass countdown {\n  constructor(counter, action) {\n    _counter.set(this, counter);\n    _action.set(this, action);\n  }\n  dec() {\n    let counter = _counter.get(this);\n    if (counter < 1) return;\n    counter--;\n    _counter.set(this, counter);\n    if (counter === 0) {\n      _action.get(this)();\n    }\n  }\n}\n\nconst c = new countdown(2, () => console.log('done'));\n\nc.dec()\nc.dec()\n// done\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码中，countdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Proxy",frontmatter:{title:"Proxy",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/f56ec2ab97d60483",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/14.Proxy.html",relativePath:"《ES6 教程》笔记/14.Proxy.md",key:"v-7055771a",path:"/pages/f56ec2ab97d60483/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:12},{level:2,title:"Proxy 实例的方法",slug:"proxy-实例的方法",normalizedTitle:"proxy 实例的方法",charIndex:3952},{level:3,title:"get()",slug:"get",normalizedTitle:"get()",charIndex:3987},{level:3,title:"set()",slug:"set",normalizedTitle:"set()",charIndex:7820},{level:3,title:"apply()",slug:"apply",normalizedTitle:"apply()",charIndex:10813},{level:3,title:"has()",slug:"has",normalizedTitle:"has()",charIndex:11742},{level:3,title:"construct()",slug:"construct",normalizedTitle:"construct()",charIndex:13347},{level:3,title:"deleteProperty()",slug:"deleteproperty",normalizedTitle:"deleteproperty()",charIndex:14078},{level:3,title:"defineProperty()",slug:"defineproperty",normalizedTitle:"defineproperty()",charIndex:14754},{level:3,title:"getOwnPropertyDescriptor()",slug:"getownpropertydescriptor",normalizedTitle:"getownpropertydescriptor()",charIndex:15196},{level:3,title:"getPrototypeOf()",slug:"getprototypeof",normalizedTitle:"getprototypeof()",charIndex:15916},{level:3,title:"isExtensible()",slug:"isextensible",normalizedTitle:"isextensible()",charIndex:16445},{level:3,title:"ownKeys()",slug:"ownkeys",normalizedTitle:"ownkeys()",charIndex:17155},{level:3,title:"preventExtensions()",slug:"preventextensions",normalizedTitle:"preventextensions()",charIndex:20334},{level:3,title:"setPrototypeOf()",slug:"setprototypeof",normalizedTitle:"setprototypeof()",charIndex:21184},{level:2,title:"Proxy.revocable()",slug:"proxy-revocable",normalizedTitle:"proxy.revocable()",charIndex:21689},{level:2,title:"this 问题",slug:"this-问题",normalizedTitle:"this 问题",charIndex:22124},{level:2,title:"实例：Web 服务的客户端",slug:"实例-web-服务的客户端",normalizedTitle:"实例：web 服务的客户端",charIndex:23563}],excerpt:'<h1 id="proxy"><a class="header-anchor" href="#proxy">#</a> Proxy</h1>\n<h2 id="概述"><a class="header-anchor" href="#概述">#</a> 概述</h2>\n<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“<strong>元编程</strong>”（meta programming），即<strong>对编程语言进行编程</strong>。</p>\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，<strong>外界对该对象的访问，都必须先通过这层拦截</strong>，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\n',headersStr:"概述 Proxy 实例的方法 get() set() apply() has() construct() deleteProperty() defineProperty() getOwnPropertyDescriptor() getPrototypeOf() isExtensible() ownKeys() preventExtensions() setPrototypeOf() Proxy.revocable() this 问题 实例：Web 服务的客户端",content:"# Proxy\n\n\n# 概述\n\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\n\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\n\nvar obj = new Proxy({}, {\n  get: function (target, propKey, receiver) {\n    console.log(`getting ${propKey}!`);\n    return Reflect.get(target, propKey, receiver);\n  },\n  set: function (target, propKey, value, receiver) {\n    console.log(`setting ${propKey}!`);\n    return Reflect.set(target, propKey, value, receiver);\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。\n\nobj.count = 1\n//  setting count!\n++obj.count\n//  getting count!\n//  setting count!\n//  2\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。\n\nES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。\n\nvar proxy = new Proxy(target, handler);\n\n\n1\n\n\nProxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。\n\n下面是另一个拦截读取属性行为的例子。\n\nvar proxy = new Proxy({}, {\n  get: function(target, propKey) {\n    return 35;\n  }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.title // 35\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。\n\n注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。\n\n如果handler没有设置任何拦截，那就等同于直接通向原对象。\n\nvar target = {};\nvar handler = {};\nvar proxy = new Proxy(target, handler);\nproxy.a = 'b';\ntarget.a // \"b\"\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，handler是一个空对象，没有任何拦截效果，访问proxy就等同于访问target。\n\n一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。\n\nvar object = { proxy: new Proxy(target, handler) };\n\n\n1\n\n\nProxy 实例也可以作为其他对象的原型对象。\n\nvar proxy = new Proxy({}, {\n  get: function(target, propKey) {\n    return 35;\n  }\n});\n\nlet obj = Object.create(proxy);\nobj.time // 35\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。\n\n同一个拦截器函数，可以设置拦截多个操作。\n\nvar handler = {\n  get: function(target, name) {\n    if (name === 'prototype') {\n      return Object.prototype;\n    }\n    return 'Hello, ' + name;\n  },\n\n  apply: function(target, thisBinding, args) {\n    return args[0];\n  },\n\n  construct: function(target, args) {\n    return {value: args[1]};\n  }\n};\n\nvar fproxy = new Proxy(function(x, y) {\n  return x + y;\n}, handler);\n\nfproxy(1, 2) // 1\nnew fproxy(1, 2) // {value: 2}\nfproxy.prototype === Object.prototype // true\nfproxy.foo === \"Hello, foo\" // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。\n\n下面是 Proxy 支持的拦截操作一览，一共 13 种。\n\n * get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。\n * set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。\n * has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。\n * deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。\n * ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。\n * getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。\n * defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。\n * preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。\n * getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。\n * isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。\n * setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。\n * apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。\n * construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。\n\n\n# Proxy 实例的方法\n\n下面是上面这些拦截方法的详细介绍。\n\n\n# get()\n\nget方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。\n\nget方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。\n\nvar person = {\n  name: \"张三\"\n};\n\nvar proxy = new Proxy(person, {\n  get: function(target, propKey) {\n    if (propKey in target) {\n      return target[propKey];\n    } else {\n      throw new ReferenceError(\"Prop name \\\"\" + propKey + \"\\\" does not exist.\");\n    }\n  }\n});\n\nproxy.name // \"张三\"\nproxy.age // 抛出一个错误\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。\n\nget方法可以继承。\n\nlet proto = new Proxy({}, {\n  get(target, propertyKey, receiver) {\n    console.log('GET ' + propertyKey);\n    return target[propertyKey];\n  }\n});\n\nlet obj = Object.create(proto);\nobj.foo // \"GET foo\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。\n\n下面的例子使用get拦截，实现数组读取负数的索引。\n\nfunction createArray(...elements) {\n  let handler = {\n    get(target, propKey, receiver) {\n      let index = Number(propKey);\n      if (index < 0) {\n        propKey = String(target.length + index);\n      }\n      return Reflect.get(target, propKey, receiver);\n    }\n  };\n\n  let target = [];\n  target.push(...elements);\n  return new Proxy(target, handler);\n}\n\nlet arr = createArray('a', 'b', 'c');\narr[-1] // c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码中，数组的位置参数是-1，就会输出数组的倒数第一个成员。\n\n利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。\n\nvar pipe = (function () {\n  return function (value) {\n    var funcStack = [];\n    var oproxy = new Proxy({} , {\n      get : function (pipeObject, fnName) {\n        if (fnName === 'get') {\n          return funcStack.reduce(function (val, fn) {\n            return fn(val);\n          },value);\n        }\n        funcStack.push(window[fnName]);\n        return oproxy;\n      }\n    });\n\n    return oproxy;\n  }\n}());\n\nvar double = n => n * 2;\nvar pow    = n => n * n;\nvar reverseInt = n => n.toString().split(\"\").reverse().join(\"\") | 0;\n\npipe(3).double.pow.reverseInt.get; // 63\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。\n\n下面的例子则是利用get拦截，实现一个生成各种 DOM 节点的通用函数dom。\n\nconst dom = new Proxy({}, {\n  get(target, property) {\n    return function(attrs = {}, ...children) {\n      const el = document.createElement(property);\n      for (let prop of Object.keys(attrs)) {\n        el.setAttribute(prop, attrs[prop]);\n      }\n      for (let child of children) {\n        if (typeof child === 'string') {\n          child = document.createTextNode(child);\n        }\n        el.appendChild(child);\n      }\n      return el;\n    }\n  }\n});\n\nconst el = dom.div({},\n  'Hello, my name is ',\n  dom.a({href: '//example.com'}, 'Mark'),\n  '. I like:',\n  dom.ul({},\n    dom.li({}, 'The web'),\n    dom.li({}, 'Food'),\n    dom.li({}, '…actually that\\'s it')\n  )\n);\n\ndocument.body.appendChild(el);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n下面是一个get方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。\n\nconst proxy = new Proxy({}, {\n  get: function(target, key, receiver) {\n    return receiver;\n  }\n});\nproxy.getReceiver === proxy // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，proxy对象的getReceiver属性是由proxy对象提供的，所以receiver指向proxy对象。\n\nconst proxy = new Proxy({}, {\n  get: function(target, key, receiver) {\n    return receiver;\n  }\n});\n\nconst d = Object.create(proxy);\nd.a === d // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，d对象本身没有a属性，所以读取d.a的时候，会去d的原型proxy对象找。这时，receiver就指向d，代表原始的读操作所在的那个对象。\n\n如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。\n\nconst target = Object.defineProperties({}, {\n  foo: {\n    value: 123,\n    writable: false,\n    configurable: false\n  },\n});\n\nconst handler = {\n  get(target, propKey) {\n    return 'abc';\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\nproxy.foo\n// TypeError: Invariant check failed\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# set()\n\nset方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。\n\n假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。\n\nlet validator = {\n  set: function(obj, prop, value) {\n    if (prop === 'age') {\n      if (!Number.isInteger(value)) {\n        throw new TypeError('The age is not an integer');\n      }\n      if (value > 200) {\n        throw new RangeError('The age seems invalid');\n      }\n    }\n\n    // 对于满足条件的 age 属性以及其他属性，直接保存\n    obj[prop] = value;\n  }\n};\n\nlet person = new Proxy({}, validator);\n\nperson.age = 100;\n\nperson.age // 100\nperson.age = 'young' // 报错\nperson.age = 300 // 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。\n\n有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。\n\nconst handler = {\n  get (target, key) {\n    invariant(key, 'get');\n    return target[key];\n  },\n  set (target, key, value) {\n    invariant(key, 'set');\n    target[key] = value;\n    return true;\n  }\n};\nfunction invariant (key, action) {\n  if (key[0] === '_') {\n    throw new Error(`Invalid attempt to ${action} private \"${key}\" property`);\n  }\n}\nconst target = {};\nconst proxy = new Proxy(target, handler);\nproxy._prop\n// Error: Invalid attempt to get private \"_prop\" property\nproxy._prop = 'c'\n// Error: Invalid attempt to set private \"_prop\" property\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。\n\n下面是set方法第四个参数的例子。\n\nconst handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = receiver;\n  }\n};\nconst proxy = new Proxy({}, handler);\nproxy.foo = 'bar';\nproxy.foo === proxy // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，set方法的第四个参数receiver，指的是原始的操作行为所在的那个对象，一般情况下是proxy实例本身，请看下面的例子。\n\nconst handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = receiver;\n  }\n};\nconst proxy = new Proxy({}, handler);\nconst myObj = {};\nObject.setPrototypeOf(myObj, proxy);\n\nmyObj.foo = 'bar';\nmyObj.foo === myObj // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，设置myObj.foo属性的值时，myObj并没有foo属性，因此引擎会到myObj的原型链去找foo属性。myObj的原型对象proxy是一个 Proxy 实例，设置它的foo属性会触发set方法。这时，第四个参数receiver就指向原始赋值行为所在的对象myObj。\n\n注意，如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。\n\nconst obj = {};\nObject.defineProperty(obj, 'foo', {\n  value: 'bar',\n  writable: false,\n});\n\nconst handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = 'baz';\n  }\n};\n\nconst proxy = new Proxy(obj, handler);\nproxy.foo = 'baz';\nproxy.foo // \"bar\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，obj.foo属性不可写，Proxy 对这个属性的set代理将不会生效。\n\n注意，严格模式下，set代理如果没有返回true，就会报错。\n\n'use strict';\nconst handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = receiver;\n    // 无论有没有下面这一行，都会报错\n    return false;\n  }\n};\nconst proxy = new Proxy({}, handler);\nproxy.foo = 'bar';\n// TypeError: 'set' on proxy: trap returned falsish for property 'foo'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，严格模式下，set代理返回false或者undefined，都会报错。\n\n\n# apply()\n\napply方法拦截函数的调用、call和apply操作。\n\napply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。\n\nvar handler = {\n  apply (target, ctx, args) {\n    return Reflect.apply(...arguments);\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\n下面是一个例子。\n\nvar target = function () { return 'I am the target'; };\nvar handler = {\n  apply: function () {\n    return 'I am the proxy';\n  }\n};\n\nvar p = new Proxy(target, handler);\n\np()\n// \"I am the proxy\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，变量p是 Proxy 的实例，当它作为函数调用时（p()），就会被apply方法拦截，返回一个字符串。\n\n下面是另外一个例子。\n\nvar twice = {\n  apply (target, ctx, args) {\n    return Reflect.apply(...arguments) * 2;\n  }\n};\nfunction sum (left, right) {\n  return left + right;\n};\nvar proxy = new Proxy(sum, twice);\nproxy(1, 2) // 6\nproxy.call(null, 5, 6) // 22\nproxy.apply(null, [7, 8]) // 30\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截。\n\n另外，直接调用Reflect.apply方法，也会被拦截。\n\nReflect.apply(proxy, null, [9, 10]) // 38\n\n\n1\n\n\n\n# has()\n\nhas方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。\n\nhas方法可以接受两个参数，分别是目标对象、需查询的属性名。\n\n下面的例子使用has方法隐藏某些属性，不被in运算符发现。\n\nvar handler = {\n  has (target, key) {\n    if (key[0] === '_') {\n      return false;\n    }\n    return key in target;\n  }\n};\nvar target = { _prop: 'foo', prop: 'foo' };\nvar proxy = new Proxy(target, handler);\n'_prop' in proxy // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，如果原对象的属性名的第一个字符是下划线，proxy.has就会返回false，从而不会被in运算符发现。\n\n如果原对象不可配置或者禁止扩展，这时has拦截会报错。\n\nvar obj = { a: 10 };\nObject.preventExtensions(obj);\n\nvar p = new Proxy(obj, {\n  has: function(target, prop) {\n    return false;\n  }\n});\n\n'a' in p // TypeError is thrown\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，obj对象禁止扩展，结果使用has拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则has方法就不得“隐藏”（即返回false）目标对象的该属性。\n\n值得注意的是，has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。\n\n另外，虽然for...in循环也用到了in运算符，但是has拦截对for...in循环不生效。\n\nlet stu1 = {name: '张三', score: 59};\nlet stu2 = {name: '李四', score: 99};\n\nlet handler = {\n  has(target, prop) {\n    if (prop === 'score' && target[prop] < 60) {\n      console.log(`${target.name} 不及格`);\n      return false;\n    }\n    return prop in target;\n  }\n}\n\nlet oproxy1 = new Proxy(stu1, handler);\nlet oproxy2 = new Proxy(stu2, handler);\n\n'score' in oproxy1\n// 张三 不及格\n// false\n\n'score' in oproxy2\n// true\n\nfor (let a in oproxy1) {\n  console.log(oproxy1[a]);\n}\n// 张三\n// 59\n\nfor (let b in oproxy2) {\n  console.log(oproxy2[b]);\n}\n// 李四\n// 99\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n上面代码中，has拦截只对in运算符生效，对for...in循环不生效，导致不符合要求的属性没有被for...in循环所排除。\n\n\n# construct()\n\nconstruct方法用于拦截new命令，下面是拦截对象的写法。\n\nvar handler = {\n  construct (target, args, newTarget) {\n    return new target(...args);\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\nconstruct方法可以接受两个参数。\n\n * target：目标对象\n * args：构造函数的参数对象\n * newTarget：创造实例对象时，new命令作用的构造函数（下面例子的p）\n\nvar p = new Proxy(function () {}, {\n  construct: function(target, args) {\n    console.log('called: ' + args.join(', '));\n    return { value: args[0] * 10 };\n  }\n});\n\n(new p(1)).value\n// \"called: 1\"\n// 10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nconstruct方法返回的必须是一个对象，否则会报错。\n\nvar p = new Proxy(function() {}, {\n  construct: function(target, argumentsList) {\n    return 1;\n  }\n});\n\nnew p() // 报错\n// Uncaught TypeError: 'construct' on proxy: trap returned non-object ('1')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# deleteProperty()\n\ndeleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。\n\nvar handler = {\n  deleteProperty (target, key) {\n    invariant(key, 'delete');\n    delete target[key];\n    return true;\n  }\n};\nfunction invariant (key, action) {\n  if (key[0] === '_') {\n    throw new Error(`Invalid attempt to ${action} private \"${key}\" property`);\n  }\n}\n\nvar target = { _prop: 'foo' };\nvar proxy = new Proxy(target, handler);\ndelete proxy._prop\n// Error: Invalid attempt to delete private \"_prop\" property\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，deleteProperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。\n\n注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。\n\n\n# defineProperty()\n\ndefineProperty方法拦截了Object.defineProperty操作。\n\nvar handler = {\n  defineProperty (target, key, descriptor) {\n    return false;\n  }\n};\nvar target = {};\nvar proxy = new Proxy(target, handler);\nproxy.foo = 'bar' // 不会生效\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，defineProperty方法返回false，导致添加新属性总是无效。\n\n注意，如果目标对象不可扩展（non-extensible），则defineProperty不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则defineProperty方法不得改变这两个设置。\n\n\n# getOwnPropertyDescriptor()\n\ngetOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。\n\nvar handler = {\n  getOwnPropertyDescriptor (target, key) {\n    if (key[0] === '_') {\n      return;\n    }\n    return Object.getOwnPropertyDescriptor(target, key);\n  }\n};\nvar target = { _foo: 'bar', baz: 'tar' };\nvar proxy = new Proxy(target, handler);\nObject.getOwnPropertyDescriptor(proxy, 'wat')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, '_foo')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, 'baz')\n// { value: 'tar', writable: true, enumerable: true, configurable: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，handler.getOwnPropertyDescriptor方法对于第一个字符为下划线的属性名会返回undefined。\n\n\n# getPrototypeOf()\n\ngetPrototypeOf方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。\n\n * Object.prototype.__proto__\n * Object.prototype.isPrototypeOf()\n * Object.getPrototypeOf()\n * Reflect.getPrototypeOf()\n * instanceof\n\n下面是一个例子。\n\nvar proto = {};\nvar p = new Proxy({}, {\n  getPrototypeOf(target) {\n    return proto;\n  }\n});\nObject.getPrototypeOf(p) === proto // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，getPrototypeOf方法拦截Object.getPrototypeOf()，返回proto对象。\n\n注意，getPrototypeOf方法的返回值必须是对象或者null，否则报错。另外，如果目标对象不可扩展（non-extensible）， getPrototypeOf方法必须返回目标对象的原型对象。\n\n\n# isExtensible()\n\nisExtensible方法拦截Object.isExtensible操作。\n\nvar p = new Proxy({}, {\n  isExtensible: function(target) {\n    console.log(\"called\");\n    return true;\n  }\n});\n\nObject.isExtensible(p)\n// \"called\"\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码设置了isExtensible方法，在调用Object.isExtensible时会输出called。\n\n注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。\n\n这个方法有一个强限制，它的返回值必须与目标对象的isExtensible属性保持一致，否则就会抛出错误。\n\nObject.isExtensible(proxy) === Object.isExtensible(target)\n\n\n1\n\n\n下面是一个例子。\n\nvar p = new Proxy({}, {\n  isExtensible: function(target) {\n    return false;\n  }\n});\n\nObject.isExtensible(p)\n// Uncaught TypeError: 'isExtensible' on proxy: trap result does not reflect extensibility of proxy target (which is 'true')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# ownKeys()\n\nownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。\n\n * Object.getOwnPropertyNames()\n * Object.getOwnPropertySymbols()\n * Object.keys()\n * for...in循环\n\n下面是拦截Object.keys()的例子。\n\nlet target = {\n  a: 1,\n  b: 2,\n  c: 3\n};\n\nlet handler = {\n  ownKeys(target) {\n    return ['a'];\n  }\n};\n\nlet proxy = new Proxy(target, handler);\n\nObject.keys(proxy)\n// [ 'a' ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码拦截了对于target对象的Object.keys()操作，只返回a、b、c三个属性之中的a属性。\n\n下面的例子是拦截第一个字符为下划线的属性名。\n\nlet target = {\n  _bar: 'foo',\n  _prop: 'bar',\n  prop: 'baz'\n};\n\nlet handler = {\n  ownKeys (target) {\n    return Reflect.ownKeys(target).filter(key => key[0] !== '_');\n  }\n};\n\nlet proxy = new Proxy(target, handler);\nfor (let key of Object.keys(proxy)) {\n  console.log(target[key]);\n}\n// \"baz\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n注意，使用Object.keys方法时，有三类属性会被ownKeys方法自动过滤，不会返回。\n\n * 目标对象上不存在的属性\n * 属性名为 Symbol 值\n * 不可遍历（enumerable）的属性\n\nlet target = {\n  a: 1,\n  b: 2,\n  c: 3,\n  [Symbol.for('secret')]: '4',\n};\n\nObject.defineProperty(target, 'key', {\n  enumerable: false,\n  configurable: true,\n  writable: true,\n  value: 'static'\n});\n\nlet handler = {\n  ownKeys(target) {\n    return ['a', 'd', Symbol.for('secret'), 'key'];\n  }\n};\n\nlet proxy = new Proxy(target, handler);\n\nObject.keys(proxy)\n// ['a']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码中，ownKeys方法之中，显式返回不存在的属性（d）、Symbol 值（Symbol.for('secret')）、不可遍历的属性（key），结果都被自动过滤掉。\n\nownKeys方法还可以拦截Object.getOwnPropertyNames()。\n\nvar p = new Proxy({}, {\n  ownKeys: function(target) {\n    return ['a', 'b', 'c'];\n  }\n});\n\nObject.getOwnPropertyNames(p)\n// [ 'a', 'b', 'c' ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nfor...in循环也受到ownKeys方法的拦截。\n\nconst obj = { hello: 'world' };\nconst proxy = new Proxy(obj, {\n  ownKeys: function () {\n    return ['a', 'b'];\n  }\n});\n\nfor (let key in proxy) {\n  console.log(key); // 没有任何输出\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，ownkeys指定只返回a和b属性，由于obj没有这两个属性，因此for...in循环不会有任何输出。\n\nownKeys方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。\n\nvar obj = {};\n\nvar p = new Proxy(obj, {\n  ownKeys: function(target) {\n    return [123, true, undefined, null, {}, []];\n  }\n});\n\nObject.getOwnPropertyNames(p)\n// Uncaught TypeError: 123 is not a valid property name\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，ownKeys方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。\n\n如果目标对象自身包含不可配置的属性，则该属性必须被ownKeys方法返回，否则报错。\n\nvar obj = {};\nObject.defineProperty(obj, 'a', {\n  configurable: false,\n  enumerable: true,\n  value: 10 }\n);\n\nvar p = new Proxy(obj, {\n  ownKeys: function(target) {\n    return ['b'];\n  }\n});\n\nObject.getOwnPropertyNames(p)\n// Uncaught TypeError: 'ownKeys' on proxy: trap result did not include 'a'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，obj对象的a属性是不可配置的，这时ownKeys方法返回的数组之中，必须包含a，否则会报错。\n\n另外，如果目标对象是不可扩展的（non-extensible），这时ownKeys方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。\n\nvar obj = {\n  a: 1\n};\n\nObject.preventExtensions(obj);\n\nvar p = new Proxy(obj, {\n  ownKeys: function(target) {\n    return ['a', 'b'];\n  }\n});\n\nObject.getOwnPropertyNames(p)\n// Uncaught TypeError: 'ownKeys' on proxy: trap returned extra keys but proxy target is non-extensible\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，obj对象是不可扩展的，这时ownKeys方法返回的数组之中，包含了obj对象的多余属性b，所以导致了报错。\n\n\n# preventExtensions()\n\npreventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。\n\n这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。\n\nvar proxy = new Proxy({}, {\n  preventExtensions: function(target) {\n    return true;\n  }\n});\n\nObject.preventExtensions(proxy)\n// Uncaught TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，proxy.preventExtensions方法返回true，但这时Object.isExtensible(proxy)会返回true，因此报错。\n\n为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensions。\n\nvar proxy = new Proxy({}, {\n  preventExtensions: function(target) {\n    console.log('called');\n    Object.preventExtensions(target);\n    return true;\n  }\n});\n\nObject.preventExtensions(proxy)\n// \"called\"\n// Proxy {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# setPrototypeOf()\n\nsetPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。\n\n下面是一个例子。\n\nvar handler = {\n  setPrototypeOf (target, proto) {\n    throw new Error('Changing the prototype is forbidden');\n  }\n};\nvar proto = {};\nvar target = function () {};\nvar proxy = new Proxy(target, handler);\nObject.setPrototypeOf(proxy, proto);\n// Error: Changing the prototype is forbidden\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，只要修改target的原型对象，就会报错。\n\n注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），setPrototypeOf方法不得改变目标对象的原型。\n\n\n# Proxy.revocable()\n\nProxy.revocable方法返回一个可取消的 Proxy 实例。\n\nlet target = {};\nlet handler = {};\n\nlet {proxy, revoke} = Proxy.revocable(target, handler);\n\nproxy.foo = 123;\nproxy.foo // 123\n\nrevoke();\nproxy.foo // TypeError: Revoked\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nProxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。\n\nProxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。\n\n\n# this 问题\n\n虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。\n\nconst target = {\n  m: function () {\n    console.log(this === proxy);\n  }\n};\nconst handler = {};\n\nconst proxy = new Proxy(target, handler);\n\ntarget.m() // false\nproxy.m()  // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，一旦proxy代理target.m，后者内部的this就是指向proxy，而不是target。\n\n下面是一个例子，由于this指向的变化，导致 Proxy 无法代理目标对象。\n\nconst _name = new WeakMap();\n\nclass Person {\n  constructor(name) {\n    _name.set(this, name);\n  }\n  get name() {\n    return _name.get(this);\n  }\n}\n\nconst jane = new Person('Jane');\njane.name // 'Jane'\n\nconst proxy = new Proxy(jane, {});\nproxy.name // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，目标对象jane的name属性，实际保存在外部WeakMap对象_name上面，通过this键区分。由于通过proxy.name访问时，this指向proxy，导致无法取到值，所以返回undefined。\n\n此外，有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。\n\nconst target = new Date();\nconst handler = {};\nconst proxy = new Proxy(target, handler);\n\nproxy.getDate();\n// TypeError: this is not a Date object.\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，getDate方法只能在Date对象实例上面拿到，如果this不是Date对象实例就会报错。这时，this绑定原始对象，就可以解决这个问题。\n\nconst target = new Date('2015-01-01');\nconst handler = {\n  get(target, prop) {\n    if (prop === 'getDate') {\n      return target.getDate.bind(target);\n    }\n    return Reflect.get(target, prop);\n  }\n};\nconst proxy = new Proxy(target, handler);\n\nproxy.getDate() // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 实例：Web 服务的客户端\n\nProxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。\n\nconst service = createWebService('http://example.com/data');\n\nservice.employees().then(json => {\n  const employees = JSON.parse(json);\n  // ···\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。\n\nfunction createWebService(baseUrl) {\n  return new Proxy({}, {\n    get(target, propKey, receiver) {\n      return () => httpGet(baseUrl + '/' + propKey);\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n同理，Proxy 也可以用来实现数据库的 ORM 层。",normalizedContent:"# proxy\n\n\n# 概述\n\nproxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\n\nproxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\n\nvar obj = new proxy({}, {\n  get: function (target, propkey, receiver) {\n    console.log(`getting ${propkey}!`);\n    return reflect.get(target, propkey, receiver);\n  },\n  set: function (target, propkey, value, receiver) {\n    console.log(`setting ${propkey}!`);\n    return reflect.set(target, propkey, value, receiver);\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。\n\nobj.count = 1\n//  setting count!\n++obj.count\n//  getting count!\n//  setting count!\n//  2\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码说明，proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。\n\nes6 原生提供 proxy 构造函数，用来生成 proxy 实例。\n\nvar proxy = new proxy(target, handler);\n\n\n1\n\n\nproxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new proxy()表示生成一个proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。\n\n下面是另一个拦截读取属性行为的例子。\n\nvar proxy = new proxy({}, {\n  get: function(target, propkey) {\n    return 35;\n  }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.title // 35\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，作为构造函数，proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。\n\n注意，要使得proxy起作用，必须针对proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。\n\n如果handler没有设置任何拦截，那就等同于直接通向原对象。\n\nvar target = {};\nvar handler = {};\nvar proxy = new proxy(target, handler);\nproxy.a = 'b';\ntarget.a // \"b\"\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，handler是一个空对象，没有任何拦截效果，访问proxy就等同于访问target。\n\n一个技巧是将 proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。\n\nvar object = { proxy: new proxy(target, handler) };\n\n\n1\n\n\nproxy 实例也可以作为其他对象的原型对象。\n\nvar proxy = new proxy({}, {\n  get: function(target, propkey) {\n    return 35;\n  }\n});\n\nlet obj = object.create(proxy);\nobj.time // 35\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。\n\n同一个拦截器函数，可以设置拦截多个操作。\n\nvar handler = {\n  get: function(target, name) {\n    if (name === 'prototype') {\n      return object.prototype;\n    }\n    return 'hello, ' + name;\n  },\n\n  apply: function(target, thisbinding, args) {\n    return args[0];\n  },\n\n  construct: function(target, args) {\n    return {value: args[1]};\n  }\n};\n\nvar fproxy = new proxy(function(x, y) {\n  return x + y;\n}, handler);\n\nfproxy(1, 2) // 1\nnew fproxy(1, 2) // {value: 2}\nfproxy.prototype === object.prototype // true\nfproxy.foo === \"hello, foo\" // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。\n\n下面是 proxy 支持的拦截操作一览，一共 13 种。\n\n * get(target, propkey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。\n * set(target, propkey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。\n * has(target, propkey)：拦截propkey in proxy的操作，返回一个布尔值。\n * deleteproperty(target, propkey)：拦截delete proxy[propkey]的操作，返回一个布尔值。\n * ownkeys(target)：拦截object.getownpropertynames(proxy)、object.getownpropertysymbols(proxy)、object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而object.keys()的返回结果仅包括目标对象自身的可遍历属性。\n * getownpropertydescriptor(target, propkey)：拦截object.getownpropertydescriptor(proxy, propkey)，返回属性的描述对象。\n * defineproperty(target, propkey, propdesc)：拦截object.defineproperty(proxy, propkey, propdesc）、object.defineproperties(proxy, propdescs)，返回一个布尔值。\n * preventextensions(target)：拦截object.preventextensions(proxy)，返回一个布尔值。\n * getprototypeof(target)：拦截object.getprototypeof(proxy)，返回一个对象。\n * isextensible(target)：拦截object.isextensible(proxy)，返回一个布尔值。\n * setprototypeof(target, proto)：拦截object.setprototypeof(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。\n * apply(target, object, args)：拦截 proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。\n * construct(target, args)：拦截 proxy 实例作为构造函数调用的操作，比如new proxy(...args)。\n\n\n# proxy 实例的方法\n\n下面是上面这些拦截方法的详细介绍。\n\n\n# get()\n\nget方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。\n\nget方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。\n\nvar person = {\n  name: \"张三\"\n};\n\nvar proxy = new proxy(person, {\n  get: function(target, propkey) {\n    if (propkey in target) {\n      return target[propkey];\n    } else {\n      throw new referenceerror(\"prop name \\\"\" + propkey + \"\\\" does not exist.\");\n    }\n  }\n});\n\nproxy.name // \"张三\"\nproxy.age // 抛出一个错误\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。\n\nget方法可以继承。\n\nlet proto = new proxy({}, {\n  get(target, propertykey, receiver) {\n    console.log('get ' + propertykey);\n    return target[propertykey];\n  }\n});\n\nlet obj = object.create(proto);\nobj.foo // \"get foo\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，拦截操作定义在prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。\n\n下面的例子使用get拦截，实现数组读取负数的索引。\n\nfunction createarray(...elements) {\n  let handler = {\n    get(target, propkey, receiver) {\n      let index = number(propkey);\n      if (index < 0) {\n        propkey = string(target.length + index);\n      }\n      return reflect.get(target, propkey, receiver);\n    }\n  };\n\n  let target = [];\n  target.push(...elements);\n  return new proxy(target, handler);\n}\n\nlet arr = createarray('a', 'b', 'c');\narr[-1] // c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码中，数组的位置参数是-1，就会输出数组的倒数第一个成员。\n\n利用 proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。\n\nvar pipe = (function () {\n  return function (value) {\n    var funcstack = [];\n    var oproxy = new proxy({} , {\n      get : function (pipeobject, fnname) {\n        if (fnname === 'get') {\n          return funcstack.reduce(function (val, fn) {\n            return fn(val);\n          },value);\n        }\n        funcstack.push(window[fnname]);\n        return oproxy;\n      }\n    });\n\n    return oproxy;\n  }\n}());\n\nvar double = n => n * 2;\nvar pow    = n => n * n;\nvar reverseint = n => n.tostring().split(\"\").reverse().join(\"\") | 0;\n\npipe(3).double.pow.reverseint.get; // 63\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码设置 proxy 以后，达到了将函数名链式使用的效果。\n\n下面的例子则是利用get拦截，实现一个生成各种 dom 节点的通用函数dom。\n\nconst dom = new proxy({}, {\n  get(target, property) {\n    return function(attrs = {}, ...children) {\n      const el = document.createelement(property);\n      for (let prop of object.keys(attrs)) {\n        el.setattribute(prop, attrs[prop]);\n      }\n      for (let child of children) {\n        if (typeof child === 'string') {\n          child = document.createtextnode(child);\n        }\n        el.appendchild(child);\n      }\n      return el;\n    }\n  }\n});\n\nconst el = dom.div({},\n  'hello, my name is ',\n  dom.a({href: '//example.com'}, 'mark'),\n  '. i like:',\n  dom.ul({},\n    dom.li({}, 'the web'),\n    dom.li({}, 'food'),\n    dom.li({}, '…actually that\\'s it')\n  )\n);\n\ndocument.body.appendchild(el);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n下面是一个get方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 proxy 实例。\n\nconst proxy = new proxy({}, {\n  get: function(target, key, receiver) {\n    return receiver;\n  }\n});\nproxy.getreceiver === proxy // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，proxy对象的getreceiver属性是由proxy对象提供的，所以receiver指向proxy对象。\n\nconst proxy = new proxy({}, {\n  get: function(target, key, receiver) {\n    return receiver;\n  }\n});\n\nconst d = object.create(proxy);\nd.a === d // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，d对象本身没有a属性，所以读取d.a的时候，会去d的原型proxy对象找。这时，receiver就指向d，代表原始的读操作所在的那个对象。\n\n如果一个属性不可配置（configurable）且不可写（writable），则 proxy 不能修改该属性，否则通过 proxy 对象访问该属性会报错。\n\nconst target = object.defineproperties({}, {\n  foo: {\n    value: 123,\n    writable: false,\n    configurable: false\n  },\n});\n\nconst handler = {\n  get(target, propkey) {\n    return 'abc';\n  }\n};\n\nconst proxy = new proxy(target, handler);\n\nproxy.foo\n// typeerror: invariant check failed\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# set()\n\nset方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 proxy 实例本身，其中最后一个参数可选。\n\n假定person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用proxy保证age的属性值符合要求。\n\nlet validator = {\n  set: function(obj, prop, value) {\n    if (prop === 'age') {\n      if (!number.isinteger(value)) {\n        throw new typeerror('the age is not an integer');\n      }\n      if (value > 200) {\n        throw new rangeerror('the age seems invalid');\n      }\n    }\n\n    // 对于满足条件的 age 属性以及其他属性，直接保存\n    obj[prop] = value;\n  }\n};\n\nlet person = new proxy({}, validator);\n\nperson.age = 100;\n\nperson.age // 100\nperson.age = 'young' // 报错\nperson.age = 300 // 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 dom。\n\n有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。\n\nconst handler = {\n  get (target, key) {\n    invariant(key, 'get');\n    return target[key];\n  },\n  set (target, key, value) {\n    invariant(key, 'set');\n    target[key] = value;\n    return true;\n  }\n};\nfunction invariant (key, action) {\n  if (key[0] === '_') {\n    throw new error(`invalid attempt to ${action} private \"${key}\" property`);\n  }\n}\nconst target = {};\nconst proxy = new proxy(target, handler);\nproxy._prop\n// error: invalid attempt to get private \"_prop\" property\nproxy._prop = 'c'\n// error: invalid attempt to set private \"_prop\" property\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。\n\n下面是set方法第四个参数的例子。\n\nconst handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = receiver;\n  }\n};\nconst proxy = new proxy({}, handler);\nproxy.foo = 'bar';\nproxy.foo === proxy // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，set方法的第四个参数receiver，指的是原始的操作行为所在的那个对象，一般情况下是proxy实例本身，请看下面的例子。\n\nconst handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = receiver;\n  }\n};\nconst proxy = new proxy({}, handler);\nconst myobj = {};\nobject.setprototypeof(myobj, proxy);\n\nmyobj.foo = 'bar';\nmyobj.foo === myobj // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，设置myobj.foo属性的值时，myobj并没有foo属性，因此引擎会到myobj的原型链去找foo属性。myobj的原型对象proxy是一个 proxy 实例，设置它的foo属性会触发set方法。这时，第四个参数receiver就指向原始赋值行为所在的对象myobj。\n\n注意，如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。\n\nconst obj = {};\nobject.defineproperty(obj, 'foo', {\n  value: 'bar',\n  writable: false,\n});\n\nconst handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = 'baz';\n  }\n};\n\nconst proxy = new proxy(obj, handler);\nproxy.foo = 'baz';\nproxy.foo // \"bar\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，obj.foo属性不可写，proxy 对这个属性的set代理将不会生效。\n\n注意，严格模式下，set代理如果没有返回true，就会报错。\n\n'use strict';\nconst handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = receiver;\n    // 无论有没有下面这一行，都会报错\n    return false;\n  }\n};\nconst proxy = new proxy({}, handler);\nproxy.foo = 'bar';\n// typeerror: 'set' on proxy: trap returned falsish for property 'foo'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，严格模式下，set代理返回false或者undefined，都会报错。\n\n\n# apply()\n\napply方法拦截函数的调用、call和apply操作。\n\napply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。\n\nvar handler = {\n  apply (target, ctx, args) {\n    return reflect.apply(...arguments);\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\n下面是一个例子。\n\nvar target = function () { return 'i am the target'; };\nvar handler = {\n  apply: function () {\n    return 'i am the proxy';\n  }\n};\n\nvar p = new proxy(target, handler);\n\np()\n// \"i am the proxy\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，变量p是 proxy 的实例，当它作为函数调用时（p()），就会被apply方法拦截，返回一个字符串。\n\n下面是另外一个例子。\n\nvar twice = {\n  apply (target, ctx, args) {\n    return reflect.apply(...arguments) * 2;\n  }\n};\nfunction sum (left, right) {\n  return left + right;\n};\nvar proxy = new proxy(sum, twice);\nproxy(1, 2) // 6\nproxy.call(null, 5, 6) // 22\nproxy.apply(null, [7, 8]) // 30\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截。\n\n另外，直接调用reflect.apply方法，也会被拦截。\n\nreflect.apply(proxy, null, [9, 10]) // 38\n\n\n1\n\n\n\n# has()\n\nhas方法用来拦截hasproperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。\n\nhas方法可以接受两个参数，分别是目标对象、需查询的属性名。\n\n下面的例子使用has方法隐藏某些属性，不被in运算符发现。\n\nvar handler = {\n  has (target, key) {\n    if (key[0] === '_') {\n      return false;\n    }\n    return key in target;\n  }\n};\nvar target = { _prop: 'foo', prop: 'foo' };\nvar proxy = new proxy(target, handler);\n'_prop' in proxy // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，如果原对象的属性名的第一个字符是下划线，proxy.has就会返回false，从而不会被in运算符发现。\n\n如果原对象不可配置或者禁止扩展，这时has拦截会报错。\n\nvar obj = { a: 10 };\nobject.preventextensions(obj);\n\nvar p = new proxy(obj, {\n  has: function(target, prop) {\n    return false;\n  }\n});\n\n'a' in p // typeerror is thrown\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，obj对象禁止扩展，结果使用has拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则has方法就不得“隐藏”（即返回false）目标对象的该属性。\n\n值得注意的是，has方法拦截的是hasproperty操作，而不是hasownproperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。\n\n另外，虽然for...in循环也用到了in运算符，但是has拦截对for...in循环不生效。\n\nlet stu1 = {name: '张三', score: 59};\nlet stu2 = {name: '李四', score: 99};\n\nlet handler = {\n  has(target, prop) {\n    if (prop === 'score' && target[prop] < 60) {\n      console.log(`${target.name} 不及格`);\n      return false;\n    }\n    return prop in target;\n  }\n}\n\nlet oproxy1 = new proxy(stu1, handler);\nlet oproxy2 = new proxy(stu2, handler);\n\n'score' in oproxy1\n// 张三 不及格\n// false\n\n'score' in oproxy2\n// true\n\nfor (let a in oproxy1) {\n  console.log(oproxy1[a]);\n}\n// 张三\n// 59\n\nfor (let b in oproxy2) {\n  console.log(oproxy2[b]);\n}\n// 李四\n// 99\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n上面代码中，has拦截只对in运算符生效，对for...in循环不生效，导致不符合要求的属性没有被for...in循环所排除。\n\n\n# construct()\n\nconstruct方法用于拦截new命令，下面是拦截对象的写法。\n\nvar handler = {\n  construct (target, args, newtarget) {\n    return new target(...args);\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\nconstruct方法可以接受两个参数。\n\n * target：目标对象\n * args：构造函数的参数对象\n * newtarget：创造实例对象时，new命令作用的构造函数（下面例子的p）\n\nvar p = new proxy(function () {}, {\n  construct: function(target, args) {\n    console.log('called: ' + args.join(', '));\n    return { value: args[0] * 10 };\n  }\n});\n\n(new p(1)).value\n// \"called: 1\"\n// 10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nconstruct方法返回的必须是一个对象，否则会报错。\n\nvar p = new proxy(function() {}, {\n  construct: function(target, argumentslist) {\n    return 1;\n  }\n});\n\nnew p() // 报错\n// uncaught typeerror: 'construct' on proxy: trap returned non-object ('1')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# deleteproperty()\n\ndeleteproperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。\n\nvar handler = {\n  deleteproperty (target, key) {\n    invariant(key, 'delete');\n    delete target[key];\n    return true;\n  }\n};\nfunction invariant (key, action) {\n  if (key[0] === '_') {\n    throw new error(`invalid attempt to ${action} private \"${key}\" property`);\n  }\n}\n\nvar target = { _prop: 'foo' };\nvar proxy = new proxy(target, handler);\ndelete proxy._prop\n// error: invalid attempt to delete private \"_prop\" property\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，deleteproperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。\n\n注意，目标对象自身的不可配置（configurable）的属性，不能被deleteproperty方法删除，否则报错。\n\n\n# defineproperty()\n\ndefineproperty方法拦截了object.defineproperty操作。\n\nvar handler = {\n  defineproperty (target, key, descriptor) {\n    return false;\n  }\n};\nvar target = {};\nvar proxy = new proxy(target, handler);\nproxy.foo = 'bar' // 不会生效\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，defineproperty方法返回false，导致添加新属性总是无效。\n\n注意，如果目标对象不可扩展（non-extensible），则defineproperty不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则defineproperty方法不得改变这两个设置。\n\n\n# getownpropertydescriptor()\n\ngetownpropertydescriptor方法拦截object.getownpropertydescriptor()，返回一个属性描述对象或者undefined。\n\nvar handler = {\n  getownpropertydescriptor (target, key) {\n    if (key[0] === '_') {\n      return;\n    }\n    return object.getownpropertydescriptor(target, key);\n  }\n};\nvar target = { _foo: 'bar', baz: 'tar' };\nvar proxy = new proxy(target, handler);\nobject.getownpropertydescriptor(proxy, 'wat')\n// undefined\nobject.getownpropertydescriptor(proxy, '_foo')\n// undefined\nobject.getownpropertydescriptor(proxy, 'baz')\n// { value: 'tar', writable: true, enumerable: true, configurable: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，handler.getownpropertydescriptor方法对于第一个字符为下划线的属性名会返回undefined。\n\n\n# getprototypeof()\n\ngetprototypeof方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。\n\n * object.prototype.__proto__\n * object.prototype.isprototypeof()\n * object.getprototypeof()\n * reflect.getprototypeof()\n * instanceof\n\n下面是一个例子。\n\nvar proto = {};\nvar p = new proxy({}, {\n  getprototypeof(target) {\n    return proto;\n  }\n});\nobject.getprototypeof(p) === proto // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，getprototypeof方法拦截object.getprototypeof()，返回proto对象。\n\n注意，getprototypeof方法的返回值必须是对象或者null，否则报错。另外，如果目标对象不可扩展（non-extensible）， getprototypeof方法必须返回目标对象的原型对象。\n\n\n# isextensible()\n\nisextensible方法拦截object.isextensible操作。\n\nvar p = new proxy({}, {\n  isextensible: function(target) {\n    console.log(\"called\");\n    return true;\n  }\n});\n\nobject.isextensible(p)\n// \"called\"\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码设置了isextensible方法，在调用object.isextensible时会输出called。\n\n注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。\n\n这个方法有一个强限制，它的返回值必须与目标对象的isextensible属性保持一致，否则就会抛出错误。\n\nobject.isextensible(proxy) === object.isextensible(target)\n\n\n1\n\n\n下面是一个例子。\n\nvar p = new proxy({}, {\n  isextensible: function(target) {\n    return false;\n  }\n});\n\nobject.isextensible(p)\n// uncaught typeerror: 'isextensible' on proxy: trap result does not reflect extensibility of proxy target (which is 'true')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# ownkeys()\n\nownkeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。\n\n * object.getownpropertynames()\n * object.getownpropertysymbols()\n * object.keys()\n * for...in循环\n\n下面是拦截object.keys()的例子。\n\nlet target = {\n  a: 1,\n  b: 2,\n  c: 3\n};\n\nlet handler = {\n  ownkeys(target) {\n    return ['a'];\n  }\n};\n\nlet proxy = new proxy(target, handler);\n\nobject.keys(proxy)\n// [ 'a' ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码拦截了对于target对象的object.keys()操作，只返回a、b、c三个属性之中的a属性。\n\n下面的例子是拦截第一个字符为下划线的属性名。\n\nlet target = {\n  _bar: 'foo',\n  _prop: 'bar',\n  prop: 'baz'\n};\n\nlet handler = {\n  ownkeys (target) {\n    return reflect.ownkeys(target).filter(key => key[0] !== '_');\n  }\n};\n\nlet proxy = new proxy(target, handler);\nfor (let key of object.keys(proxy)) {\n  console.log(target[key]);\n}\n// \"baz\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n注意，使用object.keys方法时，有三类属性会被ownkeys方法自动过滤，不会返回。\n\n * 目标对象上不存在的属性\n * 属性名为 symbol 值\n * 不可遍历（enumerable）的属性\n\nlet target = {\n  a: 1,\n  b: 2,\n  c: 3,\n  [symbol.for('secret')]: '4',\n};\n\nobject.defineproperty(target, 'key', {\n  enumerable: false,\n  configurable: true,\n  writable: true,\n  value: 'static'\n});\n\nlet handler = {\n  ownkeys(target) {\n    return ['a', 'd', symbol.for('secret'), 'key'];\n  }\n};\n\nlet proxy = new proxy(target, handler);\n\nobject.keys(proxy)\n// ['a']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码中，ownkeys方法之中，显式返回不存在的属性（d）、symbol 值（symbol.for('secret')）、不可遍历的属性（key），结果都被自动过滤掉。\n\nownkeys方法还可以拦截object.getownpropertynames()。\n\nvar p = new proxy({}, {\n  ownkeys: function(target) {\n    return ['a', 'b', 'c'];\n  }\n});\n\nobject.getownpropertynames(p)\n// [ 'a', 'b', 'c' ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nfor...in循环也受到ownkeys方法的拦截。\n\nconst obj = { hello: 'world' };\nconst proxy = new proxy(obj, {\n  ownkeys: function () {\n    return ['a', 'b'];\n  }\n});\n\nfor (let key in proxy) {\n  console.log(key); // 没有任何输出\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，ownkeys指定只返回a和b属性，由于obj没有这两个属性，因此for...in循环不会有任何输出。\n\nownkeys方法返回的数组成员，只能是字符串或 symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。\n\nvar obj = {};\n\nvar p = new proxy(obj, {\n  ownkeys: function(target) {\n    return [123, true, undefined, null, {}, []];\n  }\n});\n\nobject.getownpropertynames(p)\n// uncaught typeerror: 123 is not a valid property name\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，ownkeys方法虽然返回一个数组，但是每一个数组成员都不是字符串或 symbol 值，因此就报错了。\n\n如果目标对象自身包含不可配置的属性，则该属性必须被ownkeys方法返回，否则报错。\n\nvar obj = {};\nobject.defineproperty(obj, 'a', {\n  configurable: false,\n  enumerable: true,\n  value: 10 }\n);\n\nvar p = new proxy(obj, {\n  ownkeys: function(target) {\n    return ['b'];\n  }\n});\n\nobject.getownpropertynames(p)\n// uncaught typeerror: 'ownkeys' on proxy: trap result did not include 'a'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，obj对象的a属性是不可配置的，这时ownkeys方法返回的数组之中，必须包含a，否则会报错。\n\n另外，如果目标对象是不可扩展的（non-extensible），这时ownkeys方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。\n\nvar obj = {\n  a: 1\n};\n\nobject.preventextensions(obj);\n\nvar p = new proxy(obj, {\n  ownkeys: function(target) {\n    return ['a', 'b'];\n  }\n});\n\nobject.getownpropertynames(p)\n// uncaught typeerror: 'ownkeys' on proxy: trap returned extra keys but proxy target is non-extensible\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，obj对象是不可扩展的，这时ownkeys方法返回的数组之中，包含了obj对象的多余属性b，所以导致了报错。\n\n\n# preventextensions()\n\npreventextensions方法拦截object.preventextensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。\n\n这个方法有一个限制，只有目标对象不可扩展时（即object.isextensible(proxy)为false），proxy.preventextensions才能返回true，否则会报错。\n\nvar proxy = new proxy({}, {\n  preventextensions: function(target) {\n    return true;\n  }\n});\n\nobject.preventextensions(proxy)\n// uncaught typeerror: 'preventextensions' on proxy: trap returned truish but the proxy target is extensible\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，proxy.preventextensions方法返回true，但这时object.isextensible(proxy)会返回true，因此报错。\n\n为了防止出现这个问题，通常要在proxy.preventextensions方法里面，调用一次object.preventextensions。\n\nvar proxy = new proxy({}, {\n  preventextensions: function(target) {\n    console.log('called');\n    object.preventextensions(target);\n    return true;\n  }\n});\n\nobject.preventextensions(proxy)\n// \"called\"\n// proxy {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# setprototypeof()\n\nsetprototypeof方法主要用来拦截object.setprototypeof方法。\n\n下面是一个例子。\n\nvar handler = {\n  setprototypeof (target, proto) {\n    throw new error('changing the prototype is forbidden');\n  }\n};\nvar proto = {};\nvar target = function () {};\nvar proxy = new proxy(target, handler);\nobject.setprototypeof(proxy, proto);\n// error: changing the prototype is forbidden\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，只要修改target的原型对象，就会报错。\n\n注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），setprototypeof方法不得改变目标对象的原型。\n\n\n# proxy.revocable()\n\nproxy.revocable方法返回一个可取消的 proxy 实例。\n\nlet target = {};\nlet handler = {};\n\nlet {proxy, revoke} = proxy.revocable(target, handler);\n\nproxy.foo = 123;\nproxy.foo // 123\n\nrevoke();\nproxy.foo // typeerror: revoked\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nproxy.revocable方法返回一个对象，该对象的proxy属性是proxy实例，revoke属性是一个函数，可以取消proxy实例。上面代码中，当执行revoke函数之后，再访问proxy实例，就会抛出一个错误。\n\nproxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。\n\n\n# this 问题\n\n虽然 proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 proxy 代理的情况下，目标对象内部的this关键字会指向 proxy 代理。\n\nconst target = {\n  m: function () {\n    console.log(this === proxy);\n  }\n};\nconst handler = {};\n\nconst proxy = new proxy(target, handler);\n\ntarget.m() // false\nproxy.m()  // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，一旦proxy代理target.m，后者内部的this就是指向proxy，而不是target。\n\n下面是一个例子，由于this指向的变化，导致 proxy 无法代理目标对象。\n\nconst _name = new weakmap();\n\nclass person {\n  constructor(name) {\n    _name.set(this, name);\n  }\n  get name() {\n    return _name.get(this);\n  }\n}\n\nconst jane = new person('jane');\njane.name // 'jane'\n\nconst proxy = new proxy(jane, {});\nproxy.name // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，目标对象jane的name属性，实际保存在外部weakmap对象_name上面，通过this键区分。由于通过proxy.name访问时，this指向proxy，导致无法取到值，所以返回undefined。\n\n此外，有些原生对象的内部属性，只有通过正确的this才能拿到，所以 proxy 也无法代理这些原生对象的属性。\n\nconst target = new date();\nconst handler = {};\nconst proxy = new proxy(target, handler);\n\nproxy.getdate();\n// typeerror: this is not a date object.\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，getdate方法只能在date对象实例上面拿到，如果this不是date对象实例就会报错。这时，this绑定原始对象，就可以解决这个问题。\n\nconst target = new date('2015-01-01');\nconst handler = {\n  get(target, prop) {\n    if (prop === 'getdate') {\n      return target.getdate.bind(target);\n    }\n    return reflect.get(target, prop);\n  }\n};\nconst proxy = new proxy(target, handler);\n\nproxy.getdate() // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 实例：web 服务的客户端\n\nproxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 web 服务的客户端。\n\nconst service = createwebservice('http://example.com/data');\n\nservice.employees().then(json => {\n  const employees = json.parse(json);\n  // ···\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码新建了一个 web 服务的接口，这个接口返回各种数据。proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 proxy 拦截就可以了。\n\nfunction createwebservice(baseurl) {\n  return new proxy({}, {\n    get(target, propkey, receiver) {\n      return () => httpget(baseurl + '/' + propkey);\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n同理，proxy 也可以用来实现数据库的 orm 层。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Generator 函数的语法",frontmatter:{title:"Generator 函数的语法",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/718b48ed9ce0adce",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/18.Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95.html",relativePath:"《ES6 教程》笔记/18.Generator 函数的语法.md",key:"v-20b8f620",path:"/pages/718b48ed9ce0adce/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:22},{level:3,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:29},{level:3,title:"yield 表达式",slug:"yield-表达式",normalizedTitle:"yield 表达式",charIndex:2098},{level:3,title:"与 Iterator 接口的关系",slug:"与-iterator-接口的关系",normalizedTitle:"与 iterator 接口的关系",charIndex:4558},{level:2,title:"next 方法的参数",slug:"next-方法的参数",normalizedTitle:"next 方法的参数",charIndex:5227},{level:2,title:"for...of 循环",slug:"for-of-循环",normalizedTitle:"for...of 循环",charIndex:7662},{level:2,title:"Generator.prototype.throw()",slug:"generator-prototype-throw",normalizedTitle:"generator.prototype.throw()",charIndex:9786},{level:2,title:"Generator.prototype.return()",slug:"generator-prototype-return",normalizedTitle:"generator.prototype.return()",charIndex:14471},{level:2,title:"next()、throw()、return() 的共同点",slug:"next-、throw-、return-的共同点",normalizedTitle:"next()、throw()、return() 的共同点",charIndex:15733},{level:2,title:"yield* 表达式",slug:"yield-表达式-2",normalizedTitle:"yield* 表达式",charIndex:16559},{level:2,title:"作为对象属性的 Generator 函数",slug:"作为对象属性的-generator-函数",normalizedTitle:"作为对象属性的 generator 函数",charIndex:21944},{level:2,title:"Generator 函数的this",slug:"generator-函数的this",normalizedTitle:"generator 函数的this",charIndex:22233},{level:2,title:"含义",slug:"含义",normalizedTitle:"含义",charIndex:24337},{level:3,title:"Generator 与状态机",slug:"generator-与状态机",normalizedTitle:"generator 与状态机",charIndex:24344},{level:3,title:"Generator 与协程",slug:"generator-与协程",normalizedTitle:"generator 与协程",charIndex:24942},{level:3,title:"Generator 与上下文",slug:"generator-与上下文",normalizedTitle:"generator 与上下文",charIndex:25932},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:115},{level:3,title:"（1）异步操作的同步化表达",slug:"_1-异步操作的同步化表达",normalizedTitle:"（1）异步操作的同步化表达",charIndex:26639},{level:3,title:"（2）控制流管理",slug:"_2-控制流管理",normalizedTitle:"（2）控制流管理",charIndex:27994},{level:3,title:"（3）部署 Iterator 接口",slug:"_3-部署-iterator-接口",normalizedTitle:"（3）部署 iterator 接口",charIndex:30267},{level:3,title:"（4）作为数据结构",slug:"_4-作为数据结构",normalizedTitle:"（4）作为数据结构",charIndex:31061}],excerpt:'<h1 id="generator-函数的语法"><a class="header-anchor" href="#generator-函数的语法">#</a> Generator 函数的语法</h1>\n<h2 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h2>\n<h3 id="基本概念"><a class="header-anchor" href="#基本概念">#</a> 基本概念</h3>\n<p>Generator 函数是 ES6 提供的一种<strong>异步编程解决方案</strong>，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>\n',headersStr:"简介 基本概念 yield 表达式 与 Iterator 接口的关系 next 方法的参数 for...of 循环 Generator.prototype.throw() Generator.prototype.return() next()、throw()、return() 的共同点 yield* 表达式 作为对象属性的 Generator 函数 Generator 函数的this 含义 Generator 与状态机 Generator 与协程 Generator 与上下文 应用 （1）异步操作的同步化表达 （2）控制流管理 （3）部署 Iterator 接口 （4）作为数据结构",content:"# Generator 函数的语法\n\n\n# 简介\n\n\n# 基本概念\n\nGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。 Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\n\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n\n形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。\n\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloWorldGenerator();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。\n\n然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。\n\n下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\n\nhw.next()\n// { value: 'hello', done: false }\n\nhw.next()\n// { value: 'world', done: false }\n\nhw.next()\n// { value: 'ending', done: true }\n\nhw.next()\n// { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码一共调用了四次next方法。\n\n第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。\n\n第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。\n\n第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。\n\n第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。\n\n总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。\n\nES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。\n\nfunction * foo(x, y) { ··· }\nfunction *foo(x, y) { ··· }\nfunction* foo(x, y) { ··· }\nfunction*foo(x, y) { ··· }\n\n\n1\n2\n3\n4\n\n\n由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。本书也采用这种写法。\n\n\n# yield 表达式\n\n由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n\n遍历器对象的next方法的运行逻辑如下。\n\n（1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。\n\n（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。\n\n（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。\n\n（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。\n\n需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\n\nfunction* gen() {\n  yield  123 + 456;\n}\n\n\n1\n2\n3\n\n\n上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。\n\nyield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而**return语句不具备位置记忆的功能**。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。\n\nGenerator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。\n\nfunction* f() {\n  console.log('执行了！')\n}\n\nvar generator = f();\n\nsetTimeout(function () {\n  generator.next()\n}, 2000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个 Generator 函数，就变成只有调用next方法时，函数f才会执行。\n\n另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。\n\n(function (){\n  yield 1;\n})()\n// SyntaxError: Unexpected number\n\n\n1\n2\n3\n4\n\n\n上面代码在一个普通函数中使用yield表达式，结果产生一个句法错误。\n\n下面是另外一个例子。\n\nvar arr = [1, [[2, 3], 4], [5, 6]];\n\nvar flat = function* (a) {\n  a.forEach(function (item) {\n    if (typeof item !== 'number') {\n      yield* flat(item);\n    } else {\n      yield item;\n    }\n  });\n};\n\nfor (var f of flat(arr)){\n  console.log(f);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield表达式（这个函数里面还使用了yield*表达式，详细介绍见后文）。一种修改方法是改用for循环。\n\nvar arr = [1, [[2, 3], 4], [5, 6]];\n\nvar flat = function* (a) {\n  var length = a.length;\n  for (var i = 0; i < length; i++) {\n    var item = a[i];\n    if (typeof item !== 'number') {\n      yield* flat(item);\n    } else {\n      yield item;\n    }\n  }\n};\n\nfor (var f of flat(arr)) {\n  console.log(f);\n}\n// 1, 2, 3, 4, 5, 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n另外，yield表达式如果用在另一个表达式之中，必须放在圆括号里面。\n\nfunction* demo() {\n  console.log('Hello' + yield); // SyntaxError\n  console.log('Hello' + yield 123); // SyntaxError\n\n  console.log('Hello' + (yield)); // OK\n  console.log('Hello' + (yield 123)); // OK\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nyield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。\n\nfunction* demo() {\n  foo(yield 'a', yield 'b'); // OK\n  let input = yield; // OK\n}\n\n\n1\n2\n3\n4\n\n\n\n# 与 Iterator 接口的关系\n\n上一章说过，任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。\n\n由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。\n\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myIterable] // [1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被...运算符遍历了。\n\nGenerator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。\n\nfunction* gen(){\n  // some code\n}\n\nvar g = gen();\n\ng[Symbol.iterator]() === g\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，gen是一个 Generator 函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。\n\n\n# next 方法的参数\n\nyield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n\nfunction* f() {\n  for(var i = 0; true; i++) {\n    var reset = yield i;\n    if(reset) { i = -1; }\n  }\n}\n\nvar g = f();\n\ng.next() // { value: 0, done: false }\ng.next() // { value: 1, done: false }\ng.next(true) // { value: 0, done: false } // 参数true 传给上面的变量reset\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。\n\n这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。\n\n再看一个例子。\n\nfunction* foo(x) {\n  var y = 2 * (yield (x + 1));\n  var z = yield (y / 3);\n  return (x + y + z);\n}\n\nvar a = foo(5);\na.next() // Object{value:6, done:false}\na.next() // Object{value:NaN, done:false}\na.next() // Object{value:NaN, done:true}\n\nvar b = foo(5);\nb.next() // { value:6, done:false }\nb.next(12) // { value:8, done:false }\nb.next(13) // { value:42, done:true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。\n\n如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。\n\n注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。\n\n再看一个通过next方法的参数，向 Generator 函数内部输入值的例子。\n\nfunction* dataConsumer() {\n  console.log('Started');\n  console.log(`1. ${yield}`);\n  console.log(`2. ${yield}`);\n  return 'result';\n}\n\nlet genObj = dataConsumer();\ngenObj.next();\n// Started\ngenObj.next('a')\n// 1. a\ngenObj.next('b')\n// 2. b\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码是一个很直观的例子，每次通过next方法向 Generator 函数输入值，然后打印出来。\n\n如果想要第一次调用next方法时，就能够输入值，可以在 Generator 函数外面再包一层。\n\nfunction wrapper(generatorFunction) {\n  return function (...args) {\n    let generatorObject = generatorFunction(...args);\n    generatorObject.next();\n    return generatorObject;\n  };\n}\n\nconst wrapped = wrapper(function* () {\n  console.log(`First input: ${yield}`);\n  return 'DONE';\n});\n\nwrapped().next('hello!')\n// First input: hello!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，Generator 函数如果不用wrapper先包一层，是无法第一次调用next方法，就输入参数的。\n\n\n# for...of 循环\n\nfor...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。\n\nfunction* foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\n\nfor (let v of foo()) {\n  console.log(v);\n}\n// 1 2 3 4 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码使用for...of循环，依次显示 5 个yield表达式的值。这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。\n\n下面是一个利用 Generator 函数和for...of循环，实现斐波那契数列的例子。\n\nfunction* fibonacci() {\n  let [prev, curr] = [0, 1];\n  for (;;) {\n    yield curr;\n    [prev, curr] = [curr, prev + curr];\n  }\n}\n\nfor (let n of fibonacci()) {\n  if (n > 1000) break;\n  console.log(n);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n从上面代码可见，使用for...of语句时不需要使用next方法。\n\n利用for...of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。\n\nfunction* objectEntries(obj) {\n  let propKeys = Reflect.ownKeys(obj);\n\n  for (let propKey of propKeys) {\n    yield [propKey, obj[propKey]];\n  }\n}\n\nlet jane = { first: 'Jane', last: 'Doe' };\n\nfor (let [key, value] of objectEntries(jane)) {\n  console.log(`${key}: ${value}`);\n}\n// first: Jane\n// last: Doe\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，对象jane原生不具备 Iterator 接口，无法用for...of遍历。这时，我们通过 Generator 函数objectEntries为它加上遍历器接口，就可以用for...of遍历了。加上遍历器接口的另一种写法是，将 Generator 函数加到对象的Symbol.iterator属性上面。\n\nfunction* objectEntries() {\n  let propKeys = Object.keys(this);\n\n  for (let propKey of propKeys) {\n    yield [propKey, this[propKey]];\n  }\n}\n\nlet jane = { first: 'Jane', last: 'Doe' };\n\njane[Symbol.iterator] = objectEntries;\n\nfor (let [key, value] of jane) {\n  console.log(`${key}: ${value}`);\n}\n// first: Jane\n// last: Doe\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。\n\nfunction* numbers () {\n  yield 1\n  yield 2\n  return 3\n  yield 4\n}\n\n// 扩展运算符\n[...numbers()] // [1, 2]\n\n// Array.from 方法\nArray.from(numbers()) // [1, 2]\n\n// 解构赋值\nlet [x, y] = numbers();\nx // 1\ny // 2\n\n// for...of 循环\nfor (let n of numbers()) {\n  console.log(n)\n}\n// 1\n// 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Generator.prototype.throw()\n\nGenerator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。\n\nvar g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log('内部捕获', e);\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  i.throw('a');\n  i.throw('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 内部捕获 a\n// 外部捕获 b\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。\n\nthrow方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。\n\nvar g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nvar i = g();\ni.next();\ni.throw(new Error('出错了！'));\n// Error: 出错了！(…)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。\n\nvar g = function* () {\n  while (true) {\n    try {\n      yield;\n    } catch (e) {\n      if (e != 'a') throw e;\n      console.log('内部捕获', e);\n    }\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  throw new Error('a');\n  throw new Error('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 外部捕获 [Error: a]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。\n\n如果 Generator 函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获。\n\nvar g = function* () {\n  while (true) {\n    yield;\n    console.log('内部捕获', e);\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  i.throw('a');\n  i.throw('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 外部捕获 a\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，Generator 函数g内部没有部署try...catch代码块，所以抛出的错误直接被外部catch代码块捕获。\n\n如果 Generator 函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行。\n\nvar gen = function* gen(){\n  yield console.log('hello');\n  yield console.log('world');\n}\n\nvar g = gen();\ng.next();\ng.throw();\n// hello\n// Uncaught undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，g.throw抛出错误以后，没有任何try...catch代码块可以捕获这个错误，导致程序报错，中断执行。\n\nthrow方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。\n\nfunction* gen() {\n  try {\n    yield 1;\n  } catch (e) {\n    console.log('内部捕获');\n  }\n}\n\nvar g = gen();\ng.throw(1);\n// Uncaught 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，g.throw(1)执行时，next方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行next方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时throw方法抛错只可能抛出在函数外部。\n\nthrow方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。\n\nvar gen = function* gen(){\n  try {\n    yield console.log('a');\n  } catch (e) {\n    // ...\n  }\n  yield console.log('b');\n  yield console.log('c');\n}\n\nvar g = gen();\ng.next() // a\ng.throw() // b\ng.next() // c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。\n\n另外，throw命令与g.throw方法是无关的，两者互不影响。\n\nvar gen = function* gen(){\n  yield console.log('hello');\n  yield console.log('world');\n}\n\nvar g = gen();\ng.next();\n\ntry {\n  throw new Error();\n} catch (e) {\n  g.next();\n}\n// hello\n// world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都进行了正确的操作。\n\n这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield表达式，可以只用一个try...catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次catch语句就可以了。\n\nGenerator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的catch捕获。\n\nfunction* foo() {\n  var x = yield 3;\n  var y = x.toUpperCase();\n  yield y;\n}\n\nvar it = foo();\n\nit.next(); // { value:3, done:false }\n\ntry {\n  it.next(42);\n} catch (err) {\n  console.log(err);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，第二个next方法向函数体内传入一个参数 42，数值是没有toUpperCase方法的，所以会抛出一个 TypeError 错误，被函数体外的catch捕获。\n\n一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。\n\nfunction* g() {\n  yield 1;\n  console.log('throwing an exception');\n  throw new Error('generator broke!');\n  yield 2;\n  yield 3;\n}\n\nfunction log(generator) {\n  var v;\n  console.log('starting generator');\n  try {\n    v = generator.next();\n    console.log('第一次运行next方法', v);\n  } catch (err) {\n    console.log('捕捉错误', v);\n  }\n  try {\n    v = generator.next();\n    console.log('第二次运行next方法', v);\n  } catch (err) {\n    console.log('捕捉错误', v);\n  }\n  try {\n    v = generator.next();\n    console.log('第三次运行next方法', v);\n  } catch (err) {\n    console.log('捕捉错误', v);\n  }\n  console.log('caller done');\n}\n\nlog(g());\n// starting generator\n// 第一次运行next方法 { value: 1, done: false }\n// throwing an exception\n// 捕捉错误 { value: 1, done: false }\n// 第三次运行next方法 { value: undefined, done: true }\n// caller done\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n上面代码一共三次运行next方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。\n\n\n# Generator.prototype.return()\n\nGenerator 函数返回的遍历器对象，还有一个**return方法，可以返回给定的值，并且终结遍历 Generator 函数。**\n\nfunction* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nvar g = gen();\n\ng.next()        // { value: 1, done: false }\ng.return('foo') // { value: \"foo\", done: true }\ng.next()        // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator 函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。\n\n如果return方法调用时，不提供参数，则返回值的value属性为undefined。\n\nfunction* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nvar g = gen();\n\ng.next()        // { value: 1, done: false }\ng.return() // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果 Generator 函数内部有try...finally代码块，且正在执行try代码块，那么return方法会导致立刻进入finally代码块，执行完以后，整个函数才会结束。\n\nfunction* numbers () {\n  yield 1;\n  try {\n    yield 2;\n    yield 3;\n  } finally {\n    yield 4;\n    yield 5;\n  }\n  yield 6;\n}\nvar g = numbers();\ng.next() // { value: 1, done: false }\ng.next() // { value: 2, done: false }\ng.return(7) // { value: 4, done: false }\ng.next() // { value: 5, done: false }\ng.next() // { value: 7, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，调用return()方法后，就开始执行finally代码块，不执行try里面剩下的代码了，然后等到finally代码块执行完，再返回return()方法指定的返回值。\n\n\n# next()、throw()、return() 的共同点\n\nnext()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。\n\nnext()是将yield表达式替换成一个值。\n\nconst g = function* (x, y) {\n  let result = yield x + y;\n  return result;\n};\n\nconst gen = g(1, 2);\ngen.next(); // Object {value: 3, done: false}\n\ngen.next(1); // Object {value: 1, done: true}\n// 相当于将 let result = yield x + y\n// 替换成 let result = 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，第二个next(1)方法就相当于将yield表达式替换成一个值1。如果next方法没有参数，就相当于替换成undefined。\n\nthrow()是将yield表达式替换成一个throw语句。\n\ngen.throw(new Error('出错了')); // Uncaught Error: 出错了\n// 相当于将 let result = yield x + y\n// 替换成 let result = throw(new Error('出错了'));\n\n\n1\n2\n3\n\n\nreturn()是将yield表达式替换成一个return语句。\n\ngen.return(2); // Object {value: 2, done: true}\n// 相当于将 let result = yield x + y\n// 替换成 let result = return 2;\n\n\n1\n2\n3\n\n\n\n# yield* 表达式\n\n如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。\n\nfunction* foo() {\n  yield 'a';\n  yield 'b';\n}\n\nfunction* bar() {\n  yield 'x';\n  // 手动遍历 foo()\n  for (let i of foo()) {\n    console.log(i);\n  }\n  yield 'y';\n}\n\nfor (let v of bar()){\n  console.log(v);\n}\n// x\n// a\n// b\n// y\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面代码中，foo和bar都是 Generator 函数，在bar里面调用foo，就需要手动遍历foo。如果有多个 Generator 函数嵌套，写起来就非常麻烦。\n\nES6 提供了yield*表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。\n\nfunction* bar() {\n  yield 'x';\n  yield* foo();\n  yield 'y';\n}\n\n// 等同于\nfunction* bar() {\n  yield 'x';\n  yield 'a';\n  yield 'b';\n  yield 'y';\n}\n\n// 等同于\nfunction* bar() {\n  yield 'x';\n  for (let v of foo()) {\n    yield v;\n  }\n  yield 'y';\n}\n\nfor (let v of bar()){\n  console.log(v);\n}\n// \"x\"\n// \"a\"\n// \"b\"\n// \"y\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n再来看一个对比的例子。\n\nfunction* inner() {\n  yield 'hello!';\n}\n\nfunction* outer1() {\n  yield 'open';\n  yield inner();\n  yield 'close';\n}\n\nvar gen = outer1()\ngen.next().value // \"open\"\ngen.next().value // 返回一个遍历器对象\ngen.next().value // \"close\"\n\nfunction* outer2() {\n  yield 'open'\n  yield* inner()\n  yield 'close'\n}\n\nvar gen = outer2()\ngen.next().value // \"open\"\ngen.next().value // \"hello!\"\ngen.next().value // \"close\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n上面例子中，outer2使用了yield*，outer1没使用。结果就是，outer1返回一个遍历器对象，outer2返回该遍历器对象的内部值。\n\n从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。\n\nlet delegatedIterator = (function* () {\n  yield 'Hello!';\n  yield 'Bye!';\n}());\n\nlet delegatingIterator = (function* () {\n  yield 'Greetings!';\n  yield* delegatedIterator;\n  yield 'Ok, bye.';\n}());\n\nfor(let value of delegatingIterator) {\n  console.log(value);\n}\n// \"Greetings!\n// \"Hello!\"\n// \"Bye!\"\n// \"Ok, bye.\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码中，delegatingIterator是代理者，delegatedIterator是被代理者。由于yield* delegatedIterator语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。\n\nyield*后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个for...of循环。\n\nfunction* concat(iter1, iter2) {\n  yield* iter1;\n  yield* iter2;\n}\n\n// 等同于\n\nfunction* concat(iter1, iter2) {\n  for (var value of iter1) {\n    yield value;\n  }\n  for (var value of iter2) {\n    yield value;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码说明，yield*后面的 Generator 函数（没有return语句时），不过是for...of的一种简写形式，完全可以用后者替代前者。反之，在有return语句时，则需要用var value = yield* iterator的形式获取return语句的值。\n\n如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。\n\nfunction* gen(){\n  yield* [\"a\", \"b\", \"c\"];\n}\n\ngen().next() // { value:\"a\", done:false }\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。\n\n实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。\n\nlet read = (function* () {\n  yield 'hello';\n  yield* 'hello';\n})();\n\nread.next().value // \"hello\"\nread.next().value // \"h\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，yield表达式返回整个字符串，yield*语句返回单个字符。因为字符串具有 Iterator 接口，所以被yield*遍历。\n\n如果被代理的 Generator 函数有return语句，那么就可以向代理它的 Generator 函数返回数据。\n\nfunction* foo() {\n  yield 2;\n  yield 3;\n  return \"foo\";\n}\n\nfunction* bar() {\n  yield 1;\n  var v = yield* foo();\n  console.log(\"v: \" + v);\n  yield 4;\n}\n\nvar it = bar();\n\nit.next()\n// {value: 1, done: false}\nit.next()\n// {value: 2, done: false}\nit.next()\n// {value: 3, done: false}\nit.next();\n// \"v: foo\"\n// {value: 4, done: false}\nit.next()\n// {value: undefined, done: true}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n上面代码在第四次调用next方法的时候，屏幕上会有输出，这是因为函数foo的return语句，向函数bar提供了返回值。\n\n再看一个例子。\n\nfunction* genFuncWithReturn() {\n  yield 'a';\n  yield 'b';\n  return 'The result';\n}\nfunction* logReturned(genObj) {\n  let result = yield* genObj;\n  console.log(result);\n}\n\n[...logReturned(genFuncWithReturn())]\n// The result\n// 值为 [ 'a', 'b' ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，存在两次遍历。第一次是扩展运算符遍历函数logReturned返回的遍历器对象，第二次是yield*语句遍历函数genFuncWithReturn返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数genFuncWithReturn返回的遍历器对象。所以，最后的数据表达式得到的值等于[ 'a', 'b' ]。但是，函数genFuncWithReturn的return语句的返回值The result，会返回给函数logReturned内部的result变量，因此会有终端输出。\n\nyield*命令可以很方便地取出嵌套数组的所有成员。\n\nfunction* iterTree(tree) {\n  if (Array.isArray(tree)) {\n    for(let i=0; i < tree.length; i++) {\n      yield* iterTree(tree[i]);\n    }\n  } else {\n    yield tree;\n  }\n}\n\nconst tree = [ 'a', ['b', 'c'], ['d', 'e'] ];\n\nfor(let x of iterTree(tree)) {\n  console.log(x);\n}\n// a\n// b\n// c\n// d\n// e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n由于扩展运算符...默认调用 Iterator 接口，所以上面这个函数也可以用于嵌套数组的平铺。\n\n[...iterTree(tree)] // [\"a\", \"b\", \"c\", \"d\", \"e\"]\n\n\n1\n\n\n下面是一个稍微复杂的例子，使用yield*语句遍历完全二叉树。\n\n// 下面是二叉树的构造函数，\n// 三个参数分别是左树、当前节点和右树\nfunction Tree(left, label, right) {\n  this.left = left;\n  this.label = label;\n  this.right = right;\n}\n\n// 下面是中序（inorder）遍历函数。\n// 由于返回的是一个遍历器，所以要用generator函数。\n// 函数体内采用递归算法，所以左树和右树要用yield*遍历\nfunction* inorder(t) {\n  if (t) {\n    yield* inorder(t.left);\n    yield t.label;\n    yield* inorder(t.right);\n  }\n}\n\n// 下面生成二叉树\nfunction make(array) {\n  // 判断是否为叶节点\n  if (array.length == 1) return new Tree(null, array[0], null);\n  return new Tree(make(array[0]), array[1], make(array[2]));\n}\nlet tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);\n\n// 遍历二叉树\nvar result = [];\nfor (let node of inorder(tree)) {\n  result.push(node);\n}\n\nresult\n// ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 作为对象属性的 Generator 函数\n\n如果一个对象的属性是 Generator 函数，可以简写成下面的形式。\n\nlet obj = {\n  * myGeneratorMethod() {\n    ···\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。\n\n它的完整形式如下，与上面的写法是等价的。\n\nlet obj = {\n  myGeneratorMethod: function* () {\n    // ···\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\n\n# Generator 函数的this\n\nGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。\n\nfunction* g() {}\n\ng.prototype.hello = function () {\n  return 'hi!';\n};\n\nlet obj = g();\n\nobj instanceof g // true\nobj.hello() // 'hi!'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码表明，Generator 函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。\n\nfunction* g() {\n  this.a = 11;\n}\n\nlet obj = g();\nobj.next();\nobj.a // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，Generator 函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。\n\nGenerator 函数也不能跟new命令一起用，会报错。\n\nfunction* F() {\n  yield this.x = 2;\n  yield this.y = 3;\n}\n\nnew F()\n// TypeError: F is not a constructor\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，new命令跟构造函数F一起使用，结果报错，因为F不是构造函数。\n\n那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？\n\n下面是一个变通方法。首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。\n\nfunction* F() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\nvar obj = {};\nvar f = F.call(obj);\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nobj.a // 1\nobj.b // 2\nobj.c // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次next方法（因为F内部有两个yield表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。\n\n上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？\n\n一个办法就是将obj换成F.prototype。\n\nfunction* F() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\nvar f = F.call(F.prototype);\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nf.a // 1\nf.b // 2\nf.c // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n再将F改成构造函数，就可以对它执行new命令了。\n\nfunction* gen() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\n\nfunction F() {\n  return gen.call(gen.prototype);\n}\n\nvar f = new F();\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nf.a // 1\nf.b // 2\nf.c // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 含义\n\n\n# Generator 与状态机\n\nGenerator 是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。\n\nvar ticking = true;\nvar clock = function() {\n  if (ticking)\n    console.log('Tick!');\n  else\n    console.log('Tock!');\n  ticking = !ticking;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。\n\nvar clock = function* () {\n  while (true) {\n    console.log('Tick!');\n    yield;\n    console.log('Tock!');\n    yield;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。\n\n\n# Generator 与协程\n\n协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。\n\n（1）协程与子例程的差异\n\n传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。\n\n从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。\n\n（2）协程与普通线程的差异\n\n不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。\n\n由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。\n\nGenerator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。\n\n如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用yield表达式交换控制权。\n\n\n# Generator 与上下文\n\nJavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。\n\n这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。\n\nGenerator 函数不是这样，它执行产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行next命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。\n\nfunction* gen() {\n  yield 1;\n  return 2;\n}\n\nlet g = gen();\n\nconsole.log(\n  g.next().value,\n  g.next().value,\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，第一次执行g.next()时，Generator 函数gen的上下文会加入堆栈，即开始运行gen内部的代码。等遇到yield 1时，gen上下文退出堆栈，内部状态冻结。第二次执行g.next()时，gen上下文重新加入堆栈，变成当前的上下文，重新恢复执行。\n\n\n# 应用\n\nGenerator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。\n\n\n# （1）异步操作的同步化表达\n\nGenerator 函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。\n\nfunction* loadUI() {\n  showLoadingScreen();\n  yield loadUIDataAsynchronously();\n  hideLoadingScreen();\n}\nvar loader = loadUI();\n// 加载UI\nloader.next()\n\n// 卸载UI\nloader.next()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面（showLoadingScreen），并且异步加载数据（loadUIDataAsynchronously）。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。\n\nAjax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。\n\nfunction* main() {\n  var result = yield request(\"http://some.url\");\n  var resp = JSON.parse(result);\n    console.log(resp.value);\n}\n\nfunction request(url) {\n  makeAjaxCall(url, function(response){\n    it.next(response);\n  });\n}\n\nvar it = main();\nit.next();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码的main函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield表达式，本身是没有值的，总是等于undefined。\n\n下面是另一个例子，通过 Generator 函数逐行读取文本文件。\n\nfunction* numbers() {\n  let file = new FileReader(\"numbers.txt\");\n  try {\n    while(!file.eof) {\n      yield parseInt(file.readLine(), 10);\n    }\n  } finally {\n    file.close();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码打开文本文件，使用yield表达式可以手动逐行读取文件。\n\n\n# （2）控制流管理\n\n如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。\n\nstep1(function (value1) {\n  step2(value1, function(value2) {\n    step3(value2, function(value3) {\n      step4(value3, function(value4) {\n        // Do something with value4\n      });\n    });\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n采用 Promise 改写上面的代码。\n\nPromise.resolve(step1)\n  .then(step2)\n  .then(step3)\n  .then(step4)\n  .then(function (value4) {\n    // Do something with value4\n  }, function (error) {\n    // Handle any error from step1 through step4\n  })\n  .done();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。\n\nfunction* longRunningTask(value1) {\n  try {\n    var value2 = yield step1(value1);\n    var value3 = yield step2(value2);\n    var value4 = yield step3(value3);\n    var value5 = yield step4(value4);\n    // Do something with value4\n  } catch (e) {\n    // Handle any error from step1 through step4\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n然后，使用一个函数，按次序自动执行所有步骤。\n\nscheduler(longRunningTask(initialValue));\n\nfunction scheduler(task) {\n  var taskObj = task.next(task.value);\n  // 如果Generator函数未结束，就继续调用\n  if (!taskObj.done) {\n    task.value = taskObj.value\n    scheduler(task);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意，上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。\n\n下面，利用for...of循环会自动依次执行yield命令的特性，提供一种更一般的控制流管理的方法。\n\nlet steps = [step1Func, step2Func, step3Func];\n\nfunction* iterateSteps(steps){\n  for (var i=0; i< steps.length; i++){\n    var step = steps[i];\n    yield step();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，数组steps封装了一个任务的多个步骤，Generator 函数iterateSteps则是依次为这些步骤加上yield命令。\n\n将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。\n\nlet jobs = [job1, job2, job3];\n\nfunction* iterateJobs(jobs){\n  for (var i=0; i< jobs.length; i++){\n    var job = jobs[i];\n    yield* iterateSteps(job.steps);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，数组jobs封装了一个项目的多个任务，Generator 函数iterateJobs则是依次为这些任务加上yield*命令。\n\n最后，就可以用for...of循环一次性依次执行所有任务的所有步骤。\n\nfor (var step of iterateJobs(jobs)){\n  console.log(step.id);\n}\n\n\n1\n2\n3\n\n\n再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。\n\nfor...of的本质是一个while循环，所以上面的代码实质上执行的是下面的逻辑。\n\nvar it = iterateJobs(jobs);\nvar res = it.next();\n\nwhile (!res.done){\n  var result = res.value;\n  // ...\n  res = it.next();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# （3）部署 Iterator 接口\n\n利用 Generator 函数，可以在任意对象上部署 Iterator 接口。\n\nfunction* iterEntries(obj) {\n  let keys = Object.keys(obj);\n  for (let i=0; i < keys.length; i++) {\n    let key = keys[i];\n    yield [key, obj[key]];\n  }\n}\n\nlet myObj = { foo: 3, bar: 7 };\n\nfor (let [key, value] of iterEntries(myObj)) {\n  console.log(key, value);\n}\n\n// foo 3\n// bar 7\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署next方法。\n\n下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。\n\nfunction* makeSimpleGenerator(array){\n  var nextIndex = 0;\n\n  while(nextIndex < array.length){\n    yield array[nextIndex++];\n  }\n}\n\nvar gen = makeSimpleGenerator(['yo', 'ya']);\n\ngen.next().value // 'yo'\ngen.next().value // 'ya'\ngen.next().done  // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# （4）作为数据结构\n\nGenerator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。\n\nfunction* doStuff() {\n  yield fs.readFile.bind(null, 'hello.txt');\n  yield fs.readFile.bind(null, 'world.txt');\n  yield fs.readFile.bind(null, 'and-such.txt');\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。\n\nfor (task of doStuff()) {\n  // task是一个函数，可以像回调函数那样使用它\n}\n\n\n1\n2\n3\n\n\n实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。\n\nfunction doStuff() {\n  return [\n    fs.readFile.bind(null, 'hello.txt'),\n    fs.readFile.bind(null, 'world.txt'),\n    fs.readFile.bind(null, 'and-such.txt')\n  ];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的函数，可以用一模一样的for...of循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。",normalizedContent:"# generator 函数的语法\n\n\n# 简介\n\n\n# 基本概念\n\ngenerator 函数是 es6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 generator 函数的语法和 api，它的异步编程应用请看《generator 函数的异步应用》一章。 generator 函数有多种理解角度。语法上，首先可以把它理解成，generator 函数是一个状态机，封装了多个内部状态。\n\n执行 generator 函数会返回一个遍历器对象，也就是说，generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 generator 函数内部的每一个状态。\n\n形式上，generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。\n\nfunction* helloworldgenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloworldgenerator();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码定义了一个 generator 函数helloworldgenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。\n\n然后，generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（iterator object）。\n\n下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\n\nhw.next()\n// { value: 'hello', done: false }\n\nhw.next()\n// { value: 'world', done: false }\n\nhw.next()\n// { value: 'ending', done: true }\n\nhw.next()\n// { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码一共调用了四次next方法。\n\n第一次调用，generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。\n\n第二次调用，generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。\n\n第三次调用，generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。\n\n第四次调用，此时 generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。\n\n总结一下，调用 generator 函数，返回一个遍历器对象，代表 generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。\n\nes6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。\n\nfunction * foo(x, y) { ··· }\nfunction *foo(x, y) { ··· }\nfunction* foo(x, y) { ··· }\nfunction*foo(x, y) { ··· }\n\n\n1\n2\n3\n4\n\n\n由于 generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。本书也采用这种写法。\n\n\n# yield 表达式\n\n由于 generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n\n遍历器对象的next方法的运行逻辑如下。\n\n（1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。\n\n（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。\n\n（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。\n\n（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。\n\n需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 javascript 提供了手动的“惰性求值”（lazy evaluation）的语法功能。\n\nfunction* gen() {\n  yield  123 + 456;\n}\n\n\n1\n2\n3\n\n\n上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。\n\nyield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而**return语句不具备位置记忆的功能**。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；generator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说 generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。\n\ngenerator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。\n\nfunction* f() {\n  console.log('执行了！')\n}\n\nvar generator = f();\n\nsettimeout(function () {\n  generator.next()\n}, 2000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个 generator 函数，就变成只有调用next方法时，函数f才会执行。\n\n另外需要注意，yield表达式只能用在 generator 函数里面，用在其他地方都会报错。\n\n(function (){\n  yield 1;\n})()\n// syntaxerror: unexpected number\n\n\n1\n2\n3\n4\n\n\n上面代码在一个普通函数中使用yield表达式，结果产生一个句法错误。\n\n下面是另外一个例子。\n\nvar arr = [1, [[2, 3], 4], [5, 6]];\n\nvar flat = function* (a) {\n  a.foreach(function (item) {\n    if (typeof item !== 'number') {\n      yield* flat(item);\n    } else {\n      yield item;\n    }\n  });\n};\n\nfor (var f of flat(arr)){\n  console.log(f);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码也会产生句法错误，因为foreach方法的参数是一个普通函数，但是在里面使用了yield表达式（这个函数里面还使用了yield*表达式，详细介绍见后文）。一种修改方法是改用for循环。\n\nvar arr = [1, [[2, 3], 4], [5, 6]];\n\nvar flat = function* (a) {\n  var length = a.length;\n  for (var i = 0; i < length; i++) {\n    var item = a[i];\n    if (typeof item !== 'number') {\n      yield* flat(item);\n    } else {\n      yield item;\n    }\n  }\n};\n\nfor (var f of flat(arr)) {\n  console.log(f);\n}\n// 1, 2, 3, 4, 5, 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n另外，yield表达式如果用在另一个表达式之中，必须放在圆括号里面。\n\nfunction* demo() {\n  console.log('hello' + yield); // syntaxerror\n  console.log('hello' + yield 123); // syntaxerror\n\n  console.log('hello' + (yield)); // ok\n  console.log('hello' + (yield 123)); // ok\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nyield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。\n\nfunction* demo() {\n  foo(yield 'a', yield 'b'); // ok\n  let input = yield; // ok\n}\n\n\n1\n2\n3\n4\n\n\n\n# 与 iterator 接口的关系\n\n上一章说过，任意一个对象的symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。\n\n由于 generator 函数就是遍历器生成函数，因此可以把 generator 赋值给对象的symbol.iterator属性，从而使得该对象具有 iterator 接口。\n\nvar myiterable = {};\nmyiterable[symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myiterable] // [1, 2, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，generator 函数赋值给symbol.iterator属性，从而使得myiterable对象具有了 iterator 接口，可以被...运算符遍历了。\n\ngenerator 函数执行后，返回一个遍历器对象。该对象本身也具有symbol.iterator属性，执行后返回自身。\n\nfunction* gen(){\n  // some code\n}\n\nvar g = gen();\n\ng[symbol.iterator]() === g\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，gen是一个 generator 函数，调用它会生成一个遍历器对象g。它的symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。\n\n\n# next 方法的参数\n\nyield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n\nfunction* f() {\n  for(var i = 0; true; i++) {\n    var reset = yield i;\n    if(reset) { i = -1; }\n  }\n}\n\nvar g = f();\n\ng.next() // { value: 0, done: false }\ng.next() // { value: 1, done: false }\ng.next(true) // { value: 0, done: false } // 参数true 传给上面的变量reset\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码先定义了一个可以无限运行的 generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。\n\n这个功能有很重要的语法意义。generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。\n\n再看一个例子。\n\nfunction* foo(x) {\n  var y = 2 * (yield (x + 1));\n  var z = yield (y / 3);\n  return (x + y + z);\n}\n\nvar a = foo(5);\na.next() // object{value:6, done:false}\na.next() // object{value:nan, done:false}\na.next() // object{value:nan, done:true}\n\nvar b = foo(5);\nb.next() // { value:6, done:false }\nb.next(12) // { value:8, done:false }\nb.next(13) // { value:42, done:true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即nan），除以 3 以后还是nan，因此返回对象的value属性也等于nan。第三次运行next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + nan + undefined，即nan。\n\n如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。\n\n注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。v8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。\n\n再看一个通过next方法的参数，向 generator 函数内部输入值的例子。\n\nfunction* dataconsumer() {\n  console.log('started');\n  console.log(`1. ${yield}`);\n  console.log(`2. ${yield}`);\n  return 'result';\n}\n\nlet genobj = dataconsumer();\ngenobj.next();\n// started\ngenobj.next('a')\n// 1. a\ngenobj.next('b')\n// 2. b\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码是一个很直观的例子，每次通过next方法向 generator 函数输入值，然后打印出来。\n\n如果想要第一次调用next方法时，就能够输入值，可以在 generator 函数外面再包一层。\n\nfunction wrapper(generatorfunction) {\n  return function (...args) {\n    let generatorobject = generatorfunction(...args);\n    generatorobject.next();\n    return generatorobject;\n  };\n}\n\nconst wrapped = wrapper(function* () {\n  console.log(`first input: ${yield}`);\n  return 'done';\n});\n\nwrapped().next('hello!')\n// first input: hello!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，generator 函数如果不用wrapper先包一层，是无法第一次调用next方法，就输入参数的。\n\n\n# for...of 循环\n\nfor...of循环可以自动遍历 generator 函数运行时生成的iterator对象，且此时不再需要调用next方法。\n\nfunction* foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\n\nfor (let v of foo()) {\n  console.log(v);\n}\n// 1 2 3 4 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码使用for...of循环，依次显示 5 个yield表达式的值。这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。\n\n下面是一个利用 generator 函数和for...of循环，实现斐波那契数列的例子。\n\nfunction* fibonacci() {\n  let [prev, curr] = [0, 1];\n  for (;;) {\n    yield curr;\n    [prev, curr] = [curr, prev + curr];\n  }\n}\n\nfor (let n of fibonacci()) {\n  if (n > 1000) break;\n  console.log(n);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n从上面代码可见，使用for...of语句时不需要使用next方法。\n\n利用for...of循环，可以写出遍历任意对象（object）的方法。原生的 javascript 对象没有遍历接口，无法使用for...of循环，通过 generator 函数为它加上这个接口，就可以用了。\n\nfunction* objectentries(obj) {\n  let propkeys = reflect.ownkeys(obj);\n\n  for (let propkey of propkeys) {\n    yield [propkey, obj[propkey]];\n  }\n}\n\nlet jane = { first: 'jane', last: 'doe' };\n\nfor (let [key, value] of objectentries(jane)) {\n  console.log(`${key}: ${value}`);\n}\n// first: jane\n// last: doe\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，对象jane原生不具备 iterator 接口，无法用for...of遍历。这时，我们通过 generator 函数objectentries为它加上遍历器接口，就可以用for...of遍历了。加上遍历器接口的另一种写法是，将 generator 函数加到对象的symbol.iterator属性上面。\n\nfunction* objectentries() {\n  let propkeys = object.keys(this);\n\n  for (let propkey of propkeys) {\n    yield [propkey, this[propkey]];\n  }\n}\n\nlet jane = { first: 'jane', last: 'doe' };\n\njane[symbol.iterator] = objectentries;\n\nfor (let [key, value] of jane) {\n  console.log(`${key}: ${value}`);\n}\n// first: jane\n// last: doe\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n除了for...of循环以外，扩展运算符（...）、解构赋值和array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 generator 函数返回的 iterator 对象，作为参数。\n\nfunction* numbers () {\n  yield 1\n  yield 2\n  return 3\n  yield 4\n}\n\n// 扩展运算符\n[...numbers()] // [1, 2]\n\n// array.from 方法\narray.from(numbers()) // [1, 2]\n\n// 解构赋值\nlet [x, y] = numbers();\nx // 1\ny // 2\n\n// for...of 循环\nfor (let n of numbers()) {\n  console.log(n)\n}\n// 1\n// 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# generator.prototype.throw()\n\ngenerator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 generator 函数体内捕获。\n\nvar g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log('内部捕获', e);\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  i.throw('a');\n  i.throw('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 内部捕获 a\n// 外部捕获 b\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 generator 函数体内的catch语句捕获。i第二次抛出错误，由于 generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 generator 函数体，被函数体外的catch语句捕获。\n\nthrow方法可以接受一个参数，该参数会被catch语句接收，建议抛出error对象的实例。\n\nvar g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nvar i = g();\ni.next();\ni.throw(new error('出错了！'));\n// error: 出错了！(…)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。\n\nvar g = function* () {\n  while (true) {\n    try {\n      yield;\n    } catch (e) {\n      if (e != 'a') throw e;\n      console.log('内部捕获', e);\n    }\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  throw new error('a');\n  throw new error('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 外部捕获 [error: a]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。\n\n如果 generator 函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获。\n\nvar g = function* () {\n  while (true) {\n    yield;\n    console.log('内部捕获', e);\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  i.throw('a');\n  i.throw('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 外部捕获 a\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，generator 函数g内部没有部署try...catch代码块，所以抛出的错误直接被外部catch代码块捕获。\n\n如果 generator 函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行。\n\nvar gen = function* gen(){\n  yield console.log('hello');\n  yield console.log('world');\n}\n\nvar g = gen();\ng.next();\ng.throw();\n// hello\n// uncaught undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，g.throw抛出错误以后，没有任何try...catch代码块可以捕获这个错误，导致程序报错，中断执行。\n\nthrow方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。\n\nfunction* gen() {\n  try {\n    yield 1;\n  } catch (e) {\n    console.log('内部捕获');\n  }\n}\n\nvar g = gen();\ng.throw(1);\n// uncaught 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，g.throw(1)执行时，next方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行next方法，等同于启动执行 generator 函数的内部代码，否则 generator 函数还没有开始执行，这时throw方法抛错只可能抛出在函数外部。\n\nthrow方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。\n\nvar gen = function* gen(){\n  try {\n    yield console.log('a');\n  } catch (e) {\n    // ...\n  }\n  yield console.log('b');\n  yield console.log('c');\n}\n\nvar g = gen();\ng.next() // a\ng.throw() // b\ng.next() // c\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要 generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。\n\n另外，throw命令与g.throw方法是无关的，两者互不影响。\n\nvar gen = function* gen(){\n  yield console.log('hello');\n  yield console.log('world');\n}\n\nvar g = gen();\ng.next();\n\ntry {\n  throw new error();\n} catch (e) {\n  g.next();\n}\n// hello\n// world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都进行了正确的操作。\n\n这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield表达式，可以只用一个try...catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 generator 函数内部写一次catch语句就可以了。\n\ngenerator 函数体外抛出的错误，可以在函数体内捕获；反过来，generator 函数体内抛出的错误，也可以被函数体外的catch捕获。\n\nfunction* foo() {\n  var x = yield 3;\n  var y = x.touppercase();\n  yield y;\n}\n\nvar it = foo();\n\nit.next(); // { value:3, done:false }\n\ntry {\n  it.next(42);\n} catch (err) {\n  console.log(err);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，第二个next方法向函数体内传入一个参数 42，数值是没有touppercase方法的，所以会抛出一个 typeerror 错误，被函数体外的catch捕获。\n\n一旦 generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即 javascript 引擎认为这个 generator 已经运行结束了。\n\nfunction* g() {\n  yield 1;\n  console.log('throwing an exception');\n  throw new error('generator broke!');\n  yield 2;\n  yield 3;\n}\n\nfunction log(generator) {\n  var v;\n  console.log('starting generator');\n  try {\n    v = generator.next();\n    console.log('第一次运行next方法', v);\n  } catch (err) {\n    console.log('捕捉错误', v);\n  }\n  try {\n    v = generator.next();\n    console.log('第二次运行next方法', v);\n  } catch (err) {\n    console.log('捕捉错误', v);\n  }\n  try {\n    v = generator.next();\n    console.log('第三次运行next方法', v);\n  } catch (err) {\n    console.log('捕捉错误', v);\n  }\n  console.log('caller done');\n}\n\nlog(g());\n// starting generator\n// 第一次运行next方法 { value: 1, done: false }\n// throwing an exception\n// 捕捉错误 { value: 1, done: false }\n// 第三次运行next方法 { value: undefined, done: true }\n// caller done\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n上面代码一共三次运行next方法，第二次运行的时候会抛出错误，然后第三次运行的时候，generator 函数就已经结束了，不再执行下去了。\n\n\n# generator.prototype.return()\n\ngenerator 函数返回的遍历器对象，还有一个**return方法，可以返回给定的值，并且终结遍历 generator 函数。**\n\nfunction* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nvar g = gen();\n\ng.next()        // { value: 1, done: false }\ng.return('foo') // { value: \"foo\", done: true }\ng.next()        // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，generator 函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。\n\n如果return方法调用时，不提供参数，则返回值的value属性为undefined。\n\nfunction* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nvar g = gen();\n\ng.next()        // { value: 1, done: false }\ng.return() // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果 generator 函数内部有try...finally代码块，且正在执行try代码块，那么return方法会导致立刻进入finally代码块，执行完以后，整个函数才会结束。\n\nfunction* numbers () {\n  yield 1;\n  try {\n    yield 2;\n    yield 3;\n  } finally {\n    yield 4;\n    yield 5;\n  }\n  yield 6;\n}\nvar g = numbers();\ng.next() // { value: 1, done: false }\ng.next() // { value: 2, done: false }\ng.return(7) // { value: 4, done: false }\ng.next() // { value: 5, done: false }\ng.next() // { value: 7, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，调用return()方法后，就开始执行finally代码块，不执行try里面剩下的代码了，然后等到finally代码块执行完，再返回return()方法指定的返回值。\n\n\n# next()、throw()、return() 的共同点\n\nnext()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 generator 函数恢复执行，并且使用不同的语句替换yield表达式。\n\nnext()是将yield表达式替换成一个值。\n\nconst g = function* (x, y) {\n  let result = yield x + y;\n  return result;\n};\n\nconst gen = g(1, 2);\ngen.next(); // object {value: 3, done: false}\n\ngen.next(1); // object {value: 1, done: true}\n// 相当于将 let result = yield x + y\n// 替换成 let result = 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，第二个next(1)方法就相当于将yield表达式替换成一个值1。如果next方法没有参数，就相当于替换成undefined。\n\nthrow()是将yield表达式替换成一个throw语句。\n\ngen.throw(new error('出错了')); // uncaught error: 出错了\n// 相当于将 let result = yield x + y\n// 替换成 let result = throw(new error('出错了'));\n\n\n1\n2\n3\n\n\nreturn()是将yield表达式替换成一个return语句。\n\ngen.return(2); // object {value: 2, done: true}\n// 相当于将 let result = yield x + y\n// 替换成 let result = return 2;\n\n\n1\n2\n3\n\n\n\n# yield* 表达式\n\n如果在 generator 函数内部，调用另一个 generator 函数。需要在前者的函数体内部，自己手动完成遍历。\n\nfunction* foo() {\n  yield 'a';\n  yield 'b';\n}\n\nfunction* bar() {\n  yield 'x';\n  // 手动遍历 foo()\n  for (let i of foo()) {\n    console.log(i);\n  }\n  yield 'y';\n}\n\nfor (let v of bar()){\n  console.log(v);\n}\n// x\n// a\n// b\n// y\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面代码中，foo和bar都是 generator 函数，在bar里面调用foo，就需要手动遍历foo。如果有多个 generator 函数嵌套，写起来就非常麻烦。\n\nes6 提供了yield*表达式，作为解决办法，用来在一个 generator 函数里面执行另一个 generator 函数。\n\nfunction* bar() {\n  yield 'x';\n  yield* foo();\n  yield 'y';\n}\n\n// 等同于\nfunction* bar() {\n  yield 'x';\n  yield 'a';\n  yield 'b';\n  yield 'y';\n}\n\n// 等同于\nfunction* bar() {\n  yield 'x';\n  for (let v of foo()) {\n    yield v;\n  }\n  yield 'y';\n}\n\nfor (let v of bar()){\n  console.log(v);\n}\n// \"x\"\n// \"a\"\n// \"b\"\n// \"y\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n再来看一个对比的例子。\n\nfunction* inner() {\n  yield 'hello!';\n}\n\nfunction* outer1() {\n  yield 'open';\n  yield inner();\n  yield 'close';\n}\n\nvar gen = outer1()\ngen.next().value // \"open\"\ngen.next().value // 返回一个遍历器对象\ngen.next().value // \"close\"\n\nfunction* outer2() {\n  yield 'open'\n  yield* inner()\n  yield 'close'\n}\n\nvar gen = outer2()\ngen.next().value // \"open\"\ngen.next().value // \"hello!\"\ngen.next().value // \"close\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n上面例子中，outer2使用了yield*，outer1没使用。结果就是，outer1返回一个遍历器对象，outer2返回该遍历器对象的内部值。\n\n从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。\n\nlet delegatediterator = (function* () {\n  yield 'hello!';\n  yield 'bye!';\n}());\n\nlet delegatingiterator = (function* () {\n  yield 'greetings!';\n  yield* delegatediterator;\n  yield 'ok, bye.';\n}());\n\nfor(let value of delegatingiterator) {\n  console.log(value);\n}\n// \"greetings!\n// \"hello!\"\n// \"bye!\"\n// \"ok, bye.\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码中，delegatingiterator是代理者，delegatediterator是被代理者。由于yield* delegatediterator语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 generator 函数，有递归的效果。\n\nyield*后面的 generator 函数（没有return语句时），等同于在 generator 函数内部，部署一个for...of循环。\n\nfunction* concat(iter1, iter2) {\n  yield* iter1;\n  yield* iter2;\n}\n\n// 等同于\n\nfunction* concat(iter1, iter2) {\n  for (var value of iter1) {\n    yield value;\n  }\n  for (var value of iter2) {\n    yield value;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码说明，yield*后面的 generator 函数（没有return语句时），不过是for...of的一种简写形式，完全可以用后者替代前者。反之，在有return语句时，则需要用var value = yield* iterator的形式获取return语句的值。\n\n如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。\n\nfunction* gen(){\n  yield* [\"a\", \"b\", \"c\"];\n}\n\ngen().next() // { value:\"a\", done:false }\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。\n\n实际上，任何数据结构只要有 iterator 接口，就可以被yield*遍历。\n\nlet read = (function* () {\n  yield 'hello';\n  yield* 'hello';\n})();\n\nread.next().value // \"hello\"\nread.next().value // \"h\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，yield表达式返回整个字符串，yield*语句返回单个字符。因为字符串具有 iterator 接口，所以被yield*遍历。\n\n如果被代理的 generator 函数有return语句，那么就可以向代理它的 generator 函数返回数据。\n\nfunction* foo() {\n  yield 2;\n  yield 3;\n  return \"foo\";\n}\n\nfunction* bar() {\n  yield 1;\n  var v = yield* foo();\n  console.log(\"v: \" + v);\n  yield 4;\n}\n\nvar it = bar();\n\nit.next()\n// {value: 1, done: false}\nit.next()\n// {value: 2, done: false}\nit.next()\n// {value: 3, done: false}\nit.next();\n// \"v: foo\"\n// {value: 4, done: false}\nit.next()\n// {value: undefined, done: true}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n上面代码在第四次调用next方法的时候，屏幕上会有输出，这是因为函数foo的return语句，向函数bar提供了返回值。\n\n再看一个例子。\n\nfunction* genfuncwithreturn() {\n  yield 'a';\n  yield 'b';\n  return 'the result';\n}\nfunction* logreturned(genobj) {\n  let result = yield* genobj;\n  console.log(result);\n}\n\n[...logreturned(genfuncwithreturn())]\n// the result\n// 值为 [ 'a', 'b' ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，存在两次遍历。第一次是扩展运算符遍历函数logreturned返回的遍历器对象，第二次是yield*语句遍历函数genfuncwithreturn返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数genfuncwithreturn返回的遍历器对象。所以，最后的数据表达式得到的值等于[ 'a', 'b' ]。但是，函数genfuncwithreturn的return语句的返回值the result，会返回给函数logreturned内部的result变量，因此会有终端输出。\n\nyield*命令可以很方便地取出嵌套数组的所有成员。\n\nfunction* itertree(tree) {\n  if (array.isarray(tree)) {\n    for(let i=0; i < tree.length; i++) {\n      yield* itertree(tree[i]);\n    }\n  } else {\n    yield tree;\n  }\n}\n\nconst tree = [ 'a', ['b', 'c'], ['d', 'e'] ];\n\nfor(let x of itertree(tree)) {\n  console.log(x);\n}\n// a\n// b\n// c\n// d\n// e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n由于扩展运算符...默认调用 iterator 接口，所以上面这个函数也可以用于嵌套数组的平铺。\n\n[...itertree(tree)] // [\"a\", \"b\", \"c\", \"d\", \"e\"]\n\n\n1\n\n\n下面是一个稍微复杂的例子，使用yield*语句遍历完全二叉树。\n\n// 下面是二叉树的构造函数，\n// 三个参数分别是左树、当前节点和右树\nfunction tree(left, label, right) {\n  this.left = left;\n  this.label = label;\n  this.right = right;\n}\n\n// 下面是中序（inorder）遍历函数。\n// 由于返回的是一个遍历器，所以要用generator函数。\n// 函数体内采用递归算法，所以左树和右树要用yield*遍历\nfunction* inorder(t) {\n  if (t) {\n    yield* inorder(t.left);\n    yield t.label;\n    yield* inorder(t.right);\n  }\n}\n\n// 下面生成二叉树\nfunction make(array) {\n  // 判断是否为叶节点\n  if (array.length == 1) return new tree(null, array[0], null);\n  return new tree(make(array[0]), array[1], make(array[2]));\n}\nlet tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);\n\n// 遍历二叉树\nvar result = [];\nfor (let node of inorder(tree)) {\n  result.push(node);\n}\n\nresult\n// ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 作为对象属性的 generator 函数\n\n如果一个对象的属性是 generator 函数，可以简写成下面的形式。\n\nlet obj = {\n  * mygeneratormethod() {\n    ···\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，mygeneratormethod属性前面有一个星号，表示这个属性是一个 generator 函数。\n\n它的完整形式如下，与上面的写法是等价的。\n\nlet obj = {\n  mygeneratormethod: function* () {\n    // ···\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\n\n# generator 函数的this\n\ngenerator 函数总是返回一个遍历器，es6 规定这个遍历器是 generator 函数的实例，也继承了 generator 函数的prototype对象上的方法。\n\nfunction* g() {}\n\ng.prototype.hello = function () {\n  return 'hi!';\n};\n\nlet obj = g();\n\nobj instanceof g // true\nobj.hello() // 'hi!'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码表明，generator 函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。\n\nfunction* g() {\n  this.a = 11;\n}\n\nlet obj = g();\nobj.next();\nobj.a // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，generator 函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。\n\ngenerator 函数也不能跟new命令一起用，会报错。\n\nfunction* f() {\n  yield this.x = 2;\n  yield this.y = 3;\n}\n\nnew f()\n// typeerror: f is not a constructor\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，new命令跟构造函数f一起使用，结果报错，因为f不是构造函数。\n\n那么，有没有办法让 generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？\n\n下面是一个变通方法。首先，生成一个空对象，使用call方法绑定 generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 generator 函数的实例对象了。\n\nfunction* f() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\nvar obj = {};\nvar f = f.call(obj);\n\nf.next();  // object {value: 2, done: false}\nf.next();  // object {value: 3, done: false}\nf.next();  // object {value: undefined, done: true}\n\nobj.a // 1\nobj.b // 2\nobj.c // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，首先是f内部的this对象绑定obj对象，然后调用它，返回一个 iterator 对象。这个对象执行三次next方法（因为f内部有两个yield表达式），完成 f 内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了f的实例。\n\n上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？\n\n一个办法就是将obj换成f.prototype。\n\nfunction* f() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\nvar f = f.call(f.prototype);\n\nf.next();  // object {value: 2, done: false}\nf.next();  // object {value: 3, done: false}\nf.next();  // object {value: undefined, done: true}\n\nf.a // 1\nf.b // 2\nf.c // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n再将f改成构造函数，就可以对它执行new命令了。\n\nfunction* gen() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\n\nfunction f() {\n  return gen.call(gen.prototype);\n}\n\nvar f = new f();\n\nf.next();  // object {value: 2, done: false}\nf.next();  // object {value: 3, done: false}\nf.next();  // object {value: undefined, done: true}\n\nf.a // 1\nf.b // 2\nf.c // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 含义\n\n\n# generator 与状态机\n\ngenerator 是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。\n\nvar ticking = true;\nvar clock = function() {\n  if (ticking)\n    console.log('tick!');\n  else\n    console.log('tock!');\n  ticking = !ticking;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码的clock函数一共有两种状态（tick和tock），每运行一次，就改变一次状态。这个函数如果用 generator 实现，就是下面这样。\n\nvar clock = function* () {\n  while (true) {\n    console.log('tick!');\n    yield;\n    console.log('tock!');\n    yield;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面的 generator 实现与 es5 实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。\n\n\n# generator 与协程\n\n协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。\n\n（1）协程与子例程的差异\n\n传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。\n\n从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。\n\n（2）协程与普通线程的差异\n\n不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。\n\n由于 javascript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。\n\ngenerator 函数是 es6 对协程的实现，但属于不完全实现。generator 函数被称为“半协程”（semi-coroutine），意思是只有 generator 函数的调用者，才能将程序的执行权还给 generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。\n\n如果将 generator 函数当作协程，完全可以将多个需要互相协作的任务写成 generator 函数，它们之间使用yield表达式交换控制权。\n\n\n# generator 与上下文\n\njavascript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。\n\n这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。\n\ngenerator 函数不是这样，它执行产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行next命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。\n\nfunction* gen() {\n  yield 1;\n  return 2;\n}\n\nlet g = gen();\n\nconsole.log(\n  g.next().value,\n  g.next().value,\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，第一次执行g.next()时，generator 函数gen的上下文会加入堆栈，即开始运行gen内部的代码。等遇到yield 1时，gen上下文退出堆栈，内部状态冻结。第二次执行g.next()时，gen上下文重新加入堆栈，变成当前的上下文，重新恢复执行。\n\n\n# 应用\n\ngenerator 可以暂停函数执行，返回任意表达式的值。这种特点使得 generator 有多种应用场景。\n\n\n# （1）异步操作的同步化表达\n\ngenerator 函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。\n\nfunction* loadui() {\n  showloadingscreen();\n  yield loaduidataasynchronously();\n  hideloadingscreen();\n}\nvar loader = loadui();\n// 加载ui\nloader.next()\n\n// 卸载ui\nloader.next()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，第一次调用loadui函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示loading界面（showloadingscreen），并且异步加载数据（loaduidataasynchronously）。等到数据加载完成，再一次使用next方法，则会隐藏loading界面。可以看到，这种写法的好处是所有loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。\n\najax 是典型的异步操作，通过 generator 函数部署 ajax 操作，可以用同步的方式表达。\n\nfunction* main() {\n  var result = yield request(\"http://some.url\");\n  var resp = json.parse(result);\n    console.log(resp.value);\n}\n\nfunction request(url) {\n  makeajaxcall(url, function(response){\n    it.next(response);\n  });\n}\n\nvar it = main();\nit.next();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码的main函数，就是通过 ajax 操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeajaxcall函数中的next方法，必须加上response参数，因为yield表达式，本身是没有值的，总是等于undefined。\n\n下面是另一个例子，通过 generator 函数逐行读取文本文件。\n\nfunction* numbers() {\n  let file = new filereader(\"numbers.txt\");\n  try {\n    while(!file.eof) {\n      yield parseint(file.readline(), 10);\n    }\n  } finally {\n    file.close();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码打开文本文件，使用yield表达式可以手动逐行读取文件。\n\n\n# （2）控制流管理\n\n如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。\n\nstep1(function (value1) {\n  step2(value1, function(value2) {\n    step3(value2, function(value3) {\n      step4(value3, function(value4) {\n        // do something with value4\n      });\n    });\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n采用 promise 改写上面的代码。\n\npromise.resolve(step1)\n  .then(step2)\n  .then(step3)\n  .then(step4)\n  .then(function (value4) {\n    // do something with value4\n  }, function (error) {\n    // handle any error from step1 through step4\n  })\n  .done();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 promise 的语法。generator 函数可以进一步改善代码运行流程。\n\nfunction* longrunningtask(value1) {\n  try {\n    var value2 = yield step1(value1);\n    var value3 = yield step2(value2);\n    var value4 = yield step3(value3);\n    var value5 = yield step4(value4);\n    // do something with value4\n  } catch (e) {\n    // handle any error from step1 through step4\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n然后，使用一个函数，按次序自动执行所有步骤。\n\nscheduler(longrunningtask(initialvalue));\n\nfunction scheduler(task) {\n  var taskobj = task.next(task.value);\n  // 如果generator函数未结束，就继续调用\n  if (!taskobj.done) {\n    task.value = taskobj.value\n    scheduler(task);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意，上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。\n\n下面，利用for...of循环会自动依次执行yield命令的特性，提供一种更一般的控制流管理的方法。\n\nlet steps = [step1func, step2func, step3func];\n\nfunction* iteratesteps(steps){\n  for (var i=0; i< steps.length; i++){\n    var step = steps[i];\n    yield step();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，数组steps封装了一个任务的多个步骤，generator 函数iteratesteps则是依次为这些步骤加上yield命令。\n\n将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。\n\nlet jobs = [job1, job2, job3];\n\nfunction* iteratejobs(jobs){\n  for (var i=0; i< jobs.length; i++){\n    var job = jobs[i];\n    yield* iteratesteps(job.steps);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，数组jobs封装了一个项目的多个任务，generator 函数iteratejobs则是依次为这些任务加上yield*命令。\n\n最后，就可以用for...of循环一次性依次执行所有任务的所有步骤。\n\nfor (var step of iteratejobs(jobs)){\n  console.log(step.id);\n}\n\n\n1\n2\n3\n\n\n再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。\n\nfor...of的本质是一个while循环，所以上面的代码实质上执行的是下面的逻辑。\n\nvar it = iteratejobs(jobs);\nvar res = it.next();\n\nwhile (!res.done){\n  var result = res.value;\n  // ...\n  res = it.next();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# （3）部署 iterator 接口\n\n利用 generator 函数，可以在任意对象上部署 iterator 接口。\n\nfunction* iterentries(obj) {\n  let keys = object.keys(obj);\n  for (let i=0; i < keys.length; i++) {\n    let key = keys[i];\n    yield [key, obj[key]];\n  }\n}\n\nlet myobj = { foo: 3, bar: 7 };\n\nfor (let [key, value] of iterentries(myobj)) {\n  console.log(key, value);\n}\n\n// foo 3\n// bar 7\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上述代码中，myobj是一个普通对象，通过iterentries函数，就有了 iterator 接口。也就是说，可以在任意对象上部署next方法。\n\n下面是一个对数组部署 iterator 接口的例子，尽管数组原生具有这个接口。\n\nfunction* makesimplegenerator(array){\n  var nextindex = 0;\n\n  while(nextindex < array.length){\n    yield array[nextindex++];\n  }\n}\n\nvar gen = makesimplegenerator(['yo', 'ya']);\n\ngen.next().value // 'yo'\ngen.next().value // 'ya'\ngen.next().done  // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# （4）作为数据结构\n\ngenerator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。\n\nfunction* dostuff() {\n  yield fs.readfile.bind(null, 'hello.txt');\n  yield fs.readfile.bind(null, 'world.txt');\n  yield fs.readfile.bind(null, 'and-such.txt');\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码就是依次返回三个函数，但是由于使用了 generator 函数，导致可以像处理数组那样，处理这三个返回的函数。\n\nfor (task of dostuff()) {\n  // task是一个函数，可以像回调函数那样使用它\n}\n\n\n1\n2\n3\n\n\n实际上，如果用 es5 表达，完全可以用数组模拟 generator 的这种用法。\n\nfunction dostuff() {\n  return [\n    fs.readfile.bind(null, 'hello.txt'),\n    fs.readfile.bind(null, 'world.txt'),\n    fs.readfile.bind(null, 'and-such.txt')\n  ];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的函数，可以用一模一样的for...of循环处理！两相一比较，就不难看出 generator 使得数据或者操作，具备了类似数组的接口。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Generator 函数的异步应用",frontmatter:{title:"Generator 函数的异步应用",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/75af7031eb66847b",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/19.Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8.html",relativePath:"《ES6 教程》笔记/19.Generator 函数的异步应用.md",key:"v-1bbe4ea2",path:"/pages/75af7031eb66847b/",headers:[{level:2,title:"传统方法",slug:"传统方法",normalizedTitle:"传统方法",charIndex:124},{level:2,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:242},{level:3,title:"异步",slug:"异步",normalizedTitle:"异步",charIndex:15},{level:3,title:"回调函数",slug:"回调函数",normalizedTitle:"回调函数",charIndex:160},{level:3,title:"Promise",slug:"promise",normalizedTitle:"promise",charIndex:185},{level:2,title:"Generator 函数",slug:"generator-函数",normalizedTitle:"generator 函数",charIndex:2},{level:3,title:"协程",slug:"协程",normalizedTitle:"协程",charIndex:2005},{level:3,title:"协程的 Generator 函数实现",slug:"协程的-generator-函数实现",normalizedTitle:"协程的 generator 函数实现",charIndex:2520},{level:3,title:"Generator 函数的数据交换和错误处理",slug:"generator-函数的数据交换和错误处理",normalizedTitle:"generator 函数的数据交换和错误处理",charIndex:3165},{level:3,title:"异步任务的封装",slug:"异步任务的封装",normalizedTitle:"异步任务的封装",charIndex:4008},{level:2,title:"Thunk 函数",slug:"thunk-函数",normalizedTitle:"thunk 函数",charIndex:4684},{level:3,title:"参数的求值策略",slug:"参数的求值策略",normalizedTitle:"参数的求值策略",charIndex:4731},{level:3,title:"Thunk 函数的含义",slug:"thunk-函数的含义",normalizedTitle:"thunk 函数的含义",charIndex:5419},{level:3,title:"JavaScript 语言的 Thunk 函数",slug:"javascript-语言的-thunk-函数",normalizedTitle:"javascript 语言的 thunk 函数",charIndex:5782},{level:3,title:"Thunkify 模块",slug:"thunkify-模块",normalizedTitle:"thunkify 模块",charIndex:7024},{level:3,title:"Generator 函数的流程管理",slug:"generator-函数的流程管理",normalizedTitle:"generator 函数的流程管理",charIndex:8158},{level:3,title:"Thunk 函数的自动流程管理",slug:"thunk-函数的自动流程管理",normalizedTitle:"thunk 函数的自动流程管理",charIndex:9450},{level:2,title:"co 模块",slug:"co-模块",normalizedTitle:"co 模块",charIndex:10496},{level:3,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:10506},{level:3,title:"co 模块的原理",slug:"co-模块的原理",normalizedTitle:"co 模块的原理",charIndex:11065},{level:3,title:"基于 Promise 对象的自动执行",slug:"基于-promise-对象的自动执行",normalizedTitle:"基于 promise 对象的自动执行",charIndex:11456},{level:3,title:"co 模块的源码",slug:"co-模块的源码",normalizedTitle:"co 模块的源码",charIndex:12551},{level:3,title:"处理并发的异步操作",slug:"处理并发的异步操作",normalizedTitle:"处理并发的异步操作",charIndex:14322},{level:3,title:"实例：处理 Stream",slug:"实例-处理-stream",normalizedTitle:"实例：处理 stream",charIndex:14981}],excerpt:'<h1 id="generator-函数的异步应用"><a class="header-anchor" href="#generator-函数的异步应用">#</a> Generator 函数的异步应用</h1>\n<p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p>\n',headersStr:"传统方法 基本概念 异步 回调函数 Promise Generator 函数 协程 协程的 Generator 函数实现 Generator 函数的数据交换和错误处理 异步任务的封装 Thunk 函数 参数的求值策略 Thunk 函数的含义 JavaScript 语言的 Thunk 函数 Thunkify 模块 Generator 函数的流程管理 Thunk 函数的自动流程管理 co 模块 基本用法 co 模块的原理 基于 Promise 对象的自动执行 co 模块的源码 处理并发的异步操作 实例：处理 Stream",content:"# Generator 函数的异步应用\n\n异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。\n\n\n# 传统方法\n\nES6 诞生以前，异步编程的方法，大概有下面四种。\n\n * 回调函数\n * 事件监听\n * 发布/订阅\n * Promise 对象\n\nGenerator 函数将 JavaScript 异步编程带入了一个全新的阶段。\n\n\n# 基本概念\n\n\n# 异步\n\n所谓\"异步\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\n\n比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。\n\n相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。\n\n\n# 回调函数\n\nJavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是\"重新调用\"。\n\n读取文件进行处理，是这样写的。\n\nfs.readFile('/etc/passwd', 'utf-8', function (err, data) {\n  if (err) throw err;\n  console.log(data);\n});\n\n\n1\n2\n3\n4\n\n\n上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。\n\n一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？\n\n原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。\n\n\n# Promise\n\n回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。\n\nfs.readFile(fileA, 'utf-8', function (err, data) {\n  fs.readFile(fileB, 'utf-8', function (err, data) {\n    // ...\n  });\n});\n\n\n1\n2\n3\n4\n5\n\n\n不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为\"回调函数地狱\"（callback hell）。\n\nPromise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。\n\nvar readFile = require('fs-readfile-promise');\n\nreadFile(fileA)\n.then(function (data) {\n  console.log(data.toString());\n})\n.then(function () {\n  return readFile(fileB);\n})\n.then(function (data) {\n  console.log(data.toString());\n})\n.catch(function (err) {\n  console.log(err);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个 Promise 版本的readFile函数。Promise 提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。\n\n可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。\n\nPromise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。\n\n那么，有没有更好的写法呢？\n\n\n# Generator 函数\n\n\n# 协程\n\n传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做\"协程\"（coroutine），意思是多个线程互相协作，完成异步任务。\n\n协程有点像函数，又有点像线程。它的运行流程大致如下。\n\n * 第一步，协程A开始执行。\n * 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。\n * 第三步，（一段时间后）协程B交还执行权。\n * 第四步，协程A恢复执行。\n\n上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。\n\n举例来说，读取文件的协程写法如下。\n\nfunction* asyncJob() {\n  // ...其他代码\n  var f = yield readFile(fileA);\n  // ...其他代码\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。\n\n协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。\n\n\n# 协程的 Generator 函数实现\n\nGenerator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。\n\n整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator 函数的执行方法如下。\n\nfunction* gen(x) {\n  var y = yield x + 2;\n  return y;\n}\n\nvar g = gen(1);\ng.next() // { value: 3, done: false }\ng.next() // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）g。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。\n\n换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。\n\n\n# Generator 函数的数据交换和错误处理\n\nGenerator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。\n\nnext返回值的 value 属性，是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据。\n\nfunction* gen(x){\n  var y = yield x + 2;\n  return y;\n}\n\nvar g = gen(1);\ng.next() // { value: 3, done: false }\ng.next(2) // { value: 2, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，第一个next方法的value属性，返回表达式x + 2的值3。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的value属性，返回的就是2（变量y的值）。\n\nGenerator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。\n\nfunction* gen(x){\n  try {\n    var y = yield x + 2;\n  } catch (e){\n    console.log(e);\n  }\n  return y;\n}\n\nvar g = gen(1);\ng.next();\ng.throw('出错了');\n// 出错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码的最后一行，Generator 函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try...catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。\n\n\n# 异步任务的封装\n\n下面看看如何使用 Generator 函数，执行一个真实的异步任务。\n\nvar fetch = require('node-fetch');\n\nfunction* gen(){\n  var url = 'https://api.github.com/users/github';\n  var result = yield fetch(url);\n  console.log(result.bio);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。\n\n执行这段代码的方法如下。\n\nvar g = gen();\nvar result = g.next();\n\nresult.value.then(function(data){\n  return data.json();\n}).then(function(data){\n  g.next(data);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。\n\n可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。\n\n\n# Thunk 函数\n\nThunk 函数是自动执行 Generator 函数的一种方法。\n\n\n# 参数的求值策略\n\nThunk 函数早在上个世纪 60 年代就诞生了。\n\n那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是\"求值策略\"，即函数的参数到底应该何时求值。\n\nvar x = 1;\n\nfunction f(m) {\n  return m * 2;\n}\n\nf(x + 5)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码先定义函数f，然后向它传入表达式x + 5。请问，这个表达式应该何时求值？\n\n一种意见是\"传值调用\"（call by value），即在进入函数体之前，就计算x + 5的值（等于 6），再将这个值传入函数f。C 语言就采用这种策略。\n\nf(x + 5)\n// 传值调用时，等同于\nf(6)\n\n\n1\n2\n3\n\n\n另一种意见是“传名调用”（call by name），即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。\n\nf(x + 5)\n// 传名调用时，等同于\n(x + 5) * 2\n\n\n1\n2\n3\n\n\n传值调用和传名调用，哪一种比较好？\n\n回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。\n\nfunction f(a, b){\n  return b;\n}\n\nf(3 * x * x - 2 * x - 1, x);\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于\"传名调用\"，即只在执行时求值。\n\n\n# Thunk 函数的含义\n\n编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。\n\nfunction f(m) {\n  return m * 2;\n}\n\nf(x + 5);\n\n// 等同于\n\nvar thunk = function () {\n  return x + 5;\n};\n\nfunction f(thunk) {\n  return thunk() * 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，函数 f 的参数x + 5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。\n\n这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。\n\n\n# JavaScript 语言的 Thunk 函数\n\nJavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。\n\n// 正常版本的readFile（多参数版本）\nfs.readFile(fileName, callback);\n\n// Thunk版本的readFile（单参数版本）\nvar Thunk = function (fileName) {\n  return function (callback) {\n    return fs.readFile(fileName, callback);\n  };\n};\n\nvar readFileThunk = Thunk(fileName);\nreadFileThunk(callback);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。\n\n任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。\n\n// ES5版本\nvar Thunk = function(fn){\n  return function (){\n    var args = Array.prototype.slice.call(arguments);\n    return function (callback){\n      args.push(callback);\n      return fn.apply(this, args);\n    }\n  };\n};\n\n// ES6版本\nconst Thunk = function(fn) {\n  return function (...args) {\n    return function (callback) {\n      return fn.call(this, ...args, callback);\n    }\n  };\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n使用上面的转换器，生成fs.readFile的 Thunk 函数。\n\nvar readFileThunk = Thunk(fs.readFile);\nreadFileThunk(fileA)(callback);\n\n\n1\n2\n\n\n下面是另一个完整的例子。\n\nfunction f(a, cb) {\n  cb(a);\n}\nconst ft = Thunk(f);\n\nft(1)(console.log) // 1\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Thunkify 模块\n\n生产环境的转换器，建议使用 Thunkify 模块。\n\n首先是安装。\n\n$ npm install thunkify\n\n\n1\n\n\n使用方式如下。\n\nvar thunkify = require('thunkify');\nvar fs = require('fs');\n\nvar read = thunkify(fs.readFile);\nread('package.json')(function(err, str){\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nThunkify 的源码与上一节那个简单的转换器非常像。\n\nfunction thunkify(fn) {\n  return function() {\n    var args = new Array(arguments.length);\n    var ctx = this;\n\n    for (var i = 0; i < args.length; ++i) {\n      args[i] = arguments[i];\n    }\n\n    return function (done) {\n      var called;\n\n      args.push(function () {\n        if (called) return;\n        called = true;\n        done.apply(null, arguments);\n      });\n\n      try {\n        fn.apply(ctx, args);\n      } catch (err) {\n        done(err);\n      }\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n它的源码主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。\n\nfunction f(a, b, callback){\n  var sum = a + b;\n  callback(sum);\n  callback(sum);\n}\n\nvar ft = thunkify(f);\nvar print = console.log.bind(console);\nft(1, 2)(print);\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，由于thunkify只允许回调函数执行一次，所以只输出一行结果。\n\n\n# Generator 函数的流程管理\n\n你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。\n\nGenerator 函数可以自动执行。\n\nfunction* gen() {\n  // ...\n}\n\nvar g = gen();\nvar res = g.next();\n\nwhile(!res.done){\n  console.log(res.value);\n  res = g.next();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，Generator 函数gen会自动执行完所有步骤。\n\n但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。\n\nvar fs = require('fs');\nvar thunkify = require('thunkify');\nvar readFileThunk = thunkify(fs.readFile);\n\nvar gen = function* (){\n  var r1 = yield readFileThunk('/etc/fstab');\n  console.log(r1.toString());\n  var r2 = yield readFileThunk('/etc/shells');\n  console.log(r2.toString());\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，yield命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。\n\n这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。\n\nvar g = gen();\n\nvar r1 = g.next();\nr1.value(function (err, data) {\n  if (err) throw err;\n  var r2 = g.next(data);\n  r2.value(function (err, data) {\n    if (err) throw err;\n    g.next(data);\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，变量g是 Generator 函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。\n\n仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。\n\n\n# Thunk 函数的自动流程管理\n\nThunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。\n\nfunction run(fn) {\n  var gen = fn();\n\n  function next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value(next);\n  }\n\n  next();\n}\n\nfunction* g() {\n  // ...\n}\n\nrun(g);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码的run函数，就是一个 Generator 函数的自动执行器。内部的next函数就是 Thunk 的回调函数。next函数先将指针移到 Generator 函数的下一步（gen.next方法），然后判断 Generator 函数是否结束（result.done属性），如果没结束，就将next函数再传入 Thunk 函数（result.value属性），否则就直接退出。\n\n有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入run函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在yield命令后面的必须是 Thunk 函数。\n\nvar g = function* (){\n  var f1 = yield readFileThunk('fileA');\n  var f2 = yield readFileThunk('fileB');\n  // ...\n  var fn = yield readFileThunk('fileN');\n};\n\nrun(g);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，函数g封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。\n\nThunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。\n\n\n# co 模块\n\n\n# 基本用法\n\nco 模块是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。\n\n下面是一个 Generator 函数，用于依次读取两个文件。\n\nvar gen = function* () {\n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\nco 模块可以让你不用编写 Generator 函数的执行器。\n\nvar co = require('co');\nco(gen);\n\n\n1\n2\n\n\n上面代码中，Generator 函数只要传入co函数，就会自动执行。\n\nco函数返回一个Promise对象，因此可以用then方法添加回调函数。\n\nco(gen).then(function (){\n  console.log('Generator 函数执行完成');\n});\n\n\n1\n2\n3\n\n\n上面代码中，等到 Generator 函数执行结束，就会输出一行提示。\n\n\n# co 模块的原理\n\n为什么 co 可以自动执行 Generator 函数？\n\n前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。\n\n两种方法可以做到这一点。\n\n（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。\n\n（2）Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。\n\nco 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，详见后文的例子。\n\n上一节已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 模块必须的。\n\n\n# 基于 Promise 对象的自动执行\n\n还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个 Promise 对象。\n\nvar fs = require('fs');\n\nvar readFile = function (fileName){\n  return new Promise(function (resolve, reject){\n    fs.readFile(fileName, function(error, data){\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n\nvar gen = function* (){\n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n然后，手动执行上面的 Generator 函数。\n\nvar g = gen();\n\ng.next().value.then(function(data){\n  g.next(data).value.then(function(data){\n    g.next(data);\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。\n\nfunction run(gen){\n  var g = gen();\n\n  function next(data){\n    var result = g.next(data);\n    if (result.done) return result.value;\n    result.value.then(function(data){\n      next(data);\n    });\n  }\n\n  next();\n}\n\nrun(gen);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，只要 Generator 函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。\n\n\n# co 模块的源码\n\nco 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。\n\n首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。\n\nfunction co(gen) {\n  var ctx = this;\n\n  return new Promise(function(resolve, reject) {\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在返回的 Promise 对象里面，co 先检查参数gen是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为resolved。\n\nfunction co(gen) {\n  var ctx = this;\n\n  return new Promise(function(resolve, reject) {\n    if (typeof gen === 'function') gen = gen.call(ctx);\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n接着，co 将 Generator 函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。\n\nfunction co(gen) {\n  var ctx = this;\n\n  return new Promise(function(resolve, reject) {\n    if (typeof gen === 'function') gen = gen.call(ctx);\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\n\n    onFulfilled();\n    function onFulfilled(res) {\n      var ret;\n      try {\n        ret = gen.next(res);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n最后，就是关键的next函数，它会反复调用自身。\n\nfunction next(ret) {\n  if (ret.done) return resolve(ret.value);\n  var value = toPromise.call(ctx, ret.value);\n  if (value && isPromise(value)) return value.then(onFulfilled, onRejected);\n  return onRejected(\n    new TypeError(\n      'You may only yield a function, promise, generator, array, or object, '\n      + 'but the following object was passed: \"'\n      + String(ret.value)\n      + '\"'\n    )\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，next函数的内部代码，一共只有四行命令。\n\n第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。\n\n第二行，确保每一步的返回值，是 Promise 对象。\n\n第三行，使用then方法，为返回值加上回调函数，然后通过onFulfilled函数再次调用next函数。\n\n第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为rejected，从而终止执行。\n\n\n# 处理并发的异步操作\n\nco 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。\n\n这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。\n\n// 数组的写法\nco(function* () {\n  var res = yield [\n    Promise.resolve(1),\n    Promise.resolve(2)\n  ];\n  console.log(res);\n}).catch(onerror);\n\n// 对象的写法\nco(function* () {\n  var res = yield {\n    1: Promise.resolve(1),\n    2: Promise.resolve(2),\n  };\n  console.log(res);\n}).catch(onerror);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n下面是另一个例子。\n\nco(function* () {\n  var values = [n1, n2, n3];\n  yield values.map(somethingAsync);\n});\n\nfunction* somethingAsync(x) {\n  // do something async\n  return y\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的代码允许并发三个somethingAsync异步操作，等到它们全部完成，才会进行下一步。\n\n\n# 实例：处理 Stream\n\nNode 提供 Stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream 模式使用 EventEmitter API，会释放三个事件。\n\n * data事件：下一块数据块已经准备好了。\n * end事件：整个“数据流”处理完了。\n * error事件：发生错误。\n\n使用Promise.race()函数，可以判断这三个事件之中哪一个最先发生，只有当data事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个while循环，完成所有数据的读取。\n\nconst co = require('co');\nconst fs = require('fs');\n\nconst stream = fs.createReadStream('./les_miserables.txt');\nlet valjeanCount = 0;\n\nco(function*() {\n  while(true) {\n    const res = yield Promise.race([\n      new Promise(resolve => stream.once('data', resolve)),\n      new Promise(resolve => stream.once('end', resolve)),\n      new Promise((resolve, reject) => stream.once('error', reject))\n    ]);\n    if (!res) {\n      break;\n    }\n    stream.removeAllListeners('data');\n    stream.removeAllListeners('end');\n    stream.removeAllListeners('error');\n    valjeanCount += (res.toString().match(/valjean/ig) || []).length;\n  }\n  console.log('count:', valjeanCount); // count: 1120\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n上面代码采用 Stream 模式读取《悲惨世界》的文本文件，对于每个数据块都使用stream.once方法，在data、end、error三个事件上添加一次性回调函数。变量res只有在data事件发生时才有值，然后累加每个数据块之中valjean这个词出现的次数。",normalizedContent:"# generator 函数的异步应用\n\n异步编程对 javascript 语言太重要。javascript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 generator 函数如何完成异步操作。\n\n\n# 传统方法\n\nes6 诞生以前，异步编程的方法，大概有下面四种。\n\n * 回调函数\n * 事件监听\n * 发布/订阅\n * promise 对象\n\ngenerator 函数将 javascript 异步编程带入了一个全新的阶段。\n\n\n# 基本概念\n\n\n# 异步\n\n所谓\"异步\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\n\n比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。\n\n相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。\n\n\n# 回调函数\n\njavascript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是\"重新调用\"。\n\n读取文件进行处理，是这样写的。\n\nfs.readfile('/etc/passwd', 'utf-8', function (err, data) {\n  if (err) throw err;\n  console.log(data);\n});\n\n\n1\n2\n3\n4\n\n\n上面代码中，readfile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。\n\n一个有趣的问题是，为什么 node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？\n\n原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。\n\n\n# promise\n\n回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取a文件之后，再读取b文件，代码如下。\n\nfs.readfile(filea, 'utf-8', function (err, data) {\n  fs.readfile(fileb, 'utf-8', function (err, data) {\n    // ...\n  });\n});\n\n\n1\n2\n3\n4\n5\n\n\n不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为\"回调函数地狱\"（callback hell）。\n\npromise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 promise，连续读取多个文件，写法如下。\n\nvar readfile = require('fs-readfile-promise');\n\nreadfile(filea)\n.then(function (data) {\n  console.log(data.tostring());\n})\n.then(function () {\n  return readfile(fileb);\n})\n.then(function (data) {\n  console.log(data.tostring());\n})\n.catch(function (err) {\n  console.log(err);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个 promise 版本的readfile函数。promise 提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。\n\n可以看到，promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。\n\npromise 的最大问题是代码冗余，原来的任务被 promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。\n\n那么，有没有更好的写法呢？\n\n\n# generator 函数\n\n\n# 协程\n\n传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做\"协程\"（coroutine），意思是多个线程互相协作，完成异步任务。\n\n协程有点像函数，又有点像线程。它的运行流程大致如下。\n\n * 第一步，协程a开始执行。\n * 第二步，协程a执行到一半，进入暂停，执行权转移到协程b。\n * 第三步，（一段时间后）协程b交还执行权。\n * 第四步，协程a恢复执行。\n\n上面流程的协程a，就是异步任务，因为它分成两段（或多段）执行。\n\n举例来说，读取文件的协程写法如下。\n\nfunction* asyncjob() {\n  // ...其他代码\n  var f = yield readfile(filea);\n  // ...其他代码\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码的函数asyncjob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。\n\n协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。\n\n\n# 协程的 generator 函数实现\n\ngenerator 函数是协程在 es6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。\n\n整个 generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。generator 函数的执行方法如下。\n\nfunction* gen(x) {\n  var y = yield x + 2;\n  return y;\n}\n\nvar g = gen(1);\ng.next() // { value: 3, done: false }\ng.next() // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，调用 generator 函数，会返回一个内部指针（即遍历器）g。这是 generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。\n\n换言之，next方法的作用是分阶段执行generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示 generator 函数是否执行完毕，即是否还有下一个阶段。\n\n\n# generator 函数的数据交换和错误处理\n\ngenerator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。\n\nnext返回值的 value 属性，是 generator 函数向外输出数据；next方法还可以接受参数，向 generator 函数体内输入数据。\n\nfunction* gen(x){\n  var y = yield x + 2;\n  return y;\n}\n\nvar g = gen(1);\ng.next() // { value: 3, done: false }\ng.next(2) // { value: 2, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，第一个next方法的value属性，返回表达式x + 2的值3。第二个next方法带有参数2，这个参数可以传入 generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的value属性，返回的就是2（变量y的值）。\n\ngenerator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。\n\nfunction* gen(x){\n  try {\n    var y = yield x + 2;\n  } catch (e){\n    console.log(e);\n  }\n  return y;\n}\n\nvar g = gen(1);\ng.next();\ng.throw('出错了');\n// 出错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码的最后一行，generator 函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try...catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。\n\n\n# 异步任务的封装\n\n下面看看如何使用 generator 函数，执行一个真实的异步任务。\n\nvar fetch = require('node-fetch');\n\nfunction* gen(){\n  var url = 'https://api.github.com/users/github';\n  var result = yield fetch(url);\n  console.log(result.bio);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 json 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。\n\n执行这段代码的方法如下。\n\nvar g = gen();\nvar result = g.next();\n\nresult.value.then(function(data){\n  return data.json();\n}).then(function(data){\n  g.next(data);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，首先执行 generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。由于fetch模块返回的是一个 promise 对象，因此要用then方法调用下一个next方法。\n\n可以看到，虽然 generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。\n\n\n# thunk 函数\n\nthunk 函数是自动执行 generator 函数的一种方法。\n\n\n# 参数的求值策略\n\nthunk 函数早在上个世纪 60 年代就诞生了。\n\n那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是\"求值策略\"，即函数的参数到底应该何时求值。\n\nvar x = 1;\n\nfunction f(m) {\n  return m * 2;\n}\n\nf(x + 5)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码先定义函数f，然后向它传入表达式x + 5。请问，这个表达式应该何时求值？\n\n一种意见是\"传值调用\"（call by value），即在进入函数体之前，就计算x + 5的值（等于 6），再将这个值传入函数f。c 语言就采用这种策略。\n\nf(x + 5)\n// 传值调用时，等同于\nf(6)\n\n\n1\n2\n3\n\n\n另一种意见是“传名调用”（call by name），即直接将表达式x + 5传入函数体，只在用到它的时候求值。haskell 语言采用这种策略。\n\nf(x + 5)\n// 传名调用时，等同于\n(x + 5) * 2\n\n\n1\n2\n3\n\n\n传值调用和传名调用，哪一种比较好？\n\n回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。\n\nfunction f(a, b){\n  return b;\n}\n\nf(3 * x * x - 2 * x - 1, x);\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于\"传名调用\"，即只在执行时求值。\n\n\n# thunk 函数的含义\n\n编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 thunk 函数。\n\nfunction f(m) {\n  return m * 2;\n}\n\nf(x + 5);\n\n// 等同于\n\nvar thunk = function () {\n  return x + 5;\n};\n\nfunction f(thunk) {\n  return thunk() * 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，函数 f 的参数x + 5被一个函数替换了。凡是用到原参数的地方，对thunk函数求值即可。\n\n这就是 thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。\n\n\n# javascript 语言的 thunk 函数\n\njavascript 语言是传值调用，它的 thunk 函数含义有所不同。在 javascript 语言中，thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。\n\n// 正常版本的readfile（多参数版本）\nfs.readfile(filename, callback);\n\n// thunk版本的readfile（单参数版本）\nvar thunk = function (filename) {\n  return function (callback) {\n    return fs.readfile(filename, callback);\n  };\n};\n\nvar readfilethunk = thunk(filename);\nreadfilethunk(callback);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，fs模块的readfile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 thunk 函数。\n\n任何函数，只要参数有回调函数，就能写成 thunk 函数的形式。下面是一个简单的 thunk 函数转换器。\n\n// es5版本\nvar thunk = function(fn){\n  return function (){\n    var args = array.prototype.slice.call(arguments);\n    return function (callback){\n      args.push(callback);\n      return fn.apply(this, args);\n    }\n  };\n};\n\n// es6版本\nconst thunk = function(fn) {\n  return function (...args) {\n    return function (callback) {\n      return fn.call(this, ...args, callback);\n    }\n  };\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n使用上面的转换器，生成fs.readfile的 thunk 函数。\n\nvar readfilethunk = thunk(fs.readfile);\nreadfilethunk(filea)(callback);\n\n\n1\n2\n\n\n下面是另一个完整的例子。\n\nfunction f(a, cb) {\n  cb(a);\n}\nconst ft = thunk(f);\n\nft(1)(console.log) // 1\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# thunkify 模块\n\n生产环境的转换器，建议使用 thunkify 模块。\n\n首先是安装。\n\n$ npm install thunkify\n\n\n1\n\n\n使用方式如下。\n\nvar thunkify = require('thunkify');\nvar fs = require('fs');\n\nvar read = thunkify(fs.readfile);\nread('package.json')(function(err, str){\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nthunkify 的源码与上一节那个简单的转换器非常像。\n\nfunction thunkify(fn) {\n  return function() {\n    var args = new array(arguments.length);\n    var ctx = this;\n\n    for (var i = 0; i < args.length; ++i) {\n      args[i] = arguments[i];\n    }\n\n    return function (done) {\n      var called;\n\n      args.push(function () {\n        if (called) return;\n        called = true;\n        done.apply(null, arguments);\n      });\n\n      try {\n        fn.apply(ctx, args);\n      } catch (err) {\n        done(err);\n      }\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n它的源码主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的 generator 函数相关。请看下面的例子。\n\nfunction f(a, b, callback){\n  var sum = a + b;\n  callback(sum);\n  callback(sum);\n}\n\nvar ft = thunkify(f);\nvar print = console.log.bind(console);\nft(1, 2)(print);\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，由于thunkify只允许回调函数执行一次，所以只输出一行结果。\n\n\n# generator 函数的流程管理\n\n你可能会问， thunk 函数有什么用？回答是以前确实没什么用，但是 es6 有了 generator 函数，thunk 函数现在可以用于 generator 函数的自动流程管理。\n\ngenerator 函数可以自动执行。\n\nfunction* gen() {\n  // ...\n}\n\nvar g = gen();\nvar res = g.next();\n\nwhile(!res.done){\n  console.log(res.value);\n  res = g.next();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，generator 函数gen会自动执行完所有步骤。\n\n但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，thunk 函数就能派上用处。以读取文件为例。下面的 generator 函数封装了两个异步操作。\n\nvar fs = require('fs');\nvar thunkify = require('thunkify');\nvar readfilethunk = thunkify(fs.readfile);\n\nvar gen = function* (){\n  var r1 = yield readfilethunk('/etc/fstab');\n  console.log(r1.tostring());\n  var r2 = yield readfilethunk('/etc/shells');\n  console.log(r2.tostring());\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，yield命令用于将程序的执行权移出 generator 函数，那么就需要一种方法，将执行权再交还给 generator 函数。\n\n这种方法就是 thunk 函数，因为它可以在回调函数里，将执行权交还给 generator 函数。为了便于理解，我们先看如何手动执行上面这个 generator 函数。\n\nvar g = gen();\n\nvar r1 = g.next();\nr1.value(function (err, data) {\n  if (err) throw err;\n  var r2 = g.next(data);\n  r2.value(function (err, data) {\n    if (err) throw err;\n    g.next(data);\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，变量g是 generator 函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。\n\n仔细查看上面的代码，可以发现 generator 函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。\n\n\n# thunk 函数的自动流程管理\n\nthunk 函数真正的威力，在于可以自动执行 generator 函数。下面就是一个基于 thunk 函数的 generator 执行器。\n\nfunction run(fn) {\n  var gen = fn();\n\n  function next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value(next);\n  }\n\n  next();\n}\n\nfunction* g() {\n  // ...\n}\n\nrun(g);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码的run函数，就是一个 generator 函数的自动执行器。内部的next函数就是 thunk 的回调函数。next函数先将指针移到 generator 函数的下一步（gen.next方法），然后判断 generator 函数是否结束（result.done属性），如果没结束，就将next函数再传入 thunk 函数（result.value属性），否则就直接退出。\n\n有了这个执行器，执行 generator 函数方便多了。不管内部有多少个异步操作，直接把 generator 函数传入run函数即可。当然，前提是每一个异步操作，都要是 thunk 函数，也就是说，跟在yield命令后面的必须是 thunk 函数。\n\nvar g = function* (){\n  var f1 = yield readfilethunk('filea');\n  var f2 = yield readfilethunk('fileb');\n  // ...\n  var fn = yield readfilethunk('filen');\n};\n\nrun(g);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，函数g封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。\n\nthunk 函数并不是 generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，promise 对象也可以做到这一点。\n\n\n# co 模块\n\n\n# 基本用法\n\nco 模块是著名程序员 tj holowaychuk 于 2013 年 6 月发布的一个小工具，用于 generator 函数的自动执行。\n\n下面是一个 generator 函数，用于依次读取两个文件。\n\nvar gen = function* () {\n  var f1 = yield readfile('/etc/fstab');\n  var f2 = yield readfile('/etc/shells');\n  console.log(f1.tostring());\n  console.log(f2.tostring());\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\nco 模块可以让你不用编写 generator 函数的执行器。\n\nvar co = require('co');\nco(gen);\n\n\n1\n2\n\n\n上面代码中，generator 函数只要传入co函数，就会自动执行。\n\nco函数返回一个promise对象，因此可以用then方法添加回调函数。\n\nco(gen).then(function (){\n  console.log('generator 函数执行完成');\n});\n\n\n1\n2\n3\n\n\n上面代码中，等到 generator 函数执行结束，就会输出一行提示。\n\n\n# co 模块的原理\n\n为什么 co 可以自动执行 generator 函数？\n\n前面说过，generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。\n\n两种方法可以做到这一点。\n\n（1）回调函数。将异步操作包装成 thunk 函数，在回调函数里面交回执行权。\n\n（2）promise 对象。将异步操作包装成 promise 对象，用then方法交回执行权。\n\nco 模块其实就是将两种自动执行器（thunk 函数和 promise 对象），包装成一个模块。使用 co 的前提条件是，generator 函数的yield命令后面，只能是 thunk 函数或 promise 对象。如果数组或对象的成员，全部都是 promise 对象，也可以使用 co，详见后文的例子。\n\n上一节已经介绍了基于 thunk 函数的自动执行器。下面来看，基于 promise 对象的自动执行器。这是理解 co 模块必须的。\n\n\n# 基于 promise 对象的自动执行\n\n还是沿用上面的例子。首先，把fs模块的readfile方法包装成一个 promise 对象。\n\nvar fs = require('fs');\n\nvar readfile = function (filename){\n  return new promise(function (resolve, reject){\n    fs.readfile(filename, function(error, data){\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n\nvar gen = function* (){\n  var f1 = yield readfile('/etc/fstab');\n  var f2 = yield readfile('/etc/shells');\n  console.log(f1.tostring());\n  console.log(f2.tostring());\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n然后，手动执行上面的 generator 函数。\n\nvar g = gen();\n\ng.next().value.then(function(data){\n  g.next(data).value.then(function(data){\n    g.next(data);\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。\n\nfunction run(gen){\n  var g = gen();\n\n  function next(data){\n    var result = g.next(data);\n    if (result.done) return result.value;\n    result.value.then(function(data){\n      next(data);\n    });\n  }\n\n  next();\n}\n\nrun(gen);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，只要 generator 函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。\n\n\n# co 模块的源码\n\nco 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。\n\n首先，co 函数接受 generator 函数作为参数，返回一个 promise 对象。\n\nfunction co(gen) {\n  var ctx = this;\n\n  return new promise(function(resolve, reject) {\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在返回的 promise 对象里面，co 先检查参数gen是否为 generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 promise 对象的状态改为resolved。\n\nfunction co(gen) {\n  var ctx = this;\n\n  return new promise(function(resolve, reject) {\n    if (typeof gen === 'function') gen = gen.call(ctx);\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n接着，co 将 generator 函数的内部指针对象的next方法，包装成onfulfilled函数。这主要是为了能够捕捉抛出的错误。\n\nfunction co(gen) {\n  var ctx = this;\n\n  return new promise(function(resolve, reject) {\n    if (typeof gen === 'function') gen = gen.call(ctx);\n    if (!gen || typeof gen.next !== 'function') return resolve(gen);\n\n    onfulfilled();\n    function onfulfilled(res) {\n      var ret;\n      try {\n        ret = gen.next(res);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n最后，就是关键的next函数，它会反复调用自身。\n\nfunction next(ret) {\n  if (ret.done) return resolve(ret.value);\n  var value = topromise.call(ctx, ret.value);\n  if (value && ispromise(value)) return value.then(onfulfilled, onrejected);\n  return onrejected(\n    new typeerror(\n      'you may only yield a function, promise, generator, array, or object, '\n      + 'but the following object was passed: \"'\n      + string(ret.value)\n      + '\"'\n    )\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，next函数的内部代码，一共只有四行命令。\n\n第一行，检查当前是否为 generator 函数的最后一步，如果是就返回。\n\n第二行，确保每一步的返回值，是 promise 对象。\n\n第三行，使用then方法，为返回值加上回调函数，然后通过onfulfilled函数再次调用next函数。\n\n第四行，在参数不符合要求的情况下（参数非 thunk 函数和 promise 对象），将 promise 对象的状态改为rejected，从而终止执行。\n\n\n# 处理并发的异步操作\n\nco 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。\n\n这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。\n\n// 数组的写法\nco(function* () {\n  var res = yield [\n    promise.resolve(1),\n    promise.resolve(2)\n  ];\n  console.log(res);\n}).catch(onerror);\n\n// 对象的写法\nco(function* () {\n  var res = yield {\n    1: promise.resolve(1),\n    2: promise.resolve(2),\n  };\n  console.log(res);\n}).catch(onerror);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n下面是另一个例子。\n\nco(function* () {\n  var values = [n1, n2, n3];\n  yield values.map(somethingasync);\n});\n\nfunction* somethingasync(x) {\n  // do something async\n  return y\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的代码允许并发三个somethingasync异步操作，等到它们全部完成，才会进行下一步。\n\n\n# 实例：处理 stream\n\nnode 提供 stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。stream 模式使用 eventemitter api，会释放三个事件。\n\n * data事件：下一块数据块已经准备好了。\n * end事件：整个“数据流”处理完了。\n * error事件：发生错误。\n\n使用promise.race()函数，可以判断这三个事件之中哪一个最先发生，只有当data事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个while循环，完成所有数据的读取。\n\nconst co = require('co');\nconst fs = require('fs');\n\nconst stream = fs.createreadstream('./les_miserables.txt');\nlet valjeancount = 0;\n\nco(function*() {\n  while(true) {\n    const res = yield promise.race([\n      new promise(resolve => stream.once('data', resolve)),\n      new promise(resolve => stream.once('end', resolve)),\n      new promise((resolve, reject) => stream.once('error', reject))\n    ]);\n    if (!res) {\n      break;\n    }\n    stream.removealllisteners('data');\n    stream.removealllisteners('end');\n    stream.removealllisteners('error');\n    valjeancount += (res.tostring().match(/valjean/ig) || []).length;\n  }\n  console.log('count:', valjeancount); // count: 1120\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n上面代码采用 stream 模式读取《悲惨世界》的文本文件，对于每个数据块都使用stream.once方法，在data、end、error三个事件上添加一次性回调函数。变量res只有在data事件发生时才有值，然后累加每个数据块之中valjean这个词出现的次数。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Reflect",frontmatter:{title:"Reflect",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/74de3e45e4491e95",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/15.Reflect.html",relativePath:"《ES6 教程》笔记/15.Reflect.md",key:"v-f6e3cecc",path:"/pages/74de3e45e4491e95/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:14},{level:2,title:"静态方法",slug:"静态方法",normalizedTitle:"静态方法",charIndex:2044},{level:3,title:"Reflect.get(target, name, receiver)",slug:"reflect-get-target-name-receiver",normalizedTitle:"reflect.get(target, name, receiver)",charIndex:2152},{level:3,title:"Reflect.set(target, name, value, receiver)",slug:"reflect-set-target-name-value-receiver",normalizedTitle:"reflect.set(target, name, value, receiver)",charIndex:1097},{level:3,title:"Reflect.has(obj, name)",slug:"reflect-has-obj-name",normalizedTitle:"reflect.has(obj, name)",charIndex:695},{level:3,title:"Reflect.deleteProperty(obj, name)",slug:"reflect-deleteproperty-obj-name",normalizedTitle:"reflect.deleteproperty(obj, name)",charIndex:718},{level:3,title:"Reflect.construct(target, args)",slug:"reflect-construct-target-args",normalizedTitle:"reflect.construct(target, args)",charIndex:2117},{level:3,title:"Reflect.getPrototypeOf(obj)",slug:"reflect-getprototypeof-obj",normalizedTitle:"reflect.getprototypeof(obj)",charIndex:6109},{level:3,title:"Reflect.setPrototypeOf(obj, newProto)",slug:"reflect-setprototypeof-obj-newproto",normalizedTitle:"reflect.setprototypeof(obj, newproto)",charIndex:6618},{level:3,title:"Reflect.apply(func, thisArg, args)",slug:"reflect-apply-func-thisarg-args",normalizedTitle:"reflect.apply(func, thisarg, args)",charIndex:7595},{level:3,title:"Reflect.defineProperty(target, propertyKey, attributes)",slug:"reflect-defineproperty-target-propertykey-attributes",normalizedTitle:"reflect.defineproperty(target, propertykey, attributes)",charIndex:8263},{level:3,title:"Reflect.getOwnPropertyDescriptor(target, propertyKey)",slug:"reflect-getownpropertydescriptor-target-propertykey",normalizedTitle:"reflect.getownpropertydescriptor(target, propertykey)",charIndex:9137},{level:3,title:"Reflect.isExtensible (target)",slug:"reflect-isextensible-target",normalizedTitle:"reflect.isextensible (target)",charIndex:9781},{level:3,title:"Reflect.preventExtensions(target)",slug:"reflect-preventextensions-target",normalizedTitle:"reflect.preventextensions(target)",charIndex:2411},{level:3,title:"Reflect.ownKeys (target)",slug:"reflect-ownkeys-target",normalizedTitle:"reflect.ownkeys (target)",charIndex:10676},{level:2,title:"实例：使用 Proxy 实现观察者模式",slug:"实例-使用-proxy-实现观察者模式",normalizedTitle:"实例：使用 proxy 实现观察者模式",charIndex:11188}],excerpt:'<h1 id="reflect"><a class="header-anchor" href="#reflect">#</a> Reflect</h1>\n<h2 id="概述"><a class="header-anchor" href="#概述">#</a> 概述</h2>\n<p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>\n<p>（1） **将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。**现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>\n',headersStr:"概述 静态方法 Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.has(obj, name) Reflect.deleteProperty(obj, name) Reflect.construct(target, args) Reflect.getPrototypeOf(obj) Reflect.setPrototypeOf(obj, newProto) Reflect.apply(func, thisArg, args) Reflect.defineProperty(target, propertyKey, attributes) Reflect.getOwnPropertyDescriptor(target, propertyKey) Reflect.isExtensible (target) Reflect.preventExtensions(target) Reflect.ownKeys (target) 实例：使用 Proxy 实现观察者模式",content:"# Reflect\n\n\n# 概述\n\nReflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。\n\n（1） **将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。**现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 （2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。\n\n// 老写法\ntry {\n  Object.defineProperty(target, property, attributes);\n  // success\n} catch (e) {\n  // failure\n}\n\n// 新写法\nif (Reflect.defineProperty(target, property, attributes)) {\n  // success\n} else {\n  // failure\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n（3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。\n\n// 老写法\n'assign' in Object // true\n\n// 新写法\nReflect.has(Object, 'assign') // true\n\n\n1\n2\n3\n4\n5\n\n\n（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。\n\nProxy(target, {\n  set: function(target, name, value, receiver) {\n    var success = Reflect.set(target, name, value, receiver);\n    if (success) {\n      console.log('property ' + name + ' on ' + target + ' set to ' + value);\n    }\n    return success;\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。\n\n下面是另一个例子。\n\nvar loggedObj = new Proxy(obj, {\n  get(target, name) {\n    console.log('get', target, name);\n    return Reflect.get(target, name);\n  },\n  deleteProperty(target, name) {\n    console.log('delete' + name);\n    return Reflect.deleteProperty(target, name);\n  },\n  has(target, name) {\n    console.log('has' + name);\n    return Reflect.has(target, name);\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。\n\n有了Reflect对象以后，很多操作会更易读。\n\n// 老写法\nFunction.prototype.apply.call(Math.floor, undefined, [1.75]) // 1\n\n// 新写法\nReflect.apply(Math.floor, undefined, [1.75]) // 1\n\n\n1\n2\n3\n4\n5\n\n\n\n# 静态方法\n\nReflect对象一共有 13 个静态方法。\n\n * Reflect.apply(target, thisArg, args)\n * Reflect.construct(target, args)\n * Reflect.get(target, name, receiver)\n * Reflect.set(target, name, value, receiver)\n * Reflect.defineProperty(target, name, desc)\n * Reflect.deleteProperty(target, name)\n * Reflect.has(target, name)\n * Reflect.ownKeys(target)\n * Reflect.isExtensible(target)\n * Reflect.preventExtensions(target)\n * Reflect.getOwnPropertyDescriptor(target, name)\n * Reflect.getPrototypeOf(target)\n * Reflect.setPrototypeOf(target, prototype)\n\n上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。\n\n\n# Reflect.get(target, name, receiver)\n\nReflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。\n\nvar myObject = {\n  foo: 1,\n  bar: 2,\n  get baz() {\n    return this.foo + this.bar;\n  },\n}\n\nReflect.get(myObject, 'foo') // 1\nReflect.get(myObject, 'bar') // 2\nReflect.get(myObject, 'baz') // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。\n\nvar myObject = {\n  foo: 1,\n  bar: 2,\n  get baz() {\n    return this.foo + this.bar;\n  },\n};\n\nvar myReceiverObject = {\n  foo: 4,\n  bar: 4,\n};\n\nReflect.get(myObject, 'baz', myReceiverObject) // 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果第一个参数不是对象，Reflect.get方法会报错。\n\nReflect.get(1, 'foo') // 报错\nReflect.get(false, 'foo') // 报错\n\n\n1\n2\n\n\n\n# Reflect.set(target, name, value, receiver)\n\nReflect.set方法设置target对象的name属性等于value。\n\nvar myObject = {\n  foo: 1,\n  set bar(value) {\n    return this.foo = value;\n  },\n}\n\nmyObject.foo // 1\n\nReflect.set(myObject, 'foo', 2);\nmyObject.foo // 2\n\nReflect.set(myObject, 'bar', 3)\nmyObject.foo // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果name属性设置了赋值函数，则赋值函数的this绑定receiver。\n\nvar myObject = {\n  foo: 4,\n  set bar(value) {\n    return this.foo = value;\n  },\n};\n\nvar myReceiverObject = {\n  foo: 0,\n};\n\nReflect.set(myObject, 'bar', 1, myReceiverObject);\nmyObject.foo // 4\nmyReceiverObject.foo // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n注意，如果 Proxy对象和 Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了receiver，那么Reflect.set会触发Proxy.defineProperty拦截。\n\nlet p = {\n  a: 'a'\n};\n\nlet handler = {\n  set(target, key, value, receiver) {\n    console.log('set');\n    Reflect.set(target, key, value, receiver)\n  },\n  defineProperty(target, key, attribute) {\n    console.log('defineProperty');\n    Reflect.defineProperty(target, key, attribute);\n  }\n};\n\nlet obj = new Proxy(p, handler);\nobj.a = 'A';\n// set\n// defineProperty\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，Proxy.set拦截里面使用了Reflect.set，而且传入了receiver，导致触发Proxy.defineProperty拦截。这是因为Proxy.set的receiver参数总是指向当前的 Proxy实例（即上例的obj），而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。如果Reflect.set没有传入receiver，那么就不会触发defineProperty拦截。\n\nlet p = {\n  a: 'a'\n};\n\nlet handler = {\n  set(target, key, value, receiver) {\n    console.log('set');\n    Reflect.set(target, key, value)\n  },\n  defineProperty(target, key, attribute) {\n    console.log('defineProperty');\n    Reflect.defineProperty(target, key, attribute);\n  }\n};\n\nlet obj = new Proxy(p, handler);\nobj.a = 'A';\n// set\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n如果第一个参数不是对象，Reflect.set会报错。\n\nReflect.set(1, 'foo', {}) // 报错\nReflect.set(false, 'foo', {}) // 报错\n\n\n1\n2\n\n\n\n# Reflect.has(obj, name)\n\nReflect.has方法对应name in obj里面的in运算符。\n\nvar myObject = {\n  foo: 1,\n};\n\n// 旧写法\n'foo' in myObject // true\n\n// 新写法\nReflect.has(myObject, 'foo') // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果Reflect.has()方法的第一个参数不是对象，会报错。\n\n\n# Reflect.deleteProperty(obj, name)\n\nReflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。\n\nconst myObj = { foo: 'bar' };\n\n// 旧写法\ndelete myObj.foo;\n\n// 新写法\nReflect.deleteProperty(myObj, 'foo');\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。\n\n如果Reflect.deleteProperty()方法的第一个参数不是对象，会报错。\n\n\n# Reflect.construct(target, args)\n\nReflect.construct方法等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。\n\nfunction Greeting(name) {\n  this.name = name;\n}\n\n// new 的写法\nconst instance = new Greeting('张三');\n\n// Reflect.construct 的写法\nconst instance = Reflect.construct(Greeting, ['张三']);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果Reflect.construct()方法的第一个参数不是函数，会报错。\n\n\n# Reflect.getPrototypeOf(obj)\n\nReflect.getPrototypeOf方法用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。\n\nconst myObj = new FancyThing();\n\n// 旧写法\nObject.getPrototypeOf(myObj) === FancyThing.prototype;\n\n// 新写法\nReflect.getPrototypeOf(myObj) === FancyThing.prototype;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nReflect.getPrototypeOf和Object.getPrototypeOf的一个区别是，如果参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。\n\nObject.getPrototypeOf(1) // Number {[[PrimitiveValue]]: 0}\nReflect.getPrototypeOf(1) // 报错\n\n\n1\n2\n\n\n\n# Reflect.setPrototypeOf(obj, newProto)\n\nReflect.setPrototypeOf方法用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。\n\nconst myObj = {};\n\n// 旧写法\nObject.setPrototypeOf(myObj, Array.prototype);\n\n// 新写法\nReflect.setPrototypeOf(myObj, Array.prototype);\n\nmyObj.length // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果无法设置目标对象的原型（比如，目标对象禁止扩展），Reflect.setPrototypeOf方法返回false。\n\nReflect.setPrototypeOf({}, null)\n// true\nReflect.setPrototypeOf(Object.freeze({}), null)\n// false\n\n\n1\n2\n3\n4\n\n\n如果第一个参数不是对象，Object.setPrototypeOf会返回第一个参数本身，而Reflect.setPrototypeOf会报错。\n\nObject.setPrototypeOf(1, {})\n// 1\n\nReflect.setPrototypeOf(1, {})\n// TypeError: Reflect.setPrototypeOf called on non-object\n\n\n1\n2\n3\n4\n5\n\n\n如果第一个参数是undefined或null，Object.setPrototypeOf和Reflect.setPrototypeOf都会报错。\n\nObject.setPrototypeOf(null, {})\n// TypeError: Object.setPrototypeOf called on null or undefined\n\nReflect.setPrototypeOf(null, {})\n// TypeError: Reflect.setPrototypeOf called on non-object\n\n\n1\n2\n3\n4\n5\n\n\n\n# Reflect.apply(func, thisArg, args)\n\nReflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。\n\n一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。\n\nconst ages = [11, 33, 12, 54, 18, 96];\n\n// 旧写法\nconst youngest = Math.min.apply(Math, ages);\nconst oldest = Math.max.apply(Math, ages);\nconst type = Object.prototype.toString.call(youngest);\n\n// 新写法\nconst youngest = Reflect.apply(Math.min, Math, ages);\nconst oldest = Reflect.apply(Math.max, Math, ages);\nconst type = Reflect.apply(Object.prototype.toString, youngest, []);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Reflect.defineProperty(target, propertyKey, attributes)\n\nReflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。\n\nfunction MyDate() {\n  /*…*/\n}\n\n// 旧写法\nObject.defineProperty(MyDate, 'now', {\n  value: () => Date.now()\n});\n\n// 新写法\nReflect.defineProperty(MyDate, 'now', {\n  value: () => Date.now()\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果Reflect.defineProperty的第一个参数不是对象，就会抛出错误，比如Reflect.defineProperty(1, 'foo')。\n\n这个方法可以与Proxy.defineProperty配合使用。\n\nconst p = new Proxy({}, {\n  defineProperty(target, prop, descriptor) {\n    console.log(descriptor);\n    return Reflect.defineProperty(target, prop, descriptor);\n  }\n});\n\np.foo = 'bar';\n// {value: \"bar\", writable: true, enumerable: true, configurable: true}\n\np.foo // \"bar\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，Proxy.defineProperty对属性赋值设置了拦截，然后使用Reflect.defineProperty完成了赋值。\n\n\n# Reflect.getOwnPropertyDescriptor(target, propertyKey)\n\nReflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。\n\nvar myObject = {};\nObject.defineProperty(myObject, 'hidden', {\n  value: true,\n  enumerable: false,\n});\n\n// 旧写法\nvar theDescriptor = Object.getOwnPropertyDescriptor(myObject, 'hidden');\n\n// 新写法\nvar theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, 'hidden');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nReflect.getOwnPropertyDescriptor和Object.getOwnPropertyDescriptor的一个区别是，如果第一个参数不是对象，Object.getOwnPropertyDescriptor(1, 'foo')不报错，返回undefined，而Reflect.getOwnPropertyDescriptor(1, 'foo')会抛出错误，表示参数非法。\n\n\n# Reflect.isExtensible (target)\n\nReflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。\n\nconst myObject = {};\n\n// 旧写法\nObject.isExtensible(myObject) // true\n\n// 新写法\nReflect.isExtensible(myObject) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果参数不是对象，Object.isExtensible会返回false，因为非对象本来就是不可扩展的，而Reflect.isExtensible会报错。\n\nObject.isExtensible(1) // false\nReflect.isExtensible(1) // 报错\n\n\n1\n2\n\n\n\n# Reflect.preventExtensions(target)\n\nReflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。\n\nvar myObject = {};\n\n// 旧写法\nObject.preventExtensions(myObject) // Object {}\n\n// 新写法\nReflect.preventExtensions(myObject) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果参数不是对象，Object.preventExtensions在 ES5 环境报错，在 ES6 环境返回传入的参数，而Reflect.preventExtensions会报错。\n\n// ES5 环境\nObject.preventExtensions(1) // 报错\n\n// ES6 环境\nObject.preventExtensions(1) // 1\n\n// 新写法\nReflect.preventExtensions(1) // 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Reflect.ownKeys (target)\n\nReflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。\n\nvar myObject = {\n  foo: 1,\n  bar: 2,\n  [Symbol.for('baz')]: 3,\n  [Symbol.for('bing')]: 4,\n};\n\n// 旧写法\nObject.getOwnPropertyNames(myObject)\n// ['foo', 'bar']\n\nObject.getOwnPropertySymbols(myObject)\n//[Symbol(baz), Symbol(bing)]\n\n// 新写法\nReflect.ownKeys(myObject)\n// ['foo', 'bar', Symbol(baz), Symbol(bing)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果Reflect.ownKeys()方法的第一个参数不是对象，会报错。\n\n\n# 实例：使用 Proxy 实现观察者模式\n\n观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。\n\nconst person = observable({\n  name: '张三',\n  age: 20\n}); // 观察目标\n\nfunction print() {\n  console.log(`${person.name}, ${person.age}`)\n} // 观察者\n\nobserve(print); // 启动观察\nperson.name = '李四';\n// 输出\n// 李四, 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，数据对象person是观察目标，函数print是观察者。一旦数据对象发生变化，print就会自动执行。\n\n下面，使用 Proxy 写一个观察者模式的最简单实现，即实现observable和observe这两个函数。思路是observable函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。\n\nconst queuedObservers = new Set();\n\nconst observe = fn => queuedObservers.add(fn);\nconst observable = obj => new Proxy(obj, {set});\n\nfunction set(target, key, value, receiver) {\n  const result = Reflect.set(target, key, value, receiver);\n  queuedObservers.forEach(observer => observer());\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，先定义了一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。",normalizedContent:"# reflect\n\n\n# 概述\n\nreflect对象与proxy对象一样，也是 es6 为了操作对象而提供的新 api。reflect对象的设计目的有这样几个。\n\n（1） **将object对象的一些明显属于语言内部的方法（比如object.defineproperty），放到reflect对象上。**现阶段，某些方法同时在object和reflect对象上部署，未来的新方法将只部署在reflect对象上。也就是说，从reflect对象上可以拿到语言内部的方法。 （2） 修改某些object方法的返回结果，让其变得更合理。比如，object.defineproperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而reflect.defineproperty(obj, name, desc)则会返回false。\n\n// 老写法\ntry {\n  object.defineproperty(target, property, attributes);\n  // success\n} catch (e) {\n  // failure\n}\n\n// 新写法\nif (reflect.defineproperty(target, property, attributes)) {\n  // success\n} else {\n  // failure\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n（3） 让object操作都变成函数行为。某些object操作是命令式，比如name in obj和delete obj[name]，而reflect.has(obj, name)和reflect.deleteproperty(obj, name)让它们变成了函数行为。\n\n// 老写法\n'assign' in object // true\n\n// 新写法\nreflect.has(object, 'assign') // true\n\n\n1\n2\n3\n4\n5\n\n\n（4）reflect对象的方法与proxy对象的方法一一对应，只要是proxy对象的方法，就能在reflect对象上找到对应的方法。这就让proxy对象可以方便地调用对应的reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管proxy怎么修改默认行为，你总可以在reflect上获取默认行为。\n\nproxy(target, {\n  set: function(target, name, value, receiver) {\n    var success = reflect.set(target, name, value, receiver);\n    if (success) {\n      console.log('property ' + name + ' on ' + target + ' set to ' + value);\n    }\n    return success;\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，proxy方法拦截target对象的属性赋值行为。它采用reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。\n\n下面是另一个例子。\n\nvar loggedobj = new proxy(obj, {\n  get(target, name) {\n    console.log('get', target, name);\n    return reflect.get(target, name);\n  },\n  deleteproperty(target, name) {\n    console.log('delete' + name);\n    return reflect.deleteproperty(target, name);\n  },\n  has(target, name) {\n    console.log('has' + name);\n    return reflect.has(target, name);\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，每一个proxy对象的拦截操作（get、delete、has），内部都调用对应的reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。\n\n有了reflect对象以后，很多操作会更易读。\n\n// 老写法\nfunction.prototype.apply.call(math.floor, undefined, [1.75]) // 1\n\n// 新写法\nreflect.apply(math.floor, undefined, [1.75]) // 1\n\n\n1\n2\n3\n4\n5\n\n\n\n# 静态方法\n\nreflect对象一共有 13 个静态方法。\n\n * reflect.apply(target, thisarg, args)\n * reflect.construct(target, args)\n * reflect.get(target, name, receiver)\n * reflect.set(target, name, value, receiver)\n * reflect.defineproperty(target, name, desc)\n * reflect.deleteproperty(target, name)\n * reflect.has(target, name)\n * reflect.ownkeys(target)\n * reflect.isextensible(target)\n * reflect.preventextensions(target)\n * reflect.getownpropertydescriptor(target, name)\n * reflect.getprototypeof(target)\n * reflect.setprototypeof(target, prototype)\n\n上面这些方法的作用，大部分与object对象的同名方法的作用都是相同的，而且它与proxy对象的方法是一一对应的。下面是对它们的解释。\n\n\n# reflect.get(target, name, receiver)\n\nreflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。\n\nvar myobject = {\n  foo: 1,\n  bar: 2,\n  get baz() {\n    return this.foo + this.bar;\n  },\n}\n\nreflect.get(myobject, 'foo') // 1\nreflect.get(myobject, 'bar') // 2\nreflect.get(myobject, 'baz') // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。\n\nvar myobject = {\n  foo: 1,\n  bar: 2,\n  get baz() {\n    return this.foo + this.bar;\n  },\n};\n\nvar myreceiverobject = {\n  foo: 4,\n  bar: 4,\n};\n\nreflect.get(myobject, 'baz', myreceiverobject) // 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果第一个参数不是对象，reflect.get方法会报错。\n\nreflect.get(1, 'foo') // 报错\nreflect.get(false, 'foo') // 报错\n\n\n1\n2\n\n\n\n# reflect.set(target, name, value, receiver)\n\nreflect.set方法设置target对象的name属性等于value。\n\nvar myobject = {\n  foo: 1,\n  set bar(value) {\n    return this.foo = value;\n  },\n}\n\nmyobject.foo // 1\n\nreflect.set(myobject, 'foo', 2);\nmyobject.foo // 2\n\nreflect.set(myobject, 'bar', 3)\nmyobject.foo // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果name属性设置了赋值函数，则赋值函数的this绑定receiver。\n\nvar myobject = {\n  foo: 4,\n  set bar(value) {\n    return this.foo = value;\n  },\n};\n\nvar myreceiverobject = {\n  foo: 0,\n};\n\nreflect.set(myobject, 'bar', 1, myreceiverobject);\nmyobject.foo // 4\nmyreceiverobject.foo // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n注意，如果 proxy对象和 reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了receiver，那么reflect.set会触发proxy.defineproperty拦截。\n\nlet p = {\n  a: 'a'\n};\n\nlet handler = {\n  set(target, key, value, receiver) {\n    console.log('set');\n    reflect.set(target, key, value, receiver)\n  },\n  defineproperty(target, key, attribute) {\n    console.log('defineproperty');\n    reflect.defineproperty(target, key, attribute);\n  }\n};\n\nlet obj = new proxy(p, handler);\nobj.a = 'a';\n// set\n// defineproperty\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，proxy.set拦截里面使用了reflect.set，而且传入了receiver，导致触发proxy.defineproperty拦截。这是因为proxy.set的receiver参数总是指向当前的 proxy实例（即上例的obj），而reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineproperty拦截。如果reflect.set没有传入receiver，那么就不会触发defineproperty拦截。\n\nlet p = {\n  a: 'a'\n};\n\nlet handler = {\n  set(target, key, value, receiver) {\n    console.log('set');\n    reflect.set(target, key, value)\n  },\n  defineproperty(target, key, attribute) {\n    console.log('defineproperty');\n    reflect.defineproperty(target, key, attribute);\n  }\n};\n\nlet obj = new proxy(p, handler);\nobj.a = 'a';\n// set\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n如果第一个参数不是对象，reflect.set会报错。\n\nreflect.set(1, 'foo', {}) // 报错\nreflect.set(false, 'foo', {}) // 报错\n\n\n1\n2\n\n\n\n# reflect.has(obj, name)\n\nreflect.has方法对应name in obj里面的in运算符。\n\nvar myobject = {\n  foo: 1,\n};\n\n// 旧写法\n'foo' in myobject // true\n\n// 新写法\nreflect.has(myobject, 'foo') // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果reflect.has()方法的第一个参数不是对象，会报错。\n\n\n# reflect.deleteproperty(obj, name)\n\nreflect.deleteproperty方法等同于delete obj[name]，用于删除对象的属性。\n\nconst myobj = { foo: 'bar' };\n\n// 旧写法\ndelete myobj.foo;\n\n// 新写法\nreflect.deleteproperty(myobj, 'foo');\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。\n\n如果reflect.deleteproperty()方法的第一个参数不是对象，会报错。\n\n\n# reflect.construct(target, args)\n\nreflect.construct方法等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。\n\nfunction greeting(name) {\n  this.name = name;\n}\n\n// new 的写法\nconst instance = new greeting('张三');\n\n// reflect.construct 的写法\nconst instance = reflect.construct(greeting, ['张三']);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果reflect.construct()方法的第一个参数不是函数，会报错。\n\n\n# reflect.getprototypeof(obj)\n\nreflect.getprototypeof方法用于读取对象的__proto__属性，对应object.getprototypeof(obj)。\n\nconst myobj = new fancything();\n\n// 旧写法\nobject.getprototypeof(myobj) === fancything.prototype;\n\n// 新写法\nreflect.getprototypeof(myobj) === fancything.prototype;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nreflect.getprototypeof和object.getprototypeof的一个区别是，如果参数不是对象，object.getprototypeof会将这个参数转为对象，然后再运行，而reflect.getprototypeof会报错。\n\nobject.getprototypeof(1) // number {[[primitivevalue]]: 0}\nreflect.getprototypeof(1) // 报错\n\n\n1\n2\n\n\n\n# reflect.setprototypeof(obj, newproto)\n\nreflect.setprototypeof方法用于设置目标对象的原型（prototype），对应object.setprototypeof(obj, newproto)方法。它返回一个布尔值，表示是否设置成功。\n\nconst myobj = {};\n\n// 旧写法\nobject.setprototypeof(myobj, array.prototype);\n\n// 新写法\nreflect.setprototypeof(myobj, array.prototype);\n\nmyobj.length // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果无法设置目标对象的原型（比如，目标对象禁止扩展），reflect.setprototypeof方法返回false。\n\nreflect.setprototypeof({}, null)\n// true\nreflect.setprototypeof(object.freeze({}), null)\n// false\n\n\n1\n2\n3\n4\n\n\n如果第一个参数不是对象，object.setprototypeof会返回第一个参数本身，而reflect.setprototypeof会报错。\n\nobject.setprototypeof(1, {})\n// 1\n\nreflect.setprototypeof(1, {})\n// typeerror: reflect.setprototypeof called on non-object\n\n\n1\n2\n3\n4\n5\n\n\n如果第一个参数是undefined或null，object.setprototypeof和reflect.setprototypeof都会报错。\n\nobject.setprototypeof(null, {})\n// typeerror: object.setprototypeof called on null or undefined\n\nreflect.setprototypeof(null, {})\n// typeerror: reflect.setprototypeof called on non-object\n\n\n1\n2\n3\n4\n5\n\n\n\n# reflect.apply(func, thisarg, args)\n\nreflect.apply方法等同于function.prototype.apply.call(func, thisarg, args)，用于绑定this对象后执行给定函数。\n\n一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成function.prototype.apply.call(fn, obj, args)，采用reflect对象可以简化这种操作。\n\nconst ages = [11, 33, 12, 54, 18, 96];\n\n// 旧写法\nconst youngest = math.min.apply(math, ages);\nconst oldest = math.max.apply(math, ages);\nconst type = object.prototype.tostring.call(youngest);\n\n// 新写法\nconst youngest = reflect.apply(math.min, math, ages);\nconst oldest = reflect.apply(math.max, math, ages);\nconst type = reflect.apply(object.prototype.tostring, youngest, []);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# reflect.defineproperty(target, propertykey, attributes)\n\nreflect.defineproperty方法基本等同于object.defineproperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用reflect.defineproperty代替它。\n\nfunction mydate() {\n  /*…*/\n}\n\n// 旧写法\nobject.defineproperty(mydate, 'now', {\n  value: () => date.now()\n});\n\n// 新写法\nreflect.defineproperty(mydate, 'now', {\n  value: () => date.now()\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果reflect.defineproperty的第一个参数不是对象，就会抛出错误，比如reflect.defineproperty(1, 'foo')。\n\n这个方法可以与proxy.defineproperty配合使用。\n\nconst p = new proxy({}, {\n  defineproperty(target, prop, descriptor) {\n    console.log(descriptor);\n    return reflect.defineproperty(target, prop, descriptor);\n  }\n});\n\np.foo = 'bar';\n// {value: \"bar\", writable: true, enumerable: true, configurable: true}\n\np.foo // \"bar\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，proxy.defineproperty对属性赋值设置了拦截，然后使用reflect.defineproperty完成了赋值。\n\n\n# reflect.getownpropertydescriptor(target, propertykey)\n\nreflect.getownpropertydescriptor基本等同于object.getownpropertydescriptor，用于得到指定属性的描述对象，将来会替代掉后者。\n\nvar myobject = {};\nobject.defineproperty(myobject, 'hidden', {\n  value: true,\n  enumerable: false,\n});\n\n// 旧写法\nvar thedescriptor = object.getownpropertydescriptor(myobject, 'hidden');\n\n// 新写法\nvar thedescriptor = reflect.getownpropertydescriptor(myobject, 'hidden');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nreflect.getownpropertydescriptor和object.getownpropertydescriptor的一个区别是，如果第一个参数不是对象，object.getownpropertydescriptor(1, 'foo')不报错，返回undefined，而reflect.getownpropertydescriptor(1, 'foo')会抛出错误，表示参数非法。\n\n\n# reflect.isextensible (target)\n\nreflect.isextensible方法对应object.isextensible，返回一个布尔值，表示当前对象是否可扩展。\n\nconst myobject = {};\n\n// 旧写法\nobject.isextensible(myobject) // true\n\n// 新写法\nreflect.isextensible(myobject) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果参数不是对象，object.isextensible会返回false，因为非对象本来就是不可扩展的，而reflect.isextensible会报错。\n\nobject.isextensible(1) // false\nreflect.isextensible(1) // 报错\n\n\n1\n2\n\n\n\n# reflect.preventextensions(target)\n\nreflect.preventextensions对应object.preventextensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。\n\nvar myobject = {};\n\n// 旧写法\nobject.preventextensions(myobject) // object {}\n\n// 新写法\nreflect.preventextensions(myobject) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果参数不是对象，object.preventextensions在 es5 环境报错，在 es6 环境返回传入的参数，而reflect.preventextensions会报错。\n\n// es5 环境\nobject.preventextensions(1) // 报错\n\n// es6 环境\nobject.preventextensions(1) // 1\n\n// 新写法\nreflect.preventextensions(1) // 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# reflect.ownkeys (target)\n\nreflect.ownkeys方法用于返回对象的所有属性，基本等同于object.getownpropertynames与object.getownpropertysymbols之和。\n\nvar myobject = {\n  foo: 1,\n  bar: 2,\n  [symbol.for('baz')]: 3,\n  [symbol.for('bing')]: 4,\n};\n\n// 旧写法\nobject.getownpropertynames(myobject)\n// ['foo', 'bar']\n\nobject.getownpropertysymbols(myobject)\n//[symbol(baz), symbol(bing)]\n\n// 新写法\nreflect.ownkeys(myobject)\n// ['foo', 'bar', symbol(baz), symbol(bing)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果reflect.ownkeys()方法的第一个参数不是对象，会报错。\n\n\n# 实例：使用 proxy 实现观察者模式\n\n观察者模式（observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。\n\nconst person = observable({\n  name: '张三',\n  age: 20\n}); // 观察目标\n\nfunction print() {\n  console.log(`${person.name}, ${person.age}`)\n} // 观察者\n\nobserve(print); // 启动观察\nperson.name = '李四';\n// 输出\n// 李四, 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，数据对象person是观察目标，函数print是观察者。一旦数据对象发生变化，print就会自动执行。\n\n下面，使用 proxy 写一个观察者模式的最简单实现，即实现observable和observe这两个函数。思路是observable函数返回一个原始对象的 proxy 代理，拦截赋值操作，触发充当观察者的各个函数。\n\nconst queuedobservers = new set();\n\nconst observe = fn => queuedobservers.add(fn);\nconst observable = obj => new proxy(obj, {set});\n\nfunction set(target, key, value, receiver) {\n  const result = reflect.set(target, key, value, receiver);\n  queuedobservers.foreach(observer => observer());\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，先定义了一个set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"async 函数",frontmatter:{title:"async 函数",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/3777253e65bac487",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/20.async%20%E5%87%BD%E6%95%B0.html",relativePath:"《ES6 教程》笔记/20.async 函数.md",key:"v-4685ff34",path:"/pages/3777253e65bac487/",headers:[{level:2,title:"含义",slug:"含义",normalizedTitle:"含义",charIndex:15},{level:2,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:1536},{level:2,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:89},{level:3,title:"返回 Promise 对象",slug:"返回-promise-对象",normalizedTitle:"返回 promise 对象",charIndex:3185},{level:3,title:"Promise 对象的状态变化",slug:"promise-对象的状态变化",normalizedTitle:"promise 对象的状态变化",charIndex:3633},{level:3,title:"await 命令",slug:"await-命令",normalizedTitle:"await 命令",charIndex:4153},{level:3,title:"错误处理",slug:"错误处理",normalizedTitle:"错误处理",charIndex:3173},{level:3,title:"使用注意点",slug:"使用注意点",normalizedTitle:"使用注意点",charIndex:7702},{level:2,title:"async 函数的实现原理",slug:"async-函数的实现原理",normalizedTitle:"async 函数的实现原理",charIndex:6727},{level:2,title:"与其他异步处理方法的比较",slug:"与其他异步处理方法的比较",normalizedTitle:"与其他异步处理方法的比较",charIndex:10914},{level:2,title:"实例：按顺序完成异步操作",slug:"实例-按顺序完成异步操作",normalizedTitle:"实例：按顺序完成异步操作",charIndex:12518},{level:2,title:"顶层 await",slug:"顶层-await",normalizedTitle:"顶层 await",charIndex:13770}],excerpt:'<h1 id="async-函数"><a class="header-anchor" href="#async-函数">#</a> async 函数</h1>\n<h2 id="含义"><a class="header-anchor" href="#含义">#</a> 含义</h2>\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\n<p>async 函数是什么？一句话，它就<strong>是 Generator 函数的语法糖</strong>。</p>\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\n',headersStr:"含义 基本用法 语法 返回 Promise 对象 Promise 对象的状态变化 await 命令 错误处理 使用注意点 async 函数的实现原理 与其他异步处理方法的比较 实例：按顺序完成异步操作 顶层 await",content:"# async 函数\n\n\n# 含义\n\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\n\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\n\n前文有一个 Generator 函数，依次读取两个文件。\n\nconst fs = require('fs');\n\nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n\nconst gen = function* () {\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码的函数gen可以写成async函数，就是下面这样。\n\nconst asyncReadFile = async function () {\n  const f1 = await readFile('/etc/fstab');\n  const f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\n\nasync函数对 Generator 函数的改进，体现在以下四点。\n\n（1）内置执行器。\n\nGenerator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。\n\nasyncReadFile();\n\n\n1\n\n\n上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。\n\n（2）更好的语义。\n\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n\n（3）更广的适用性。\n\nco模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。\n\n（4）返回值是 Promise。\n\nasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n\n进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\n\n# 基本用法\n\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n\n下面是一个例子。\n\nasync function getStockPriceByName(name) {\n  const symbol = await getStockSymbol(name);\n  const stockPrice = await getStockPrice(symbol);\n  return stockPrice;\n}\n\ngetStockPriceByName('goog').then(function (result) {\n  console.log(result);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。\n\n下面是另一个例子，指定多少毫秒后输出一个值。\n\nfunction timeout(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码指定 50 毫秒以后，输出hello world。\n\n由于async函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式。\n\nasync function timeout(ms) {\n  await new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nasync 函数有多种使用形式。\n\n// 函数声明\nasync function foo() {}\n\n// 函数表达式\nconst foo = async function () {};\n\n// 对象的方法\nlet obj = { async foo() {} };\nobj.foo().then(...)\n\n// Class 的方法\nclass Storage {\n  constructor() {\n    this.cachePromise = caches.open('avatars');\n  }\n\n  async getAvatar(name) {\n    const cache = await this.cachePromise;\n    return cache.match(`/avatars/${name}.jpg`);\n  }\n}\n\nconst storage = new Storage();\nstorage.getAvatar('jake').then(…);\n\n// 箭头函数\nconst foo = async () => {};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 语法\n\nasync函数的语法规则总体上比较简单，难点是错误处理机制。\n\n\n# 返回 Promise 对象\n\nasync函数返回一个 Promise 对象。\n\nasync函数内部return语句返回的值，会成为then方法回调函数的参数。\n\nasync function f() {\n  return 'hello world';\n}\n\nf().then(v => console.log(v))\n// \"hello world\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。\n\nasync函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。\n\nasync function f() {\n  throw new Error('出错了');\n}\n\nf().then(\n  v => console.log(v),\n  e => console.log(e)\n)\n// Error: 出错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Promise 对象的状态变化\n\nasync函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。\n\n下面是一个例子。\n\nasync function getTitle(url) {\n  let response = await fetch(url);\n  let html = await response.text();\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n}\ngetTitle('https://tc39.github.io/ecma262/').then(console.log)\n// \"ECMAScript 2017 Language Specification\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。\n\n\n# await 命令\n\n正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。\n\nasync function f() {\n  // 等同于\n  // return 123;\n  return await 123;\n}\n\nf().then(v => console.log(v))\n// 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，await命令的参数是数值123，这时等同于return 123。\n\n另一种情况是，await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象。\n\nclass Sleep {\n  constructor(timeout) {\n    this.timeout = timeout;\n  }\n  then(resolve, reject) {\n    const startTime = Date.now();\n    setTimeout(\n      () => resolve(Date.now() - startTime),\n      this.timeout\n    );\n  }\n}\n\n(async () => {\n  const sleepTime = await new Sleep(1000);\n  console.log(sleepTime);\n})();\n// 1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码中，await命令后面是一个Sleep对象的实例。这个实例不是 Promise 对象，但是因为定义了then方法，await会将其视为Promise处理。\n\n这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助await命令就可以让程序停顿指定的时间。下面给出了一个简化的sleep实现。\n\nfunction sleep(interval) {\n  return new Promise(resolve => {\n    setTimeout(resolve, interval);\n  })\n}\n\n// 用法\nasync function one2FiveInAsync() {\n  for(let i = 1; i <= 5; i++) {\n    console.log(i);\n    await sleep(1000);\n  }\n}\n\none2FiveInAsync();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nawait命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。\n\nasync function f() {\n  await Promise.reject('出错了');\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// 出错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。\n\n任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。\n\nasync function f() {\n  await Promise.reject('出错了');\n  await Promise.resolve('hello world'); // 不会执行\n}\n\n\n1\n2\n3\n4\n\n\n上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。\n\n有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。\n\nasync function f() {\n  try {\n    await Promise.reject('出错了');\n  } catch(e) {\n  }\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// hello world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。\n\nasync function f() {\n  await Promise.reject('出错了')\n    .catch(e => console.log(e));\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// 出错了\n// hello world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 错误处理\n\n如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。\n\nasync function f() {\n  await new Promise(function (resolve, reject) {\n    throw new Error('出错了');\n  });\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// Error：出错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。\n\n防止出错的方法，也是将其放在try...catch代码块之中。\n\nasync function f() {\n  try {\n    await new Promise(function (resolve, reject) {\n      throw new Error('出错了');\n    });\n  } catch(e) {\n  }\n  return await('hello world');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果有多个await命令，可以统一放在try...catch结构中。\n\nasync function main() {\n  try {\n    const val1 = await firstStep();\n    const val2 = await secondStep(val1);\n    const val3 = await thirdStep(val1, val2);\n\n    console.log('Final: ', val3);\n  }\n  catch (err) {\n    console.error(err);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n下面的例子使用try...catch结构，实现多次重复尝试。\n\nconst superagent = require('superagent');\nconst NUM_RETRIES = 3;\n\nasync function test() {\n  let i;\n  for (i = 0; i < NUM_RETRIES; ++i) {\n    try {\n      await superagent.get('http://google.com/this-throws-an-error');\n      break;\n    } catch(err) {}\n  }\n  console.log(i); // 3\n}\n\ntest();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，如果await操作成功，就会使用break语句退出循环；如果失败，会被catch语句捕捉，然后进入下一轮循环。\n\n\n# 使用注意点\n\n第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。\n\nasync function myFunction() {\n  try {\n    await somethingThatReturnsAPromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 另一种写法\n\nasync function myFunction() {\n  await somethingThatReturnsAPromise()\n  .catch(function (err) {\n    console.log(err);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发（并发）。\n\nlet foo = await getFoo();\nlet bar = await getBar();\n\n\n1\n2\n\n\n上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。\n\n// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。\n\n第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。\n\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 报错\n  docs.forEach(function (doc) {\n    await db.post(doc);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。\n\nfunction dbFuc(db) { //这里不需要 async\n  let docs = [{}, {}, {}];\n\n  // 可能得到错误结果\n  docs.forEach(async function (doc) {\n    await db.post(doc);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。\n\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。\n\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n\n// 或者使用下面的写法\n\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n第四点，async 函数可以保留运行堆栈。\n\nconst a = () => {\n  b().then(() => c());\n};\n\n\n1\n2\n3\n\n\n上面代码中，函数a内部运行了一个异步任务b()。当b()运行的时候，函数a()不会中断，而是继续执行。等到b()运行结束，可能a()早就运行结束了，b()所在的上下文环境已经消失了。如果b()或c()报错，错误堆栈将不包括a()。\n\n现在将这个例子改成async函数。\n\nconst a = async () => {\n  await b();\n  c();\n};\n\n\n1\n2\n3\n4\n\n\n上面代码中，b()运行的时候，a()是暂停执行，上下文环境都保存着。一旦b()或c()报错，错误堆栈将包括a()。\n\n\n# async 函数的实现原理\n\nasync 函数的实现原理**，就是将 Generator 函数和自动执行器，包装在一个函数里**。\n\nasync function fn(args) {\n  // ...\n}\n\n// 等同于\n\nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。\n\n下面给出spawn函数的实现，基本就是前文自动执行器的翻版。\n\nfunction spawn(genF) {\n  return new Promise(function(resolve, reject) {\n    const gen = genF();\n    function step(nextF) {\n      let next;\n      try {\n        next = nextF();\n      } catch(e) {\n        return reject(e);\n      }\n      if(next.done) {\n        return resolve(next.value);\n      }\n      Promise.resolve(next.value).then(function(v) {\n        step(function() { return gen.next(v); });\n      }, function(e) {\n        step(function() { return gen.throw(e); });\n      });\n    }\n    step(function() { return gen.next(undefined); });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 与其他异步处理方法的比较\n\n我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。\n\n假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。\n\n首先是 Promise 的写法。\n\nfunction chainAnimationsPromise(elem, animations) {\n\n  // 变量ret用来保存上一个动画的返回值\n  let ret = null;\n\n  // 新建一个空的Promise\n  let p = Promise.resolve();\n\n  // 使用then方法，添加所有动画\n  for(let anim of animations) {\n    p = p.then(function(val) {\n      ret = val;\n      return anim(elem);\n    });\n  }\n\n  // 返回一个部署了错误捕捉机制的Promise\n  return p.catch(function(e) {\n    /* 忽略错误，继续执行 */\n  }).then(function() {\n    return ret;\n  });\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch等等），操作本身的语义反而不容易看出来。\n\n接着是 Generator 函数的写法。\n\nfunction chainAnimationsGenerator(elem, animations) {\n\n  return spawn(function*() {\n    let ret = null;\n    try {\n      for(let anim of animations) {\n        ret = yield anim(elem);\n      }\n    } catch(e) {\n      /* 忽略错误，继续执行 */\n    }\n    return ret;\n  });\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的spawn函数就是自动执行器，它返回一个 Promise 对象，而且必须保证yield语句后面的表达式，必须返回一个 Promise。\n\n最后是 async 函数的写法。\n\nasync function chainAnimationsAsync(elem, animations) {\n  let ret = null;\n  try {\n    for(let anim of animations) {\n      ret = await anim(elem);\n    }\n  } catch(e) {\n    /* 忽略错误，继续执行 */\n  }\n  return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。\n\n\n# 实例：按顺序完成异步操作\n\n实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。\n\nPromise 的写法如下。\n\nfunction logInOrder(urls) {\n  // 远程读取所有URL\n  const textPromises = urls.map(url => {\n    return fetch(url).then(response => response.text());\n  });\n\n  // 按次序输出\n  textPromises.reduce((chain, textPromise) => {\n    return chain.then(() => textPromise)\n      .then(text => console.log(text));\n  }, Promise.resolve());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码使用fetch方法，同时远程读取一组 URL。每个fetch操作都返回一个 Promise 对象，放入textPromises数组。然后，reduce方法依次处理每个 Promise 对象，然后使用then，将所有 Promise 对象连起来，因此就可以依次输出结果。\n\n这种写法不太直观，可读性比较差。下面是 async 函数实现。\n\nasync function logInOrder(urls) {\n  for (const url of urls) {\n    const response = await fetch(url);\n    console.log(await response.text());\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。\n\nasync function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。\n\n\n# 顶层 await\n\n根据语法规格，await命令只能出现在 async 函数内部，否则都会报错。\n\n// 报错\nconst data = await fetch('https://api.example.com');\n\n\n1\n2\n\n\n上面代码中，await命令独立使用，没有放在 async 函数里面，就会报错。\n\n目前，有一个语法提案，允许在模块的顶层独立使用await命令。这个提案的目的，是借用await解决模块异步加载的问题。\n\n// awaiting.js\nlet output;\nasync function main() {\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n}\nmain();\nexport { output };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，模块awaiting.js的输出值output，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量output才会有值，否则就返回undefined。\n\n上面的代码也可以写成立即执行函数的形式。\n\n// awaiting.js\nlet output;\n(async function main() {\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n})();\nexport { output };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面是加载这个模块的写法。\n\n// usage.js\nimport { output } from \"./awaiting.js\";\n\nfunction outputPlusValue(value) { return output + value }\n\nconsole.log(outputPlusValue(100));\nsetTimeout(() => console.log(outputPlusValue(100), 1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，outputPlusValue()的执行结果，完全取决于执行的时间。如果awaiting.js里面的异步操作没执行完，加载进来的output的值就是undefined。\n\n目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。\n\n// awaiting.js\nlet output;\nexport default (async function main() {\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n})();\nexport { output };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，awaiting.js除了输出output，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。\n\n下面是加载这个模块的新的写法。\n\n// usage.js\nimport promise, { output } from \"./awaiting.js\";\n\nfunction outputPlusValue(value) { return output + value }\n\npromise.then(() => {\n  console.log(outputPlusValue(100));\n  setTimeout(() => console.log(outputPlusValue(100), 1000);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，将awaiting.js对象的输出，放在promise.then()里面，这样就能保证异步操作完成以后，才去读取output。\n\n这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的usage.js又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。\n\n顶层的await命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。\n\n// awaiting.js\nconst dynamic = import(someMission);\nconst data = fetch(url);\nexport const output = someProcess((await dynamic).default, await data);\n\n\n1\n2\n3\n4\n\n\n上面代码中，两个异步操作在输出的时候，都加上了await命令。只有等到异步操作完成，这个模块才会输出值。\n\n加载这个模块的写法如下。\n\n// usage.js\nimport { output } from \"./awaiting.js\";\nfunction outputPlusValue(value) { return output + value }\n\nconsole.log(outputPlusValue(100));\nsetTimeout(() => console.log(outputPlusValue(100), 1000);\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。\n\n这时，模块的加载会等待依赖模块（上例是awaiting.js）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的output，不会因为加载时机的不同，而得到不一样的值。\n\n下面是顶层await的一些使用场景。\n\n// import() 方法加载\nconst strings = await import(`/i18n/${navigator.language}`);\n\n// 数据库操作\nconst connection = await dbConnector();\n\n// 依赖回滚\nlet jQuery;\ntry {\n  jQuery = await import('https://cdn-a.com/jQuery');\n} catch {\n  jQuery = await import('https://cdn-b.com/jQuery');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n注意，如果加载多个包含顶层await命令的模块，加载命令是同步执行的。\n\n// x.js\nconsole.log(\"X1\");\nawait new Promise(r => setTimeout(r, 1000));\nconsole.log(\"X2\");\n\n// y.js\nconsole.log(\"Y\");\n\n// z.js\nimport \"./x.js\";\nimport \"./y.js\";\nconsole.log(\"Z\");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码有三个模块，最后的z.js加载x.js和y.js，打印结果是X1、Y、X2、Z。这说明，z.js并没有等待x.js加载完成，再去加载y.js。\n\n顶层的await命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。",normalizedContent:"# async 函数\n\n\n# 含义\n\nes2017 标准引入了 async 函数，使得异步操作变得更加方便。\n\nasync 函数是什么？一句话，它就是 generator 函数的语法糖。\n\n前文有一个 generator 函数，依次读取两个文件。\n\nconst fs = require('fs');\n\nconst readfile = function (filename) {\n  return new promise(function (resolve, reject) {\n    fs.readfile(filename, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n\nconst gen = function* () {\n  const f1 = yield readfile('/etc/fstab');\n  const f2 = yield readfile('/etc/shells');\n  console.log(f1.tostring());\n  console.log(f2.tostring());\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码的函数gen可以写成async函数，就是下面这样。\n\nconst asyncreadfile = async function () {\n  const f1 = await readfile('/etc/fstab');\n  const f2 = await readfile('/etc/shells');\n  console.log(f1.tostring());\n  console.log(f2.tostring());\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n一比较就会发现，async函数就是将 generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\n\nasync函数对 generator 函数的改进，体现在以下四点。\n\n（1）内置执行器。\n\ngenerator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。\n\nasyncreadfile();\n\n\n1\n\n\n上面的代码调用了asyncreadfile函数，然后它就会自动执行，输出最后结果。这完全不像 generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。\n\n（2）更好的语义。\n\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n\n（3）更广的适用性。\n\nco模块约定，yield命令后面只能是 thunk 函数或 promise 对象，而async函数的await命令后面，可以是 promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 promise 对象）。\n\n（4）返回值是 promise。\n\nasync函数的返回值是 promise 对象，这比 generator 函数的返回值是 iterator 对象方便多了。你可以用then方法指定下一步的操作。\n\n进一步说，async函数完全可以看作多个异步操作，包装成的一个 promise 对象，而await命令就是内部then命令的语法糖。\n\n\n# 基本用法\n\nasync函数返回一个 promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n\n下面是一个例子。\n\nasync function getstockpricebyname(name) {\n  const symbol = await getstocksymbol(name);\n  const stockprice = await getstockprice(symbol);\n  return stockprice;\n}\n\ngetstockpricebyname('goog').then(function (result) {\n  console.log(result);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个promise对象。\n\n下面是另一个例子，指定多少毫秒后输出一个值。\n\nfunction timeout(ms) {\n  return new promise((resolve) => {\n    settimeout(resolve, ms);\n  });\n}\n\nasync function asyncprint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncprint('hello world', 50);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码指定 50 毫秒以后，输出hello world。\n\n由于async函数返回的是 promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式。\n\nasync function timeout(ms) {\n  await new promise((resolve) => {\n    settimeout(resolve, ms);\n  });\n}\n\nasync function asyncprint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncprint('hello world', 50);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nasync 函数有多种使用形式。\n\n// 函数声明\nasync function foo() {}\n\n// 函数表达式\nconst foo = async function () {};\n\n// 对象的方法\nlet obj = { async foo() {} };\nobj.foo().then(...)\n\n// class 的方法\nclass storage {\n  constructor() {\n    this.cachepromise = caches.open('avatars');\n  }\n\n  async getavatar(name) {\n    const cache = await this.cachepromise;\n    return cache.match(`/avatars/${name}.jpg`);\n  }\n}\n\nconst storage = new storage();\nstorage.getavatar('jake').then(…);\n\n// 箭头函数\nconst foo = async () => {};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 语法\n\nasync函数的语法规则总体上比较简单，难点是错误处理机制。\n\n\n# 返回 promise 对象\n\nasync函数返回一个 promise 对象。\n\nasync函数内部return语句返回的值，会成为then方法回调函数的参数。\n\nasync function f() {\n  return 'hello world';\n}\n\nf().then(v => console.log(v))\n// \"hello world\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。\n\nasync函数内部抛出错误，会导致返回的 promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。\n\nasync function f() {\n  throw new error('出错了');\n}\n\nf().then(\n  v => console.log(v),\n  e => console.log(e)\n)\n// error: 出错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# promise 对象的状态变化\n\nasync函数返回的 promise 对象，必须等到内部所有await命令后面的 promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。\n\n下面是一个例子。\n\nasync function gettitle(url) {\n  let response = await fetch(url);\n  let html = await response.text();\n  return html.match(/<title>([\\s\\s]+)<\\/title>/i)[1];\n}\ngettitle('https://tc39.github.io/ecma262/').then(console.log)\n// \"ecmascript 2017 language specification\"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，函数gettitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。\n\n\n# await 命令\n\n正常情况下，await命令后面是一个 promise 对象，返回该对象的结果。如果不是 promise 对象，就直接返回对应的值。\n\nasync function f() {\n  // 等同于\n  // return 123;\n  return await 123;\n}\n\nf().then(v => console.log(v))\n// 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，await命令的参数是数值123，这时等同于return 123。\n\n另一种情况是，await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 promise 对象。\n\nclass sleep {\n  constructor(timeout) {\n    this.timeout = timeout;\n  }\n  then(resolve, reject) {\n    const starttime = date.now();\n    settimeout(\n      () => resolve(date.now() - starttime),\n      this.timeout\n    );\n  }\n}\n\n(async () => {\n  const sleeptime = await new sleep(1000);\n  console.log(sleeptime);\n})();\n// 1000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码中，await命令后面是一个sleep对象的实例。这个实例不是 promise 对象，但是因为定义了then方法，await会将其视为promise处理。\n\n这个例子还演示了如何实现休眠效果。javascript 一直没有休眠的语法，但是借助await命令就可以让程序停顿指定的时间。下面给出了一个简化的sleep实现。\n\nfunction sleep(interval) {\n  return new promise(resolve => {\n    settimeout(resolve, interval);\n  })\n}\n\n// 用法\nasync function one2fiveinasync() {\n  for(let i = 1; i <= 5; i++) {\n    console.log(i);\n    await sleep(1000);\n  }\n}\n\none2fiveinasync();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nawait命令后面的 promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。\n\nasync function f() {\n  await promise.reject('出错了');\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// 出错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。\n\n任何一个await语句后面的 promise 对象变为reject状态，那么整个async函数都会中断执行。\n\nasync function f() {\n  await promise.reject('出错了');\n  await promise.resolve('hello world'); // 不会执行\n}\n\n\n1\n2\n3\n4\n\n\n上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。\n\n有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。\n\nasync function f() {\n  try {\n    await promise.reject('出错了');\n  } catch(e) {\n  }\n  return await promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// hello world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n另一种方法是await后面的 promise 对象再跟一个catch方法，处理前面可能出现的错误。\n\nasync function f() {\n  await promise.reject('出错了')\n    .catch(e => console.log(e));\n  return await promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// 出错了\n// hello world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 错误处理\n\n如果await后面的异步操作出错，那么等同于async函数返回的 promise 对象被reject。\n\nasync function f() {\n  await new promise(function (resolve, reject) {\n    throw new error('出错了');\n  });\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// error：出错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，async函数f执行后，await后面的 promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。\n\n防止出错的方法，也是将其放在try...catch代码块之中。\n\nasync function f() {\n  try {\n    await new promise(function (resolve, reject) {\n      throw new error('出错了');\n    });\n  } catch(e) {\n  }\n  return await('hello world');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果有多个await命令，可以统一放在try...catch结构中。\n\nasync function main() {\n  try {\n    const val1 = await firststep();\n    const val2 = await secondstep(val1);\n    const val3 = await thirdstep(val1, val2);\n\n    console.log('final: ', val3);\n  }\n  catch (err) {\n    console.error(err);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n下面的例子使用try...catch结构，实现多次重复尝试。\n\nconst superagent = require('superagent');\nconst num_retries = 3;\n\nasync function test() {\n  let i;\n  for (i = 0; i < num_retries; ++i) {\n    try {\n      await superagent.get('http://google.com/this-throws-an-error');\n      break;\n    } catch(err) {}\n  }\n  console.log(i); // 3\n}\n\ntest();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，如果await操作成功，就会使用break语句退出循环；如果失败，会被catch语句捕捉，然后进入下一轮循环。\n\n\n# 使用注意点\n\n第一点，前面已经说过，await命令后面的promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。\n\nasync function myfunction() {\n  try {\n    await somethingthatreturnsapromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 另一种写法\n\nasync function myfunction() {\n  await somethingthatreturnsapromise()\n  .catch(function (err) {\n    console.log(err);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发（并发）。\n\nlet foo = await getfoo();\nlet bar = await getbar();\n\n\n1\n2\n\n\n上面代码中，getfoo和getbar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getfoo完成以后，才会执行getbar，完全可以让它们同时触发。\n\n// 写法一\nlet [foo, bar] = await promise.all([getfoo(), getbar()]);\n\n// 写法二\nlet foopromise = getfoo();\nlet barpromise = getbar();\nlet foo = await foopromise;\nlet bar = await barpromise;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面两种写法，getfoo和getbar都是同时触发，这样就会缩短程序的执行时间。\n\n第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。\n\nasync function dbfuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 报错\n  docs.foreach(function (doc) {\n    await db.post(doc);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码会报错，因为await用在普通函数之中了。但是，如果将foreach方法的参数改成async函数，也有问题。\n\nfunction dbfuc(db) { //这里不需要 async\n  let docs = [{}, {}, {}];\n\n  // 可能得到错误结果\n  docs.foreach(async function (doc) {\n    await db.post(doc);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。\n\nasync function dbfuc(db) {\n  let docs = [{}, {}, {}];\n\n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果确实希望多个请求并发执行，可以使用promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。\n\nasync function dbfuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await promise.all(promises);\n  console.log(results);\n}\n\n// 或者使用下面的写法\n\nasync function dbfuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n第四点，async 函数可以保留运行堆栈。\n\nconst a = () => {\n  b().then(() => c());\n};\n\n\n1\n2\n3\n\n\n上面代码中，函数a内部运行了一个异步任务b()。当b()运行的时候，函数a()不会中断，而是继续执行。等到b()运行结束，可能a()早就运行结束了，b()所在的上下文环境已经消失了。如果b()或c()报错，错误堆栈将不包括a()。\n\n现在将这个例子改成async函数。\n\nconst a = async () => {\n  await b();\n  c();\n};\n\n\n1\n2\n3\n4\n\n\n上面代码中，b()运行的时候，a()是暂停执行，上下文环境都保存着。一旦b()或c()报错，错误堆栈将包括a()。\n\n\n# async 函数的实现原理\n\nasync 函数的实现原理**，就是将 generator 函数和自动执行器，包装在一个函数里**。\n\nasync function fn(args) {\n  // ...\n}\n\n// 等同于\n\nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。\n\n下面给出spawn函数的实现，基本就是前文自动执行器的翻版。\n\nfunction spawn(genf) {\n  return new promise(function(resolve, reject) {\n    const gen = genf();\n    function step(nextf) {\n      let next;\n      try {\n        next = nextf();\n      } catch(e) {\n        return reject(e);\n      }\n      if(next.done) {\n        return resolve(next.value);\n      }\n      promise.resolve(next.value).then(function(v) {\n        step(function() { return gen.next(v); });\n      }, function(e) {\n        step(function() { return gen.throw(e); });\n      });\n    }\n    step(function() { return gen.next(undefined); });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 与其他异步处理方法的比较\n\n我们通过一个例子，来看 async 函数与 promise、generator 函数的比较。\n\n假定某个 dom 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。\n\n首先是 promise 的写法。\n\nfunction chainanimationspromise(elem, animations) {\n\n  // 变量ret用来保存上一个动画的返回值\n  let ret = null;\n\n  // 新建一个空的promise\n  let p = promise.resolve();\n\n  // 使用then方法，添加所有动画\n  for(let anim of animations) {\n    p = p.then(function(val) {\n      ret = val;\n      return anim(elem);\n    });\n  }\n\n  // 返回一个部署了错误捕捉机制的promise\n  return p.catch(function(e) {\n    /* 忽略错误，继续执行 */\n  }).then(function() {\n    return ret;\n  });\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n虽然 promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 promise 的 api（then、catch等等），操作本身的语义反而不容易看出来。\n\n接着是 generator 函数的写法。\n\nfunction chainanimationsgenerator(elem, animations) {\n\n  return spawn(function*() {\n    let ret = null;\n    try {\n      for(let anim of animations) {\n        ret = yield anim(elem);\n      }\n    } catch(e) {\n      /* 忽略错误，继续执行 */\n    }\n    return ret;\n  });\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码使用 generator 函数遍历了每个动画，语义比 promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 generator 函数，上面代码的spawn函数就是自动执行器，它返回一个 promise 对象，而且必须保证yield语句后面的表达式，必须返回一个 promise。\n\n最后是 async 函数的写法。\n\nasync function chainanimationsasync(elem, animations) {\n  let ret = null;\n  try {\n    for(let anim of animations) {\n      ret = await anim(elem);\n    }\n  } catch(e) {\n    /* 忽略错误，继续执行 */\n  }\n  return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n可以看到 async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 generator 写法，自动执行器需要用户自己提供。\n\n\n# 实例：按顺序完成异步操作\n\n实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 url，然后按照读取的顺序输出结果。\n\npromise 的写法如下。\n\nfunction loginorder(urls) {\n  // 远程读取所有url\n  const textpromises = urls.map(url => {\n    return fetch(url).then(response => response.text());\n  });\n\n  // 按次序输出\n  textpromises.reduce((chain, textpromise) => {\n    return chain.then(() => textpromise)\n      .then(text => console.log(text));\n  }, promise.resolve());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码使用fetch方法，同时远程读取一组 url。每个fetch操作都返回一个 promise 对象，放入textpromises数组。然后，reduce方法依次处理每个 promise 对象，然后使用then，将所有 promise 对象连起来，因此就可以依次输出结果。\n\n这种写法不太直观，可读性比较差。下面是 async 函数实现。\n\nasync function loginorder(urls) {\n  for (const url of urls) {\n    const response = await fetch(url);\n    console.log(await response.text());\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 url 返回结果，才会去读取下一个 url，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。\n\nasync function loginorder(urls) {\n  // 并发读取远程url\n  const textpromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textpromise of textpromises) {\n    console.log(await textpromise);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。\n\n\n# 顶层 await\n\n根据语法规格，await命令只能出现在 async 函数内部，否则都会报错。\n\n// 报错\nconst data = await fetch('https://api.example.com');\n\n\n1\n2\n\n\n上面代码中，await命令独立使用，没有放在 async 函数里面，就会报错。\n\n目前，有一个语法提案，允许在模块的顶层独立使用await命令。这个提案的目的，是借用await解决模块异步加载的问题。\n\n// awaiting.js\nlet output;\nasync function main() {\n  const dynamic = await import(somemission);\n  const data = await fetch(url);\n  output = someprocess(dynamic.default, data);\n}\nmain();\nexport { output };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，模块awaiting.js的输出值output，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量output才会有值，否则就返回undefined。\n\n上面的代码也可以写成立即执行函数的形式。\n\n// awaiting.js\nlet output;\n(async function main() {\n  const dynamic = await import(somemission);\n  const data = await fetch(url);\n  output = someprocess(dynamic.default, data);\n})();\nexport { output };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面是加载这个模块的写法。\n\n// usage.js\nimport { output } from \"./awaiting.js\";\n\nfunction outputplusvalue(value) { return output + value }\n\nconsole.log(outputplusvalue(100));\nsettimeout(() => console.log(outputplusvalue(100), 1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，outputplusvalue()的执行结果，完全取决于执行的时间。如果awaiting.js里面的异步操作没执行完，加载进来的output的值就是undefined。\n\n目前的解决方法，就是让原始模块输出一个 promise 对象，从这个 promise 对象判断异步操作有没有结束。\n\n// awaiting.js\nlet output;\nexport default (async function main() {\n  const dynamic = await import(somemission);\n  const data = await fetch(url);\n  output = someprocess(dynamic.default, data);\n})();\nexport { output };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，awaiting.js除了输出output，还默认输出一个 promise 对象（async 函数立即执行后，返回一个 promise 对象），从这个对象判断异步操作是否结束。\n\n下面是加载这个模块的新的写法。\n\n// usage.js\nimport promise, { output } from \"./awaiting.js\";\n\nfunction outputplusvalue(value) { return output + value }\n\npromise.then(() => {\n  console.log(outputplusvalue(100));\n  settimeout(() => console.log(outputplusvalue(100), 1000);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，将awaiting.js对象的输出，放在promise.then()里面，这样就能保证异步操作完成以后，才去读取output。\n\n这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的usage.js又有对外的输出，等于这个依赖链的所有模块都要使用 promise 加载。\n\n顶层的await命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。\n\n// awaiting.js\nconst dynamic = import(somemission);\nconst data = fetch(url);\nexport const output = someprocess((await dynamic).default, await data);\n\n\n1\n2\n3\n4\n\n\n上面代码中，两个异步操作在输出的时候，都加上了await命令。只有等到异步操作完成，这个模块才会输出值。\n\n加载这个模块的写法如下。\n\n// usage.js\nimport { output } from \"./awaiting.js\";\nfunction outputplusvalue(value) { return output + value }\n\nconsole.log(outputplusvalue(100));\nsettimeout(() => console.log(outputplusvalue(100), 1000);\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。\n\n这时，模块的加载会等待依赖模块（上例是awaiting.js）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的output，不会因为加载时机的不同，而得到不一样的值。\n\n下面是顶层await的一些使用场景。\n\n// import() 方法加载\nconst strings = await import(`/i18n/${navigator.language}`);\n\n// 数据库操作\nconst connection = await dbconnector();\n\n// 依赖回滚\nlet jquery;\ntry {\n  jquery = await import('https://cdn-a.com/jquery');\n} catch {\n  jquery = await import('https://cdn-b.com/jquery');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n注意，如果加载多个包含顶层await命令的模块，加载命令是同步执行的。\n\n// x.js\nconsole.log(\"x1\");\nawait new promise(r => settimeout(r, 1000));\nconsole.log(\"x2\");\n\n// y.js\nconsole.log(\"y\");\n\n// z.js\nimport \"./x.js\";\nimport \"./y.js\";\nconsole.log(\"z\");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码有三个模块，最后的z.js加载x.js和y.js，打印结果是x1、y、x2、z。这说明，z.js并没有等待x.js加载完成，再去加载y.js。\n\n顶层的await命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Class 的继承",frontmatter:{title:"Class 的继承",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/83f8c3a0cd87dd83",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/22.Class%20%E7%9A%84%E7%BB%A7%E6%89%BF.html",relativePath:"《ES6 教程》笔记/22.Class 的继承.md",key:"v-44d2c0fc",path:"/pages/83f8c3a0cd87dd83/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:16},{level:2,title:"Object.getPrototypeOf()",slug:"object-getprototypeof",normalizedTitle:"object.getprototypeof()",charIndex:2131},{level:2,title:"super 关键字",slug:"super-关键字",normalizedTitle:"super 关键字",charIndex:2286},{level:2,title:"类的 prototype 属性和__proto__属性",slug:"类的-prototype-属性和-proto-属性",normalizedTitle:"类的 prototype 属性和__proto__属性",charIndex:6501},{level:3,title:"实例的 __proto__ 属性",slug:"实例的-proto-属性",normalizedTitle:"实例的 <strong>proto</strong> 属性",charIndex:null},{level:2,title:"原生构造函数的继承",slug:"原生构造函数的继承",normalizedTitle:"原生构造函数的继承",charIndex:8813},{level:2,title:"Mixin 模式的实现",slug:"mixin-模式的实现",normalizedTitle:"mixin 模式的实现",charIndex:12041}],excerpt:'<h1 id="class-的继承"><a class="header-anchor" href="#class-的继承">#</a> Class 的继承</h1>\n<h2 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h2>\n<p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\n\x3c!--beforebegin--\x3e<div class="language-javascript line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">ColorPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"简介 Object.getPrototypeOf() super 关键字 类的 prototype 属性和__proto__属性 实例的 __proto__ 属性 原生构造函数的继承 Mixin 模式的实现",content:"# Class 的继承\n\n\n# 简介\n\nClass 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\n\nclass Point {\n}\n\nclass ColorPoint extends Point {\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n\n  toString() {\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。\n\n**子类必须在constructor方法中调用super方法，否则新建实例时会报错。**这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。\n\nclass Point { /* ... */ }\n\nclass ColorPoint extends Point {\n  constructor() {\n  }\n}\n\nlet cp = new ColorPoint(); // ReferenceError\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。\n\nES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。\n\n如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。\n\nclass ColorPoint extends Point {\n}\n\n// 等同于\nclass ColorPoint extends Point {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n另一个需要注意的地方是，**在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。**这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。\n\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。\n\n下面是生成子类实例的代码。\n\nlet cp = new ColorPoint(25, 8, 'green');\n\ncp instanceof ColorPoint // true\ncp instanceof Point // true\n\n\n1\n2\n3\n4\n\n\n上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。\n\n最后，父类的静态方法，也会被子类继承。\n\nclass A {\n  static hello() {\n    console.log('hello world');\n  }\n}\n\nclass B extends A {\n}\n\nB.hello()  // hello world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。\n\n\n# Object.getPrototypeOf()\n\nObject.getPrototypeOf方法可以用来从子类上获取父类。\n\nObject.getPrototypeOf(ColorPoint) === Point\n// true\n\n\n1\n2\n\n\n因此，可以使用这个方法判断，一个类是否继承了另一个类。\n\n\n# super 关键字\n\nsuper这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。\n\n第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。\n\nclass A {}\n\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。\n\n注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。\n\nclass A {\n  constructor() {\n    console.log(new.target.name);\n  }\n}\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\nnew A() // A\nnew B() // B\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。\n\n作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。\n\nclass A {}\n\nclass B extends A {\n  m() {\n    super(); // 报错\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，super()用在B类的m方法之中，就会造成语法错误。\n\n第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\n\nclass A {\n  p() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.p()); // 2\n  }\n}\n\nlet b = new B();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。\n\n这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。\n\nclass A {\n  constructor() {\n    this.p = 2; // 这是定于在实例上的属性\n  }\n}\n\nclass B extends A {\n  get m() {\n    return super.p;\n  }\n}\n\nlet b = new B();\nb.m // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，p是父类A实例的属性，super.p就引用不到它。\n\n如果属性定义在父类的原型对象上，super就可以取到。\n\nclass A {}\nA.prototype.x = 2;\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.x) // 2\n  }\n}\n\nlet b = new B();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。\n\nES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。\n\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n  print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  m() {\n    super.print();\n  }\n}\n\nlet b = new B();\nb.m() // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。\n\n由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。\n\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n    super.x = 3;\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  }\n}\n\nlet b = new B();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。\n\n如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。\n\nclass Parent {\n  static myMethod(msg) {\n    console.log('static', msg);\n  }\n\n  myMethod(msg) {\n    console.log('instance', msg);\n  }\n}\n\nclass Child extends Parent {\n  static myMethod(msg) {\n    super.myMethod(msg);\n  }\n\n  myMethod(msg) {\n    super.myMethod(msg);\n  }\n}\n\nChild.myMethod(1); // static 1\n\nvar child = new Child();\nchild.myMethod(2); // instance 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。\n\n另外，在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。\n\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n  static print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  static m() {\n    super.print();\n  }\n}\n\nB.x = 3;\nB.m() // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。\n\n注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。\n\nclass A {}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super); // 报错\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。\n\nclass A {}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.valueOf() instanceof B); // true\n  }\n}\n\nlet b = new B();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。\n\n最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。\n\nvar obj = {\n  toString() {\n    return \"MyObject: \" + super.toString();\n  }\n};\n\nobj.toString(); // MyObject: [object Object]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 类的 prototype 属性和__proto__属性\n\n大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\n\n（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。\n\n（2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。\n\nclass A {\n}\n\nclass B extends A {\n}\n\nB.__proto__ === A // true\nB.prototype.__proto__ === A.prototype // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。\n\n这样的结果是因为，类的继承是按照下面的模式实现的。\n\nclass A {\n}\n\nclass B {\n}\n\n// B 的实例继承 A 的实例\nObject.setPrototypeOf(B.prototype, A.prototype);\n\n// B 继承 A 的静态属性\nObject.setPrototypeOf(B, A);\n\nconst b = new B();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。\n\nObject.setPrototypeOf = function (obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n\n\n1\n2\n3\n4\n\n\n因此，就得到了上面的结果。\n\nObject.setPrototypeOf(B.prototype, A.prototype);\n// 等同于\nB.prototype.__proto__ = A.prototype;\n\nObject.setPrototypeOf(B, A);\n// 等同于\nB.__proto__ = A;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。\n\nB.prototype = Object.create(A.prototype);\n// 等同于\nB.prototype.__proto__ = A.prototype;\n\n\n1\n2\n3\n\n\nextends关键字后面可以跟多种类型的值。\n\nclass B extends A {\n}\n\n\n1\n2\n\n\n上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。\n\n下面，讨论两种情况。第一种，子类继承Object类。\n\nclass A extends Object {\n}\n\nA.__proto__ === Object // true\nA.prototype.__proto__ === Object.prototype // true\n\n\n1\n2\n3\n4\n5\n\n\n这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。\n\n第二种情况，不存在任何继承。\n\nclass A {\n}\n\nA.__proto__ === Function.prototype // true\nA.prototype.__proto__ === Object.prototype // true\n\n\n1\n2\n3\n4\n5\n\n\n这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。\n\n\n# 实例的 __proto__ 属性\n\n子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。\n\nvar p1 = new Point(2, 3);\nvar p2 = new ColorPoint(2, 3, 'red');\n\np2.__proto__ === p1.__proto__ // false\np2.__proto__.__proto__ === p1.__proto__ // true\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。\n\n因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。\n\np2.__proto__.__proto__.printName = function () {\n  console.log('Ha');\n};\n\np1.printName() // \"Ha\"\n\n\n1\n2\n3\n4\n5\n\n\n上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。\n\n\n# 原生构造函数的继承\n\n原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。\n\n * Boolean()\n * Number()\n * String()\n * Array()\n * Date()\n * Function()\n * RegExp()\n * Error()\n * Object()\n\n以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。\n\nfunction MyArray() {\n  Array.apply(this, arguments);\n}\n\nMyArray.prototype = Object.create(Array.prototype, {\n  constructor: {\n    value: MyArray,\n    writable: true,\n    configurable: true,\n    enumerable: true\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码定义了一个继承 Array 的MyArray类。但是，这个类的行为与Array完全不一致。\n\nvar colors = new MyArray();\ncolors[0] = \"red\";\ncolors.length  // 0\n\ncolors.length = 0;\ncolors[0]  // \"red\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。\n\nES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。\n\n下面的例子中，我们想让一个普通对象继承Error对象。\n\nvar e = {};\n\nObject.getOwnPropertyNames(Error.call(e))\n// [ 'stack' ]\n\nObject.getOwnPropertyNames(e)\n// []\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。\n\nES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。\n\nclass MyArray extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如Array、String等）的子类，这是 ES5 无法做到的。\n\n上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。\n\nclass VersionedArray extends Array {\n  constructor() {\n    super();\n    this.history = [[]];\n  }\n  commit() {\n    this.history.push(this.slice());\n  }\n  revert() {\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\n  }\n}\n\nvar x = new VersionedArray();\n\nx.push(1);\nx.push(2);\nx // [1, 2]\nx.history // [[]]\n\nx.commit();\nx.history // [[], [1, 2]]\n\nx.push(3);\nx // [1, 2, 3]\nx.history // [[], [1, 2]]\n\nx.revert();\nx // [1, 2]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面代码中，VersionedArray会通过commit方法，将自己的当前状态生成一个版本快照，存入history属性。revert方法用来将数组重置为最新一次保存的版本。除此之外，VersionedArray依然是一个普通数组，所有原生的数组方法都可以在它上面调用。\n\n下面是一个自定义Error子类的例子，可以用来定制报错时的行为。\n\nclass ExtendableError extends Error {\n  constructor(message) {\n    super();\n    this.message = message;\n    this.stack = (new Error()).stack;\n    this.name = this.constructor.name;\n  }\n}\n\nclass MyError extends ExtendableError {\n  constructor(m) {\n    super(m);\n  }\n}\n\nvar myerror = new MyError('ll');\nmyerror.message // \"ll\"\nmyerror instanceof Error // true\nmyerror.name // \"MyError\"\nmyerror.stack\n// Error\n//     at MyError.ExtendableError\n//     ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n注意，继承Object的子类，有一个行为差异。\n\nclass NewObj extends Object{\n  constructor(){\n    super(...arguments);\n  }\n}\nvar o = new NewObj({attr: true});\no.attr === true  // false\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为 ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6 规定Object构造函数会忽略参数。\n\n\n# Mixin 模式的实现\n\nMixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。\n\nconst a = {\n  a: 'a'\n};\nconst b = {\n  b: 'b'\n};\nconst c = {...a, ...b}; // {a: 'a', b: 'b'}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，c对象是a对象和b对象的合成，具有两者的接口。\n\n下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。\n\nfunction mix(...mixins) {\n  class Mix {\n    constructor() {\n      for (let mixin of mixins) {\n        copyProperties(this, new mixin()); // 拷贝实例属性\n      }\n    }\n  }\n\n  for (let mixin of mixins) {\n    copyProperties(Mix, mixin); // 拷贝静态属性\n    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性\n  }\n\n  return Mix;\n}\n\nfunction copyProperties(target, source) {\n  for (let key of Reflect.ownKeys(source)) {\n    if ( key !== 'constructor'\n      && key !== 'prototype'\n      && key !== 'name'\n    ) {\n      let desc = Object.getOwnPropertyDescriptor(source, key);\n      Object.defineProperty(target, key, desc);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。\n\nclass DistributedEdit extends mix(Loggable, Serializable) {\n  // ...\n}\n\n\n1\n2\n3\n",normalizedContent:"# class 的继承\n\n\n# 简介\n\nclass 可以通过extends关键字实现继承，这比 es5 的通过修改原型链实现继承，要清晰和方便很多。\n\nclass point {\n}\n\nclass colorpoint extends point {\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码定义了一个colorpoint类，该类通过extends关键字，继承了point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个point类。下面，我们在colorpoint内部加上代码。\n\nclass colorpoint extends point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n\n  tostring() {\n    return this.color + ' ' + super.tostring(); // 调用父类的tostring()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，constructor方法和tostring方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。\n\n**子类必须在constructor方法中调用super方法，否则新建实例时会报错。**这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。\n\nclass point { /* ... */ }\n\nclass colorpoint extends point {\n  constructor() {\n  }\n}\n\nlet cp = new colorpoint(); // referenceerror\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，colorpoint继承了父类point，但是它的构造函数没有调用super方法，导致新建实例时报错。\n\nes5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（parent.apply(this)）。es6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。\n\n如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。\n\nclass colorpoint extends point {\n}\n\n// 等同于\nclass colorpoint extends point {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n另一个需要注意的地方是，**在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。**这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。\n\nclass point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass colorpoint extends point {\n  constructor(x, y, color) {\n    this.color = color; // referenceerror\n    super(x, y);\n    this.color = color; // 正确\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。\n\n下面是生成子类实例的代码。\n\nlet cp = new colorpoint(25, 8, 'green');\n\ncp instanceof colorpoint // true\ncp instanceof point // true\n\n\n1\n2\n3\n4\n\n\n上面代码中，实例对象cp同时是colorpoint和point两个类的实例，这与 es5 的行为完全一致。\n\n最后，父类的静态方法，也会被子类继承。\n\nclass a {\n  static hello() {\n    console.log('hello world');\n  }\n}\n\nclass b extends a {\n}\n\nb.hello()  // hello world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，hello()是a类的静态方法，b继承a，也继承了a的静态方法。\n\n\n# object.getprototypeof()\n\nobject.getprototypeof方法可以用来从子类上获取父类。\n\nobject.getprototypeof(colorpoint) === point\n// true\n\n\n1\n2\n\n\n因此，可以使用这个方法判断，一个类是否继承了另一个类。\n\n\n# super 关键字\n\nsuper这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。\n\n第一种情况，super作为函数调用时，代表父类的构造函数。es6 要求，子类的构造函数必须执行一次super函数。\n\nclass a {}\n\nclass b extends a {\n  constructor() {\n    super();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，子类b的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 javascript 引擎会报错。\n\n注意，super虽然代表了父类a的构造函数，但是返回的是子类b的实例，即super内部的this指的是b的实例，因此super()在这里相当于a.prototype.constructor.call(this)。\n\nclass a {\n  constructor() {\n    console.log(new.target.name);\n  }\n}\nclass b extends a {\n  constructor() {\n    super();\n  }\n}\nnew a() // a\nnew b() // b\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类b的构造函数，而不是父类a的构造函数。也就是说，super()内部的this指向的是b。\n\n作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。\n\nclass a {}\n\nclass b extends a {\n  m() {\n    super(); // 报错\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，super()用在b类的m方法之中，就会造成语法错误。\n\n第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\n\nclass a {\n  p() {\n    return 2;\n  }\n}\n\nclass b extends a {\n  constructor() {\n    super();\n    console.log(super.p()); // 2\n  }\n}\n\nlet b = new b();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，子类b当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向a.prototype，所以super.p()就相当于a.prototype.p()。\n\n这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。\n\nclass a {\n  constructor() {\n    this.p = 2; // 这是定于在实例上的属性\n  }\n}\n\nclass b extends a {\n  get m() {\n    return super.p;\n  }\n}\n\nlet b = new b();\nb.m // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，p是父类a实例的属性，super.p就引用不到它。\n\n如果属性定义在父类的原型对象上，super就可以取到。\n\nclass a {}\na.prototype.x = 2;\n\nclass b extends a {\n  constructor() {\n    super();\n    console.log(super.x) // 2\n  }\n}\n\nlet b = new b();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，属性x是定义在a.prototype上面的，所以super.x可以取到它的值。\n\nes6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。\n\nclass a {\n  constructor() {\n    this.x = 1;\n  }\n  print() {\n    console.log(this.x);\n  }\n}\n\nclass b extends a {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  m() {\n    super.print();\n  }\n}\n\nlet b = new b();\nb.m() // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面代码中，super.print()虽然调用的是a.prototype.print()，但是a.prototype.print()内部的this指向子类b的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。\n\n由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。\n\nclass a {\n  constructor() {\n    this.x = 1;\n  }\n}\n\nclass b extends a {\n  constructor() {\n    super();\n    this.x = 2;\n    super.x = 3;\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  }\n}\n\nlet b = new b();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是a.prototype.x，所以返回undefined。\n\n如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。\n\nclass parent {\n  static mymethod(msg) {\n    console.log('static', msg);\n  }\n\n  mymethod(msg) {\n    console.log('instance', msg);\n  }\n}\n\nclass child extends parent {\n  static mymethod(msg) {\n    super.mymethod(msg);\n  }\n\n  mymethod(msg) {\n    super.mymethod(msg);\n  }\n}\n\nchild.mymethod(1); // static 1\n\nvar child = new child();\nchild.mymethod(2); // instance 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。\n\n另外，在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。\n\nclass a {\n  constructor() {\n    this.x = 1;\n  }\n  static print() {\n    console.log(this.x);\n  }\n}\n\nclass b extends a {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  static m() {\n    super.print();\n  }\n}\n\nb.x = 3;\nb.m() // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面代码中，静态方法b.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是b，而不是b的实例。\n\n注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。\n\nclass a {}\n\nclass b extends a {\n  constructor() {\n    super();\n    console.log(super); // 报错\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 javascript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。\n\nclass a {}\n\nclass b extends a {\n  constructor() {\n    super();\n    console.log(super.valueof() instanceof b); // true\n  }\n}\n\nlet b = new b();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，super.valueof()表明super是一个对象，因此就不会报错。同时，由于super使得this指向b的实例，所以super.valueof()返回的是一个b的实例。\n\n最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。\n\nvar obj = {\n  tostring() {\n    return \"myobject: \" + super.tostring();\n  }\n};\n\nobj.tostring(); // myobject: [object object]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 类的 prototype 属性和__proto__属性\n\n大多数浏览器的 es5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\n\n（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。\n\n（2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。\n\nclass a {\n}\n\nclass b extends a {\n}\n\nb.__proto__ === a // true\nb.prototype.__proto__ === a.prototype // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，子类b的__proto__属性指向父类a，子类b的prototype属性的__proto__属性指向父类a的prototype属性。\n\n这样的结果是因为，类的继承是按照下面的模式实现的。\n\nclass a {\n}\n\nclass b {\n}\n\n// b 的实例继承 a 的实例\nobject.setprototypeof(b.prototype, a.prototype);\n\n// b 继承 a 的静态属性\nobject.setprototypeof(b, a);\n\nconst b = new b();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n《对象的扩展》一章给出过object.setprototypeof方法的实现。\n\nobject.setprototypeof = function (obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n\n\n1\n2\n3\n4\n\n\n因此，就得到了上面的结果。\n\nobject.setprototypeof(b.prototype, a.prototype);\n// 等同于\nb.prototype.__proto__ = a.prototype;\n\nobject.setprototypeof(b, a);\n// 等同于\nb.__proto__ = a;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这两条继承链，可以这样理解：作为一个对象，子类（b）的原型（__proto__属性）是父类（a）；作为一个构造函数，子类（b）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。\n\nb.prototype = object.create(a.prototype);\n// 等同于\nb.prototype.__proto__ = a.prototype;\n\n\n1\n2\n3\n\n\nextends关键字后面可以跟多种类型的值。\n\nclass b extends a {\n}\n\n\n1\n2\n\n\n上面代码的a，只要是一个有prototype属性的函数，就能被b继承。由于函数都有prototype属性（除了function.prototype函数），因此a可以是任意函数。\n\n下面，讨论两种情况。第一种，子类继承object类。\n\nclass a extends object {\n}\n\na.__proto__ === object // true\na.prototype.__proto__ === object.prototype // true\n\n\n1\n2\n3\n4\n5\n\n\n这种情况下，a其实就是构造函数object的复制，a的实例就是object的实例。\n\n第二种情况，不存在任何继承。\n\nclass a {\n}\n\na.__proto__ === function.prototype // true\na.prototype.__proto__ === object.prototype // true\n\n\n1\n2\n3\n4\n5\n\n\n这种情况下，a作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承function.prototype。但是，a调用后返回一个空对象（即object实例），所以a.prototype.__proto__指向构造函数（object）的prototype属性。\n\n\n# 实例的 __proto__ 属性\n\n子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。\n\nvar p1 = new point(2, 3);\nvar p2 = new colorpoint(2, 3, 'red');\n\np2.__proto__ === p1.__proto__ // false\np2.__proto__.__proto__ === p1.__proto__ // true\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，colorpoint继承了point，导致前者原型的原型是后者的原型。\n\n因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。\n\np2.__proto__.__proto__.printname = function () {\n  console.log('ha');\n};\n\np1.printname() // \"ha\"\n\n\n1\n2\n3\n4\n5\n\n\n上面代码在colorpoint的实例p2上向point类添加方法，结果影响到了point的实例p1。\n\n\n# 原生构造函数的继承\n\n原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ecmascript 的原生构造函数大致有下面这些。\n\n * boolean()\n * number()\n * string()\n * array()\n * date()\n * function()\n * regexp()\n * error()\n * object()\n\n以前，这些原生构造函数是无法继承的，比如，不能自己定义一个array的子类。\n\nfunction myarray() {\n  array.apply(this, arguments);\n}\n\nmyarray.prototype = object.create(array.prototype, {\n  constructor: {\n    value: myarray,\n    writable: true,\n    configurable: true,\n    enumerable: true\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码定义了一个继承 array 的myarray类。但是，这个类的行为与array完全不一致。\n\nvar colors = new myarray();\ncolors[0] = \"red\";\ncolors.length  // 0\n\ncolors.length = 0;\ncolors[0]  // \"red\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。\n\nes5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，array构造函数有一个内部属性[[defineownproperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。\n\n下面的例子中，我们想让一个普通对象继承error对象。\n\nvar e = {};\n\nobject.getownpropertynames(error.call(e))\n// [ 'stack' ]\n\nobject.getownpropertynames(e)\n// []\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，我们想通过error.call(e)这种写法，让普通对象e具有error对象的实例属性。但是，error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了error.call(e)这种写法，无法继承原生构造函数。\n\nes6 允许继承原生构造函数定义子类，因为 es6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承array的例子。\n\nclass myarray extends array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new myarray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码定义了一个myarray类，继承了array构造函数，因此就可以从myarray生成数组的实例。这意味着，es6 可以自定义原生数据结构（比如array、string等）的子类，这是 es5 无法做到的。\n\n上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。\n\nclass versionedarray extends array {\n  constructor() {\n    super();\n    this.history = [[]];\n  }\n  commit() {\n    this.history.push(this.slice());\n  }\n  revert() {\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\n  }\n}\n\nvar x = new versionedarray();\n\nx.push(1);\nx.push(2);\nx // [1, 2]\nx.history // [[]]\n\nx.commit();\nx.history // [[], [1, 2]]\n\nx.push(3);\nx // [1, 2, 3]\nx.history // [[], [1, 2]]\n\nx.revert();\nx // [1, 2]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面代码中，versionedarray会通过commit方法，将自己的当前状态生成一个版本快照，存入history属性。revert方法用来将数组重置为最新一次保存的版本。除此之外，versionedarray依然是一个普通数组，所有原生的数组方法都可以在它上面调用。\n\n下面是一个自定义error子类的例子，可以用来定制报错时的行为。\n\nclass extendableerror extends error {\n  constructor(message) {\n    super();\n    this.message = message;\n    this.stack = (new error()).stack;\n    this.name = this.constructor.name;\n  }\n}\n\nclass myerror extends extendableerror {\n  constructor(m) {\n    super(m);\n  }\n}\n\nvar myerror = new myerror('ll');\nmyerror.message // \"ll\"\nmyerror instanceof error // true\nmyerror.name // \"myerror\"\nmyerror.stack\n// error\n//     at myerror.extendableerror\n//     ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n注意，继承object的子类，有一个行为差异。\n\nclass newobj extends object{\n  constructor(){\n    super(...arguments);\n  }\n}\nvar o = new newobj({attr: true});\no.attr === true  // false\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，newobj继承了object，但是无法通过super方法向父类object传参。这是因为 es6 改变了object构造函数的行为，一旦发现object方法不是通过new object()这种形式调用，es6 规定object构造函数会忽略参数。\n\n\n# mixin 模式的实现\n\nmixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。\n\nconst a = {\n  a: 'a'\n};\nconst b = {\n  b: 'b'\n};\nconst c = {...a, ...b}; // {a: 'a', b: 'b'}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，c对象是a对象和b对象的合成，具有两者的接口。\n\n下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。\n\nfunction mix(...mixins) {\n  class mix {\n    constructor() {\n      for (let mixin of mixins) {\n        copyproperties(this, new mixin()); // 拷贝实例属性\n      }\n    }\n  }\n\n  for (let mixin of mixins) {\n    copyproperties(mix, mixin); // 拷贝静态属性\n    copyproperties(mix.prototype, mixin.prototype); // 拷贝原型属性\n  }\n\n  return mix;\n}\n\nfunction copyproperties(target, source) {\n  for (let key of reflect.ownkeys(source)) {\n    if ( key !== 'constructor'\n      && key !== 'prototype'\n      && key !== 'name'\n    ) {\n      let desc = object.getownpropertydescriptor(source, key);\n      object.defineproperty(target, key, desc);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。\n\nclass distributededit extends mix(loggable, serializable) {\n  // ...\n}\n\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Class 的基本语法",frontmatter:{title:"Class 的基本语法",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/e831e1593c82bbe0",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/21.Class%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html",relativePath:"《ES6 教程》笔记/21.Class 的基本语法.md",key:"v-73e6fcbe",path:"/pages/e831e1593c82bbe0/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:18},{level:3,title:"类的由来",slug:"类的由来",normalizedTitle:"类的由来",charIndex:25},{level:3,title:"constructor 方法",slug:"constructor-方法",normalizedTitle:"constructor 方法",charIndex:2634},{level:3,title:"类的实例",slug:"类的实例",normalizedTitle:"类的实例",charIndex:1522},{level:3,title:"取值函数（getter）和存值函数（setter）",slug:"取值函数-getter-和存值函数-setter",normalizedTitle:"取值函数（getter）和存值函数（setter）",charIndex:4982},{level:3,title:"属性表达式",slug:"属性表达式",normalizedTitle:"属性表达式",charIndex:5891},{level:3,title:"Class 表达式",slug:"class-表达式",normalizedTitle:"class 表达式",charIndex:6101},{level:3,title:"注意点",slug:"注意点",normalizedTitle:"注意点",charIndex:6764},{level:2,title:"静态方法",slug:"静态方法",normalizedTitle:"静态方法",charIndex:9310},{level:2,title:"实例属性的新写法",slug:"实例属性的新写法",normalizedTitle:"实例属性的新写法",charIndex:10519},{level:2,title:"静态属性",slug:"静态属性",normalizedTitle:"静态属性",charIndex:11358},{level:2,title:"私有方法和私有属性",slug:"私有方法和私有属性",normalizedTitle:"私有方法和私有属性",charIndex:11976},{level:3,title:"现有的解决方案",slug:"现有的解决方案",normalizedTitle:"现有的解决方案",charIndex:11990},{level:3,title:"私有属性的提案",slug:"私有属性的提案",normalizedTitle:"私有属性的提案",charIndex:13124},{level:2,title:"new.target 属性",slug:"new-target-属性",normalizedTitle:"new.target 属性",charIndex:15392}],excerpt:'<h1 id="class-的基本语法"><a class="header-anchor" href="#class-的基本语法">#</a> Class 的基本语法</h1>\n<h2 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h2>\n<h3 id="类的由来"><a class="header-anchor" href="#类的由来">#</a> 类的由来</h3>\n<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>\n\x3c!--beforebegin--\x3e<div class="language-javascript line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token string">\'(\'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">\', \'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token string">\')\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"简介 类的由来 constructor 方法 类的实例 取值函数（getter）和存值函数（setter） 属性表达式 Class 表达式 注意点 静态方法 实例属性的新写法 静态属性 私有方法和私有属性 现有的解决方案 私有属性的提案 new.target 属性",content:"# Class 的基本语法\n\n\n# 简介\n\n\n# 类的由来\n\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。\n\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\n\nES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。\n\n基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。\n\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Point，对应 ES6 的Point类的构造方法。\n\nPoint类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。\n\nES6 的类，完全可以看作构造函数的另一种写法。\n\nclass Point {\n  // ...\n}\n\ntypeof Point // \"function\"\nPoint === Point.prototype.constructor // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码表明，类的数据类型就是函数，类本身就指向构造函数。\n\n使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。\n\nclass Bar {\n  doStuff() {\n    console.log('stuff');\n  }\n}\n\nvar b = new Bar();\nb.doStuff() // \"stuff\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。\n\nclass Point {\n  constructor() {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n\n  toValue() {\n    // ...\n  }\n}\n\n// 等同于\n\nPoint.prototype = {\n  constructor() {},\n  toString() {},\n  toValue() {},\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在类的实例上面调用方法，其实就是调用原型上的方法。\n\nclass B {}\nlet b = new B();\n\nb.constructor === B.prototype.constructor // true\n\n\n1\n2\n3\n4\n\n\n上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。\n\n由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。\n\nclass Point {\n  constructor(){\n    // ...\n  }\n}\n\nObject.assign(Point.prototype, {\n  toString(){},\n  toValue(){}\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nprototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。\n\nPoint.prototype.constructor === Point // true\n\n\n1\n\n\n另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。\n\nclass Point {\n  constructor(x, y) {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n}\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。\n\nvar Point = function (x, y) {\n  // ...\n};\n\nPoint.prototype.toString = function() {\n  // ...\n};\n\nObject.keys(Point.prototype)\n// [\"toString\"]\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码采用 ES5 的写法，toString方法就是可枚举的。\n\n\n# constructor 方法\n\nconstructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。\n\nclass Point {\n}\n\n// 等同于\nclass Point {\n  constructor() {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor方法。\n\nconstructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。\n\nclass Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}\n\nnew Foo() instanceof Foo\n// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。\n\n类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。\n\nclass Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}\n\nFoo()\n// TypeError: Class constructor Foo cannot be invoked without 'new'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 类的实例\n\n生成类的实例的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。\n\nclass Point {\n  // ...\n}\n\n// 报错\nvar point = Point(2, 3);\n\n// 正确\nvar point = new Point(2, 3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。\n\n//定义类\nclass Point {\n\n  constructor(x, y) { // constructor属性定义在原型上\n    this.x = x; // x属性定义在实例上\n    this.y = y; // y属性定义在实例上\n  }\n\n  toString() { // toString属性定义在原型上\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n\n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。\n\n与 ES5 一样，类的所有实例共享一个原型对象。\n\nvar p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__ === p2.__proto__\n//true\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。\n\n这也意味着，可以通过实例的__proto__属性为“类”添加方法。\n\n> __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。\n\nvar p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__.printName = function () { return 'Oops' };\n\np1.printName() // \"Oops\"\np2.printName() // \"Oops\"\n\nvar p3 = new Point(4,2);\np3.printName() // \"Oops\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。\n\n\n# 取值函数（getter）和存值函数（setter）\n\n与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n\nclass MyClass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n}\n\nlet inst = new MyClass();\n\ninst.prop = 123;\n// setter: 123\n\ninst.prop\n// 'getter'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。\n\n存值函数和取值函数是设置在属性的 Descriptor 对象上的。\n\nclass CustomHTMLElement {\n  constructor(element) {\n    this.element = element;\n  }\n\n  get html() {\n    return this.element.innerHTML;\n  }\n\n  set html(value) {\n    this.element.innerHTML = value;\n  }\n}\n\nvar descriptor = Object.getOwnPropertyDescriptor(\n  CustomHTMLElement.prototype, \"html\"\n);\n\n\"get\" in descriptor  // true\n\"set\" in descriptor  // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。\n\n\n# 属性表达式\n\n类的属性名，可以采用表达式。\n\nlet methodName = 'getArea';\n\nclass Square {\n  constructor(length) {\n    // ...\n  }\n\n  [methodName]() {\n    // ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，Square类的方法名getArea，是从表达式得到的。\n\n\n# Class 表达式\n\n与函数一样，类也可以使用表达式的形式定义。\n\nconst MyClass = class Me {\n  getClassName() {\n    return Me.name;\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\n上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。\n\nlet inst = new MyClass();\ninst.getClassName() // Me\nMe.name // ReferenceError: Me is not defined\n\n\n1\n2\n3\n\n\n上面代码表示，Me只在 Class 内部有定义。\n\n如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。\n\nconst MyClass = class { /* ... */ };\n\n\n1\n\n\n采用 Class 表达式，可以写出立即执行的 Class。\n\nlet person = new class {\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayName() {\n    console.log(this.name);\n  }\n}('张三');\n\nperson.sayName(); // \"张三\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，person是一个立即执行的类的实例。\n\n\n# 注意点\n\n（1）严格模式\n\n类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。\n\n（2）不存在提升\n\n类不存在变量提升（hoist），这一点与 ES5 完全不同。\n\nnew Foo(); // ReferenceError\nclass Foo {}\n\n\n1\n2\n\n\n上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。\n\n{\n  let Foo = class {};\n  class Bar extends Foo {\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。\n\n（3）name 属性\n\n由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。\n\nclass Point {}\nPoint.name // \"Point\"\n\n\n1\n2\n\n\nname属性总是返回紧跟在class关键字后面的类名。\n\n（4）Generator 方法\n\n如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。\n\nclass Foo {\n  constructor(...args) {\n    this.args = args;\n  }\n  * [Symbol.iterator]() {\n    for (let arg of this.args) {\n      yield arg;\n    }\n  }\n}\n\nfor (let x of new Foo('hello', 'world')) {\n  console.log(x);\n}\n// hello\n// world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。\n\n（5）this 的指向\n\n类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。\n\nclass Logger {\n  printName(name = 'there') {\n    this.print(`Hello ${name}`);\n  }\n\n  print(text) {\n    console.log(text);\n  }\n}\n\nconst logger = new Logger();\nconst { printName } = logger;\nprintName(); // TypeError: Cannot read property 'print' of undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是undefined），从而导致找不到print方法而报错。\n\n一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。\n\nclass Logger {\n  constructor() {\n    this.printName = this.printName.bind(this);\n  }\n\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n另一种解决方法是使用箭头函数。\n\nclass Obj {\n  constructor() {\n    this.getThis = () => this;\n  }\n}\n\nconst myObj = new Obj();\nmyObj.getThis() === myObj // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n箭头函数内部的this总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以this会总是指向实例对象。\n\n还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。\n\nfunction selfish (target) {\n  const cache = new WeakMap();\n  const handler = {\n    get (target, key) {\n      const value = Reflect.get(target, key);\n      if (typeof value !== 'function') {\n        return value;\n      }\n      if (!cache.has(value)) {\n        cache.set(value, value.bind(target));\n      }\n      return cache.get(value);\n    }\n  };\n  const proxy = new Proxy(target, handler);\n  return proxy;\n}\n\nconst logger = selfish(new Logger());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 静态方法\n\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\n\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nFoo.classMethod() // 'hello'\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\n\n注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。\n\nclass Foo {\n  static bar() {\n    this.baz();\n  }\n  static baz() {\n    console.log('hello');\n  }\n  baz() {\n    console.log('world');\n  }\n}\n\nFoo.bar() // hello\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。\n\n父类的静态方法，可以被子类继承。\n\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n}\n\nBar.classMethod() // 'hello'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。\n\n静态方法也是可以从super对象上调用的。\n\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n  static classMethod() {\n    return super.classMethod() + ', too';\n  }\n}\n\nBar.classMethod() // \"hello, too\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 实例属性的新写法\n\n实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。\n\nclass IncreasingCounter {\n  constructor() {\n    this._count = 0;\n  }\n  get value() {\n    console.log('Getting the current value!');\n    return this._count;\n  }\n  increment() {\n    this._count++;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，实例属性this._count定义在constructor()方法里面。另一种写法是，这个属性也可以定义在类的最顶层，其他都不变。\n\nclass IncreasingCounter {\n  _count = 0;\n  get value() {\n    console.log('Getting the current value!');\n    return this._count;\n  }\n  increment() {\n    this._count++;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，实例属性_count与取值函数value()和increment()方法，处于同一个层级。这时，不需要在实例属性前面加上this。\n\n这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。\n\nclass foo {\n  bar = 'hello';\n  baz = 'world';\n\n  constructor() {\n    // ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面的代码，一眼就能看出，foo类有两个实例属性，一目了然。另外，写起来也比较简洁。\n\n\n# 静态属性\n\n静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。\n\nclass Foo {\n}\n\nFoo.prop = 1;\nFoo.prop // 1\n\n\n1\n2\n3\n4\n5\n\n\n上面的写法为Foo类定义了一个静态属性prop。\n\n目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字。\n\nclass MyClass {\n  static myStaticProp = 42;\n\n  constructor() {\n    console.log(MyClass.myStaticProp); // 42\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这个新写法大大方便了静态属性的表达。\n\n// 老写法\nclass Foo {\n  // ...\n}\nFoo.prop = 1;\n\n// 新写法\nclass Foo {\n  static prop = 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。\n\n\n# 私有方法和私有属性\n\n\n# 现有的解决方案\n\n私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。\n\n一种做法是在命名上加以区别。\n\nclass Widget {\n\n  // 公有方法\n  foo (baz) {\n    this._bar(baz);\n  }\n\n  // 私有方法\n  _bar(baz) {\n    return this.snaf = baz;\n  }\n\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。\n\n另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。\n\nclass Widget {\n  foo (baz) {\n    bar.call(this, baz);\n  }\n\n  // ...\n}\n\nfunction bar(baz) {\n  return this.snaf = baz;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。\n\n还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。\n\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\n\nexport default class myClass{\n\n  // 公有方法\n  foo(baz) {\n    this[bar](baz);\n  }\n\n  // 私有方法\n  [bar](baz) {\n    return this[snaf] = baz;\n  }\n\n  // ...\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，bar和snaf都是Symbol值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，Reflect.ownKeys()依然可以拿到它们。\n\nconst inst = new myClass();\n\nReflect.ownKeys(myClass.prototype)\n// [ 'constructor', 'foo', Symbol(bar) ]\n\n\n1\n2\n3\n4\n\n\n上面代码中，Symbol 值的属性名依然可以从类的外部拿到。\n\n\n# 私有属性的提案\n\n目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。\n\nclass IncreasingCounter {\n  #count = 0;\n  get value() {\n    console.log('Getting the current value!');\n    return this.#count;\n  }\n  increment() {\n    this.#count++;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，#count就是私有属性，只能在类的内部使用（this.#count）。如果在类的外部使用，就会报错。\n\nconst counter = new IncreasingCounter();\ncounter.#count // 报错\ncounter.#count = 42 // 报错\n\n\n1\n2\n3\n\n\n上面代码在类的外部，读取私有属性，就会报错。\n\n下面是另一个例子。\n\nclass Point {\n  #x;\n\n  constructor(x = 0) {\n    this.#x = +x;\n  }\n\n  get x() {\n    return this.#x;\n  }\n\n  set x(value) {\n    this.#x = +value;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，#x就是私有属性，在Point类之外是读取不到这个属性的。由于井号#是属性名的一部分，使用时必须带有#一起使用，所以#x和x是两个不同的属性。\n\n之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。\n\n这种写法不仅可以写私有属性，还可以用来写私有方法。\n\nclass Foo {\n  #a;\n  #b;\n  constructor(a, b) {\n    this.#a = a;\n    this.#b = b;\n  }\n  #sum() {\n    return #a + #b;\n  }\n  printSum() {\n    console.log(this.#sum());\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，#sum()就是一个私有方法。\n\n另外，私有属性也可以设置 getter 和 setter 方法。\n\nclass Counter {\n  #xValue = 0;\n\n  constructor() {\n    super();\n    // ...\n  }\n\n  get #x() { return #xValue; }\n  set #x(value) {\n    this.#xValue = value;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，#x是一个私有属性，它的读写都通过get #x()和set #x()来完成。\n\n私有属性不限于从this引用，只要是在类的内部，实例也可以引用私有属性。\n\nclass Foo {\n  #privateValue = 42;\n  static getPrivateValue(foo) {\n    return foo.#privateValue;\n  }\n}\n\nFoo.getPrivateValue(new Foo()); // 42\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码允许从实例foo上面引用私有属性。\n\n私有属性和私有方法前面，也可以加上static关键字，表示这是一个静态的私有属性或私有方法。\n\nclass FakeMath {\n  static PI = 22 / 7;\n  static #totallyRandomNumber = 4;\n\n  static #computeRandomNumber() {\n    return FakeMath.#totallyRandomNumber;\n  }\n\n  static random() {\n    console.log('I heard you like random numbers…')\n    return FakeMath.#computeRandomNumber();\n  }\n}\n\nFakeMath.PI // 3.142857142857143\nFakeMath.random()\n// I heard you like random numbers…\n// 4\nFakeMath.#totallyRandomNumber // 报错\nFakeMath.#computeRandomNumber() // 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n上面代码中，#totallyRandomNumber是私有属性，#computeRandomNumber()是私有方法，只能在FakeMath这个类的内部调用，外部调用就会报错。\n\n\n# new.target 属性\n\nnew是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。\n\nfunction Person(name) {\n  if (new.target !== undefined) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用 new 命令生成实例');\n  }\n}\n\n// 另一种写法\nfunction Person(name) {\n  if (new.target === Person) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用 new 命令生成实例');\n  }\n}\n\nvar person = new Person('张三'); // 正确\nvar notAPerson = Person.call(person, '张三');  // 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码确保构造函数只能通过new命令调用。\n\nClass 内部调用new.target，返回当前 Class。\n\nclass Rectangle {\n  constructor(length, width) {\n    console.log(new.target === Rectangle);\n    this.length = length;\n    this.width = width;\n  }\n}\n\nvar obj = new Rectangle(3, 4); // 输出 true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n需要注意的是，子类继承父类时，new.target会返回子类。\n\nclass Rectangle {\n  constructor(length, width) {\n    console.log(new.target === Rectangle);\n    // ...\n  }\n}\n\nclass Square extends Rectangle {\n  constructor(length) {\n    super(length, width);\n  }\n}\n\nvar obj = new Square(3); // 输出 false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，new.target会返回子类。\n\n利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。\n\nclass Shape {\n  constructor() {\n    if (new.target === Shape) {\n      throw new Error('本类不能实例化');\n    }\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(length, width) {\n    super();\n    // ...\n  }\n}\n\nvar x = new Shape();  // 报错\nvar y = new Rectangle(3, 4);  // 正确\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，Shape类不能被实例化，只能用于继承。\n\n注意，在函数外部，使用new.target会报错。",normalizedContent:"# class 的基本语法\n\n\n# 简介\n\n\n# 类的由来\n\njavascript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。\n\nfunction point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\npoint.prototype.tostring = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new point(1, 2);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面这种写法跟传统的面向对象语言（比如 c++ 和 java）差异很大，很容易让新学习这门语言的程序员感到困惑。\n\nes6 提供了更接近传统语言的写法，引入了 class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。\n\n基本上，es6 的class可以看作只是一个语法糖，它的绝大部分功能，es5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 es6 的class改写，就是下面这样。\n\nclass point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  tostring() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，es5 的构造函数point，对应 es6 的point类的构造方法。\n\npoint类除了构造方法，还定义了一个tostring方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。\n\nes6 的类，完全可以看作构造函数的另一种写法。\n\nclass point {\n  // ...\n}\n\ntypeof point // \"function\"\npoint === point.prototype.constructor // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码表明，类的数据类型就是函数，类本身就指向构造函数。\n\n使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。\n\nclass bar {\n  dostuff() {\n    console.log('stuff');\n  }\n}\n\nvar b = new bar();\nb.dostuff() // \"stuff\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n构造函数的prototype属性，在 es6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。\n\nclass point {\n  constructor() {\n    // ...\n  }\n\n  tostring() {\n    // ...\n  }\n\n  tovalue() {\n    // ...\n  }\n}\n\n// 等同于\n\npoint.prototype = {\n  constructor() {},\n  tostring() {},\n  tovalue() {},\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在类的实例上面调用方法，其实就是调用原型上的方法。\n\nclass b {}\nlet b = new b();\n\nb.constructor === b.prototype.constructor // true\n\n\n1\n2\n3\n4\n\n\n上面代码中，b是b类的实例，它的constructor方法就是b类原型的constructor方法。\n\n由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。object.assign方法可以很方便地一次向类添加多个方法。\n\nclass point {\n  constructor(){\n    // ...\n  }\n}\n\nobject.assign(point.prototype, {\n  tostring(){},\n  tovalue(){}\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nprototype对象的constructor属性，直接指向“类”的本身，这与 es5 的行为是一致的。\n\npoint.prototype.constructor === point // true\n\n\n1\n\n\n另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。\n\nclass point {\n  constructor(x, y) {\n    // ...\n  }\n\n  tostring() {\n    // ...\n  }\n}\n\nobject.keys(point.prototype)\n// []\nobject.getownpropertynames(point.prototype)\n// [\"constructor\",\"tostring\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，tostring方法是point类内部定义的方法，它是不可枚举的。这一点与 es5 的行为不一致。\n\nvar point = function (x, y) {\n  // ...\n};\n\npoint.prototype.tostring = function() {\n  // ...\n};\n\nobject.keys(point.prototype)\n// [\"tostring\"]\nobject.getownpropertynames(point.prototype)\n// [\"constructor\",\"tostring\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码采用 es5 的写法，tostring方法就是可枚举的。\n\n\n# constructor 方法\n\nconstructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。\n\nclass point {\n}\n\n// 等同于\nclass point {\n  constructor() {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，定义了一个空的类point，javascript 引擎会自动为它添加一个空的constructor方法。\n\nconstructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。\n\nclass foo {\n  constructor() {\n    return object.create(null);\n  }\n}\n\nnew foo() instanceof foo\n// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是foo类的实例。\n\n类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。\n\nclass foo {\n  constructor() {\n    return object.create(null);\n  }\n}\n\nfoo()\n// typeerror: class constructor foo cannot be invoked without 'new'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 类的实例\n\n生成类的实例的写法，与 es5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用class，将会报错。\n\nclass point {\n  // ...\n}\n\n// 报错\nvar point = point(2, 3);\n\n// 正确\nvar point = new point(2, 3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n与 es5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。\n\n//定义类\nclass point {\n\n  constructor(x, y) { // constructor属性定义在原型上\n    this.x = x; // x属性定义在实例上\n    this.y = y; // y属性定义在实例上\n  }\n\n  tostring() { // tostring属性定义在原型上\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n\n}\n\nvar point = new point(2, 3);\n\npoint.tostring() // (2, 3)\n\npoint.hasownproperty('x') // true\npoint.hasownproperty('y') // true\npoint.hasownproperty('tostring') // false\npoint.__proto__.hasownproperty('tostring') // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasownproperty方法返回true，而tostring是原型对象的属性（因为定义在point类上），所以hasownproperty方法返回false。这些都与 es5 的行为保持一致。\n\n与 es5 一样，类的所有实例共享一个原型对象。\n\nvar p1 = new point(2,3);\nvar p2 = new point(3,2);\n\np1.__proto__ === p2.__proto__\n//true\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，p1和p2都是point的实例，它们的原型都是point.prototype，所以__proto__属性是相等的。\n\n这也意味着，可以通过实例的__proto__属性为“类”添加方法。\n\n> __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 js 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 object.getprototypeof 方法来获取实例对象的原型，然后再来为原型添加方法/属性。\n\nvar p1 = new point(2,3);\nvar p2 = new point(3,2);\n\np1.__proto__.printname = function () { return 'oops' };\n\np1.printname() // \"oops\"\np2.printname() // \"oops\"\n\nvar p3 = new point(4,2);\np3.printname() // \"oops\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码在p1的原型上添加了一个printname方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。\n\n\n# 取值函数（getter）和存值函数（setter）\n\n与 es5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n\nclass myclass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n}\n\nlet inst = new myclass();\n\ninst.prop = 123;\n// setter: 123\n\ninst.prop\n// 'getter'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。\n\n存值函数和取值函数是设置在属性的 descriptor 对象上的。\n\nclass customhtmlelement {\n  constructor(element) {\n    this.element = element;\n  }\n\n  get html() {\n    return this.element.innerhtml;\n  }\n\n  set html(value) {\n    this.element.innerhtml = value;\n  }\n}\n\nvar descriptor = object.getownpropertydescriptor(\n  customhtmlelement.prototype, \"html\"\n);\n\n\"get\" in descriptor  // true\n\"set\" in descriptor  // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 es5 完全一致。\n\n\n# 属性表达式\n\n类的属性名，可以采用表达式。\n\nlet methodname = 'getarea';\n\nclass square {\n  constructor(length) {\n    // ...\n  }\n\n  [methodname]() {\n    // ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，square类的方法名getarea，是从表达式得到的。\n\n\n# class 表达式\n\n与函数一样，类也可以使用表达式的形式定义。\n\nconst myclass = class me {\n  getclassname() {\n    return me.name;\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\n上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是me，但是me只在 class 的内部可用，指代当前类。在 class 外部，这个类只能用myclass引用。\n\nlet inst = new myclass();\ninst.getclassname() // me\nme.name // referenceerror: me is not defined\n\n\n1\n2\n3\n\n\n上面代码表示，me只在 class 内部有定义。\n\n如果类的内部没用到的话，可以省略me，也就是可以写成下面的形式。\n\nconst myclass = class { /* ... */ };\n\n\n1\n\n\n采用 class 表达式，可以写出立即执行的 class。\n\nlet person = new class {\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayname() {\n    console.log(this.name);\n  }\n}('张三');\n\nperson.sayname(); // \"张三\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，person是一个立即执行的类的实例。\n\n\n# 注意点\n\n（1）严格模式\n\n类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 es6 实际上把整个语言升级到了严格模式。\n\n（2）不存在提升\n\n类不存在变量提升（hoist），这一点与 es5 完全不同。\n\nnew foo(); // referenceerror\nclass foo {}\n\n\n1\n2\n\n\n上面代码中，foo类使用在前，定义在后，这样会报错，因为 es6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。\n\n{\n  let foo = class {};\n  class bar extends foo {\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面的代码不会报错，因为bar继承foo的时候，foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致bar继承foo的时候，foo还没有定义。\n\n（3）name 属性\n\n由于本质上，es6 的类只是 es5 的构造函数的一层包装，所以函数的许多特性都被class继承，包括name属性。\n\nclass point {}\npoint.name // \"point\"\n\n\n1\n2\n\n\nname属性总是返回紧跟在class关键字后面的类名。\n\n（4）generator 方法\n\n如果某个方法之前加上星号（*），就表示该方法是一个 generator 函数。\n\nclass foo {\n  constructor(...args) {\n    this.args = args;\n  }\n  * [symbol.iterator]() {\n    for (let arg of this.args) {\n      yield arg;\n    }\n  }\n}\n\nfor (let x of new foo('hello', 'world')) {\n  console.log(x);\n}\n// hello\n// world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，foo类的symbol.iterator方法前有一个星号，表示该方法是一个 generator 函数。symbol.iterator方法返回一个foo类的默认遍历器，for...of循环会自动调用这个遍历器。\n\n（5）this 的指向\n\n类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。\n\nclass logger {\n  printname(name = 'there') {\n    this.print(`hello ${name}`);\n  }\n\n  print(text) {\n    console.log(text);\n  }\n}\n\nconst logger = new logger();\nconst { printname } = logger;\nprintname(); // typeerror: cannot read property 'print' of undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，printname方法中的this，默认指向logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是undefined），从而导致找不到print方法而报错。\n\n一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。\n\nclass logger {\n  constructor() {\n    this.printname = this.printname.bind(this);\n  }\n\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n另一种解决方法是使用箭头函数。\n\nclass obj {\n  constructor() {\n    this.getthis = () => this;\n  }\n}\n\nconst myobj = new obj();\nmyobj.getthis() === myobj // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n箭头函数内部的this总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以this会总是指向实例对象。\n\n还有一种解决方法是使用proxy，获取方法的时候，自动绑定this。\n\nfunction selfish (target) {\n  const cache = new weakmap();\n  const handler = {\n    get (target, key) {\n      const value = reflect.get(target, key);\n      if (typeof value !== 'function') {\n        return value;\n      }\n      if (!cache.has(value)) {\n        cache.set(value, value.bind(target));\n      }\n      return cache.get(value);\n    }\n  };\n  const proxy = new proxy(target, handler);\n  return proxy;\n}\n\nconst logger = selfish(new logger());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 静态方法\n\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\n\nclass foo {\n  static classmethod() {\n    return 'hello';\n  }\n}\n\nfoo.classmethod() // 'hello'\n\nvar foo = new foo();\nfoo.classmethod()\n// typeerror: foo.classmethod is not a function\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，foo类的classmethod方法前有static关键字，表明该方法是一个静态方法，可以直接在foo类上调用（foo.classmethod()），而不是在foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\n\n注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。\n\nclass foo {\n  static bar() {\n    this.baz();\n  }\n  static baz() {\n    console.log('hello');\n  }\n  baz() {\n    console.log('world');\n  }\n}\n\nfoo.bar() // hello\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，静态方法bar调用了this.baz，这里的this指的是foo类，而不是foo的实例，等同于调用foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。\n\n父类的静态方法，可以被子类继承。\n\nclass foo {\n  static classmethod() {\n    return 'hello';\n  }\n}\n\nclass bar extends foo {\n}\n\nbar.classmethod() // 'hello'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，父类foo有一个静态方法，子类bar可以调用这个方法。\n\n静态方法也是可以从super对象上调用的。\n\nclass foo {\n  static classmethod() {\n    return 'hello';\n  }\n}\n\nclass bar extends foo {\n  static classmethod() {\n    return super.classmethod() + ', too';\n  }\n}\n\nbar.classmethod() // \"hello, too\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 实例属性的新写法\n\n实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。\n\nclass increasingcounter {\n  constructor() {\n    this._count = 0;\n  }\n  get value() {\n    console.log('getting the current value!');\n    return this._count;\n  }\n  increment() {\n    this._count++;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，实例属性this._count定义在constructor()方法里面。另一种写法是，这个属性也可以定义在类的最顶层，其他都不变。\n\nclass increasingcounter {\n  _count = 0;\n  get value() {\n    console.log('getting the current value!');\n    return this._count;\n  }\n  increment() {\n    this._count++;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，实例属性_count与取值函数value()和increment()方法，处于同一个层级。这时，不需要在实例属性前面加上this。\n\n这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。\n\nclass foo {\n  bar = 'hello';\n  baz = 'world';\n\n  constructor() {\n    // ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面的代码，一眼就能看出，foo类有两个实例属性，一目了然。另外，写起来也比较简洁。\n\n\n# 静态属性\n\n静态属性指的是 class 本身的属性，即class.propname，而不是定义在实例对象（this）上的属性。\n\nclass foo {\n}\n\nfoo.prop = 1;\nfoo.prop // 1\n\n\n1\n2\n3\n4\n5\n\n\n上面的写法为foo类定义了一个静态属性prop。\n\n目前，只有这种写法可行，因为 es6 明确规定，class 内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字。\n\nclass myclass {\n  static mystaticprop = 42;\n\n  constructor() {\n    console.log(myclass.mystaticprop); // 42\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这个新写法大大方便了静态属性的表达。\n\n// 老写法\nclass foo {\n  // ...\n}\nfoo.prop = 1;\n\n// 新写法\nclass foo {\n  static prop = 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。\n\n\n# 私有方法和私有属性\n\n\n# 现有的解决方案\n\n私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 es6 不提供，只能通过变通方法模拟实现。\n\n一种做法是在命名上加以区别。\n\nclass widget {\n\n  // 公有方法\n  foo (baz) {\n    this._bar(baz);\n  }\n\n  // 私有方法\n  _bar(baz) {\n    return this.snaf = baz;\n  }\n\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。\n\n另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。\n\nclass widget {\n  foo (baz) {\n    bar.call(this, baz);\n  }\n\n  // ...\n}\n\nfunction bar(baz) {\n  return this.snaf = baz;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。\n\n还有一种方法是利用symbol值的唯一性，将私有方法的名字命名为一个symbol值。\n\nconst bar = symbol('bar');\nconst snaf = symbol('snaf');\n\nexport default class myclass{\n\n  // 公有方法\n  foo(baz) {\n    this[bar](baz);\n  }\n\n  // 私有方法\n  [bar](baz) {\n    return this[snaf] = baz;\n  }\n\n  // ...\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，bar和snaf都是symbol值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，reflect.ownkeys()依然可以拿到它们。\n\nconst inst = new myclass();\n\nreflect.ownkeys(myclass.prototype)\n// [ 'constructor', 'foo', symbol(bar) ]\n\n\n1\n2\n3\n4\n\n\n上面代码中，symbol 值的属性名依然可以从类的外部拿到。\n\n\n# 私有属性的提案\n\n目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。\n\nclass increasingcounter {\n  #count = 0;\n  get value() {\n    console.log('getting the current value!');\n    return this.#count;\n  }\n  increment() {\n    this.#count++;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，#count就是私有属性，只能在类的内部使用（this.#count）。如果在类的外部使用，就会报错。\n\nconst counter = new increasingcounter();\ncounter.#count // 报错\ncounter.#count = 42 // 报错\n\n\n1\n2\n3\n\n\n上面代码在类的外部，读取私有属性，就会报错。\n\n下面是另一个例子。\n\nclass point {\n  #x;\n\n  constructor(x = 0) {\n    this.#x = +x;\n  }\n\n  get x() {\n    return this.#x;\n  }\n\n  set x(value) {\n    this.#x = +value;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，#x就是私有属性，在point类之外是读取不到这个属性的。由于井号#是属性名的一部分，使用时必须带有#一起使用，所以#x和x是两个不同的属性。\n\n之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 javascript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。另外，ruby 语言使用@表示私有属性，es6 没有用这个符号而使用#，是因为@已经被留给了 decorator。\n\n这种写法不仅可以写私有属性，还可以用来写私有方法。\n\nclass foo {\n  #a;\n  #b;\n  constructor(a, b) {\n    this.#a = a;\n    this.#b = b;\n  }\n  #sum() {\n    return #a + #b;\n  }\n  printsum() {\n    console.log(this.#sum());\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，#sum()就是一个私有方法。\n\n另外，私有属性也可以设置 getter 和 setter 方法。\n\nclass counter {\n  #xvalue = 0;\n\n  constructor() {\n    super();\n    // ...\n  }\n\n  get #x() { return #xvalue; }\n  set #x(value) {\n    this.#xvalue = value;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，#x是一个私有属性，它的读写都通过get #x()和set #x()来完成。\n\n私有属性不限于从this引用，只要是在类的内部，实例也可以引用私有属性。\n\nclass foo {\n  #privatevalue = 42;\n  static getprivatevalue(foo) {\n    return foo.#privatevalue;\n  }\n}\n\nfoo.getprivatevalue(new foo()); // 42\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码允许从实例foo上面引用私有属性。\n\n私有属性和私有方法前面，也可以加上static关键字，表示这是一个静态的私有属性或私有方法。\n\nclass fakemath {\n  static pi = 22 / 7;\n  static #totallyrandomnumber = 4;\n\n  static #computerandomnumber() {\n    return fakemath.#totallyrandomnumber;\n  }\n\n  static random() {\n    console.log('i heard you like random numbers…')\n    return fakemath.#computerandomnumber();\n  }\n}\n\nfakemath.pi // 3.142857142857143\nfakemath.random()\n// i heard you like random numbers…\n// 4\nfakemath.#totallyrandomnumber // 报错\nfakemath.#computerandomnumber() // 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n上面代码中，#totallyrandomnumber是私有属性，#computerandomnumber()是私有方法，只能在fakemath这个类的内部调用，外部调用就会报错。\n\n\n# new.target 属性\n\nnew是从构造函数生成实例对象的命令。es6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。\n\nfunction person(name) {\n  if (new.target !== undefined) {\n    this.name = name;\n  } else {\n    throw new error('必须使用 new 命令生成实例');\n  }\n}\n\n// 另一种写法\nfunction person(name) {\n  if (new.target === person) {\n    this.name = name;\n  } else {\n    throw new error('必须使用 new 命令生成实例');\n  }\n}\n\nvar person = new person('张三'); // 正确\nvar notaperson = person.call(person, '张三');  // 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码确保构造函数只能通过new命令调用。\n\nclass 内部调用new.target，返回当前 class。\n\nclass rectangle {\n  constructor(length, width) {\n    console.log(new.target === rectangle);\n    this.length = length;\n    this.width = width;\n  }\n}\n\nvar obj = new rectangle(3, 4); // 输出 true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n需要注意的是，子类继承父类时，new.target会返回子类。\n\nclass rectangle {\n  constructor(length, width) {\n    console.log(new.target === rectangle);\n    // ...\n  }\n}\n\nclass square extends rectangle {\n  constructor(length) {\n    super(length, width);\n  }\n}\n\nvar obj = new square(3); // 输出 false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，new.target会返回子类。\n\n利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。\n\nclass shape {\n  constructor() {\n    if (new.target === shape) {\n      throw new error('本类不能实例化');\n    }\n  }\n}\n\nclass rectangle extends shape {\n  constructor(length, width) {\n    super();\n    // ...\n  }\n}\n\nvar x = new shape();  // 报错\nvar y = new rectangle(3, 4);  // 正确\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，shape类不能被实例化，只能用于继承。\n\n注意，在函数外部，使用new.target会报错。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Module 的语法",frontmatter:{title:"Module 的语法",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/efe2fb04eb8ac5fb",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/23.Module%20%E7%9A%84%E8%AF%AD%E6%B3%95.html",relativePath:"《ES6 教程》笔记/23.Module 的语法.md",key:"v-ad45f6fa",path:"/pages/efe2fb04eb8ac5fb/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:17},{level:2,title:"严格模式",slug:"严格模式",normalizedTitle:"严格模式",charIndex:1328},{level:2,title:"export 命令",slug:"export-命令",normalizedTitle:"export 命令",charIndex:1904},{level:2,title:"import 命令",slug:"import-命令",normalizedTitle:"import 命令",charIndex:3872},{level:2,title:"模块的整体加载-(星号*)",slug:"模块的整体加载-星号",normalizedTitle:"模块的整体加载-(星号*)",charIndex:5996},{level:2,title:"export default 命令",slug:"export-default-命令",normalizedTitle:"export default 命令",charIndex:6797},{level:2,title:"export 与 import 的复合写法",slug:"export-与-import-的复合写法",normalizedTitle:"export 与 import 的复合写法",charIndex:9298},{level:2,title:"模块的继承",slug:"模块的继承",normalizedTitle:"模块的继承",charIndex:10367},{level:2,title:"跨模块常量",slug:"跨模块常量",normalizedTitle:"跨模块常量",charIndex:10989},{level:2,title:"import()",slug:"import",normalizedTitle:"import()",charIndex:11948},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:11961},{level:3,title:"适用场合",slug:"适用场合",normalizedTitle:"适用场合",charIndex:13119},{level:3,title:"注意点",slug:"注意点",normalizedTitle:"注意点",charIndex:13710}],excerpt:'<h1 id="module-的语法"><a class="header-anchor" href="#module-的语法">#</a> Module 的语法</h1>\n<h2 id="概述"><a class="header-anchor" href="#概述">#</a> 概述</h2>\n<p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\n',headersStr:"概述 严格模式 export 命令 import 命令 模块的整体加载-(星号*) export default 命令 export 与 import 的复合写法 模块的继承 跨模块常量 import() 简介 适用场合 注意点",content:"# Module 的语法\n\n\n# 概述\n\n历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\n\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\n\n// CommonJS模块\nlet { stat, exists, readFile } = require('fs');\n\n// 等同于\nlet _fs = require('fs');\nlet stat = _fs.stat;\nlet exists = _fs.exists;\nlet readfile = _fs.readfile;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。\n\nES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。\n\n// ES6模块\nimport { stat, exists, readFile } from 'fs';\n\n\n1\n2\n\n\n上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，**即 ES6 可以在编译时就完成模块加载，**效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。\n\n由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。\n\n除了静态加载带来的各种好处，ES6 模块还有以下好处。\n\n * 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。\n * 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。\n * 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。\n\n本章介绍 ES6 模块的语法，下一章介绍如何在浏览器和 Node 之中，加载 ES6 模块。\n\n\n# 严格模式\n\nES6 的模块自动采用严格模式，不管你有没有在模块头部加上\"use strict\";。\n\n严格模式主要有以下限制。\n\n * 变量必须声明后再使用\n * 函数的参数不能有同名属性，否则报错\n * 不能使用with语句\n * 不能对只读属性赋值，否则报错\n * 不能使用前缀 0 表示八进制数，否则报错\n * 不能删除不可删除的属性，否则报错\n * 不能删除变量delete prop，会报错，只能删除属性delete global[prop]\n * eval不会在它的外层作用域引入变量\n * eval和arguments不能被重新赋值\n * arguments不会自动反映函数参数的变化\n * 不能使用arguments.callee\n * 不能使用arguments.caller\n * 禁止this指向全局对象\n * 不能使用fn.caller和fn.arguments获取函数调用的堆栈\n * 增加了保留字（比如protected、static和interface）\n\n上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。\n\n其中，尤其需要注意this的限制。ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。\n\n\n# export 命令\n\n模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。\n\n// profile.js\nexport var firstName = 'Michael';\nexport var lastName = 'Jackson';\nexport var year = 1958;\n\n\n1\n2\n3\n4\n\n\n上面代码是profile.js文件，保存了用户信息。ES6 将其视为一个模块，里面用export命令对外部输出了三个变量。\n\nexport的写法，除了像上面这样，还有另外一种。\n\n// profile.js\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexport { firstName, lastName, year };\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。\n\nexport命令除了输出变量，还可以输出函数或类（class）。\n\nexport function multiply(x, y) {\n  return x * y;\n};\n\n\n1\n2\n3\n\n\n上面代码对外输出一个函数multiply。\n\n通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。\n\nfunction v1() { ... }\nfunction v2() { ... }\n\nexport {\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。\n\n需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。\n\n// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。\n\n// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。\n\n同样的，function和class的输出，也必须遵守这样的写法。\n\n// 报错\nfunction f() {}\nexport f;\n\n// 正确\nexport function f() {};\n\n// 正确\nfunction f() {}\nexport {f};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。\n\nexport var foo = 'bar';\nsetTimeout(() => foo = 'baz', 500);\n\n\n1\n2\n\n\n上面代码输出变量foo，值为bar，500 毫秒之后变成baz。\n\n这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新，详见下文《Module 的加载实现》一节。\n\n最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。\n\nfunction foo() {\n  export default 'bar' // SyntaxError\n}\nfoo()\n\n\n1\n2\n3\n4\n\n\n上面代码中，export语句放在函数之中，结果报错。\n\n\n# import 命令\n\n使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。\n\n// main.js\nimport { firstName, lastName, year } from './profile.js';\n\nfunction setName(element) {\n  element.textContent = firstName + ' ' + lastName;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。\n\n如果想为输入的变量重新取一个名字**，import命令要使用as关键字，将输入的变量重命名。**\n\nimport { lastName as surname } from './profile.js';\n\n\n1\n\n\nimport命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。\n\nimport {a} from './xxx.js'\n\na = {}; // Syntax Error : 'a' is read-only;\n\n\n1\n2\n3\n\n\n上面代码中，脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口。但是**，如果a是一个对象，改写a的属性是允许的**。\n\nimport {a} from './xxx.js'\n\na.foo = 'hello'; // 合法操作\n\n\n1\n2\n3\n\n\n上面代码中，a的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。\n\nimport后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。\n\nimport {myMethod} from 'util';\n\n\n1\n\n\n上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。\n\n注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。\n\nfoo();\n\nimport { foo } from 'my_module';\n\n\n1\n2\n3\n\n\n上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。\n\n由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。\n\n// 报错\nimport { 'f' + 'oo' } from 'my_module';\n\n// 报错\nlet module = 'my_module';\nimport { foo } from module;\n\n// 报错\nif (x === 1) {\n  import { foo } from 'module1';\n} else {\n  import { foo } from 'module2';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。\n\n最后，import语句会执行所加载的模块，因此可以有下面的写法。\n\nimport 'lodash';\n\n\n1\n\n\n上面代码仅仅执行lodash模块，但是不输入任何值。\n\n如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。\n\nimport 'lodash';\nimport 'lodash';\n\n\n1\n2\n\n\n上面代码加载了两次lodash，但是只会执行一次。\n\nimport { foo } from 'my_module';\nimport { bar } from 'my_module';\n\n// 等同于\nimport { foo, bar } from 'my_module';\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式。\n\n目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。\n\nrequire('core-js/modules/es6.symbol');\nrequire('core-js/modules/es6.promise');\nimport React from 'React';\n\n\n1\n2\n3\n\n\n\n# 模块的整体加载-(星号*)\n\n除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。\n\n下面是一个circle.js文件，它输出两个方法area和circumference。\n\n// circle.js\n\nexport function area(radius) {\n  return Math.PI * radius * radius;\n}\n\nexport function circumference(radius) {\n  return 2 * Math.PI * radius;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n现在，加载这个模块。\n\n// main.js\n\nimport { area, circumference } from './circle';\n\nconsole.log('圆面积：' + area(4));\nconsole.log('圆周长：' + circumference(14));\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面写法是逐一指定要加载的方法，整体加载的写法如下。\n\nimport * as circle from './circle';\n\nconsole.log('圆面积：' + circle.area(4));\nconsole.log('圆周长：' + circle.circumference(14));\n\n\n1\n2\n3\n4\n\n\n注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。\n\nimport * as circle from './circle';\n\n// 下面两行都是不允许的\ncircle.foo = 'hello';\ncircle.area = function () {};\n\n\n1\n2\n3\n4\n5\n\n\n\n# export default 命令\n\n从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。\n\n为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到**export default命令，为模块指定默认输出。**\n\n// export-default.js\nexport default function () {\n  console.log('foo');\n}\n\n\n1\n2\n3\n4\n\n\n上面代码是一个模块文件export-default.js，它的默认输出是一个函数。\n\n其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。\n\n// import-default.js\nimport customName from './export-default';\ncustomName(); // 'foo'\n\n\n1\n2\n3\n\n\n上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。\n\nexport default命令用在非匿名函数前，也是可以的。\n\n// export-default.js\nexport default function foo() {\n  console.log('foo');\n}\n\n// 或者写成\n\nfunction foo() {\n  console.log('foo');\n}\n\nexport default foo;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。\n\n下面比较一下默认输出和正常输出。\n\n// 第一组\nexport default function crc32() { // 输出\n  // ...\n}\n\nimport crc32 from 'crc32'; // 输入\n\n// 第二组\nexport function crc32() { // 输出\n  // ...\n};\n\nimport {crc32} from 'crc32'; // 输入\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。\n\nexport default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。\n\n**本质上，export default就是输出一个叫做default的变量或方法，**然后系统允许你为它取任意名字。所以，下面的写法是有效的。\n\n// modules.js\nfunction add(x, y) {\n  return x * y;\n}\nexport {add as default};\n// 等同于\n// export default add;\n\n// app.js\nimport { default as foo } from 'modules';\n// 等同于\n// import foo from 'modules';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。\n\n// 正确\nexport var a = 1;\n\n// 正确\nvar a = 1;\nexport default a;\n\n// 错误\nexport default var a = 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。\n\n同样地，因为export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。\n\n// 正确\nexport default 42;\n\n// 报错\nexport 42;\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为default。\n\n有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。\n\nimport _ from 'lodash';\n\n\n1\n\n\n如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样。\n\nimport _, { each, forEach } from 'lodash';\n\n\n1\n\n\n对应上面代码的export语句如下。\n\nexport default function (obj) {\n  // ···\n}\n\nexport function each(obj, iterator, context) {\n  // ···\n}\n\nexport { each as forEach };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码的最后一行的意思是，暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法。\n\nexport default也可以用来输出类。\n\n// MyClass.js\nexport default class { ... }\n\n// main.js\nimport MyClass from 'MyClass';\nlet o = new MyClass();\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# export 与 import 的复合写法\n\n如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。\n\nexport { foo, bar } from 'my_module';\n\n// 可以简单理解为\nimport { foo, bar } from 'my_module';\nexport { foo, bar };\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，export和import语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。\n\n模块的接口改名和整体输出，也可以采用这种写法。\n\n// 接口改名\nexport { foo as myFoo } from 'my_module';\n\n// 整体输出\nexport * from 'my_module';\n\n\n1\n2\n3\n4\n5\n\n\n默认接口的写法如下。\n\nexport { default } from 'foo';\n\n\n1\n\n\n具名接口改为默认接口的写法如下。\n\nexport { es6 as default } from './someModule';\n\n// 等同于\nimport { es6 } from './someModule';\nexport default es6;\n\n\n1\n2\n3\n4\n5\n\n\n同样地，默认接口也可以改名为具名接口。\n\nexport { default as es6 } from './someModule';\n\n\n1\n\n\n下面三种import语句，没有对应的复合写法。\n\nimport * as someIdentifier from \"someModule\";\nimport someIdentifier from \"someModule\";\nimport someIdentifier, { namedIdentifier } from \"someModule\";\n\n\n1\n2\n3\n\n\n为了做到形式的对称，现在有提案，提出补上这三种复合写法。\n\nexport * as someIdentifier from \"someModule\";\nexport someIdentifier from \"someModule\";\nexport someIdentifier, { namedIdentifier } from \"someModule\";\n\n\n1\n2\n3\n\n\n\n# 模块的继承\n\n模块之间也可以继承。\n\n假设有一个circleplus模块，继承了circle模块。\n\n// circleplus.js\n\nexport * from 'circle';\nexport var e = 2.71828182846;\nexport default function(x) {\n  return Math.exp(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。\n\n这时，也可以将circle的属性或方法，改名后再输出。\n\n// circleplus.js\n\nexport { area as circleArea } from 'circle';\n\n\n1\n2\n3\n\n\n上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。\n\n加载上面模块的写法如下。\n\n// main.js\n\nimport * as math from 'circleplus';\nimport exp from 'circleplus';\nconsole.log(exp(math.e));\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。\n\n\n# 跨模块常量\n\n本书介绍const命令的时候说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。\n\n// constants.js 模块\nexport const A = 1;\nexport const B = 3;\nexport const C = 4;\n\n// test1.js 模块\nimport * as constants from './constants';\nconsole.log(constants.A); // 1\nconsole.log(constants.B); // 3\n\n// test2.js 模块\nimport {A, B} from './constants';\nconsole.log(A); // 1\nconsole.log(B); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。\n\n// constants/db.js\nexport const db = {\n  url: 'http://my.couchdbserver.local:5984',\n  admin_username: 'admin',\n  admin_password: 'admin password'\n};\n\n// constants/user.js\nexport const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n然后，将这些文件输出的常量，合并在index.js里面。\n\n// constants/index.js\nexport {db} from './db';\nexport {users} from './users';\n\n\n1\n2\n3\n\n\n使用的时候，直接加载index.js就可以了。\n\n// script.js\nimport {db, users} from './constants/index';\n\n\n1\n2\n\n\n\n# import()\n\n\n# 简介\n\n前面介绍过，import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。\n\n// 报错\nif (x === 2) {\n  import MyModual from './myModual';\n}\n\n\n1\n2\n3\n4\n\n\n上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。\n\n这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。\n\nconst path = './' + fileName;\nconst myModual = require(path);\n\n\n1\n2\n\n\n上面的语句就是动态加载，require到底加载哪一个模块，只有运行时才知道。import命令做不到这一点。\n\nES2020提案 引入import()函数，支持动态加载模块。\n\nimport(specifier)\n\n\n1\n\n\n上面代码中，import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。\n\nimport()返回一个 Promise 对象。下面是一个例子。\n\nconst main = document.querySelector('main');\n\nimport(`./section-modules/${someVariable}.js`)\n  .then(module => {\n    module.loadPageInto(main);\n  })\n  .catch(err => {\n    main.textContent = err.message;\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nimport()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。\n\n\n# 适用场合\n\n下面是import()的一些适用场合。\n\n（1）按需加载。\n\nimport()可以在需要的时候，再加载某个模块。\n\nbutton.addEventListener('click', event => {\n  import('./dialogBox.js')\n  .then(dialogBox => {\n    dialogBox.open();\n  })\n  .catch(error => {\n    /* Error handling */\n  })\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，import()方法放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。\n\n（2）条件加载\n\nimport()可以放在if代码块，根据不同的情况，加载不同的模块。\n\nif (condition) {\n  import('moduleA').then(...);\n} else {\n  import('moduleB').then(...);\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。\n\n（3）动态的模块路径\n\nimport()允许模块路径动态生成。\n\nimport(f())\n.then(...);\n\n\n1\n2\n\n\n上面代码中，根据函数f的返回结果，加载不同的模块。\n\n\n# 注意点\n\nimport()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。\n\nimport('./myModule.js')\n.then(({export1, export2}) => {\n  // ...·\n});\n\n\n1\n2\n3\n4\n\n\n上面代码中，export1和export2都是myModule.js的输出接口，可以解构获得。\n\n如果模块有default输出接口，可以用参数直接获得。\n\nimport('./myModule.js')\n.then(myModule => {\n  console.log(myModule.default);\n});\n\n\n1\n2\n3\n4\n\n\n上面的代码也可以使用具名输入的形式。\n\nimport('./myModule.js')\n.then(({default: theDefault}) => {\n  console.log(theDefault);\n});\n\n\n1\n2\n3\n4\n\n\n如果想同时加载多个模块，可以采用下面的写法。\n\nPromise.all([\n  import('./module1.js'),\n  import('./module2.js'),\n  import('./module3.js'),\n])\n.then(([module1, module2, module3]) => {\n   ···\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport()也可以用在 async 函数之中。\n\nasync function main() {\n  const myModule = await import('./myModule.js');\n  const {export1, export2} = await import('./myModule.js');\n  const [module1, module2, module3] =\n    await Promise.all([\n      import('./module1.js'),\n      import('./module2.js'),\n      import('./module3.js'),\n    ]);\n}\nmain();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",normalizedContent:"# module 的语法\n\n\n# 概述\n\n历史上，javascript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 ruby 的require、python 的import，甚至就连 css 都有@import，但是 javascript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 es6 之前，社区制定了一些模块加载方案，最主要的有 commonjs 和 amd 两种。前者用于服务器，后者用于浏览器。es6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 commonjs 和 amd 规范，成为浏览器和服务器通用的模块解决方案。\n\nes6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。commonjs 和 amd 模块，都只能在运行时确定这些东西。比如，commonjs 模块就是对象，输入时必须查找对象属性。\n\n// commonjs模块\nlet { stat, exists, readfile } = require('fs');\n\n// 等同于\nlet _fs = require('fs');\nlet stat = _fs.stat;\nlet exists = _fs.exists;\nlet readfile = _fs.readfile;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。\n\nes6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。\n\n// es6模块\nimport { stat, exists, readfile } from 'fs';\n\n\n1\n2\n\n\n上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，**即 es6 可以在编译时就完成模块加载，**效率要比 commonjs 模块的加载方式高。当然，这也导致了没法引用 es6 模块本身，因为它不是对象。\n\n由于 es6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 javascript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。\n\n除了静态加载带来的各种好处，es6 模块还有以下好处。\n\n * 不再需要umd模块格式了，将来服务器和浏览器都会支持 es6 模块格式。目前，通过各种工具库，其实已经做到了这一点。\n * 将来浏览器的新 api 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。\n * 不再需要对象作为命名空间（比如math对象），未来这些功能可以通过模块提供。\n\n本章介绍 es6 模块的语法，下一章介绍如何在浏览器和 node 之中，加载 es6 模块。\n\n\n# 严格模式\n\nes6 的模块自动采用严格模式，不管你有没有在模块头部加上\"use strict\";。\n\n严格模式主要有以下限制。\n\n * 变量必须声明后再使用\n * 函数的参数不能有同名属性，否则报错\n * 不能使用with语句\n * 不能对只读属性赋值，否则报错\n * 不能使用前缀 0 表示八进制数，否则报错\n * 不能删除不可删除的属性，否则报错\n * 不能删除变量delete prop，会报错，只能删除属性delete global[prop]\n * eval不会在它的外层作用域引入变量\n * eval和arguments不能被重新赋值\n * arguments不会自动反映函数参数的变化\n * 不能使用arguments.callee\n * 不能使用arguments.caller\n * 禁止this指向全局对象\n * 不能使用fn.caller和fn.arguments获取函数调用的堆栈\n * 增加了保留字（比如protected、static和interface）\n\n上面这些限制，模块都必须遵守。由于严格模式是 es5 引入的，不属于 es6，所以请参阅相关 es5 书籍，本书不再详细介绍了。\n\n其中，尤其需要注意this的限制。es6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。\n\n\n# export 命令\n\n模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 js 文件，里面使用export命令输出变量。\n\n// profile.js\nexport var firstname = 'michael';\nexport var lastname = 'jackson';\nexport var year = 1958;\n\n\n1\n2\n3\n4\n\n\n上面代码是profile.js文件，保存了用户信息。es6 将其视为一个模块，里面用export命令对外部输出了三个变量。\n\nexport的写法，除了像上面这样，还有另外一种。\n\n// profile.js\nvar firstname = 'michael';\nvar lastname = 'jackson';\nvar year = 1958;\n\nexport { firstname, lastname, year };\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。\n\nexport命令除了输出变量，还可以输出函数或类（class）。\n\nexport function multiply(x, y) {\n  return x * y;\n};\n\n\n1\n2\n3\n\n\n上面代码对外输出一个函数multiply。\n\n通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。\n\nfunction v1() { ... }\nfunction v2() { ... }\n\nexport {\n  v1 as streamv1,\n  v2 as streamv2,\n  v2 as streamlatestversion\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。\n\n需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。\n\n// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。\n\n// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。\n\n同样的，function和class的输出，也必须遵守这样的写法。\n\n// 报错\nfunction f() {}\nexport f;\n\n// 正确\nexport function f() {};\n\n// 正确\nfunction f() {}\nexport {f};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。\n\nexport var foo = 'bar';\nsettimeout(() => foo = 'baz', 500);\n\n\n1\n2\n\n\n上面代码输出变量foo，值为bar，500 毫秒之后变成baz。\n\n这一点与 commonjs 规范完全不同。commonjs 模块输出的是值的缓存，不存在动态更新，详见下文《module 的加载实现》一节。\n\n最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 es6 模块的设计初衷。\n\nfunction foo() {\n  export default 'bar' // syntaxerror\n}\nfoo()\n\n\n1\n2\n3\n4\n\n\n上面代码中，export语句放在函数之中，结果报错。\n\n\n# import 命令\n\n使用export命令定义了模块的对外接口以后，其他 js 文件就可以通过import命令加载这个模块。\n\n// main.js\nimport { firstname, lastname, year } from './profile.js';\n\nfunction setname(element) {\n  element.textcontent = firstname + ' ' + lastname;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。\n\n如果想为输入的变量重新取一个名字**，import命令要使用as关键字，将输入的变量重命名。**\n\nimport { lastname as surname } from './profile.js';\n\n\n1\n\n\nimport命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。\n\nimport {a} from './xxx.js'\n\na = {}; // syntax error : 'a' is read-only;\n\n\n1\n2\n3\n\n\n上面代码中，脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口。但是**，如果a是一个对象，改写a的属性是允许的**。\n\nimport {a} from './xxx.js'\n\na.foo = 'hello'; // 合法操作\n\n\n1\n2\n3\n\n\n上面代码中，a的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。\n\nimport后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 javascript 引擎该模块的位置。\n\nimport {mymethod} from 'util';\n\n\n1\n\n\n上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。\n\n注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。\n\nfoo();\n\nimport { foo } from 'my_module';\n\n\n1\n2\n3\n\n\n上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。\n\n由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。\n\n// 报错\nimport { 'f' + 'oo' } from 'my_module';\n\n// 报错\nlet module = 'my_module';\nimport { foo } from module;\n\n// 报错\nif (x === 1) {\n  import { foo } from 'module1';\n} else {\n  import { foo } from 'module2';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。\n\n最后，import语句会执行所加载的模块，因此可以有下面的写法。\n\nimport 'lodash';\n\n\n1\n\n\n上面代码仅仅执行lodash模块，但是不输入任何值。\n\n如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。\n\nimport 'lodash';\nimport 'lodash';\n\n\n1\n2\n\n\n上面代码加载了两次lodash，但是只会执行一次。\n\nimport { foo } from 'my_module';\nimport { bar } from 'my_module';\n\n// 等同于\nimport { foo, bar } from 'my_module';\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 singleton 模式。\n\n目前阶段，通过 babel 转码，commonjs 模块的require命令和 es6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。\n\nrequire('core-js/modules/es6.symbol');\nrequire('core-js/modules/es6.promise');\nimport react from 'react';\n\n\n1\n2\n3\n\n\n\n# 模块的整体加载-(星号*)\n\n除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。\n\n下面是一个circle.js文件，它输出两个方法area和circumference。\n\n// circle.js\n\nexport function area(radius) {\n  return math.pi * radius * radius;\n}\n\nexport function circumference(radius) {\n  return 2 * math.pi * radius;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n现在，加载这个模块。\n\n// main.js\n\nimport { area, circumference } from './circle';\n\nconsole.log('圆面积：' + area(4));\nconsole.log('圆周长：' + circumference(14));\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面写法是逐一指定要加载的方法，整体加载的写法如下。\n\nimport * as circle from './circle';\n\nconsole.log('圆面积：' + circle.area(4));\nconsole.log('圆周长：' + circle.circumference(14));\n\n\n1\n2\n3\n4\n\n\n注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。\n\nimport * as circle from './circle';\n\n// 下面两行都是不允许的\ncircle.foo = 'hello';\ncircle.area = function () {};\n\n\n1\n2\n3\n4\n5\n\n\n\n# export default 命令\n\n从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。\n\n为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到**export default命令，为模块指定默认输出。**\n\n// export-default.js\nexport default function () {\n  console.log('foo');\n}\n\n\n1\n2\n3\n4\n\n\n上面代码是一个模块文件export-default.js，它的默认输出是一个函数。\n\n其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。\n\n// import-default.js\nimport customname from './export-default';\ncustomname(); // 'foo'\n\n\n1\n2\n3\n\n\n上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。\n\nexport default命令用在非匿名函数前，也是可以的。\n\n// export-default.js\nexport default function foo() {\n  console.log('foo');\n}\n\n// 或者写成\n\nfunction foo() {\n  console.log('foo');\n}\n\nexport default foo;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。\n\n下面比较一下默认输出和正常输出。\n\n// 第一组\nexport default function crc32() { // 输出\n  // ...\n}\n\nimport crc32 from 'crc32'; // 输入\n\n// 第二组\nexport function crc32() { // 输出\n  // ...\n};\n\nimport {crc32} from 'crc32'; // 输入\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。\n\nexport default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。\n\n**本质上，export default就是输出一个叫做default的变量或方法，**然后系统允许你为它取任意名字。所以，下面的写法是有效的。\n\n// modules.js\nfunction add(x, y) {\n  return x * y;\n}\nexport {add as default};\n// 等同于\n// export default add;\n\n// app.js\nimport { default as foo } from 'modules';\n// 等同于\n// import foo from 'modules';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。\n\n// 正确\nexport var a = 1;\n\n// 正确\nvar a = 1;\nexport default a;\n\n// 错误\nexport default var a = 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。\n\n同样地，因为export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。\n\n// 正确\nexport default 42;\n\n// 报错\nexport 42;\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为default。\n\n有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。\n\nimport _ from 'lodash';\n\n\n1\n\n\n如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样。\n\nimport _, { each, foreach } from 'lodash';\n\n\n1\n\n\n对应上面代码的export语句如下。\n\nexport default function (obj) {\n  // ···\n}\n\nexport function each(obj, iterator, context) {\n  // ···\n}\n\nexport { each as foreach };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码的最后一行的意思是，暴露出foreach接口，默认指向each接口，即foreach和each指向同一个方法。\n\nexport default也可以用来输出类。\n\n// myclass.js\nexport default class { ... }\n\n// main.js\nimport myclass from 'myclass';\nlet o = new myclass();\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# export 与 import 的复合写法\n\n如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。\n\nexport { foo, bar } from 'my_module';\n\n// 可以简单理解为\nimport { foo, bar } from 'my_module';\nexport { foo, bar };\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，export和import语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。\n\n模块的接口改名和整体输出，也可以采用这种写法。\n\n// 接口改名\nexport { foo as myfoo } from 'my_module';\n\n// 整体输出\nexport * from 'my_module';\n\n\n1\n2\n3\n4\n5\n\n\n默认接口的写法如下。\n\nexport { default } from 'foo';\n\n\n1\n\n\n具名接口改为默认接口的写法如下。\n\nexport { es6 as default } from './somemodule';\n\n// 等同于\nimport { es6 } from './somemodule';\nexport default es6;\n\n\n1\n2\n3\n4\n5\n\n\n同样地，默认接口也可以改名为具名接口。\n\nexport { default as es6 } from './somemodule';\n\n\n1\n\n\n下面三种import语句，没有对应的复合写法。\n\nimport * as someidentifier from \"somemodule\";\nimport someidentifier from \"somemodule\";\nimport someidentifier, { namedidentifier } from \"somemodule\";\n\n\n1\n2\n3\n\n\n为了做到形式的对称，现在有提案，提出补上这三种复合写法。\n\nexport * as someidentifier from \"somemodule\";\nexport someidentifier from \"somemodule\";\nexport someidentifier, { namedidentifier } from \"somemodule\";\n\n\n1\n2\n3\n\n\n\n# 模块的继承\n\n模块之间也可以继承。\n\n假设有一个circleplus模块，继承了circle模块。\n\n// circleplus.js\n\nexport * from 'circle';\nexport var e = 2.71828182846;\nexport default function(x) {\n  return math.exp(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。\n\n这时，也可以将circle的属性或方法，改名后再输出。\n\n// circleplus.js\n\nexport { area as circlearea } from 'circle';\n\n\n1\n2\n3\n\n\n上面代码表示，只输出circle模块的area方法，且将其改名为circlearea。\n\n加载上面模块的写法如下。\n\n// main.js\n\nimport * as math from 'circleplus';\nimport exp from 'circleplus';\nconsole.log(exp(math.e));\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。\n\n\n# 跨模块常量\n\n本书介绍const命令的时候说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。\n\n// constants.js 模块\nexport const a = 1;\nexport const b = 3;\nexport const c = 4;\n\n// test1.js 模块\nimport * as constants from './constants';\nconsole.log(constants.a); // 1\nconsole.log(constants.b); // 3\n\n// test2.js 模块\nimport {a, b} from './constants';\nconsole.log(a); // 1\nconsole.log(b); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。\n\n// constants/db.js\nexport const db = {\n  url: 'http://my.couchdbserver.local:5984',\n  admin_username: 'admin',\n  admin_password: 'admin password'\n};\n\n// constants/user.js\nexport const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n然后，将这些文件输出的常量，合并在index.js里面。\n\n// constants/index.js\nexport {db} from './db';\nexport {users} from './users';\n\n\n1\n2\n3\n\n\n使用的时候，直接加载index.js就可以了。\n\n// script.js\nimport {db, users} from './constants/index';\n\n\n1\n2\n\n\n\n# import()\n\n\n# 简介\n\n前面介绍过，import命令会被 javascript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。\n\n// 报错\nif (x === 2) {\n  import mymodual from './mymodual';\n}\n\n\n1\n2\n3\n4\n\n\n上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。\n\n这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。\n\nconst path = './' + filename;\nconst mymodual = require(path);\n\n\n1\n2\n\n\n上面的语句就是动态加载，require到底加载哪一个模块，只有运行时才知道。import命令做不到这一点。\n\nes2020提案 引入import()函数，支持动态加载模块。\n\nimport(specifier)\n\n\n1\n\n\n上面代码中，import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。\n\nimport()返回一个 promise 对象。下面是一个例子。\n\nconst main = document.queryselector('main');\n\nimport(`./section-modules/${somevariable}.js`)\n  .then(module => {\n    module.loadpageinto(main);\n  })\n  .catch(err => {\n    main.textcontent = err.message;\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nimport()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。import()类似于 node 的require方法，区别主要是前者是异步加载，后者是同步加载。\n\n\n# 适用场合\n\n下面是import()的一些适用场合。\n\n（1）按需加载。\n\nimport()可以在需要的时候，再加载某个模块。\n\nbutton.addeventlistener('click', event => {\n  import('./dialogbox.js')\n  .then(dialogbox => {\n    dialogbox.open();\n  })\n  .catch(error => {\n    /* error handling */\n  })\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，import()方法放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。\n\n（2）条件加载\n\nimport()可以放在if代码块，根据不同的情况，加载不同的模块。\n\nif (condition) {\n  import('modulea').then(...);\n} else {\n  import('moduleb').then(...);\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，如果满足条件，就加载模块 a，否则加载模块 b。\n\n（3）动态的模块路径\n\nimport()允许模块路径动态生成。\n\nimport(f())\n.then(...);\n\n\n1\n2\n\n\n上面代码中，根据函数f的返回结果，加载不同的模块。\n\n\n# 注意点\n\nimport()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。\n\nimport('./mymodule.js')\n.then(({export1, export2}) => {\n  // ...·\n});\n\n\n1\n2\n3\n4\n\n\n上面代码中，export1和export2都是mymodule.js的输出接口，可以解构获得。\n\n如果模块有default输出接口，可以用参数直接获得。\n\nimport('./mymodule.js')\n.then(mymodule => {\n  console.log(mymodule.default);\n});\n\n\n1\n2\n3\n4\n\n\n上面的代码也可以使用具名输入的形式。\n\nimport('./mymodule.js')\n.then(({default: thedefault}) => {\n  console.log(thedefault);\n});\n\n\n1\n2\n3\n4\n\n\n如果想同时加载多个模块，可以采用下面的写法。\n\npromise.all([\n  import('./module1.js'),\n  import('./module2.js'),\n  import('./module3.js'),\n])\n.then(([module1, module2, module3]) => {\n   ···\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport()也可以用在 async 函数之中。\n\nasync function main() {\n  const mymodule = await import('./mymodule.js');\n  const {export1, export2} = await import('./mymodule.js');\n  const [module1, module2, module3] =\n    await promise.all([\n      import('./module1.js'),\n      import('./module2.js'),\n      import('./module3.js'),\n    ]);\n}\nmain();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Module 的加载实现",frontmatter:{title:"Module 的加载实现",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/a79ca2e64ceae213",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/24.Module%20%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0.html",relativePath:"《ES6 教程》笔记/24.Module 的加载实现.md",key:"v-25827231",path:"/pages/a79ca2e64ceae213/",headers:[{level:2,title:"浏览器加载",slug:"浏览器加载",normalizedTitle:"浏览器加载",charIndex:90},{level:3,title:"传统方法",slug:"传统方法",normalizedTitle:"传统方法",charIndex:100},{level:3,title:"加载规则",slug:"加载规则",normalizedTitle:"加载规则",charIndex:990},{level:2,title:"ES6 模块与 CommonJS 模块的差异",slug:"es6-模块与-commonjs-模块的差异",normalizedTitle:"es6 模块与 commonjs 模块的差异",charIndex:2460},{level:2,title:"Node.js 加载",slug:"node-js-加载",normalizedTitle:"node.js 加载",charIndex:2487},{level:3,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:5283},{level:3,title:"main 字段",slug:"main-字段",normalizedTitle:"main 字段",charIndex:6048},{level:3,title:"exports 字段",slug:"exports-字段",normalizedTitle:"exports 字段",charIndex:6676},{level:3,title:"ES6 模块加载 CommonJS 模块",slug:"es6-模块加载-commonjs-模块",normalizedTitle:"es6 模块加载 commonjs 模块",charIndex:8575},{level:3,title:"CommonJS 模块加载 ES6 模块",slug:"commonjs-模块加载-es6-模块",normalizedTitle:"commonjs 模块加载 es6 模块",charIndex:9699},{level:3,title:"Node.js 的内置模块",slug:"node-js-的内置模块",normalizedTitle:"node.js 的内置模块",charIndex:9868},{level:3,title:"加载路径",slug:"加载路径",normalizedTitle:"加载路径",charIndex:10193},{level:3,title:"内部变量",slug:"内部变量",normalizedTitle:"内部变量",charIndex:2982},{level:2,title:"循环加载",slug:"循环加载",normalizedTitle:"循环加载",charIndex:79},{level:3,title:"CommonJS 模块的加载原理",slug:"commonjs-模块的加载原理",normalizedTitle:"commonjs 模块的加载原理",charIndex:11337},{level:3,title:"CommonJS 模块的循环加载",slug:"commonjs-模块的循环加载",normalizedTitle:"commonjs 模块的循环加载",charIndex:11795},{level:3,title:"ES6 模块的循环加载",slug:"es6-模块的循环加载",normalizedTitle:"es6 模块的循环加载",charIndex:13477}],excerpt:'<h1 id="module-的加载实现"><a class="header-anchor" href="#module-的加载实现">#</a> Module 的加载实现</h1>\n<p>上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。</p>\n',headersStr:"浏览器加载 传统方法 加载规则 ES6 模块与 CommonJS 模块的差异 Node.js 加载 概述 main 字段 exports 字段 ES6 模块加载 CommonJS 模块 CommonJS 模块加载 ES6 模块 Node.js 的内置模块 加载路径 内部变量 循环加载 CommonJS 模块的加载原理 CommonJS 模块的循环加载 ES6 模块的循环加载",content:'# Module 的加载实现\n\n上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。\n\n\n# 浏览器加载\n\n\n# 传统方法\n\nHTML 网页中，浏览器通过<script>标签加载 JavaScript 脚本。\n\n\x3c!-- 页面内嵌的脚本 --\x3e\n<script type="application/javascript">\n  // module code\n<\/script>\n\n\x3c!-- 外部脚本 --\x3e\n<script type="application/javascript" src="path/to/myModule.js">\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此type="application/javascript"可以省略。\n\n默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<script>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。\n\n如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。\n\n<script src="path/to/myModule.js" defer><\/script>\n<script src="path/to/myModule.js" async><\/script>\n\n\n1\n2\n\n\n上面代码中，<script>标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。\n\ndefer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。\n\n\n# 加载规则\n\n浏览器加载 ES6 模块，也使用<script>标签，但是要加入type="module"属性。\n\n<script type="module" src="./foo.js"><\/script>\n\n\n1\n\n\n上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 ES6 模块。\n\n浏览器对于带有type="module"的<script>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<script>标签的defer属性。\n\n<script type="module" src="./foo.js"><\/script>\n\x3c!-- 等同于 --\x3e\n<script type="module" src="./foo.js" defer><\/script>\n\n\n1\n2\n3\n\n\n如果网页有多个<script type="module">，它们会按照在页面出现的顺序依次执行。\n\n<script>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。\n\n<script type="module" src="./foo.js" async><\/script>\n\n\n1\n\n\n一旦使用了async属性，<script type="module">就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。\n\nES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。\n\n<script type="module">\n  import utils from "./utils.js";\n\n  // other code\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n举例来说，jQuery 就支持模块加载。\n\n<script type="module">\n  import $ from "./jquery/src/jquery.js";\n  $(\'#message\').text(\'Hi from jQuery!\');\n<\/script>\n\n\n1\n2\n3\n4\n\n\n对于外部的模块脚本（上例是foo.js），有几点需要注意。\n\n * 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。\n * 模块脚本自动采用严格模式，不管有没有声明use strict。\n * 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。\n * 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。\n * 同一个模块如果加载多次，将只执行一次。\n\n下面是一个示例模块。\n\nimport utils from \'https://example.com/js/utils.js\';\n\nconst x = 1;\n\nconsole.log(x === window.x); //false\nconsole.log(this === undefined); // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。\n\nconst isNotModuleScript = this !== undefined;\n\n\n1\n\n\n\n# ES6 模块与 CommonJS 模块的差异\n\n讨论 Node.js 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。\n\n它们有两个重大差异。\n\n * CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n * CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n\n第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n下面重点解释第一个差异。\n\nCommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。\n\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码输出内部变量counter和改写这个变量的内部方法incCounter。然后，在main.js里面加载这个模块。\n\n// main.js\nvar mod = require(\'./lib\');\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。\n\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  get counter() {\n    return counter\n  },\n  incCounter: incCounter,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。\n\n$ node main.js\n3\n4\n\n\n1\n2\n3\n\n\nES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n还是举上面的例子。\n\n// lib.js\nexport let counter = 3;\nexport function incCounter() {\n  counter++;\n}\n\n// main.js\nimport { counter, incCounter } from \'./lib\';\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码说明，ES6 模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化。\n\n再举一个出现在export一节中的例子。\n\n// m1.js\nexport var foo = \'bar\';\nsetTimeout(() => foo = \'baz\', 500);\n\n// m2.js\nimport {foo} from \'./m1.js\';\nconsole.log(foo);\nsetTimeout(() => console.log(foo), 500);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，m1.js的变量foo，在刚加载时等于bar，过了 500 毫秒，又变为等于baz。\n\n让我们看看，m2.js能否正确读取这个变化。\n\n$ babel-node m2.js\n\nbar\nbaz\n\n\n1\n2\n3\n4\n\n\n上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。\n\n由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。\n\n// lib.js\nexport let obj = {};\n\n// main.js\nimport { obj } from \'./lib\';\n\nobj.prop = 123; // OK\nobj = {}; // TypeError\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量。\n\n最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。\n\n// mod.js\nfunction C() {\n  this.sum = 0;\n  this.add = function () {\n    this.sum += 1;\n  };\n  this.show = function () {\n    console.log(this.sum);\n  };\n}\n\nexport let c = new C();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。\n\n// x.js\nimport {c} from \'./mod\';\nc.add();\n\n// y.js\nimport {c} from \'./mod\';\nc.show();\n\n// main.js\nimport \'./x\';\nimport \'./y\';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n现在执行main.js，输出的是1。\n\n$ babel-node main.js\n1\n\n\n1\n2\n\n\n这就证明了x.js和y.js加载的都是C的同一个实例。\n\n\n# Node.js 加载\n\n\n# 概述\n\nNode.js 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。从 v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。\n\nNode.js 要求 ES6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。Node.js 遇到.mjs文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定"use strict"。\n\n如果不希望将后缀名改成.mjs，可以在项目的package.json文件中，指定type字段为module。\n\n{\n   "type": "module"\n}\n\n\n1\n2\n3\n\n\n一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。\n\n# 解释成 ES6 模块\n$ node my-app.js\n\n\n1\n2\n\n\n如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成.cjs。如果没有type字段，或者type字段为commonjs，则.js脚本会被解释成 CommonJS 模块。\n\n总结为一句话：.mjs文件总是以 ES6 模块加载，.cjs文件总是以 CommonJS 模块加载，.js文件的加载取决于package.json里面type字段的设置。\n\n注意，ES6 模块与 CommonJS 模块尽量不要混用。require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。反过来，.mjs文件里面也不能使用require命令，必须使用import。\n\n\n# main 字段\n\npackage.json文件有两个字段可以指定模块的入口文件：main和exports。比较简单的模块，可以只使用main字段，指定模块加载的入口文件。\n\n// ./node_modules/es-module-package/package.json\n{\n  "type": "module",\n  "main": "./src/index.js"\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码指定项目的入口脚本为./src/index.js，它的格式为 ES6 模块。如果没有type字段，index.js就会被解释为 CommonJS 模块。\n\n然后，import命令就可以加载这个模块。\n\n// ./my-app.mjs\n\nimport { something } from \'es-module-package\';\n// 实际加载的是 ./node_modules/es-module-package/src/index.js\n\n\n1\n2\n3\n4\n\n\n上面代码中，运行该脚本以后，Node.js 就会到./node_modules目录下面，寻找es-module-package模块，然后根据该模块package.json的main字段去执行入口文件。\n\n这时，如果用 CommonJS 模块的require()命令去加载es-module-package模块会报错，因为 CommonJS 模块不能处理export命令。\n\n\n# exports 字段\n\nexports字段的优先级高于main字段。它有多种用法。\n\n（1）子目录别名\n\npackage.json文件的exports字段可以指定脚本或子目录的别名。\n\n// ./node_modules/es-module-package/package.json\n{\n  "exports": {\n    "./submodule": "./src/submodule.js"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面的代码指定src/submodule.js别名为submodule，然后就可以从别名加载这个文件。\n\nimport submodule from \'es-module-package/submodule\';\n// 加载 ./node_modules/es-module-package/src/submodule.js\n\n\n1\n2\n\n\n下面是子目录别名的例子。\n\n// ./node_modules/es-module-package/package.json\n{\n  "exports": {\n    "./features/": "./src/features/"\n  }\n}\n\nimport feature from \'es-module-package/features/x.js\';\n// 加载 ./node_modules/es-module-package/src/features/x.js\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。\n\n// 报错\nimport submodule from \'es-module-package/private-module.js\';\n\n// 不报错\nimport submodule from \'./node_modules/es-module-package/private-module.js\';\n\n\n1\n2\n3\n4\n5\n\n\n（2）main 的别名\n\nexports字段的别名如果是.，就代表模块的主入口，优先级高于main字段，并且可以直接简写成exports字段的值。\n\n{\n  "exports": {\n    ".": "./main.js"\n  }\n}\n\n// 等同于\n{\n  "exports": "./main.js"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n由于exports字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。\n\n{\n  "main": "./main-legacy.cjs",\n  "exports": {\n    ".": "./main-modern.cjs"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是main-legacy.cjs，新版本的 Node.js 的入口文件是main-modern.cjs。\n\n（3）条件加载\n\n利用.这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开--experimental-conditional-exports标志。\n\n{\n  "type": "module",\n  "exports": {\n    ".": {\n      "require": "./main.cjs",\n      "default": "./main.js"\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，别名.的require条件指定require()命令的入口文件（即 CommonJS 的入口），default条件指定其他情况的入口（即 ES6 的入口）。\n\n上面的写法可以简写如下。\n\n{\n  "exports": {\n    "require": "./main.cjs",\n    "default": "./main.js"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意，如果同时还有其他别名，就不能采用简写，否则或报错。\n\n{\n  // 报错\n  "exports": {\n    "./feature": "./lib/feature.js",\n    "require": "./main.cjs",\n    "default": "./main.js"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# ES6 模块加载 CommonJS 模块\n\n目前，一个模块同时支持 ES6 和 CommonJS 两种格式的常见方法是，package.json文件的main字段指定 CommonJS 入口，给 Node.js 使用；module字段指定 ES6 模块入口，给打包工具使用，因为 Node.js 不认识module字段。\n\n有了上一节的条件加载以后，Node.js 本身就可以同时处理两种模块。\n\n// ./node_modules/pkg/package.json\n{\n  "type": "module",\n  "main": "./index.cjs",\n  "exports": {\n    "require": "./index.cjs",\n    "default": "./wrapper.mjs"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码指定了 CommonJS 入口文件index.cjs，下面是这个文件的代码。\n\n// ./node_modules/pkg/index.cjs\nexports.name = \'value\';\n\n\n1\n2\n\n\n然后，ES6 模块可以加载这个文件。\n\n// ./node_modules/pkg/wrapper.mjs\nimport cjsModule from \'./index.cjs\';\nexport const name = cjsModule.name;\n\n\n1\n2\n3\n\n\n注意，import命令加载 CommonJS 模块，只能整体加载，不能只加载单一的输出项。\n\n// 正确\nimport packageMain from \'commonjs-package\';\n\n// 报错\nimport { method } from \'commonjs-package\';\n\n\n1\n2\n3\n4\n5\n\n\n还有一种变通的加载方法，就是使用 Node.js 内置的module.createRequire()方法。\n\n// cjs.cjs\nmodule.exports = \'cjs\';\n\n// esm.mjs\nimport { createRequire } from \'module\';\n\nconst require = createRequire(import.meta.url);\n\nconst cjs = require(\'./cjs.cjs\');\ncjs === \'cjs\'; // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，ES6 模块通过module.createRequire()方法可以加载 CommonJS 模块\n\n\n# CommonJS 模块加载 ES6 模块\n\nCommonJS 的require命令不能加载 ES6 模块，会报错，只能使用import()这个方法加载。\n\n(async () => {\n  await import(\'./my-app.mjs\');\n})();\n\n\n1\n2\n3\n\n\n上面代码可以在 CommonJS 模块中运行。\n\n\n# Node.js 的内置模块\n\nNode.js 的内置模块可以整体加载，也可以加载指定的输出项。\n\n// 整体加载\nimport EventEmitter from \'events\';\nconst e = new EventEmitter();\n\n// 加载指定的输出项\nimport { readFile } from \'fs\';\nreadFile(\'./foo.txt\', (err, source) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(source);\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 加载路径\n\nES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。import命令和package.json文件的main字段如果省略脚本的后缀名，会报错。\n\n// ES6 模块中将报错\nimport { something } from \'./index\';\n\n\n1\n2\n\n\n为了与浏览器的import加载规则相同，Node.js 的.mjs文件支持 URL 路径。\n\nimport \'./foo.mjs?query=1\'; // 加载 ./foo 传入参数 ?query=1\n\n\n1\n\n\n上面代码中，脚本路径带有参数?query=1，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有:、%、#、?等特殊字符，最好对这些字符进行转义。\n\n目前，Node.js 的import命令只支持加载本地模块（file:协议）和data:协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以/或//开头的路径）。\n\n最后，Node 的import命令是异步加载，这一点与浏览器的处理方法相同。\n\n\n# 内部变量\n\nES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。\n\n首先，就是this关键字。ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。\n\n其次，以下这些顶层变量在 ES6 模块之中都是不存在的。\n\n * arguments\n * require\n * module\n * exports\n * __filename\n * __dirname\n\n\n# 循环加载\n\n“循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。\n\n// a.js\nvar b = require(\'b\');\n\n// b.js\nvar a = require(\'a\');\n\n\n1\n2\n3\n4\n5\n\n\n通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。\n\n但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现a依赖b，b依赖c，c又依赖a这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。\n\n对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。\n\n\n# CommonJS 模块的加载原理\n\n介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。\n\nCommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。\n\n{\n  id: \'...\',\n  exports: { ... },\n  loaded: true,\n  ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。\n\n以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。\n\n\n# CommonJS 模块的循环加载\n\nCommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。\n\n让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下。\n\nexports.done = false;\nvar b = require(\'./b.js\');\nconsole.log(\'在 a.js 之中，b.done = %j\', b.done);\nexports.done = true;\nconsole.log(\'a.js 执行完毕\');\n\n\n1\n2\n3\n4\n5\n\n\n上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。\n\n再看b.js的代码。\n\nexports.done = false;\nvar a = require(\'./a.js\');\nconsole.log(\'在 b.js 之中，a.done = %j\', a.done);\nexports.done = true;\nconsole.log(\'b.js 执行完毕\');\n\n\n1\n2\n3\n4\n5\n\n\n上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。\n\na.js已经执行的部分，只有一行。\n\nexports.done = false;\n\n\n1\n\n\n因此，对于b.js来说，它从a.js只输入一个变量done，值为false。\n\n然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。\n\nvar a = require(\'./a.js\');\nvar b = require(\'./b.js\');\nconsole.log(\'在 main.js 之中, a.done=%j, b.done=%j\', a.done, b.done);\n\n\n1\n2\n3\n\n\n执行main.js，运行结果如下。\n\n$ node main.js\n\n在 b.js 之中，a.done = false\nb.js 执行完毕\n在 a.js 之中，b.done = true\na.js 执行完毕\n在 main.js 之中, a.done=true, b.done=true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。\n\nexports.done = true;\n\n\n1\n\n\n总之，CommonJS 输入的是被输出值的拷贝，不是引用。\n\n另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。\n\nvar a = require(\'a\'); // 安全的写法\nvar foo = require(\'a\').foo; // 危险的写法\n\nexports.good = function (arg) {\n  return a.foo(\'good\', arg); // 使用的是 a.foo 的最新值\n};\n\nexports.bad = function (arg) {\n  return foo(\'bad\', arg); // 使用的是一个部分加载时的值\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，如果发生循环加载，require(\'a\').foo的值很可能后面会被改写，改用require(\'a\')会更保险一点。\n\n\n# ES6 模块的循环加载\n\nES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from \'foo\'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。\n\n请看下面这个例子。\n\n// a.mjs\nimport {bar} from \'./b\';\nconsole.log(\'a.mjs\');\nconsole.log(bar);\nexport let foo = \'foo\';\n\n// b.mjs\nimport {foo} from \'./a\';\nconsole.log(\'b.mjs\');\nconsole.log(foo);\nexport let bar = \'bar\';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。\n\n$ node --experimental-modules a.mjs\nb.mjs\nReferenceError: foo is not defined\n\n\n1\n2\n3\n\n\n上面代码中，执行a.mjs以后会报错，foo变量未定义，这是为什么？\n\n让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。\n\n解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。\n\n// a.mjs\nimport {bar} from \'./b\';\nconsole.log(\'a.mjs\');\nconsole.log(bar());\nfunction foo() { return \'foo\' }\nexport {foo};\n\n// b.mjs\nimport {foo} from \'./a\';\nconsole.log(\'b.mjs\');\nconsole.log(foo());\nfunction bar() { return \'bar\' }\nexport {bar};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这时再执行a.mjs就可以得到预期结果。\n\n$ node --experimental-modules a.mjs\nb.mjs\nfoo\na.mjs\nbar\n\n\n1\n2\n3\n4\n5\n\n\n这是因为函数具有提升作用，在执行import {bar} from \'./b\'时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。这也意味着，如果把函数foo改写成函数表达式，也会报错。\n\n// a.mjs\nimport {bar} from \'./b\';\nconsole.log(\'a.mjs\');\nconsole.log(bar());\nconst foo = () => \'foo\';\nexport {foo};\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。\n\n我们再来看 ES6 模块加载器SystemJS给出的一个例子。\n\n// even.js\nimport { odd } from \'./odd\'\nexport var counter = 0;\nexport function even(n) {\n  counter++;\n  return n === 0 || odd(n - 1);\n}\n\n// odd.js\nimport { even } from \'./even\';\nexport function odd(n) {\n  return n !== 0 && even(n - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，even.js里面的函数even有一个参数n，只要不等于 0，就会减去 1，传入加载的odd()。odd.js也会做类似操作。\n\n运行上面这段代码，结果如下。\n\n$ babel-node\n> import * as m from \'./even.js\';\n> m.even(10);\ntrue\n> m.counter\n6\n> m.even(20)\ntrue\n> m.counter\n17\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，参数n从 10 变为 0 的过程中，even()一共会执行 6 次，所以变量counter等于 6。第二次调用even()时，参数n从 20 变为 0，even()一共会执行 11 次，加上前面的 6 次，所以变量counter等于 17。\n\n这个例子要是改写成 CommonJS，就根本无法执行，会报错。\n\n// even.js\nvar odd = require(\'./odd\');\nvar counter = 0;\nexports.counter = counter;\nexports.even = function (n) {\n  counter++;\n  return n == 0 || odd(n - 1);\n}\n\n// odd.js\nvar even = require(\'./even\').even;\nmodule.exports = function (n) {\n  return n != 0 && even(n - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成“循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于undefined，等到后面调用even(n - 1)就会报错。\n\n$ node\n> var m = require(\'./even\');\n> m.even(10)\nTypeError: even is not a function\n\n\n1\n2\n3\n4\n',normalizedContent:'# module 的加载实现\n\n上一章介绍了模块的语法，本章介绍如何在浏览器和 node.js 之中加载 es6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。\n\n\n# 浏览器加载\n\n\n# 传统方法\n\nhtml 网页中，浏览器通过<script>标签加载 javascript 脚本。\n\n\x3c!-- 页面内嵌的脚本 --\x3e\n<script type="application/javascript">\n  // module code\n<\/script>\n\n\x3c!-- 外部脚本 --\x3e\n<script type="application/javascript" src="path/to/mymodule.js">\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，由于浏览器脚本的默认语言是 javascript，因此type="application/javascript"可以省略。\n\n默认情况下，浏览器是同步加载 javascript 脚本，即渲染引擎遇到<script>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。\n\n如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。\n\n<script src="path/to/mymodule.js" defer><\/script>\n<script src="path/to/mymodule.js" async><\/script>\n\n\n1\n2\n\n\n上面代码中，<script>标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。\n\ndefer与async的区别是：defer要等到整个页面在内存中正常渲染结束（dom 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。\n\n\n# 加载规则\n\n浏览器加载 es6 模块，也使用<script>标签，但是要加入type="module"属性。\n\n<script type="module" src="./foo.js"><\/script>\n\n\n1\n\n\n上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 es6 模块。\n\n浏览器对于带有type="module"的<script>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<script>标签的defer属性。\n\n<script type="module" src="./foo.js"><\/script>\n\x3c!-- 等同于 --\x3e\n<script type="module" src="./foo.js" defer><\/script>\n\n\n1\n2\n3\n\n\n如果网页有多个<script type="module">，它们会按照在页面出现的顺序依次执行。\n\n<script>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。\n\n<script type="module" src="./foo.js" async><\/script>\n\n\n1\n\n\n一旦使用了async属性，<script type="module">就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。\n\nes6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。\n\n<script type="module">\n  import utils from "./utils.js";\n\n  // other code\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n举例来说，jquery 就支持模块加载。\n\n<script type="module">\n  import $ from "./jquery/src/jquery.js";\n  $(\'#message\').text(\'hi from jquery!\');\n<\/script>\n\n\n1\n2\n3\n4\n\n\n对于外部的模块脚本（上例是foo.js），有几点需要注意。\n\n * 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。\n * 模块脚本自动采用严格模式，不管有没有声明use strict。\n * 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 url 或相对 url），也可以使用export命令输出对外接口。\n * 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。\n * 同一个模块如果加载多次，将只执行一次。\n\n下面是一个示例模块。\n\nimport utils from \'https://example.com/js/utils.js\';\n\nconst x = 1;\n\nconsole.log(x === window.x); //false\nconsole.log(this === undefined); // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 es6 模块之中。\n\nconst isnotmodulescript = this !== undefined;\n\n\n1\n\n\n\n# es6 模块与 commonjs 模块的差异\n\n讨论 node.js 加载 es6 模块之前，必须了解 es6 模块与 commonjs 模块完全不同。\n\n它们有两个重大差异。\n\n * commonjs 模块输出的是一个值的拷贝，es6 模块输出的是值的引用。\n * commonjs 模块是运行时加载，es6 模块是编译时输出接口。\n\n第二个差异是因为 commonjs 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 es6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n下面重点解释第一个差异。\n\ncommonjs 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。\n\n// lib.js\nvar counter = 3;\nfunction inccounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  inccounter: inccounter,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码输出内部变量counter和改写这个变量的内部方法inccounter。然后，在main.js里面加载这个模块。\n\n// main.js\nvar mod = require(\'./lib\');\n\nconsole.log(mod.counter);  // 3\nmod.inccounter();\nconsole.log(mod.counter); // 3\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。\n\n// lib.js\nvar counter = 3;\nfunction inccounter() {\n  counter++;\n}\nmodule.exports = {\n  get counter() {\n    return counter\n  },\n  inccounter: inccounter,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。\n\n$ node main.js\n3\n4\n\n\n1\n2\n3\n\n\nes6 模块的运行机制与 commonjs 不一样。js 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，es6 的import有点像 unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，es6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n还是举上面的例子。\n\n// lib.js\nexport let counter = 3;\nexport function inccounter() {\n  counter++;\n}\n\n// main.js\nimport { counter, inccounter } from \'./lib\';\nconsole.log(counter); // 3\ninccounter();\nconsole.log(counter); // 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码说明，es6 模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化。\n\n再举一个出现在export一节中的例子。\n\n// m1.js\nexport var foo = \'bar\';\nsettimeout(() => foo = \'baz\', 500);\n\n// m2.js\nimport {foo} from \'./m1.js\';\nconsole.log(foo);\nsettimeout(() => console.log(foo), 500);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，m1.js的变量foo，在刚加载时等于bar，过了 500 毫秒，又变为等于baz。\n\n让我们看看，m2.js能否正确读取这个变化。\n\n$ babel-node m2.js\n\nbar\nbaz\n\n\n1\n2\n3\n4\n\n\n上面代码表明，es6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。\n\n由于 es6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。\n\n// lib.js\nexport let obj = {};\n\n// main.js\nimport { obj } from \'./lib\';\n\nobj.prop = 123; // ok\nobj = {}; // typeerror\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量。\n\n最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。\n\n// mod.js\nfunction c() {\n  this.sum = 0;\n  this.add = function () {\n    this.sum += 1;\n  };\n  this.show = function () {\n    console.log(this.sum);\n  };\n}\n\nexport let c = new c();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面的脚本mod.js，输出的是一个c的实例。不同的脚本加载这个模块，得到的都是同一个实例。\n\n// x.js\nimport {c} from \'./mod\';\nc.add();\n\n// y.js\nimport {c} from \'./mod\';\nc.show();\n\n// main.js\nimport \'./x\';\nimport \'./y\';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n现在执行main.js，输出的是1。\n\n$ babel-node main.js\n1\n\n\n1\n2\n\n\n这就证明了x.js和y.js加载的都是c的同一个实例。\n\n\n# node.js 加载\n\n\n# 概述\n\nnode.js 对 es6 模块的处理比较麻烦，因为它有自己的 commonjs 模块格式，与 es6 模块格式是不兼容的。目前的解决方案是，将两者分开，es6 模块和 commonjs 采用各自的加载方案。从 v13.2 版本开始，node.js 已经默认打开了 es6 模块支持。\n\nnode.js 要求 es6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。node.js 遇到.mjs文件，就认为它是 es6 模块，默认启用严格模式，不必在每个模块文件顶部指定"use strict"。\n\n如果不希望将后缀名改成.mjs，可以在项目的package.json文件中，指定type字段为module。\n\n{\n   "type": "module"\n}\n\n\n1\n2\n3\n\n\n一旦设置了以后，该目录里面的 js 脚本，就被解释用 es6 模块。\n\n# 解释成 es6 模块\n$ node my-app.js\n\n\n1\n2\n\n\n如果这时还要使用 commonjs 模块，那么需要将 commonjs 脚本的后缀名都改成.cjs。如果没有type字段，或者type字段为commonjs，则.js脚本会被解释成 commonjs 模块。\n\n总结为一句话：.mjs文件总是以 es6 模块加载，.cjs文件总是以 commonjs 模块加载，.js文件的加载取决于package.json里面type字段的设置。\n\n注意，es6 模块与 commonjs 模块尽量不要混用。require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。反过来，.mjs文件里面也不能使用require命令，必须使用import。\n\n\n# main 字段\n\npackage.json文件有两个字段可以指定模块的入口文件：main和exports。比较简单的模块，可以只使用main字段，指定模块加载的入口文件。\n\n// ./node_modules/es-module-package/package.json\n{\n  "type": "module",\n  "main": "./src/index.js"\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码指定项目的入口脚本为./src/index.js，它的格式为 es6 模块。如果没有type字段，index.js就会被解释为 commonjs 模块。\n\n然后，import命令就可以加载这个模块。\n\n// ./my-app.mjs\n\nimport { something } from \'es-module-package\';\n// 实际加载的是 ./node_modules/es-module-package/src/index.js\n\n\n1\n2\n3\n4\n\n\n上面代码中，运行该脚本以后，node.js 就会到./node_modules目录下面，寻找es-module-package模块，然后根据该模块package.json的main字段去执行入口文件。\n\n这时，如果用 commonjs 模块的require()命令去加载es-module-package模块会报错，因为 commonjs 模块不能处理export命令。\n\n\n# exports 字段\n\nexports字段的优先级高于main字段。它有多种用法。\n\n（1）子目录别名\n\npackage.json文件的exports字段可以指定脚本或子目录的别名。\n\n// ./node_modules/es-module-package/package.json\n{\n  "exports": {\n    "./submodule": "./src/submodule.js"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面的代码指定src/submodule.js别名为submodule，然后就可以从别名加载这个文件。\n\nimport submodule from \'es-module-package/submodule\';\n// 加载 ./node_modules/es-module-package/src/submodule.js\n\n\n1\n2\n\n\n下面是子目录别名的例子。\n\n// ./node_modules/es-module-package/package.json\n{\n  "exports": {\n    "./features/": "./src/features/"\n  }\n}\n\nimport feature from \'es-module-package/features/x.js\';\n// 加载 ./node_modules/es-module-package/src/features/x.js\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。\n\n// 报错\nimport submodule from \'es-module-package/private-module.js\';\n\n// 不报错\nimport submodule from \'./node_modules/es-module-package/private-module.js\';\n\n\n1\n2\n3\n4\n5\n\n\n（2）main 的别名\n\nexports字段的别名如果是.，就代表模块的主入口，优先级高于main字段，并且可以直接简写成exports字段的值。\n\n{\n  "exports": {\n    ".": "./main.js"\n  }\n}\n\n// 等同于\n{\n  "exports": "./main.js"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n由于exports字段只有支持 es6 的 node.js 才认识，所以可以用来兼容旧版本的 node.js。\n\n{\n  "main": "./main-legacy.cjs",\n  "exports": {\n    ".": "./main-modern.cjs"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，老版本的 node.js （不支持 es6 模块）的入口文件是main-legacy.cjs，新版本的 node.js 的入口文件是main-modern.cjs。\n\n（3）条件加载\n\n利用.这个别名，可以为 es6 模块和 commonjs 指定不同的入口。目前，这个功能需要在 node.js 运行的时候，打开--experimental-conditional-exports标志。\n\n{\n  "type": "module",\n  "exports": {\n    ".": {\n      "require": "./main.cjs",\n      "default": "./main.js"\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，别名.的require条件指定require()命令的入口文件（即 commonjs 的入口），default条件指定其他情况的入口（即 es6 的入口）。\n\n上面的写法可以简写如下。\n\n{\n  "exports": {\n    "require": "./main.cjs",\n    "default": "./main.js"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意，如果同时还有其他别名，就不能采用简写，否则或报错。\n\n{\n  // 报错\n  "exports": {\n    "./feature": "./lib/feature.js",\n    "require": "./main.cjs",\n    "default": "./main.js"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# es6 模块加载 commonjs 模块\n\n目前，一个模块同时支持 es6 和 commonjs 两种格式的常见方法是，package.json文件的main字段指定 commonjs 入口，给 node.js 使用；module字段指定 es6 模块入口，给打包工具使用，因为 node.js 不认识module字段。\n\n有了上一节的条件加载以后，node.js 本身就可以同时处理两种模块。\n\n// ./node_modules/pkg/package.json\n{\n  "type": "module",\n  "main": "./index.cjs",\n  "exports": {\n    "require": "./index.cjs",\n    "default": "./wrapper.mjs"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码指定了 commonjs 入口文件index.cjs，下面是这个文件的代码。\n\n// ./node_modules/pkg/index.cjs\nexports.name = \'value\';\n\n\n1\n2\n\n\n然后，es6 模块可以加载这个文件。\n\n// ./node_modules/pkg/wrapper.mjs\nimport cjsmodule from \'./index.cjs\';\nexport const name = cjsmodule.name;\n\n\n1\n2\n3\n\n\n注意，import命令加载 commonjs 模块，只能整体加载，不能只加载单一的输出项。\n\n// 正确\nimport packagemain from \'commonjs-package\';\n\n// 报错\nimport { method } from \'commonjs-package\';\n\n\n1\n2\n3\n4\n5\n\n\n还有一种变通的加载方法，就是使用 node.js 内置的module.createrequire()方法。\n\n// cjs.cjs\nmodule.exports = \'cjs\';\n\n// esm.mjs\nimport { createrequire } from \'module\';\n\nconst require = createrequire(import.meta.url);\n\nconst cjs = require(\'./cjs.cjs\');\ncjs === \'cjs\'; // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，es6 模块通过module.createrequire()方法可以加载 commonjs 模块\n\n\n# commonjs 模块加载 es6 模块\n\ncommonjs 的require命令不能加载 es6 模块，会报错，只能使用import()这个方法加载。\n\n(async () => {\n  await import(\'./my-app.mjs\');\n})();\n\n\n1\n2\n3\n\n\n上面代码可以在 commonjs 模块中运行。\n\n\n# node.js 的内置模块\n\nnode.js 的内置模块可以整体加载，也可以加载指定的输出项。\n\n// 整体加载\nimport eventemitter from \'events\';\nconst e = new eventemitter();\n\n// 加载指定的输出项\nimport { readfile } from \'fs\';\nreadfile(\'./foo.txt\', (err, source) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(source);\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 加载路径\n\nes6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。import命令和package.json文件的main字段如果省略脚本的后缀名，会报错。\n\n// es6 模块中将报错\nimport { something } from \'./index\';\n\n\n1\n2\n\n\n为了与浏览器的import加载规则相同，node.js 的.mjs文件支持 url 路径。\n\nimport \'./foo.mjs?query=1\'; // 加载 ./foo 传入参数 ?query=1\n\n\n1\n\n\n上面代码中，脚本路径带有参数?query=1，node 会按 url 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有:、%、#、?等特殊字符，最好对这些字符进行转义。\n\n目前，node.js 的import命令只支持加载本地模块（file:协议）和data:协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以/或//开头的路径）。\n\n最后，node 的import命令是异步加载，这一点与浏览器的处理方法相同。\n\n\n# 内部变量\n\nes6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，node 规定 es6 模块之中不能使用 commonjs 模块的特有的一些内部变量。\n\n首先，就是this关键字。es6 模块之中，顶层的this指向undefined；commonjs 模块的顶层this指向当前模块，这是两者的一个重大差异。\n\n其次，以下这些顶层变量在 es6 模块之中都是不存在的。\n\n * arguments\n * require\n * module\n * exports\n * __filename\n * __dirname\n\n\n# 循环加载\n\n“循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。\n\n// a.js\nvar b = require(\'b\');\n\n// b.js\nvar a = require(\'a\');\n\n\n1\n2\n3\n4\n5\n\n\n通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。\n\n但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现a依赖b，b依赖c，c又依赖a这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。\n\n对于 javascript 语言来说，目前最常见的两种模块格式 commonjs 和 es6，处理“循环加载”的方法是不一样的，返回的结果也不一样。\n\n\n# commonjs 模块的加载原理\n\n介绍 es6 如何处理“循环加载”之前，先介绍目前最流行的 commonjs 模块格式的加载原理。\n\ncommonjs 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。\n\n{\n  id: \'...\',\n  exports: { ... },\n  loaded: true,\n  ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码就是 node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。\n\n以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，commonjs 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。\n\n\n# commonjs 模块的循环加载\n\ncommonjs 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。\n\n让我们来看，node 官方文档里面的例子。脚本文件a.js代码如下。\n\nexports.done = false;\nvar b = require(\'./b.js\');\nconsole.log(\'在 a.js 之中，b.done = %j\', b.done);\nexports.done = true;\nconsole.log(\'a.js 执行完毕\');\n\n\n1\n2\n3\n4\n5\n\n\n上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。\n\n再看b.js的代码。\n\nexports.done = false;\nvar a = require(\'./a.js\');\nconsole.log(\'在 b.js 之中，a.done = %j\', a.done);\nexports.done = true;\nconsole.log(\'b.js 执行完毕\');\n\n\n1\n2\n3\n4\n5\n\n\n上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。\n\na.js已经执行的部分，只有一行。\n\nexports.done = false;\n\n\n1\n\n\n因此，对于b.js来说，它从a.js只输入一个变量done，值为false。\n\n然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。\n\nvar a = require(\'./a.js\');\nvar b = require(\'./b.js\');\nconsole.log(\'在 main.js 之中, a.done=%j, b.done=%j\', a.done, b.done);\n\n\n1\n2\n3\n\n\n执行main.js，运行结果如下。\n\n$ node main.js\n\n在 b.js 之中，a.done = false\nb.js 执行完毕\n在 a.js 之中，b.done = true\na.js 执行完毕\n在 main.js 之中, a.done=true, b.done=true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。\n\nexports.done = true;\n\n\n1\n\n\n总之，commonjs 输入的是被输出值的拷贝，不是引用。\n\n另外，由于 commonjs 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。\n\nvar a = require(\'a\'); // 安全的写法\nvar foo = require(\'a\').foo; // 危险的写法\n\nexports.good = function (arg) {\n  return a.foo(\'good\', arg); // 使用的是 a.foo 的最新值\n};\n\nexports.bad = function (arg) {\n  return foo(\'bad\', arg); // 使用的是一个部分加载时的值\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，如果发生循环加载，require(\'a\').foo的值很可能后面会被改写，改用require(\'a\')会更保险一点。\n\n\n# es6 模块的循环加载\n\nes6 处理“循环加载”与 commonjs 有本质的不同。es6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from \'foo\'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。\n\n请看下面这个例子。\n\n// a.mjs\nimport {bar} from \'./b\';\nconsole.log(\'a.mjs\');\nconsole.log(bar);\nexport let foo = \'foo\';\n\n// b.mjs\nimport {foo} from \'./a\';\nconsole.log(\'b.mjs\');\nconsole.log(foo);\nexport let bar = \'bar\';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。\n\n$ node --experimental-modules a.mjs\nb.mjs\nreferenceerror: foo is not defined\n\n\n1\n2\n3\n\n\n上面代码中，执行a.mjs以后会报错，foo变量未定义，这是为什么？\n\n让我们一行行来看，es6 循环加载是怎么处理的。首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。\n\n解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。\n\n// a.mjs\nimport {bar} from \'./b\';\nconsole.log(\'a.mjs\');\nconsole.log(bar());\nfunction foo() { return \'foo\' }\nexport {foo};\n\n// b.mjs\nimport {foo} from \'./a\';\nconsole.log(\'b.mjs\');\nconsole.log(foo());\nfunction bar() { return \'bar\' }\nexport {bar};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这时再执行a.mjs就可以得到预期结果。\n\n$ node --experimental-modules a.mjs\nb.mjs\nfoo\na.mjs\nbar\n\n\n1\n2\n3\n4\n5\n\n\n这是因为函数具有提升作用，在执行import {bar} from \'./b\'时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。这也意味着，如果把函数foo改写成函数表达式，也会报错。\n\n// a.mjs\nimport {bar} from \'./b\';\nconsole.log(\'a.mjs\');\nconsole.log(bar());\nconst foo = () => \'foo\';\nexport {foo};\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。\n\n我们再来看 es6 模块加载器systemjs给出的一个例子。\n\n// even.js\nimport { odd } from \'./odd\'\nexport var counter = 0;\nexport function even(n) {\n  counter++;\n  return n === 0 || odd(n - 1);\n}\n\n// odd.js\nimport { even } from \'./even\';\nexport function odd(n) {\n  return n !== 0 && even(n - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，even.js里面的函数even有一个参数n，只要不等于 0，就会减去 1，传入加载的odd()。odd.js也会做类似操作。\n\n运行上面这段代码，结果如下。\n\n$ babel-node\n> import * as m from \'./even.js\';\n> m.even(10);\ntrue\n> m.counter\n6\n> m.even(20)\ntrue\n> m.counter\n17\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，参数n从 10 变为 0 的过程中，even()一共会执行 6 次，所以变量counter等于 6。第二次调用even()时，参数n从 20 变为 0，even()一共会执行 11 次，加上前面的 6 次，所以变量counter等于 17。\n\n这个例子要是改写成 commonjs，就根本无法执行，会报错。\n\n// even.js\nvar odd = require(\'./odd\');\nvar counter = 0;\nexports.counter = counter;\nexports.even = function (n) {\n  counter++;\n  return n == 0 || odd(n - 1);\n}\n\n// odd.js\nvar even = require(\'./even\').even;\nmodule.exports = function (n) {\n  return n != 0 && even(n - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成“循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于undefined，等到后面调用even(n - 1)就会报错。\n\n$ node\n> var m = require(\'./even\');\n> m.even(10)\ntypeerror: even is not a function\n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"编程风格",frontmatter:{title:"编程风格",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/984bf549204bb266",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/25.%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC.html",relativePath:"《ES6 教程》笔记/25.编程风格.md",key:"v-092c0610",path:"/pages/984bf549204bb266/",headers:[{level:2,title:"块级作用域",slug:"块级作用域",normalizedTitle:"块级作用域",charIndex:141},{level:2,title:"字符串",slug:"字符串",normalizedTitle:"字符串",charIndex:1251},{level:2,title:"解构赋值",slug:"解构赋值",normalizedTitle:"解构赋值",charIndex:1465},{level:2,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:1640},{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:1473},{level:2,title:"函数",slug:"函数",normalizedTitle:"函数",charIndex:787},{level:2,title:"Map 结构",slug:"map-结构",normalizedTitle:"map 结构",charIndex:5039},{level:2,title:"Class",slug:"class",normalizedTitle:"class",charIndex:5384},{level:2,title:"模块",slug:"模块",normalizedTitle:"模块",charIndex:6272},{level:2,title:"ESLint 的使用",slug:"eslint-的使用",normalizedTitle:"eslint 的使用",charIndex:7372}],excerpt:'<h1 id="编程风格"><a class="header-anchor" href="#编程风格">#</a> 编程风格</h1>\n<p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。</p>\n<p>多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener noreferrer">Airbnb<OutboundLink/></a> 公司的 JavaScript 风格规范。</p>\n',headersStr:"块级作用域 字符串 解构赋值 对象 数组 函数 Map 结构 Class 模块 ESLint 的使用",content:"# 编程风格\n\n本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。\n\n多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 Airbnb 公司的 JavaScript 风格规范。\n\n\n# 块级作用域\n\n（1）let 取代 var\n\nES6 提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。\n\n'use strict';\n\nif (true) {\n  let x = 'hello';\n}\n\nfor (let i = 0; i < 10; i++) {\n  console.log(i);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。\n\nvar命令存在变量提升效用，let命令没有这个问题。\n\n'use strict';\n\nif (true) {\n  console.log(x); // ReferenceError\n  let x = 'hello';\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。\n\n所以，建议不再使用var命令，而是使用let命令取代。\n\n（2）全局常量和线程安全\n\n在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。\n\nconst优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。\n\n// bad\nvar a = 1, b = 2, c = 3;\n\n// good\nconst a = 1;\nconst b = 2;\nconst c = 3;\n\n// best\nconst [a, b, c] = [1, 2, 3];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nconst声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。\n\n所有的函数都应该设置为常量。\n\n长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。\n\n\n# 字符串\n\n静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。\n\n// bad\nconst a = \"foobar\";\nconst b = 'foo' + a + 'bar';\n\n// acceptable\nconst c = `foobar`;\n\n// good\nconst a = 'foobar';\nconst b = `foo${a}bar`;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 解构赋值\n\n使用数组成员对变量赋值时，优先使用解构赋值。\n\nconst arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n函数的参数如果是对象的成员，优先使用解构赋值。\n\n// bad\nfunction getFullName(user) {\n  const firstName = user.firstName;\n  const lastName = user.lastName;\n}\n\n// good\nfunction getFullName(obj) {\n  const { firstName, lastName } = obj;\n}\n\n// best\nfunction getFullName({ firstName, lastName }) {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。\n\n// bad\nfunction processInput(input) {\n  return [left, right, top, bottom];\n}\n\n// good\nfunction processInput(input) {\n  return { left, right, top, bottom };\n}\n\nconst { left, right } = processInput(input);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 对象\n\n单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。\n\n// bad\nconst a = { k1: v1, k2: v2, };\nconst b = {\n  k1: v1,\n  k2: v2\n};\n\n// good\nconst a = { k1: v1, k2: v2 };\nconst b = {\n  k1: v1,\n  k2: v2,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。\n\n// bad\nconst a = {};\na.x = 3;\n\n// if reshape unavoidable\nconst a = {};\nObject.assign(a, { x: 3 });\n\n// good\nconst a = { x: null };\na.x = 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。\n\n// bad\nconst obj = {\n  id: 5,\n  name: 'San Francisco',\n};\nobj[getKey('enabled')] = true;\n\n// good\nconst obj = {\n  id: 5,\n  name: 'San Francisco',\n  [getKey('enabled')]: true,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。\n\n另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。\n\nvar ref = 'some value';\n\n// bad\nconst atom = {\n  ref: ref,\n\n  value: 1,\n\n  addValue: function (value) {\n    return atom.value + value;\n  },\n};\n\n// good\nconst atom = {\n  ref,\n\n  value: 1,\n\n  addValue(value) {\n    return atom.value + value;\n  },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 数组\n\n使用扩展运算符（...）拷贝数组。\n\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i++) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n使用 Array.from 方法，将类似数组的对象转为数组。\n\nconst foo = document.querySelectorAll('.foo');\nconst nodes = Array.from(foo);\n\n\n1\n2\n\n\n\n# 函数\n\n立即执行函数可以写成箭头函数的形式。\n\n(() => {\n  console.log('Welcome to the Internet.');\n})();\n\n\n1\n2\n3\n\n\n那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。\n\n// bad\n[1, 2, 3].map(function (x) {\n  return x * x;\n});\n\n// good\n[1, 2, 3].map((x) => {\n  return x * x;\n});\n\n// best\n[1, 2, 3].map(x => x * x);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。\n\n// bad\nconst self = this;\nconst boundMethod = function(...params) {\n  return method.apply(self, params);\n}\n\n// acceptable\nconst boundMethod = method.bind(this);\n\n// best\nconst boundMethod = (...params) => method.apply(this, params);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。\n\n所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。\n\n// bad\nfunction divide(a, b, option = false ) {\n}\n\n// good\nfunction divide(a, b, { option = false } = {}) {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n不要在函数体内使用 arguments 变量，使用 rest 运算符（...）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。\n\n// bad\nfunction concatenateAll() {\n  const args = Array.prototype.slice.call(arguments);\n  return args.join('');\n}\n\n// good\nfunction concatenateAll(...args) {\n  return args.join('');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用默认值语法设置函数参数的默认值。\n\n// bad\nfunction handleThings(opts) {\n  opts = opts || {};\n}\n\n// good\nfunction handleThings(opts = {}) {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Map 结构\n\n注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。\n\nlet map = new Map(arr);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Class\n\n总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。\n\n// bad\nfunction Queue(contents = []) {\n  this._queue = [...contents];\n}\nQueue.prototype.pop = function() {\n  const value = this._queue[0];\n  this._queue.splice(0, 1);\n  return value;\n}\n\n// good\nclass Queue {\n  constructor(contents = []) {\n    this._queue = [...contents];\n  }\n  pop() {\n    const value = this._queue[0];\n    this._queue.splice(0, 1);\n    return value;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。\n\n// bad\nconst inherits = require('inherits');\nfunction PeekableQueue(contents) {\n  Queue.apply(this, contents);\n}\ninherits(PeekableQueue, Queue);\nPeekableQueue.prototype.peek = function() {\n  return this._queue[0];\n}\n\n// good\nclass PeekableQueue extends Queue {\n  peek() {\n    return this._queue[0];\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 模块\n\n首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require。\n\n// bad\nconst moduleA = require('moduleA');\nconst func1 = moduleA.func1;\nconst func2 = moduleA.func2;\n\n// good\nimport { func1, func2 } from 'moduleA';\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n使用export取代module.exports。\n\n// commonJS的写法\nvar React = require('react');\n\nvar Breadcrumbs = React.createClass({\n  render() {\n    return <nav />;\n  }\n});\n\nmodule.exports = Breadcrumbs;\n\n// ES6的写法\nimport React from 'react';\n\nclass Breadcrumbs extends React.Component {\n  render() {\n    return <nav />;\n  }\n};\n\nexport default Breadcrumbs;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。\n\n不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。\n\n// bad\nimport * as myObject from './importModule';\n\n// good\nimport myObject from './importModule';\n\n\n1\n2\n3\n4\n5\n\n\n如果模块默认输出一个函数，函数名的首字母应该小写。\n\nfunction makeStyleGuide() {\n}\n\nexport default makeStyleGuide;\n\n\n1\n2\n3\n4\n\n\n如果模块默认输出一个对象，对象名的首字母应该大写。\n\nconst StyleGuide = {\n  es6: {\n  }\n};\n\nexport default StyleGuide;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# ESLint 的使用\n\nESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。\n\n首先，安装 ESLint。\n\n$ npm i -g eslint\n\n\n1\n\n\n然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。\n\n$ npm i -g eslint-config-airbnb\n$ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react\n\n\n1\n2\n\n\n最后，在项目的根目录下新建一个.eslintrc文件，配置 ESLint。\n\n{\n  \"extends\": \"eslint-config-airbnb\"\n}\n\n\n1\n2\n3\n\n\n现在就可以检查，当前项目的代码是否符合预设的规则。\n\nindex.js文件的代码如下。\n\nvar unusued = 'I have no purpose!';\n\nfunction greet() {\n    var message = 'Hello, World!';\n    alert(message);\n}\n\ngreet();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用 ESLint 检查这个文件，就会报出错误。\n\n$ eslint index.js\nindex.js\n  1:1  error  Unexpected var, use let or const instead          no-var\n  1:5  error  unusued is defined but never used                 no-unused-vars\n  4:5  error  Expected indentation of 2 characters but found 4  indent\n  4:5  error  Unexpected var, use let or const instead          no-var\n  5:5  error  Expected indentation of 2 characters but found 4  indent\n\n✖ 5 problems (5 errors, 0 warnings)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码说明，原文件有五个错误，其中两个是不应该使用var命令，而要使用let或const；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。",normalizedContent:"# 编程风格\n\n本章探讨如何将 es6 的新语法，运用到编码实践之中，与传统的 javascript 语法结合在一起，写出合理的、易于阅读和维护的代码。\n\n多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 airbnb 公司的 javascript 风格规范。\n\n\n# 块级作用域\n\n（1）let 取代 var\n\nes6 提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。\n\n'use strict';\n\nif (true) {\n  let x = 'hello';\n}\n\nfor (let i = 0; i < 10; i++) {\n  console.log(i);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。\n\nvar命令存在变量提升效用，let命令没有这个问题。\n\n'use strict';\n\nif (true) {\n  console.log(x); // referenceerror\n  let x = 'hello';\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。\n\n所以，建议不再使用var命令，而是使用let命令取代。\n\n（2）全局常量和线程安全\n\n在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。\n\nconst优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 javascript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。\n\n// bad\nvar a = 1, b = 2, c = 3;\n\n// good\nconst a = 1;\nconst b = 2;\nconst c = 3;\n\n// best\nconst [a, b, c] = [1, 2, 3];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nconst声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。\n\n所有的函数都应该设置为常量。\n\n长远来看，javascript 可能会有多线程的实现（比如 intel 公司的 river trail 那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。\n\n\n# 字符串\n\n静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。\n\n// bad\nconst a = \"foobar\";\nconst b = 'foo' + a + 'bar';\n\n// acceptable\nconst c = `foobar`;\n\n// good\nconst a = 'foobar';\nconst b = `foo${a}bar`;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 解构赋值\n\n使用数组成员对变量赋值时，优先使用解构赋值。\n\nconst arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n函数的参数如果是对象的成员，优先使用解构赋值。\n\n// bad\nfunction getfullname(user) {\n  const firstname = user.firstname;\n  const lastname = user.lastname;\n}\n\n// good\nfunction getfullname(obj) {\n  const { firstname, lastname } = obj;\n}\n\n// best\nfunction getfullname({ firstname, lastname }) {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。\n\n// bad\nfunction processinput(input) {\n  return [left, right, top, bottom];\n}\n\n// good\nfunction processinput(input) {\n  return { left, right, top, bottom };\n}\n\nconst { left, right } = processinput(input);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 对象\n\n单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。\n\n// bad\nconst a = { k1: v1, k2: v2, };\nconst b = {\n  k1: v1,\n  k2: v2\n};\n\n// good\nconst a = { k1: v1, k2: v2 };\nconst b = {\n  k1: v1,\n  k2: v2,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用object.assign方法。\n\n// bad\nconst a = {};\na.x = 3;\n\n// if reshape unavoidable\nconst a = {};\nobject.assign(a, { x: 3 });\n\n// good\nconst a = { x: null };\na.x = 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。\n\n// bad\nconst obj = {\n  id: 5,\n  name: 'san francisco',\n};\nobj[getkey('enabled')] = true;\n\n// good\nconst obj = {\n  id: 5,\n  name: 'san francisco',\n  [getkey('enabled')]: true,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。\n\n另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。\n\nvar ref = 'some value';\n\n// bad\nconst atom = {\n  ref: ref,\n\n  value: 1,\n\n  addvalue: function (value) {\n    return atom.value + value;\n  },\n};\n\n// good\nconst atom = {\n  ref,\n\n  value: 1,\n\n  addvalue(value) {\n    return atom.value + value;\n  },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 数组\n\n使用扩展运算符（...）拷贝数组。\n\n// bad\nconst len = items.length;\nconst itemscopy = [];\nlet i;\n\nfor (i = 0; i < len; i++) {\n  itemscopy[i] = items[i];\n}\n\n// good\nconst itemscopy = [...items];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n使用 array.from 方法，将类似数组的对象转为数组。\n\nconst foo = document.queryselectorall('.foo');\nconst nodes = array.from(foo);\n\n\n1\n2\n\n\n\n# 函数\n\n立即执行函数可以写成箭头函数的形式。\n\n(() => {\n  console.log('welcome to the internet.');\n})();\n\n\n1\n2\n3\n\n\n那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。\n\n// bad\n[1, 2, 3].map(function (x) {\n  return x * x;\n});\n\n// good\n[1, 2, 3].map((x) => {\n  return x * x;\n});\n\n// best\n[1, 2, 3].map(x => x * x);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n箭头函数取代function.prototype.bind，不应再用 self/_this/that 绑定 this。\n\n// bad\nconst self = this;\nconst boundmethod = function(...params) {\n  return method.apply(self, params);\n}\n\n// acceptable\nconst boundmethod = method.bind(this);\n\n// best\nconst boundmethod = (...params) => method.apply(this, params);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。\n\n所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。\n\n// bad\nfunction divide(a, b, option = false ) {\n}\n\n// good\nfunction divide(a, b, { option = false } = {}) {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n不要在函数体内使用 arguments 变量，使用 rest 运算符（...）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。\n\n// bad\nfunction concatenateall() {\n  const args = array.prototype.slice.call(arguments);\n  return args.join('');\n}\n\n// good\nfunction concatenateall(...args) {\n  return args.join('');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用默认值语法设置函数参数的默认值。\n\n// bad\nfunction handlethings(opts) {\n  opts = opts || {};\n}\n\n// good\nfunction handlethings(opts = {}) {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# map 结构\n\n注意区分 object 和 map，只有模拟现实世界的实体对象时，才使用 object。如果只是需要key: value的数据结构，使用 map 结构。因为 map 有内建的遍历机制。\n\nlet map = new map(arr);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# class\n\n总是用 class，取代需要 prototype 的操作。因为 class 的写法更简洁，更易于理解。\n\n// bad\nfunction queue(contents = []) {\n  this._queue = [...contents];\n}\nqueue.prototype.pop = function() {\n  const value = this._queue[0];\n  this._queue.splice(0, 1);\n  return value;\n}\n\n// good\nclass queue {\n  constructor(contents = []) {\n    this._queue = [...contents];\n  }\n  pop() {\n    const value = this._queue[0];\n    this._queue.splice(0, 1);\n    return value;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。\n\n// bad\nconst inherits = require('inherits');\nfunction peekablequeue(contents) {\n  queue.apply(this, contents);\n}\ninherits(peekablequeue, queue);\npeekablequeue.prototype.peek = function() {\n  return this._queue[0];\n}\n\n// good\nclass peekablequeue extends queue {\n  peek() {\n    return this._queue[0];\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 模块\n\n首先，module 语法是 javascript 模块的标准写法，坚持使用这种写法。使用import取代require。\n\n// bad\nconst modulea = require('modulea');\nconst func1 = modulea.func1;\nconst func2 = modulea.func2;\n\n// good\nimport { func1, func2 } from 'modulea';\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n使用export取代module.exports。\n\n// commonjs的写法\nvar react = require('react');\n\nvar breadcrumbs = react.createclass({\n  render() {\n    return <nav />;\n  }\n});\n\nmodule.exports = breadcrumbs;\n\n// es6的写法\nimport react from 'react';\n\nclass breadcrumbs extends react.component {\n  render() {\n    return <nav />;\n  }\n};\n\nexport default breadcrumbs;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。\n\n不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。\n\n// bad\nimport * as myobject from './importmodule';\n\n// good\nimport myobject from './importmodule';\n\n\n1\n2\n3\n4\n5\n\n\n如果模块默认输出一个函数，函数名的首字母应该小写。\n\nfunction makestyleguide() {\n}\n\nexport default makestyleguide;\n\n\n1\n2\n3\n4\n\n\n如果模块默认输出一个对象，对象名的首字母应该大写。\n\nconst styleguide = {\n  es6: {\n  }\n};\n\nexport default styleguide;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# eslint 的使用\n\neslint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。\n\n首先，安装 eslint。\n\n$ npm i -g eslint\n\n\n1\n\n\n然后，安装 airbnb 语法规则，以及 import、a11y、react 插件。\n\n$ npm i -g eslint-config-airbnb\n$ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react\n\n\n1\n2\n\n\n最后，在项目的根目录下新建一个.eslintrc文件，配置 eslint。\n\n{\n  \"extends\": \"eslint-config-airbnb\"\n}\n\n\n1\n2\n3\n\n\n现在就可以检查，当前项目的代码是否符合预设的规则。\n\nindex.js文件的代码如下。\n\nvar unusued = 'i have no purpose!';\n\nfunction greet() {\n    var message = 'hello, world!';\n    alert(message);\n}\n\ngreet();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用 eslint 检查这个文件，就会报出错误。\n\n$ eslint index.js\nindex.js\n  1:1  error  unexpected var, use let or const instead          no-var\n  1:5  error  unusued is defined but never used                 no-unused-vars\n  4:5  error  expected indentation of 2 characters but found 4  indent\n  4:5  error  unexpected var, use let or const instead          no-var\n  5:5  error  expected indentation of 2 characters but found 4  indent\n\n✖ 5 problems (5 errors, 0 warnings)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码说明，原文件有五个错误，其中两个是不应该使用var命令，而要使用let或const；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"异步遍历器",frontmatter:{title:"异步遍历器",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/16121351be68691b",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/27.%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8.html",relativePath:"《ES6 教程》笔记/27.异步遍历器.md",key:"v-31cb3fe6",path:"/pages/16121351be68691b/",headers:[{level:2,title:"同步遍历器的问题",slug:"同步遍历器的问题",normalizedTitle:"同步遍历器的问题",charIndex:12},{level:2,title:"异步遍历的接口",slug:"异步遍历的接口",normalizedTitle:"异步遍历的接口",charIndex:1708},{level:2,title:"for await...of",slug:"for-await-of",normalizedTitle:"for await...of",charIndex:3920},{level:2,title:"异步 Generator 函数",slug:"异步-generator-函数",normalizedTitle:"异步 generator 函数",charIndex:5704},{level:2,title:"yield* 语句",slug:"yield-语句",normalizedTitle:"yield* 语句",charIndex:10679}],excerpt:'<h1 id="异步遍历器"><a class="header-anchor" href="#异步遍历器">#</a> 异步遍历器</h1>\n<h2 id="同步遍历器的问题"><a class="header-anchor" href="#同步遍历器的问题">#</a> 同步遍历器的问题</h2>\n<p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\n',headersStr:"同步遍历器的问题 异步遍历的接口 for await...of 异步 Generator 函数 yield* 语句",content:"# 异步遍历器\n\n\n# 同步遍历器的问题\n\n《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的next方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法返回的对象的结构是{value, done}，其中value表示当前的数据的值，done是一个布尔值，表示遍历是否结束。\n\nfunction idMaker() {\n  let index = 0;\n\n  return {\n    next: function() {\n      return { value: index++, done: false };\n    }\n  };\n}\n\nconst it = idMaker();\n\nit.next().value // 0\nit.next().value // 1\nit.next().value // 2\n// ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，变量it是一个遍历器（iterator）。每次调用it.next()方法，就返回一个对象，表示当前遍历位置的信息。\n\n这里隐含着一个规定，it.next()方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行it.next()方法，就必须同步地得到value和done这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。\n\nfunction idMaker() {\n  let index = 0;\n\n  return {\n    next: function() {\n      return new Promise(function (resolve, reject) {\n        setTimeout(() => {\n          resolve({ value: index++, done: false });\n        }, 1000);\n      });\n    }\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，next()方法返回的是一个 Promise 对象，这样就不行，不符合 Iterator 协议，只要代码里面包含异步操作都不行。也就是说，Iterator 协议里面next()方法只能包含同步操作。\n\n目前的解决方法是，将异步操作包装成 Thunk 函数或者 Promise 对象，即next()方法返回值的value属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而done属性则还是同步产生的。\n\nfunction idMaker() {\n  let index = 0;\n\n  return {\n    next: function() {\n      return {\n        value: new Promise(resolve => setTimeout(() => resolve(index++), 1000)),\n        done: false\n      };\n    }\n  };\n}\n\nconst it = idMaker();\n\nit.next().value.then(o => console.log(o)) // 1\nit.next().value.then(o => console.log(o)) // 2\nit.next().value.then(o => console.log(o)) // 3\n// ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，value属性的返回值是一个 Promise 对象，用来放置异步操作。但是这样写很麻烦，不太符合直觉，语义也比较绕。\n\nES2018 引入了“异步遍历器”（Async Iterator），为异步操作提供原生的遍历器接口，即value和done这两个属性都是异步产生。\n\n\n# 异步遍历的接口\n\n异步遍历器的最大的语法特点，就是调用遍历器的next方法，返回的是一个 Promise 对象。\n\nasyncIterator\n  .next()\n  .then(\n    ({ value, done }) => /* ... */\n  );\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，asyncIterator是一个异步遍历器，调用next方法以后，返回一个 Promise 对象。因此，可以使用then方法指定，这个 Promise 对象的状态变为resolve以后的回调函数。回调函数的参数，则是一个具有value和done两个属性的对象，这个跟同步遍历器是一样的。\n\n我们知道，一个对象的同步遍历器的接口，部署在Symbol.iterator属性上面。同样地，对象的异步遍历器接口，部署在Symbol.asyncIterator属性上面。不管是什么样的对象，只要它的Symbol.asyncIterator属性有值，就表示应该对它进行异步遍历。\n\n下面是一个异步遍历器的例子。\n\nconst asyncIterable = createAsyncIterable(['a', 'b']);\nconst asyncIterator = asyncIterable[Symbol.asyncIterator]();\n\nasyncIterator\n.next()\n.then(iterResult1 => {\n  console.log(iterResult1); // { value: 'a', done: false }\n  return asyncIterator.next();\n})\n.then(iterResult2 => {\n  console.log(iterResult2); // { value: 'b', done: false }\n  return asyncIterator.next();\n})\n.then(iterResult3 => {\n  console.log(iterResult3); // { value: undefined, done: true }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象resolve了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。\n\n由于异步遍历器的next方法，返回的是一个 Promise 对象。因此，可以把它放在await命令后面。\n\nasync function f() {\n  const asyncIterable = createAsyncIterable(['a', 'b']);\n  const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n  console.log(await asyncIterator.next());\n  // { value: 'a', done: false }\n  console.log(await asyncIterator.next());\n  // { value: 'b', done: false }\n  console.log(await asyncIterator.next());\n  // { value: undefined, done: true }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，next方法用await处理以后，就不必使用then方法了。整个流程已经很接近同步处理了。\n\n注意，异步遍历器的next方法是可以连续调用的，不必等到上一步产生的 Promise 对象resolve以后再调用。这种情况下，next方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的next方法放在Promise.all方法里面。\n\nconst asyncIterable = createAsyncIterable(['a', 'b']);\nconst asyncIterator = asyncIterable[Symbol.asyncIterator]();\nconst [{value: v1}, {value: v2}] = await Promise.all([\n  asyncIterator.next(), asyncIterator.next()\n]);\n\nconsole.log(v1, v2); // a b\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n另一种用法是一次性调用所有的next方法，然后await最后一步操作。\n\nasync function runner() {\n  const writer = openFile('someFile.txt');\n  writer.next('hello');\n  writer.next('world');\n  await writer.return();\n}\n\nrunner();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# for await...of\n\n前面介绍过，for...of循环用于遍历同步的 Iterator 接口。新引入的for await...of循环，则是用于遍历异步的 Iterator 接口。\n\nasync function f() {\n  for await (const x of createAsyncIterable(['a', 'b'])) {\n    console.log(x);\n  }\n}\n// a\n// b\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，createAsyncIterable()返回一个拥有异步遍历器接口的对象，for...of循环自动调用这个对象的异步遍历器的next方法，会得到一个 Promise 对象。await用来处理这个 Promise 对象，一旦resolve，就把得到的值（x）传入for...of的循环体。\n\nfor await...of循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。\n\nlet body = '';\n\nasync function f() {\n  for await(const data of req) body += data;\n  const parsed = JSON.parse(body);\n  console.log('got', parsed);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，req是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用for await...of循环以后，代码会非常简洁。\n\n如果next方法返回的 Promise 对象被reject，for await...of就会报错，要用try...catch捕捉。\n\nasync function () {\n  try {\n    for await (const x of createRejectingIterable()) {\n      console.log(x);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意，for await...of循环也可以用于同步遍历器。\n\n(async function () {\n  for await (const x of ['a', 'b']) {\n    console.log(x);\n  }\n})();\n// a\n// b\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNode v10 支持异步遍历器，Stream 就部署了这个接口。下面是读取文件的传统写法与异步遍历器写法的差异。\n\n// 传统写法\nfunction main(inputFilePath) {\n  const readStream = fs.createReadStream(\n    inputFilePath,\n    { encoding: 'utf8', highWaterMark: 1024 }\n  );\n  readStream.on('data', (chunk) => {\n    console.log('>>> '+chunk);\n  });\n  readStream.on('end', () => {\n    console.log('### DONE ###');\n  });\n}\n\n// 异步遍历器写法\nasync function main(inputFilePath) {\n  const readStream = fs.createReadStream(\n    inputFilePath,\n    { encoding: 'utf8', highWaterMark: 1024 }\n  );\n\n  for await (const chunk of readStream) {\n    console.log('>>> '+chunk);\n  }\n  console.log('### DONE ###');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 异步 Generator 函数\n\n就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。\n\n在语法上，异步 Generator 函数就是async函数与 Generator 函数的结合。\n\nasync function* gen() {\n  yield 'hello';\n}\nconst genObj = gen();\ngenObj.next().then(x => console.log(x));\n// { value: 'hello', done: false }\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，gen是一个异步 Generator 函数，执行后返回一个异步 Iterator 对象。对该对象调用next方法，返回一个 Promise 对象。\n\n异步遍历器的设计目的之一，就是 Generator 函数处理同步操作和异步操作时，能够使用同一套接口。\n\n// 同步 Generator 函数\nfunction* map(iterable, func) {\n  const iter = iterable[Symbol.iterator]();\n  while (true) {\n    const {value, done} = iter.next();\n    if (done) break;\n    yield func(value);\n  }\n}\n\n// 异步 Generator 函数\nasync function* map(iterable, func) {\n  const iter = iterable[Symbol.asyncIterator]();\n  while (true) {\n    const {value, done} = await iter.next();\n    if (done) break;\n    yield func(value);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，map是一个 Generator 函数，第一个参数是可遍历对象iterable，第二个参数是一个回调函数func。map的作用是将iterable每一步返回的值，使用func进行处理。上面有两个版本的map，前一个处理同步遍历器，后一个处理异步遍历器，可以看到两个版本的写法基本上是一致的。\n\n下面是另一个异步 Generator 函数的例子。\n\nasync function* readLines(path) {\n  let file = await fileOpen(path);\n\n  try {\n    while (!file.EOF) {\n      yield await file.readLine();\n    }\n  } finally {\n    await file.close();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，异步操作前面使用await关键字标明，即await后面的操作，应该返回 Promise 对象。凡是使用yield关键字的地方，就是next方法停下来的地方，它后面的表达式的值（即await file.readLine()的值），会作为next()返回对象的value属性，这一点是与同步 Generator 函数一致的。\n\n异步 Generator 函数内部，能够同时使用await和yield命令。可以这样理解，await命令用于将外部操作产生的值输入函数内部，yield命令用于将函数内部的值输出。\n\n上面代码定义的异步 Generator 函数的用法如下。\n\n(async function () {\n  for await (const line of readLines(filePath)) {\n    console.log(line);\n  }\n})()\n\n\n1\n2\n3\n4\n5\n\n\n异步 Generator 函数可以与for await...of循环结合起来使用。\n\nasync function* prefixLines(asyncIterable) {\n  for await (const line of asyncIterable) {\n    yield '> ' + line;\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n异步 Generator 函数的返回值是一个异步 Iterator，即每次调用它的next方法，会返回一个 Promise 对象，也就是说，跟在yield命令后面的，应该是一个 Promise 对象。如果像上面那个例子那样，yield命令后面是一个字符串，会被自动包装成一个 Promise 对象。\n\nfunction fetchRandom() {\n  const url = 'https://www.random.org/decimal-fractions/'\n    + '?num=1&dec=10&col=1&format=plain&rnd=new';\n  return fetch(url);\n}\n\nasync function* asyncGenerator() {\n  console.log('Start');\n  const result = await fetchRandom(); // (A)\n  yield 'Result: ' + await result.text(); // (B)\n  console.log('Done');\n}\n\nconst ag = asyncGenerator();\nag.next().then(({value, done}) => {\n  console.log(value);\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，ag是asyncGenerator函数返回的异步遍历器对象。调用ag.next()以后，上面代码的执行顺序如下。\n\n 1. ag.next()立刻返回一个 Promise 对象。\n 2. asyncGenerator函数开始执行，打印出Start。\n 3. await命令返回一个 Promise 对象，asyncGenerator函数停在这里。\n 4. A 处变成 fulfilled 状态，产生的值放入result变量，asyncGenerator函数继续往下执行。\n 5. 函数在 B 处的yield暂停执行，一旦yield命令取到值，ag.next()返回的那个 Promise 对象变成 fulfilled 状态。\n 6. ag.next()后面的then方法指定的回调函数开始执行。该回调函数的参数是一个对象{value, done}，其中value的值是yield命令后面的那个表达式的值，done的值是false。\n\nA 和 B 两行的作用类似于下面的代码。\n\nreturn new Promise((resolve, reject) => {\n  fetchRandom()\n  .then(result => result.text())\n  .then(result => {\n     resolve({\n       value: 'Result: ' + result,\n       done: false,\n     });\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果异步 Generator 函数抛出错误，会导致 Promise 对象的状态变为reject，然后抛出的错误被catch方法捕获。\n\nasync function* asyncGenerator() {\n  throw new Error('Problem!');\n}\n\nasyncGenerator()\n.next()\n.catch(err => console.log(err)); // Error: Problem!\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步 Iterator 对象。可以这样理解，async 函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过for await...of执行，或者自己编写执行器。下面就是一个异步 Generator 函数的执行器。\n\nasync function takeAsync(asyncIterable, count = Infinity) {\n  const result = [];\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  while (result.length < count) {\n    const {value, done} = await iterator.next();\n    if (done) break;\n    result.push(value);\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，异步 Generator 函数产生的异步遍历器，会通过while循环自动执行，每当await iterator.next()完成，就会进入下一轮循环。一旦done属性变为true，就会跳出循环，异步遍历器执行结束。\n\n下面是这个自动执行器的一个使用实例。\n\nasync function f() {\n  async function* gen() {\n    yield 'a';\n    yield 'b';\n    yield 'c';\n  }\n\n  return await takeAsync(gen());\n}\n\nf().then(function (result) {\n  console.log(result); // ['a', 'b', 'c']\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n异步 Generator 函数出现以后，JavaScript 就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。基本上，如果是一系列按照顺序执行的异步操作（比如读取文件，然后写入新内容，再存入硬盘），可以使用 async 函数；如果是一系列产生相同数据结构的异步操作（比如一行一行读取文件），可以使用异步 Generator 函数。\n\n异步 Generator 函数也可以通过next方法的参数，接收外部传入的数据。\n\nconst writer = openFile('someFile.txt');\nwriter.next('hello'); // 立即执行\nwriter.next('world'); // 立即执行\nawait writer.return(); // 等待写入结束\n\n\n1\n2\n3\n4\n\n\n上面代码中，openFile是一个异步 Generator 函数。next方法的参数，向该函数内部的操作传入数据。每次next方法都是同步执行的，最后的await命令用于等待整个写入操作结束。\n\n最后，同步的数据结构，也可以使用异步 Generator 函数。\n\nasync function* createAsyncIterable(syncIterable) {\n  for (const elem of syncIterable) {\n    yield elem;\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，由于没有异步操作，所以也就没有使用await关键字。\n\n\n# yield* 语句\n\nyield*语句也可以跟一个异步遍历器。\n\nasync function* gen1() {\n  yield 'a';\n  yield 'b';\n  return 2;\n}\n\nasync function* gen2() {\n  // result 最终会等于 2\n  const result = yield* gen1();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，gen2函数里面的result变量，最后的值是2。\n\n与同步 Generator 函数一样，for await...of循环会展开yield*。\n\n(async function () {\n  for await (const x of gen2()) {\n    console.log(x);\n  }\n})();\n// a\n// b\n\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"# 异步遍历器\n\n\n# 同步遍历器的问题\n\n《遍历器》一章说过，iterator 接口是一种数据遍历的协议，只要调用遍历器对象的next方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法返回的对象的结构是{value, done}，其中value表示当前的数据的值，done是一个布尔值，表示遍历是否结束。\n\nfunction idmaker() {\n  let index = 0;\n\n  return {\n    next: function() {\n      return { value: index++, done: false };\n    }\n  };\n}\n\nconst it = idmaker();\n\nit.next().value // 0\nit.next().value // 1\nit.next().value // 2\n// ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，变量it是一个遍历器（iterator）。每次调用it.next()方法，就返回一个对象，表示当前遍历位置的信息。\n\n这里隐含着一个规定，it.next()方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行it.next()方法，就必须同步地得到value和done这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。\n\nfunction idmaker() {\n  let index = 0;\n\n  return {\n    next: function() {\n      return new promise(function (resolve, reject) {\n        settimeout(() => {\n          resolve({ value: index++, done: false });\n        }, 1000);\n      });\n    }\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，next()方法返回的是一个 promise 对象，这样就不行，不符合 iterator 协议，只要代码里面包含异步操作都不行。也就是说，iterator 协议里面next()方法只能包含同步操作。\n\n目前的解决方法是，将异步操作包装成 thunk 函数或者 promise 对象，即next()方法返回值的value属性是一个 thunk 函数或者 promise 对象，等待以后返回真正的值，而done属性则还是同步产生的。\n\nfunction idmaker() {\n  let index = 0;\n\n  return {\n    next: function() {\n      return {\n        value: new promise(resolve => settimeout(() => resolve(index++), 1000)),\n        done: false\n      };\n    }\n  };\n}\n\nconst it = idmaker();\n\nit.next().value.then(o => console.log(o)) // 1\nit.next().value.then(o => console.log(o)) // 2\nit.next().value.then(o => console.log(o)) // 3\n// ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，value属性的返回值是一个 promise 对象，用来放置异步操作。但是这样写很麻烦，不太符合直觉，语义也比较绕。\n\nes2018 引入了“异步遍历器”（async iterator），为异步操作提供原生的遍历器接口，即value和done这两个属性都是异步产生。\n\n\n# 异步遍历的接口\n\n异步遍历器的最大的语法特点，就是调用遍历器的next方法，返回的是一个 promise 对象。\n\nasynciterator\n  .next()\n  .then(\n    ({ value, done }) => /* ... */\n  );\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，asynciterator是一个异步遍历器，调用next方法以后，返回一个 promise 对象。因此，可以使用then方法指定，这个 promise 对象的状态变为resolve以后的回调函数。回调函数的参数，则是一个具有value和done两个属性的对象，这个跟同步遍历器是一样的。\n\n我们知道，一个对象的同步遍历器的接口，部署在symbol.iterator属性上面。同样地，对象的异步遍历器接口，部署在symbol.asynciterator属性上面。不管是什么样的对象，只要它的symbol.asynciterator属性有值，就表示应该对它进行异步遍历。\n\n下面是一个异步遍历器的例子。\n\nconst asynciterable = createasynciterable(['a', 'b']);\nconst asynciterator = asynciterable[symbol.asynciterator]();\n\nasynciterator\n.next()\n.then(iterresult1 => {\n  console.log(iterresult1); // { value: 'a', done: false }\n  return asynciterator.next();\n})\n.then(iterresult2 => {\n  console.log(iterresult2); // { value: 'b', done: false }\n  return asynciterator.next();\n})\n.then(iterresult3 => {\n  console.log(iterresult3); // { value: undefined, done: true }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 promise 对象；等到 promise 对象resolve了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 promise 对象，作为中介。\n\n由于异步遍历器的next方法，返回的是一个 promise 对象。因此，可以把它放在await命令后面。\n\nasync function f() {\n  const asynciterable = createasynciterable(['a', 'b']);\n  const asynciterator = asynciterable[symbol.asynciterator]();\n  console.log(await asynciterator.next());\n  // { value: 'a', done: false }\n  console.log(await asynciterator.next());\n  // { value: 'b', done: false }\n  console.log(await asynciterator.next());\n  // { value: undefined, done: true }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，next方法用await处理以后，就不必使用then方法了。整个流程已经很接近同步处理了。\n\n注意，异步遍历器的next方法是可以连续调用的，不必等到上一步产生的 promise 对象resolve以后再调用。这种情况下，next方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的next方法放在promise.all方法里面。\n\nconst asynciterable = createasynciterable(['a', 'b']);\nconst asynciterator = asynciterable[symbol.asynciterator]();\nconst [{value: v1}, {value: v2}] = await promise.all([\n  asynciterator.next(), asynciterator.next()\n]);\n\nconsole.log(v1, v2); // a b\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n另一种用法是一次性调用所有的next方法，然后await最后一步操作。\n\nasync function runner() {\n  const writer = openfile('somefile.txt');\n  writer.next('hello');\n  writer.next('world');\n  await writer.return();\n}\n\nrunner();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# for await...of\n\n前面介绍过，for...of循环用于遍历同步的 iterator 接口。新引入的for await...of循环，则是用于遍历异步的 iterator 接口。\n\nasync function f() {\n  for await (const x of createasynciterable(['a', 'b'])) {\n    console.log(x);\n  }\n}\n// a\n// b\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，createasynciterable()返回一个拥有异步遍历器接口的对象，for...of循环自动调用这个对象的异步遍历器的next方法，会得到一个 promise 对象。await用来处理这个 promise 对象，一旦resolve，就把得到的值（x）传入for...of的循环体。\n\nfor await...of循环的一个用途，是部署了 asynciterable 操作的异步接口，可以直接放入这个循环。\n\nlet body = '';\n\nasync function f() {\n  for await(const data of req) body += data;\n  const parsed = json.parse(body);\n  console.log('got', parsed);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，req是一个 asynciterable 对象，用来异步读取数据。可以看到，使用for await...of循环以后，代码会非常简洁。\n\n如果next方法返回的 promise 对象被reject，for await...of就会报错，要用try...catch捕捉。\n\nasync function () {\n  try {\n    for await (const x of createrejectingiterable()) {\n      console.log(x);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意，for await...of循环也可以用于同步遍历器。\n\n(async function () {\n  for await (const x of ['a', 'b']) {\n    console.log(x);\n  }\n})();\n// a\n// b\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnode v10 支持异步遍历器，stream 就部署了这个接口。下面是读取文件的传统写法与异步遍历器写法的差异。\n\n// 传统写法\nfunction main(inputfilepath) {\n  const readstream = fs.createreadstream(\n    inputfilepath,\n    { encoding: 'utf8', highwatermark: 1024 }\n  );\n  readstream.on('data', (chunk) => {\n    console.log('>>> '+chunk);\n  });\n  readstream.on('end', () => {\n    console.log('### done ###');\n  });\n}\n\n// 异步遍历器写法\nasync function main(inputfilepath) {\n  const readstream = fs.createreadstream(\n    inputfilepath,\n    { encoding: 'utf8', highwatermark: 1024 }\n  );\n\n  for await (const chunk of readstream) {\n    console.log('>>> '+chunk);\n  }\n  console.log('### done ###');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 异步 generator 函数\n\n就像 generator 函数返回一个同步遍历器对象一样，异步 generator 函数的作用，是返回一个异步遍历器对象。\n\n在语法上，异步 generator 函数就是async函数与 generator 函数的结合。\n\nasync function* gen() {\n  yield 'hello';\n}\nconst genobj = gen();\ngenobj.next().then(x => console.log(x));\n// { value: 'hello', done: false }\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，gen是一个异步 generator 函数，执行后返回一个异步 iterator 对象。对该对象调用next方法，返回一个 promise 对象。\n\n异步遍历器的设计目的之一，就是 generator 函数处理同步操作和异步操作时，能够使用同一套接口。\n\n// 同步 generator 函数\nfunction* map(iterable, func) {\n  const iter = iterable[symbol.iterator]();\n  while (true) {\n    const {value, done} = iter.next();\n    if (done) break;\n    yield func(value);\n  }\n}\n\n// 异步 generator 函数\nasync function* map(iterable, func) {\n  const iter = iterable[symbol.asynciterator]();\n  while (true) {\n    const {value, done} = await iter.next();\n    if (done) break;\n    yield func(value);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码中，map是一个 generator 函数，第一个参数是可遍历对象iterable，第二个参数是一个回调函数func。map的作用是将iterable每一步返回的值，使用func进行处理。上面有两个版本的map，前一个处理同步遍历器，后一个处理异步遍历器，可以看到两个版本的写法基本上是一致的。\n\n下面是另一个异步 generator 函数的例子。\n\nasync function* readlines(path) {\n  let file = await fileopen(path);\n\n  try {\n    while (!file.eof) {\n      yield await file.readline();\n    }\n  } finally {\n    await file.close();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，异步操作前面使用await关键字标明，即await后面的操作，应该返回 promise 对象。凡是使用yield关键字的地方，就是next方法停下来的地方，它后面的表达式的值（即await file.readline()的值），会作为next()返回对象的value属性，这一点是与同步 generator 函数一致的。\n\n异步 generator 函数内部，能够同时使用await和yield命令。可以这样理解，await命令用于将外部操作产生的值输入函数内部，yield命令用于将函数内部的值输出。\n\n上面代码定义的异步 generator 函数的用法如下。\n\n(async function () {\n  for await (const line of readlines(filepath)) {\n    console.log(line);\n  }\n})()\n\n\n1\n2\n3\n4\n5\n\n\n异步 generator 函数可以与for await...of循环结合起来使用。\n\nasync function* prefixlines(asynciterable) {\n  for await (const line of asynciterable) {\n    yield '> ' + line;\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n异步 generator 函数的返回值是一个异步 iterator，即每次调用它的next方法，会返回一个 promise 对象，也就是说，跟在yield命令后面的，应该是一个 promise 对象。如果像上面那个例子那样，yield命令后面是一个字符串，会被自动包装成一个 promise 对象。\n\nfunction fetchrandom() {\n  const url = 'https://www.random.org/decimal-fractions/'\n    + '?num=1&dec=10&col=1&format=plain&rnd=new';\n  return fetch(url);\n}\n\nasync function* asyncgenerator() {\n  console.log('start');\n  const result = await fetchrandom(); // (a)\n  yield 'result: ' + await result.text(); // (b)\n  console.log('done');\n}\n\nconst ag = asyncgenerator();\nag.next().then(({value, done}) => {\n  console.log(value);\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，ag是asyncgenerator函数返回的异步遍历器对象。调用ag.next()以后，上面代码的执行顺序如下。\n\n 1. ag.next()立刻返回一个 promise 对象。\n 2. asyncgenerator函数开始执行，打印出start。\n 3. await命令返回一个 promise 对象，asyncgenerator函数停在这里。\n 4. a 处变成 fulfilled 状态，产生的值放入result变量，asyncgenerator函数继续往下执行。\n 5. 函数在 b 处的yield暂停执行，一旦yield命令取到值，ag.next()返回的那个 promise 对象变成 fulfilled 状态。\n 6. ag.next()后面的then方法指定的回调函数开始执行。该回调函数的参数是一个对象{value, done}，其中value的值是yield命令后面的那个表达式的值，done的值是false。\n\na 和 b 两行的作用类似于下面的代码。\n\nreturn new promise((resolve, reject) => {\n  fetchrandom()\n  .then(result => result.text())\n  .then(result => {\n     resolve({\n       value: 'result: ' + result,\n       done: false,\n     });\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果异步 generator 函数抛出错误，会导致 promise 对象的状态变为reject，然后抛出的错误被catch方法捕获。\n\nasync function* asyncgenerator() {\n  throw new error('problem!');\n}\n\nasyncgenerator()\n.next()\n.catch(err => console.log(err)); // error: problem!\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意，普通的 async 函数返回的是一个 promise 对象，而异步 generator 函数返回的是一个异步 iterator 对象。可以这样理解，async 函数和异步 generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过for await...of执行，或者自己编写执行器。下面就是一个异步 generator 函数的执行器。\n\nasync function takeasync(asynciterable, count = infinity) {\n  const result = [];\n  const iterator = asynciterable[symbol.asynciterator]();\n  while (result.length < count) {\n    const {value, done} = await iterator.next();\n    if (done) break;\n    result.push(value);\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，异步 generator 函数产生的异步遍历器，会通过while循环自动执行，每当await iterator.next()完成，就会进入下一轮循环。一旦done属性变为true，就会跳出循环，异步遍历器执行结束。\n\n下面是这个自动执行器的一个使用实例。\n\nasync function f() {\n  async function* gen() {\n    yield 'a';\n    yield 'b';\n    yield 'c';\n  }\n\n  return await takeasync(gen());\n}\n\nf().then(function (result) {\n  console.log(result); // ['a', 'b', 'c']\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n异步 generator 函数出现以后，javascript 就有了四种函数形式：普通函数、async 函数、generator 函数和异步 generator 函数。请注意区分每种函数的不同之处。基本上，如果是一系列按照顺序执行的异步操作（比如读取文件，然后写入新内容，再存入硬盘），可以使用 async 函数；如果是一系列产生相同数据结构的异步操作（比如一行一行读取文件），可以使用异步 generator 函数。\n\n异步 generator 函数也可以通过next方法的参数，接收外部传入的数据。\n\nconst writer = openfile('somefile.txt');\nwriter.next('hello'); // 立即执行\nwriter.next('world'); // 立即执行\nawait writer.return(); // 等待写入结束\n\n\n1\n2\n3\n4\n\n\n上面代码中，openfile是一个异步 generator 函数。next方法的参数，向该函数内部的操作传入数据。每次next方法都是同步执行的，最后的await命令用于等待整个写入操作结束。\n\n最后，同步的数据结构，也可以使用异步 generator 函数。\n\nasync function* createasynciterable(synciterable) {\n  for (const elem of synciterable) {\n    yield elem;\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，由于没有异步操作，所以也就没有使用await关键字。\n\n\n# yield* 语句\n\nyield*语句也可以跟一个异步遍历器。\n\nasync function* gen1() {\n  yield 'a';\n  yield 'b';\n  return 2;\n}\n\nasync function* gen2() {\n  // result 最终会等于 2\n  const result = yield* gen1();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，gen2函数里面的result变量，最后的值是2。\n\n与同步 generator 函数一样，for await...of循环会展开yield*。\n\n(async function () {\n  for await (const x of gen2()) {\n    console.log(x);\n  }\n})();\n// a\n// b\n\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"ArrayBuffer",frontmatter:{title:"ArrayBuffer",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/a2ba314746bfdbdd",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/28.ArrayBuffer.html",relativePath:"《ES6 教程》笔记/28.ArrayBuffer.md",key:"v-6145bf5a",path:"/pages/a2ba314746bfdbdd/",headers:[{level:2,title:"ArrayBuffer 对象",slug:"arraybuffer-对象",normalizedTitle:"arraybuffer 对象",charIndex:1609},{level:3,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:1628},{level:3,title:"ArrayBuffer.prototype.byteLength",slug:"arraybuffer-prototype-bytelength",normalizedTitle:"arraybuffer.prototype.bytelength",charIndex:2801},{level:3,title:"ArrayBuffer.prototype.slice()",slug:"arraybuffer-prototype-slice",normalizedTitle:"arraybuffer.prototype.slice()",charIndex:3078},{level:3,title:"ArrayBuffer.isView()",slug:"arraybuffer-isview",normalizedTitle:"arraybuffer.isview()",charIndex:3529},{level:2,title:"TypedArray 视图",slug:"typedarray-视图",normalizedTitle:"typedarray 视图",charIndex:3804},{level:3,title:"概述",slug:"概述-2",normalizedTitle:"概述",charIndex:1628},{level:3,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:1739},{level:3,title:"数组方法",slug:"数组方法",normalizedTitle:"数组方法",charIndex:7066},{level:3,title:"字节序",slug:"字节序",normalizedTitle:"字节序",charIndex:849},{level:3,title:"BYTESPERELEMENT 属性",slug:"bytes-per-element-属性",normalizedTitle:"bytesperelement 属性",charIndex:null},{level:3,title:"ArrayBuffer 与字符串的互相转换",slug:"arraybuffer-与字符串的互相转换",normalizedTitle:"arraybuffer 与字符串的互相转换",charIndex:11652},{level:3,title:"溢出",slug:"溢出",normalizedTitle:"溢出",charIndex:1175},{level:3,title:"TypedArray.prototype.buffer",slug:"typedarray-prototype-buffer",normalizedTitle:"typedarray.prototype.buffer",charIndex:14118},{level:3,title:"TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset",slug:"typedarray-prototype-bytelength-typedarray-prototype-byteoffset",normalizedTitle:"typedarray.prototype.bytelength，typedarray.prototype.byteoffset",charIndex:14329},{level:3,title:"TypedArray.prototype.length",slug:"typedarray-prototype-length",normalizedTitle:"typedarray.prototype.length",charIndex:14785},{level:3,title:"TypedArray.prototype.set()",slug:"typedarray-prototype-set",normalizedTitle:"typedarray.prototype.set()",charIndex:14973},{level:3,title:"TypedArray.prototype.subarray()",slug:"typedarray-prototype-subarray",normalizedTitle:"typedarray.prototype.subarray()",charIndex:15355},{level:3,title:"TypedArray.prototype.slice()",slug:"typedarray-prototype-slice",normalizedTitle:"typedarray.prototype.slice()",charIndex:15657},{level:3,title:"TypedArray.of()",slug:"typedarray-of",normalizedTitle:"typedarray.of()",charIndex:15951},{level:3,title:"TypedArray.from()",slug:"typedarray-from",normalizedTitle:"typedarray.from()",charIndex:16322},{level:2,title:"复合视图",slug:"复合视图",normalizedTitle:"复合视图",charIndex:16924},{level:2,title:"DataView 视图",slug:"dataview-视图",normalizedTitle:"dataview 视图",charIndex:17436},{level:2,title:"二进制数组的应用",slug:"二进制数组的应用",normalizedTitle:"二进制数组的应用",charIndex:19853},{level:3,title:"AJAX",slug:"ajax",normalizedTitle:"ajax",charIndex:19904},{level:3,title:"Canvas",slug:"canvas",normalizedTitle:"canvas",charIndex:1541},{level:3,title:"WebSocket",slug:"websocket",normalizedTitle:"websocket",charIndex:1576},{level:3,title:"Fetch API",slug:"fetch-api",normalizedTitle:"fetch api",charIndex:1551},{level:3,title:"File API",slug:"file-api",normalizedTitle:"file api",charIndex:1564},{level:2,title:"SharedArrayBuffer",slug:"sharedarraybuffer",normalizedTitle:"sharedarraybuffer",charIndex:24086},{level:2,title:"Atomics 对象",slug:"atomics-对象",normalizedTitle:"atomics 对象",charIndex:26147}],excerpt:'<h1 id="arraybuffer"><a class="header-anchor" href="#arraybuffer">#</a> ArrayBuffer</h1>\n<p><code>ArrayBuffer</code>对象、<code>TypedArray</code>视图和<code>DataView</code>视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。</p>\n',headersStr:"ArrayBuffer 对象 概述 ArrayBuffer.prototype.byteLength ArrayBuffer.prototype.slice() ArrayBuffer.isView() TypedArray 视图 概述 构造函数 数组方法 字节序 BYTESPERELEMENT 属性 ArrayBuffer 与字符串的互相转换 溢出 TypedArray.prototype.buffer TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset TypedArray.prototype.length TypedArray.prototype.set() TypedArray.prototype.subarray() TypedArray.prototype.slice() TypedArray.of() TypedArray.from() 复合视图 DataView 视图 二进制数组的应用 AJAX Canvas WebSocket Fetch API File API SharedArrayBuffer Atomics 对象",content:"# ArrayBuffer\n\nArrayBuffer对象、TypedArray视图和DataView视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。 这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 JavaScript 脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像 C 语言那样，直接操作字节，将 4 个字节的 32 位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。\n\n二进制数组就是在这种背景下诞生的。它很像 C 语言的数组，允许开发者以数组下标的形式，直接操作内存，大大增强了 JavaScript 处理二进制数据的能力，使得开发者有可能通过 JavaScript 与操作系统的原生接口进行二进制通信。\n\n二进制数组由三类对象组成。\n\n（1）ArrayBuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。\n\n（2）TypedArray视图：共包括 9 种类型的视图，比如Uint8Array（无符号 8 位整数）数组视图, Int16Array（16 位整数）数组视图, Float32Array（32 位浮点数）数组视图等等。\n\n（3）DataView视图：可以自定义复合格式的视图，比如第一个字节是 Uint8（无符号 8 位整数）、第二、三个字节是 Int16（16 位整数）、第四个字节开始是 Float32（32 位浮点数）等等，此外还可以自定义字节序。\n\n简单说，ArrayBuffer对象代表原始的二进制数据，TypedArray视图用来读写简单类型的二进制数据，DataView视图用来读写复杂类型的二进制数据。\n\nTypedArray视图支持的数据类型一共有 9 种（DataView视图支持除Uint8C以外的其他 8 种）。\n\n数据类型      字节长度   含义                  对应的 C 语言类型\nInt8      1      8 位带符号整数            signed char\nUint8     1      8 位不带符号整数           unsigned char\nUint8C    1      8 位不带符号整数（自动过滤溢出）   unsigned char\nInt16     2      16 位带符号整数           short\nUint16    2      16 位不带符号整数          unsigned short\nInt32     4      32 位带符号整数           int\nUint32    4      32 位不带符号的整数         unsigned int\nFloat32   4      32 位浮点数             float\nFloat64   8      64 位浮点数             double\n\n注意，二进制数组并不是真正的数组，而是类似数组的对象。\n\n很多浏览器操作的 API，用到了二进制数组操作二进制数据，下面是其中的几个。\n\n * Canvas\n * Fetch API\n * File API\n * WebSockets\n * XMLHttpRequest\n\n\n# ArrayBuffer 对象\n\n\n# 概述\n\nArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。\n\nArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。\n\nconst buf = new ArrayBuffer(32);\n\n\n1\n\n\n上面代码生成了一段 32 字节的内存区域，每个字节的值默认都是 0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。\n\n为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。\n\nconst buf = new ArrayBuffer(32);\nconst dataView = new DataView(buf);\ndataView.getUint8(0) // 0\n\n\n1\n2\n3\n\n\n上面代码对一段 32 字节的内存，建立DataView视图，然后以不带符号的 8 位整数格式，从头读取 8 位二进制数据，结果得到 0，因为原始内存的ArrayBuffer对象，默认所有位都是 0。\n\n另一种TypedArray视图，与DataView视图的一个区别是，它不是一个构造函数，而是一组构造函数，代表不同的数据格式。\n\nconst buffer = new ArrayBuffer(12);\n\nconst x1 = new Int32Array(buffer);\nx1[0] = 1;\nconst x2 = new Uint8Array(buffer);\nx2[0]  = 2;\n\nx1[0] // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码对同一段内存，分别建立两种视图：32 位带符号整数（Int32Array构造函数）和 8 位不带符号整数（Uint8Array构造函数）。由于两个视图对应的是同一段内存，一个视图修改底层内存，会影响到另一个视图。\n\nTypedArray视图的构造函数，除了接受ArrayBuffer实例作为参数，还可以接受普通数组作为参数，直接分配内存生成底层的ArrayBuffer实例，并同时完成对这段内存的赋值。\n\nconst typedArray = new Uint8Array([0,1,2]);\ntypedArray.length // 3\n\ntypedArray[0] = 5;\ntypedArray // [5, 1, 2]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码使用TypedArray视图的Uint8Array构造函数，新建一个不带符号的 8 位整数视图。可以看到，Uint8Array直接使用普通数组作为参数，对底层内存的赋值同时完成。\n\n\n# ArrayBuffer.prototype.byteLength\n\nArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。\n\nconst buffer = new ArrayBuffer(32);\nbuffer.byteLength\n// 32\n\n\n1\n2\n3\n\n\n如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。\n\nif (buffer.byteLength === n) {\n  // 成功\n} else {\n  // 失败\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# ArrayBuffer.prototype.slice()\n\nArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。\n\nconst buffer = new ArrayBuffer(8);\nconst newBuffer = buffer.slice(0, 3);\n\n\n1\n2\n\n\n上面代码拷贝buffer对象的前 3 个字节（从 0 开始，到第 3 个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。\n\nslice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。\n\n除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。\n\n\n# ArrayBuffer.isView()\n\nArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。\n\nconst buffer = new ArrayBuffer(8);\nArrayBuffer.isView(buffer) // false\n\nconst v = new Int32Array(buffer);\nArrayBuffer.isView(v) // true\n\n\n1\n2\n3\n4\n5\n\n\n\n# TypedArray 视图\n\n\n# 概述\n\nArrayBuffer对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view）。ArrayBuffer有两种视图，一种是TypedArray视图，另一种是DataView视图。前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。\n\n目前，TypedArray视图一共包括 9 种类型，每一种视图都是一种构造函数。\n\n * Int8Array：8 位有符号整数，长度 1 个字节。\n * Uint8Array：8 位无符号整数，长度 1 个字节。\n * Uint8ClampedArray：8 位无符号整数，长度 1 个字节，溢出处理不同。\n * Int16Array：16 位有符号整数，长度 2 个字节。\n * Uint16Array：16 位无符号整数，长度 2 个字节。\n * Int32Array：32 位有符号整数，长度 4 个字节。\n * Uint32Array：32 位无符号整数，长度 4 个字节。\n * Float32Array：32 位浮点数，长度 4 个字节。\n * Float64Array：64 位浮点数，长度 8 个字节。\n\n这 9 个构造函数生成的数组，统称为TypedArray视图。它们很像普通数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在它们上面都能使用。普通数组与 TypedArray 数组的差异主要在以下方面。\n\n * TypedArray 数组的所有成员，都是同一种类型。\n * TypedArray 数组的成员是连续的，不会有空位。\n * TypedArray 数组成员的默认值为 0。比如，new Array(10)返回一个普通数组，里面没有任何成员，只是 10 个空位；new Uint8Array(10)返回一个 TypedArray 数组，里面 10 个成员都是 0。\n * TypedArray 数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。\n\n\n# 构造函数\n\nTypedArray 数组提供 9 种构造函数，用来生成相应类型的数组实例。\n\n构造函数有多种用法。\n\n（1）TypedArray(buffer, byteOffset=0, length?)\n\n同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。\n\n// 创建一个8字节的ArrayBuffer\nconst b = new ArrayBuffer(8);\n\n// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾\nconst v1 = new Int32Array(b);\n\n// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾\nconst v2 = new Uint8Array(b, 2);\n\n// 创建一个指向b的Int16视图，开始于字节2，长度为2\nconst v3 = new Int16Array(b, 2, 2);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码在一段长度为 8 个字节的内存（b）之上，生成了三个视图：v1、v2和v3。\n\n视图的构造函数可以接受三个参数：\n\n * 第一个参数（必需）：视图对应的底层ArrayBuffer对象。\n * 第二个参数（可选）：视图开始的字节序号，默认从 0 开始。\n * 第三个参数（可选）：视图包含的数据个数，默认直到本段内存区域结束。\n\n因此，v1、v2和v3是重叠的：v1[0]是一个 32 位整数，指向字节 0 ～字节 3；v2[0]是一个 8 位无符号整数，指向字节 2；v3[0]是一个 16 位整数，指向字节 2 ～字节 3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。\n\n注意，byteOffset必须与所要建立的数据类型一致，否则会报错。\n\nconst buffer = new ArrayBuffer(8);\nconst i16 = new Int16Array(buffer, 1);\n// Uncaught RangeError: start offset of Int16Array should be a multiple of 2\n\n\n1\n2\n3\n\n\n上面代码中，新生成一个 8 个字节的ArrayBuffer对象，然后在这个对象的第一个字节，建立带符号的 16 位整数视图，结果报错。因为，带符号的 16 位整数需要两个字节，所以byteOffset参数必须能够被 2 整除。\n\n如果想从任意字节开始解读ArrayBuffer对象，必须使用DataView视图，因为TypedArray视图只提供 9 种固定的解读格式。\n\n（2）TypedArray(length)\n\n视图还可以不通过ArrayBuffer对象，直接分配内存而生成。\n\nconst f64a = new Float64Array(8);\nf64a[0] = 10;\nf64a[1] = 20;\nf64a[2] = f64a[0] + f64a[1];\n\n\n1\n2\n3\n4\n\n\n上面代码生成一个 8 个成员的Float64Array数组（共 64 字节），然后依次对每个成员赋值。这时，视图构造函数的参数就是成员的个数。可以看到，视图数组的赋值操作与普通数组的操作毫无两样。\n\n（3）TypedArray(typedArray)\n\nTypedArray 数组的构造函数，可以接受另一个TypedArray实例作为参数。\n\nconst typedArray = new Int8Array(new Uint8Array(4));\n\n\n1\n\n\n上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。\n\n注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。\n\nconst x = new Int8Array([1, 1]);\nconst y = new Int8Array(x);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。\n\n如果想基于同一段内存，构造不同的视图，可以采用下面的写法。\n\nconst x = new Int8Array([1, 1]);\nconst y = new Int8Array(x.buffer);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（4）TypedArray(arrayLikeObject)\n\n构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。\n\nconst typedArray = new Uint8Array([1, 2, 3, 4]);\n\n\n1\n\n\n注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。\n\n上面代码从一个普通的数组，生成一个 8 位无符号整数的TypedArray实例。\n\nTypedArray 数组也可以转换回普通数组。\n\nconst normalArray = [...typedArray];\n// or\nconst normalArray = Array.from(typedArray);\n// or\nconst normalArray = Array.prototype.slice.call(typedArray);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 数组方法\n\n普通数组的操作方法和属性，对 TypedArray 数组完全适用。\n\n * TypedArray.prototype.copyWithin(target, start[, end = this.length])\n * TypedArray.prototype.entries()\n * TypedArray.prototype.every(callbackfn, thisArg?)\n * TypedArray.prototype.fill(value, start=0, end=this.length)\n * TypedArray.prototype.filter(callbackfn, thisArg?)\n * TypedArray.prototype.find(predicate, thisArg?)\n * TypedArray.prototype.findIndex(predicate, thisArg?)\n * TypedArray.prototype.forEach(callbackfn, thisArg?)\n * TypedArray.prototype.indexOf(searchElement, fromIndex=0)\n * TypedArray.prototype.join(separator)\n * TypedArray.prototype.keys()\n * TypedArray.prototype.lastIndexOf(searchElement, fromIndex?)\n * TypedArray.prototype.map(callbackfn, thisArg?)\n * TypedArray.prototype.reduce(callbackfn, initialValue?)\n * TypedArray.prototype.reduceRight(callbackfn, initialValue?)\n * TypedArray.prototype.reverse()\n * TypedArray.prototype.slice(start=0, end=this.length)\n * TypedArray.prototype.some(callbackfn, thisArg?)\n * TypedArray.prototype.sort(comparefn)\n * TypedArray.prototype.toLocaleString(reserved1?, reserved2?)\n * TypedArray.prototype.toString()\n * TypedArray.prototype.values()\n\n上面所有方法的用法，请参阅数组方法的介绍，这里不再重复了。\n\n注意，TypedArray 数组没有concat方法。如果想要合并多个 TypedArray 数组，可以用下面这个函数。\n\nfunction concatenate(resultConstructor, ...arrays) {\n  let totalLength = 0;\n  for (let arr of arrays) {\n    totalLength += arr.length;\n  }\n  let result = new resultConstructor(totalLength);\n  let offset = 0;\n  for (let arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\n\nconcatenate(Uint8Array, Uint8Array.of(1, 2), Uint8Array.of(3, 4))\n// Uint8Array [1, 2, 3, 4]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n另外，TypedArray 数组与普通数组一样，部署了 Iterator 接口，所以可以被遍历。\n\nlet ui8 = Uint8Array.of(0, 1, 2);\nfor (let byte of ui8) {\n  console.log(byte);\n}\n// 0\n// 1\n// 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 字节序\n\n字节序指的是数值在内存中的表示方式。\n\nconst buffer = new ArrayBuffer(16);\nconst int32View = new Int32Array(buffer);\n\nfor (let i = 0; i < int32View.length; i++) {\n  int32View[i] = i * 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码生成一个 16 字节的ArrayBuffer对象，然后在它的基础上，建立了一个 32 位整数的视图。由于每个 32 位整数占据 4 个字节，所以一共可以写入 4 个整数，依次为 0，2，4，6。\n\n如果在这段数据上接着建立一个 16 位整数的视图，则可以读出完全不一样的结果。\n\nconst int16View = new Int16Array(buffer);\n\nfor (let i = 0; i < int16View.length; i++) {\n  console.log(\"Entry \" + i + \": \" + int16View[i]);\n}\n// Entry 0: 0\n// Entry 1: 0\n// Entry 2: 2\n// Entry 3: 0\n// Entry 4: 4\n// Entry 5: 0\n// Entry 6: 6\n// Entry 7: 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n由于每个 16 位整数占据 2 个字节，所以整个ArrayBuffer对象现在分成 8 段。然后，由于 x86 体系的计算机都采用小端字节序（little endian），相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址，所以就得到了上面的结果。\n\n比如，一个占据四个字节的 16 进制数0x12345678，决定其大小的最重要的字节是“12”，最不重要的是“78”。小端字节序将最不重要的字节排在前面，储存顺序就是78563412；大端字节序则完全相反，将最重要的字节排在前面，储存顺序就是12345678。目前，所有个人电脑几乎都是小端字节序，所以 TypedArray 数组内部也采用小端字节序读写数据，或者更准确的说，按照本机操作系统设定的字节序读写数据。\n\n这并不意味大端字节序不重要，事实上，很多网络设备和特定的操作系统采用的是大端字节序。这就带来一个严重的问题：如果一段数据是大端字节序，TypedArray 数组将无法正确解析，因为它只能处理小端字节序！为了解决这个问题，JavaScript 引入DataView对象，可以设定字节序，下文会详细介绍。\n\n下面是另一个例子。\n\n// 假定某段buffer包含如下字节 [0x02, 0x01, 0x03, 0x07]\nconst buffer = new ArrayBuffer(4);\nconst v1 = new Uint8Array(buffer);\nv1[0] = 2;\nv1[1] = 1;\nv1[2] = 3;\nv1[3] = 7;\n\nconst uInt16View = new Uint16Array(buffer);\n\n// 计算机采用小端字节序\n// 所以头两个字节等于258\nif (uInt16View[0] === 258) {\n  console.log('OK'); // \"OK\"\n}\n\n// 赋值运算\nuInt16View[0] = 255;    // 字节变为[0xFF, 0x00, 0x03, 0x07]\nuInt16View[0] = 0xff05; // 字节变为[0x05, 0xFF, 0x03, 0x07]\nuInt16View[1] = 0x0210; // 字节变为[0x05, 0xFF, 0x10, 0x02]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n下面的函数可以用来判断，当前视图是小端字节序，还是大端字节序。\n\nconst BIG_ENDIAN = Symbol('BIG_ENDIAN');\nconst LITTLE_ENDIAN = Symbol('LITTLE_ENDIAN');\n\nfunction getPlatformEndianness() {\n  let arr32 = Uint32Array.of(0x12345678);\n  let arr8 = new Uint8Array(arr32.buffer);\n  switch ((arr8[0]*0x1000000) + (arr8[1]*0x10000) + (arr8[2]*0x100) + (arr8[3])) {\n    case 0x12345678:\n      return BIG_ENDIAN;\n    case 0x78563412:\n      return LITTLE_ENDIAN;\n    default:\n      throw new Error('Unknown endianness');\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n总之，与普通数组相比，TypedArray 数组的最大优点就是可以直接操作内存，不需要数据类型转换，所以速度快得多。\n\n\n# BYTES_PER_ELEMENT 属性\n\n每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。\n\nInt8Array.BYTES_PER_ELEMENT // 1\nUint8Array.BYTES_PER_ELEMENT // 1\nUint8ClampedArray.BYTES_PER_ELEMENT // 1\nInt16Array.BYTES_PER_ELEMENT // 2\nUint16Array.BYTES_PER_ELEMENT // 2\nInt32Array.BYTES_PER_ELEMENT // 4\nUint32Array.BYTES_PER_ELEMENT // 4\nFloat32Array.BYTES_PER_ELEMENT // 4\nFloat64Array.BYTES_PER_ELEMENT // 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这个属性在TypedArray实例上也能获取，即有TypedArray.prototype.BYTES_PER_ELEMENT。\n\n\n# ArrayBuffer 与字符串的互相转换\n\nArrayBuffer 和字符串的相互转换，使用原生 TextEncoder 和 TextDecoder 方法。为了便于说明用法，下面的代码都按照 TypeScript 的用法，给出了类型签名。\n\n/**\n * Convert ArrayBuffer/TypedArray to String via TextDecoder\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder\n */\nfunction ab2str(\n  input: ArrayBuffer | Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array,\n  outputEncoding: string = 'utf8',\n): string {\n  const decoder = new TextDecoder(outputEncoding)\n  return decoder.decode(input)\n}\n\n/**\n * Convert String to ArrayBuffer via TextEncoder\n *\n * @see https://developer.mozilla.org/zh-CN/docs/Web/API/TextEncoder\n */\nfunction str2ab(input: string): ArrayBuffer {\n  const view = str2Uint8Array(input)\n  return view.buffer\n}\n\n/** Convert String to Uint8Array */\nfunction str2Uint8Array(input: string): Uint8Array {\n  const encoder = new TextEncoder()\n  const view = encoder.encode(input)\n  return view\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面代码中，ab2str()的第二个参数outputEncoding给出了输出编码的编码，一般保持默认值（utf-8），其他可选值参见官方文档或 Node.js 文档。\n\n\n# 溢出\n\n不同的视图类型，所能容纳的数值范围是确定的。超出这个范围，就会出现溢出。比如，8 位视图只能容纳一个 8 位的二进制值，如果放入一个 9 位的值，就会溢出。\n\nTypedArray 数组的溢出处理规则，简单来说，就是抛弃溢出的位，然后按照视图类型进行解释。\n\nconst uint8 = new Uint8Array(1);\n\nuint8[0] = 256;\nuint8[0] // 0\n\nuint8[0] = -1;\nuint8[0] // 255\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，uint8是一个 8 位视图，而 256 的二进制形式是一个 9 位的值100000000，这时就会发生溢出。根据规则，只会保留后 8 位，即00000000。uint8视图的解释规则是无符号的 8 位整数，所以00000000就是0。\n\n负数在计算机内部采用“2 的补码”表示，也就是说，将对应的正数值进行否运算，然后加1。比如，-1对应的正值是1，进行否运算以后，得到11111110，再加上1就是补码形式11111111。uint8按照无符号的 8 位整数解释11111111，返回结果就是255。\n\n一个简单转换规则，可以这样表示。\n\n * 正向溢出（overflow）：当输入值大于当前数据类型的最大值，结果等于当前数据类型的最小值加上余值，再减去 1。\n * 负向溢出（underflow）：当输入值小于当前数据类型的最小值，结果等于当前数据类型的最大值减去余值的绝对值，再加上 1。\n\n上面的“余值”就是模运算的结果，即 JavaScript 里面的%运算符的结果。\n\n12 % 4 // 0\n12 % 5 // 2\n\n\n1\n2\n\n\n上面代码中，12 除以 4 是没有余值的，而除以 5 会得到余值 2。\n\n请看下面的例子。\n\nconst int8 = new Int8Array(1);\n\nint8[0] = 128;\nint8[0] // -128\n\nint8[0] = -129;\nint8[0] // 127\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面例子中，int8是一个带符号的 8 位整数视图，它的最大值是 127，最小值是-128。输入值为128时，相当于正向溢出1，根据“最小值加上余值（128 除以 127 的余值是 1），再减去 1”的规则，就会返回-128；输入值为-129时，相当于负向溢出1，根据“最大值减去余值的绝对值（-129 除以-128 的余值的绝对值是 1），再加上 1”的规则，就会返回127。\n\nUint8ClampedArray视图的溢出规则，与上面的规则不同。它规定，凡是发生正向溢出，该值一律等于当前数据类型的最大值，即 255；如果发生负向溢出，该值一律等于当前数据类型的最小值，即 0。\n\nconst uint8c = new Uint8ClampedArray(1);\n\nuint8c[0] = 256;\nuint8c[0] // 255\n\nuint8c[0] = -1;\nuint8c[0] // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面例子中，uint8C是一个Uint8ClampedArray视图，正向溢出时都返回 255，负向溢出都返回 0。\n\n\n# TypedArray.prototype.buffer\n\nTypedArray实例的buffer属性，返回整段内存区域对应的ArrayBuffer对象。该属性为只读属性。\n\nconst a = new Float32Array(64);\nconst b = new Uint8Array(a.buffer);\n\n\n1\n2\n\n\n上面代码的a视图对象和b视图对象，对应同一个ArrayBuffer对象，即同一段内存。\n\n\n# TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset\n\nbyteLength属性返回 TypedArray 数组占据的内存长度，单位为字节。byteOffset属性返回 TypedArray 数组从底层ArrayBuffer对象的哪个字节开始。这两个属性都是只读属性。\n\nconst b = new ArrayBuffer(8);\n\nconst v1 = new Int32Array(b);\nconst v2 = new Uint8Array(b, 2);\nconst v3 = new Int16Array(b, 2, 2);\n\nv1.byteLength // 8\nv2.byteLength // 6\nv3.byteLength // 4\n\nv1.byteOffset // 0\nv2.byteOffset // 2\nv3.byteOffset // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# TypedArray.prototype.length\n\nlength属性表示 TypedArray 数组含有多少个成员。注意将 length 属性和 byteLength 属性区分，前者是成员长度，后者是字节长度。\n\nconst a = new Int16Array(8);\n\na.length // 8\na.byteLength // 16\n\n\n1\n2\n3\n4\n\n\n\n# TypedArray.prototype.set()\n\nTypedArray 数组的set方法用于复制数组（普通数组或 TypedArray 数组），也就是将一段内容完全复制到另一段内存。\n\nconst a = new Uint8Array(8);\nconst b = new Uint8Array(8);\n\nb.set(a);\n\n\n1\n2\n3\n4\n\n\n上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。\n\nset方法还可以接受第二个参数，表示从b对象的哪一个成员开始复制a对象。\n\nconst a = new Uint16Array(8);\nconst b = new Uint16Array(10);\n\nb.set(a, 2)\n\n\n1\n2\n3\n4\n\n\n上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。\n\n\n# TypedArray.prototype.subarray()\n\nsubarray方法是对于 TypedArray 数组的一部分，再建立一个新的视图。\n\nconst a = new Uint16Array(8);\nconst b = a.subarray(2,3);\n\na.byteLength // 16\nb.byteLength // 2\n\n\n1\n2\n3\n4\n5\n\n\nsubarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着 b 只包含a[2]一个成员，字节长度为 2。\n\n\n# TypedArray.prototype.slice()\n\nTypeArray 实例的slice方法，可以返回一个指定位置的新的TypedArray实例。\n\nlet ui8 = Uint8Array.of(0, 1, 2);\nui8.slice(-1)\n// Uint8Array [ 2 ]\n\n\n1\n2\n3\n\n\n上面代码中，ui8是 8 位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。\n\nslice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1 为倒数第一个位置，-2 表示倒数第二个位置，以此类推。\n\n\n# TypedArray.of()\n\nTypedArray 数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。\n\nFloat32Array.of(0.151, -8, 3.7)\n// Float32Array [ 0.151, -8, 3.7 ]\n\n\n1\n2\n\n\n下面三种方法都会生成同样一个 TypedArray 数组。\n\n// 方法一\nlet tarr = new Uint8Array([1,2,3]);\n\n// 方法二\nlet tarr = Uint8Array.of(1,2,3);\n\n// 方法三\nlet tarr = new Uint8Array(3);\ntarr[0] = 1;\ntarr[1] = 2;\ntarr[2] = 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# TypedArray.from()\n\n静态方法from接受一个可遍历的数据结构（比如数组）作为参数，返回一个基于这个结构的TypedArray实例。\n\nUint16Array.from([0, 1, 2])\n// Uint16Array [ 0, 1, 2 ]\n\n\n1\n2\n\n\n这个方法还可以将一种TypedArray实例，转为另一种。\n\nconst ui16 = Uint16Array.from(Uint8Array.of(0, 1, 2));\nui16 instanceof Uint16Array // true\n\n\n1\n2\n\n\nfrom方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。\n\nInt8Array.of(127, 126, 125).map(x => 2 * x)\n// Int8Array [ -2, -4, -6 ]\n\nInt16Array.from(Int8Array.of(127, 126, 125), x => 2 * x)\n// Int16Array [ 254, 252, 250 ]\n\n\n1\n2\n3\n4\n5\n\n\n上面的例子中，from方法没有发生溢出，这说明遍历不是针对原来的 8 位整数数组。也就是说，from会将第一个参数指定的 TypedArray 数组，拷贝到另一段内存之中，处理之后再将结果转成指定的数组格式。\n\n\n# 复合视图\n\n由于视图的构造函数可以指定起始位置和长度，所以在同一段内存之中，可以依次存放不同类型的数据，这叫做“复合视图”。\n\nconst buffer = new ArrayBuffer(24);\n\nconst idView = new Uint32Array(buffer, 0, 1);\nconst usernameView = new Uint8Array(buffer, 4, 16);\nconst amountDueView = new Float32Array(buffer, 20, 1);\n\n\n1\n2\n3\n4\n5\n\n\n上面代码将一个 24 字节长度的ArrayBuffer对象，分成三个部分：\n\n * 字节 0 到字节 3：1 个 32 位无符号整数\n * 字节 4 到字节 19：16 个 8 位整数\n * 字节 20 到字节 23：1 个 32 位浮点数\n\n这种数据结构可以用如下的 C 语言描述：\n\nstruct someStruct {\n  unsigned long id;\n  char username[16];\n  float amountDue;\n};\n\n\n1\n2\n3\n4\n5\n\n\n\n# DataView 视图\n\n如果一段数据包括多种类型（比如服务器传来的 HTTP 数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。\n\nDataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。\n\nDataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。\n\nDataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]);\n\n\n1\n\n\n下面是一个例子。\n\nconst buffer = new ArrayBuffer(24);\nconst dv = new DataView(buffer);\n\n\n1\n2\n\n\nDataView实例有以下属性，含义与TypedArray实例的同名方法相同。\n\n * DataView.prototype.buffer：返回对应的 ArrayBuffer 对象\n * DataView.prototype.byteLength：返回占据的内存字节长度\n * DataView.prototype.byteOffset：返回当前视图从对应的 ArrayBuffer 对象的哪个字节开始\n\nDataView实例提供 8 个方法读取内存。\n\n * getInt8：读取 1 个字节，返回一个 8 位整数。\n * getUint8：读取 1 个字节，返回一个无符号的 8 位整数。\n * getInt16：读取 2 个字节，返回一个 16 位整数。\n * getUint16：读取 2 个字节，返回一个无符号的 16 位整数。\n * getInt32：读取 4 个字节，返回一个 32 位整数。\n * getUint32：读取 4 个字节，返回一个无符号的 32 位整数。\n * getFloat32：读取 4 个字节，返回一个 32 位浮点数。\n * getFloat64：读取 8 个字节，返回一个 64 位浮点数。\n\n这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。\n\nconst buffer = new ArrayBuffer(24);\nconst dv = new DataView(buffer);\n\n// 从第1个字节读取一个8位无符号整数\nconst v1 = dv.getUint8(0);\n\n// 从第2个字节读取一个16位无符号整数\nconst v2 = dv.getUint16(1);\n\n// 从第4个字节读取一个16位无符号整数\nconst v3 = dv.getUint16(3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码读取了ArrayBuffer对象的前 5 个字节，其中有一个 8 位整数和两个十六位整数。\n\n如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。\n\n// 小端字节序\nconst v1 = dv.getUint16(1, true);\n\n// 大端字节序\nconst v2 = dv.getUint16(3, false);\n\n// 大端字节序\nconst v3 = dv.getUint16(3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nDataView 视图提供 8 个方法写入内存。\n\n * setInt8：写入 1 个字节的 8 位整数。\n * setUint8：写入 1 个字节的 8 位无符号整数。\n * setInt16：写入 2 个字节的 16 位整数。\n * setUint16：写入 2 个字节的 16 位无符号整数。\n * setInt32：写入 4 个字节的 32 位整数。\n * setUint32：写入 4 个字节的 32 位无符号整数。\n * setFloat32：写入 4 个字节的 32 位浮点数。\n * setFloat64：写入 8 个字节的 64 位浮点数。\n\n这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。\n\n// 在第1个字节，以大端字节序写入值为25的32位整数\ndv.setInt32(0, 25, false);\n\n// 在第5个字节，以大端字节序写入值为25的32位整数\ndv.setInt32(4, 25);\n\n// 在第9个字节，以小端字节序写入值为2.5的32位浮点数\ndv.setFloat32(8, 2.5, true);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。\n\nconst littleEndian = (function() {\n  const buffer = new ArrayBuffer(2);\n  new DataView(buffer).setInt16(0, 256, true);\n  return new Int16Array(buffer)[0] === 256;\n})();\n\n\n1\n2\n3\n4\n5\n\n\n如果返回true，就是小端字节序；如果返回false，就是大端字节序。\n\n\n# 二进制数组的应用\n\n大量的 Web API 用到了ArrayBuffer对象和它的视图对象。\n\n\n# AJAX\n\n传统上，服务器通过 AJAX 操作只能返回文本数据，即responseType属性默认为text。XMLHttpRequest第二版XHR2允许服务器返回二进制数据，这时分成两种情况。如果明确知道返回的二进制数据类型，可以把返回类型（responseType）设为arraybuffer；如果不知道，就设为blob。\n\nlet xhr = new XMLHttpRequest();\nxhr.open('GET', someUrl);\nxhr.responseType = 'arraybuffer';\n\nxhr.onload = function () {\n  let arrayBuffer = xhr.response;\n  // ···\n};\n\nxhr.send();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果知道传回来的是 32 位整数，可以像下面这样处理。\n\nxhr.onreadystatechange = function () {\n  if (req.readyState === 4 ) {\n    const arrayResponse = xhr.response;\n    const dataView = new DataView(arrayResponse);\n    const ints = new Uint32Array(dataView.byteLength / 4);\n\n    xhrDiv.style.backgroundColor = \"#00FF00\";\n    xhrDiv.innerText = \"Array is \" + ints.length + \"uints long\";\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Canvas\n\n网页Canvas元素输出的二进制像素数据，就是 TypedArray 数组。\n\nconst canvas = document.getElementById('myCanvas');\nconst ctx = canvas.getContext('2d');\n\nconst imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\nconst uint8ClampedArray = imageData.data;\n\n\n1\n2\n3\n4\n5\n\n\n需要注意的是，上面代码的uint8ClampedArray虽然是一个 TypedArray 数组，但是它的视图类型是一种针对Canvas元素的专有类型Uint8ClampedArray。这个视图类型的特点，就是专门针对颜色，把每个字节解读为无符号的 8 位整数，即只能取值 0 ～ 255，而且发生运算的时候自动过滤高位溢出。这为图像处理带来了巨大的方便。\n\n举例来说，如果把像素的颜色值设为Uint8Array类型，那么乘以一个 gamma 值的时候，就必须这样计算：\n\nu8[i] = Math.min(255, Math.max(0, u8[i] * gamma));\n\n\n1\n\n\n因为Uint8Array类型对于大于 255 的运算结果（比如0xFF+1），会自动变为0x00，所以图像处理必须要像上面这样算。这样做很麻烦，而且影响性能。如果将颜色值设为Uint8ClampedArray类型，计算就简化许多。\n\npixels[i] *= gamma;\n\n\n1\n\n\nUint8ClampedArray类型确保将小于 0 的值设为 0，将大于 255 的值设为 255。注意，IE 10 不支持该类型。\n\n\n# WebSocket\n\nWebSocket可以通过ArrayBuffer，发送或接收二进制数据。\n\nlet socket = new WebSocket('ws://127.0.0.1:8081');\nsocket.binaryType = 'arraybuffer';\n\n// Wait until socket is open\nsocket.addEventListener('open', function (event) {\n  // Send binary data\n  const typedArray = new Uint8Array(4);\n  socket.send(typedArray.buffer);\n});\n\n// Receive binary data\nsocket.addEventListener('message', function (event) {\n  const arrayBuffer = event.data;\n  // ···\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Fetch API\n\nFetch API 取回的数据，就是ArrayBuffer对象。\n\nfetch(url)\n.then(function(response){\n  return response.arrayBuffer()\n})\n.then(function(arrayBuffer){\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# File API\n\n如果知道一个文件的二进制数据类型，也可以将这个文件读取为ArrayBuffer对象。\n\nconst fileInput = document.getElementById('fileInput');\nconst file = fileInput.files[0];\nconst reader = new FileReader();\nreader.readAsArrayBuffer(file);\nreader.onload = function () {\n  const arrayBuffer = reader.result;\n  // ···\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面以处理 bmp 文件为例。假定file变量是一个指向 bmp 文件的文件对象，首先读取文件。\n\nconst reader = new FileReader();\nreader.addEventListener(\"load\", processimage, false);\nreader.readAsArrayBuffer(file);\n\n\n1\n2\n3\n\n\n然后，定义处理图像的回调函数：先在二进制数据之上建立一个DataView视图，再建立一个bitmap对象，用于存放处理后的数据，最后将图像展示在Canvas元素之中。\n\nfunction processimage(e) {\n  const buffer = e.target.result;\n  const datav = new DataView(buffer);\n  const bitmap = {};\n  // 具体的处理步骤\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n具体处理图像数据时，先处理 bmp 的文件头。具体每个文件头的格式和定义，请参阅有关资料。\n\nbitmap.fileheader = {};\nbitmap.fileheader.bfType = datav.getUint16(0, true);\nbitmap.fileheader.bfSize = datav.getUint32(2, true);\nbitmap.fileheader.bfReserved1 = datav.getUint16(6, true);\nbitmap.fileheader.bfReserved2 = datav.getUint16(8, true);\nbitmap.fileheader.bfOffBits = datav.getUint32(10, true);\n\n\n1\n2\n3\n4\n5\n6\n\n\n接着处理图像元信息部分。\n\nbitmap.infoheader = {};\nbitmap.infoheader.biSize = datav.getUint32(14, true);\nbitmap.infoheader.biWidth = datav.getUint32(18, true);\nbitmap.infoheader.biHeight = datav.getUint32(22, true);\nbitmap.infoheader.biPlanes = datav.getUint16(26, true);\nbitmap.infoheader.biBitCount = datav.getUint16(28, true);\nbitmap.infoheader.biCompression = datav.getUint32(30, true);\nbitmap.infoheader.biSizeImage = datav.getUint32(34, true);\nbitmap.infoheader.biXPelsPerMeter = datav.getUint32(38, true);\nbitmap.infoheader.biYPelsPerMeter = datav.getUint32(42, true);\nbitmap.infoheader.biClrUsed = datav.getUint32(46, true);\nbitmap.infoheader.biClrImportant = datav.getUint32(50, true);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n最后处理图像本身的像素信息。\n\nconst start = bitmap.fileheader.bfOffBits;\nbitmap.pixels = new Uint8Array(buffer, start);\n\n\n1\n2\n\n\n至此，图像文件的数据全部处理完成。下一步，可以根据需要，进行图像变形，或者转换格式，或者展示在Canvas网页元素之中。\n\n\n# SharedArrayBuffer\n\nJavaScript 是单线程的，Web worker 引入了多线程：主线程用来与用户互动，Worker 线程用来承担计算任务。每个线程的数据都是隔离的，通过postMessage()通信。下面是一个例子。\n\n// 主线程\nconst w = new Worker('myworker.js');\n\n\n1\n2\n\n\n上面代码中，主线程新建了一个 Worker 线程。该线程与主线程之间会有一个通信渠道，主线程通过w.postMessage向 Worker 线程发消息，同时通过message事件监听 Worker 线程的回应。\n\n// 主线程\nw.postMessage('hi');\nw.onmessage = function (ev) {\n  console.log(ev.data);\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，主线程先发一个消息hi，然后在监听到 Worker 线程的回应后，就将其打印出来。\n\nWorker 线程也是通过监听message事件，来获取主线程发来的消息，并作出反应。\n\n// Worker 线程\nonmessage = function (ev) {\n  console.log(ev.data);\n  postMessage('ho');\n}\n\n\n1\n2\n3\n4\n5\n\n\n线程之间的数据交换可以是各种格式，不仅仅是字符串，也可以是二进制数据。这种交换采用的是复制机制，即一个进程将需要分享的数据复制一份，通过postMessage方法交给另一个进程。如果数据量比较大，这种通信的效率显然比较低。很容易想到，这时可以留出一块内存区域，由主线程与 Worker 线程共享，两方都可以读写，那么就会大大提高效率，协作起来也会比较简单（不像postMessage那么麻烦）。\n\nES2017 引入SharedArrayBuffer，允许 Worker 线程与主线程共享同一块内存。SharedArrayBuffer的 API 与ArrayBuffer一模一样，唯一的区别是后者无法共享数据。\n\n// 主线程\n\n// 新建 1KB 共享内存\nconst sharedBuffer = new SharedArrayBuffer(1024);\n\n// 主线程将共享内存的地址发送出去\nw.postMessage(sharedBuffer);\n\n// 在共享内存上建立视图，供写入数据\nconst sharedArray = new Int32Array(sharedBuffer);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，postMessage方法的参数是SharedArrayBuffer对象。\n\nWorker 线程从事件的data属性上面取到数据。\n\n// Worker 线程\nonmessage = function (ev) {\n  // 主线程共享的数据，就是 1KB 的共享内存\n  const sharedBuffer = ev.data;\n\n  // 在共享内存上建立视图，方便读写\n  const sharedArray = new Int32Array(sharedBuffer);\n\n  // ...\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n共享内存也可以在 Worker 线程创建，发给主线程。\n\nSharedArrayBuffer与ArrayBuffer一样，本身是无法读写的，必须在上面建立视图，然后通过视图读写。\n\n// 分配 10 万个 32 位整数占据的内存空间\nconst sab = new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * 100000);\n\n// 建立 32 位整数视图\nconst ia = new Int32Array(sab);  // ia.length == 100000\n\n// 新建一个质数生成器\nconst primes = new PrimeGenerator();\n\n// 将 10 万个质数，写入这段内存空间\nfor ( let i=0 ; i < ia.length ; i++ )\n  ia[i] = primes.next();\n\n// 向 Worker 线程发送这段共享内存\nw.postMessage(ia);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nWorker 线程收到数据后的处理如下。\n\n// Worker 线程\nlet ia;\nonmessage = function (ev) {\n  ia = ev.data;\n  console.log(ia.length); // 100000\n  console.log(ia[37]); // 输出 163，因为这是第38个质数\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Atomics 对象\n\n多线程共享内存，最大的问题就是如何防止两个线程同时修改某个地址，或者说，当一个线程修改共享内存以后，必须有一个机制让其他线程同步。SharedArrayBuffer API 提供Atomics对象，保证所有共享内存的操作都是“原子性”的，并且可以在所有线程内同步。\n\n什么叫“原子性操作”呢？现代编程语言中，一条普通的命令被编译器处理以后，会变成多条机器指令。如果是单线程运行，这是没有问题的；多线程环境并且共享内存时，就会出问题，因为这一组机器指令的运行期间，可能会插入其他线程的指令，从而导致运行结果出错。请看下面的例子。\n\n// 主线程\nia[42] = 314159;  // 原先的值 191\nia[37] = 123456;  // 原先的值 163\n\n// Worker 线程\nconsole.log(ia[37]);\nconsole.log(ia[42]);\n// 可能的结果\n// 123456\n// 191\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，主线程的原始顺序是先对 42 号位置赋值，再对 37 号位置赋值。但是，编译器和 CPU 为了优化，可能会改变这两个操作的执行顺序（因为它们之间互不依赖），先对 37 号位置赋值，再对 42 号位置赋值。而执行到一半的时候，Worker 线程可能就会来读取数据，导致打印出123456和191。\n\n下面是另一个例子。\n\n// 主线程\nconst sab = new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * 100000);\nconst ia = new Int32Array(sab);\n\nfor (let i = 0; i < ia.length; i++) {\n  ia[i] = primes.next(); // 将质数放入 ia\n}\n\n// worker 线程\nia[112]++; // 错误\nAtomics.add(ia, 112, 1); // 正确\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，Worker 线程直接改写共享内存ia[112]++是不正确的。因为这行语句会被编译成多条机器指令，这些指令之间无法保证不会插入其他进程的指令。请设想如果两个线程同时ia[112]++，很可能它们得到的结果都是不正确的。\n\nAtomics对象就是为了解决这个问题而提出，它可以保证一个操作所对应的多条机器指令，一定是作为一个整体运行的，中间不会被打断。也就是说，它所涉及的操作都可以看作是原子性的单操作，这可以避免线程竞争，提高多线程共享内存时的操作安全。所以，ia[112]++要改写成Atomics.add(ia, 112, 1)。\n\nAtomics对象提供多种方法。\n\n（1）Atomics.store()，Atomics.load()\n\nstore()方法用来向共享内存写入数据，load()方法用来从共享内存读出数据。比起直接的读写操作，它们的好处是保证了读写操作的原子性。\n\n此外，它们还用来解决一个问题：多个线程使用共享内存的某个位置作为开关（flag），一旦该位置的值变了，就执行特定操作。这时，必须保证该位置的赋值操作，一定是在它前面的所有可能会改写内存的操作结束后执行；而该位置的取值操作，一定是在它后面所有可能会读取该位置的操作开始之前执行。store方法和load方法就能做到这一点，编译器不会为了优化，而打乱机器指令的执行顺序。\n\nAtomics.load(array, index)\nAtomics.store(array, index, value)\n\n\n1\n2\n\n\nstore方法接受三个参数：SharedBuffer 的视图、位置索引和值，返回sharedArray[index]的值。load方法只接受两个参数：SharedBuffer 的视图和位置索引，也是返回sharedArray[index]的值。\n\n// 主线程 main.js\nia[42] = 314159;  // 原先的值 191\nAtomics.store(ia, 37, 123456);  // 原先的值是 163\n\n// Worker 线程 worker.js\nwhile (Atomics.load(ia, 37) == 163);\nconsole.log(ia[37]);  // 123456\nconsole.log(ia[42]);  // 314159\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，主线程的Atomics.store向 42 号位置的赋值，一定是早于 37 位置的赋值。只要 37 号位置等于 163，Worker 线程就不会终止循环，而对 37 号位置和 42 号位置的取值，一定是在Atomics.load操作之后。\n\n下面是另一个例子。\n\n// 主线程\nconst worker = new Worker('worker.js');\nconst length = 10;\nconst size = Int32Array.BYTES_PER_ELEMENT * length;\n// 新建一段共享内存\nconst sharedBuffer = new SharedArrayBuffer(size);\nconst sharedArray = new Int32Array(sharedBuffer);\nfor (let i = 0; i < 10; i++) {\n  // 向共享内存写入 10 个整数\n  Atomics.store(sharedArray, i, 0);\n}\nworker.postMessage(sharedBuffer);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，主线程用Atomics.store()方法写入数据。下面是 Worker 线程用Atomics.load()方法读取数据。\n\n// worker.js\nself.addEventListener('message', (event) => {\n  const sharedArray = new Int32Array(event.data);\n  for (let i = 0; i < 10; i++) {\n    const arrayValue = Atomics.load(sharedArray, i);\n    console.log(`The item at array index ${i} is ${arrayValue}`);\n  }\n}, false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n（2）Atomics.exchange()\n\nWorker 线程如果要写入数据，可以使用上面的Atomics.store()方法，也可以使用Atomics.exchange()方法。它们的区别是，Atomics.store()返回写入的值，而Atomics.exchange()返回被替换的值。\n\n// Worker 线程\nself.addEventListener('message', (event) => {\n  const sharedArray = new Int32Array(event.data);\n  for (let i = 0; i < 10; i++) {\n    if (i % 2 === 0) {\n      const storedValue = Atomics.store(sharedArray, i, 1);\n      console.log(`The item at array index ${i} is now ${storedValue}`);\n    } else {\n      const exchangedValue = Atomics.exchange(sharedArray, i, 2);\n      console.log(`The item at array index ${i} was ${exchangedValue}, now 2`);\n    }\n  }\n}, false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码将共享内存的偶数位置的值改成1，奇数位置的值改成2。\n\n（3）Atomics.wait()，Atomics.wake()\n\n使用while循环等待主线程的通知，不是很高效，如果用在主线程，就会造成卡顿，Atomics对象提供了wait()和wake()两个方法用于等待通知。这两个方法相当于锁内存，即在一个线程进行操作时，让其他线程休眠（建立锁），等到操作结束，再唤醒那些休眠的线程（解除锁）。\n\n// Worker 线程\nself.addEventListener('message', (event) => {\n  const sharedArray = new Int32Array(event.data);\n  const arrayIndex = 0;\n  const expectedStoredValue = 50;\n  Atomics.wait(sharedArray, arrayIndex, expectedStoredValue);\n  console.log(Atomics.load(sharedArray, arrayIndex));\n}, false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，Atomics.wait()方法等同于告诉 Worker 线程，只要满足给定条件（sharedArray的0号位置等于50），就在这一行 Worker 线程进入休眠。\n\n主线程一旦更改了指定位置的值，就可以唤醒 Worker 线程。\n\n// 主线程\nconst newArrayValue = 100;\nAtomics.store(sharedArray, 0, newArrayValue);\nconst arrayIndex = 0;\nconst queuePos = 1;\nAtomics.wake(sharedArray, arrayIndex, queuePos);\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，sharedArray的0号位置改为100，然后就执行Atomics.wake()方法，唤醒在sharedArray的0号位置休眠队列里的一个线程。\n\nAtomics.wait()方法的使用格式如下。\n\nAtomics.wait(sharedArray, index, value, timeout)\n\n\n1\n\n\n它的四个参数含义如下。\n\n * sharedArray：共享内存的视图数组。\n * index：视图数据的位置（从0开始）。\n * value：该位置的预期值。一旦实际值等于预期值，就进入休眠。\n * timeout：整数，表示过了这个时间以后，就自动唤醒，单位毫秒。该参数可选，默认值是Infinity，即无限期的休眠，只有通过Atomics.wake()方法才能唤醒。\n\nAtomics.wait()的返回值是一个字符串，共有三种可能的值。如果sharedArray[index]不等于value，就返回字符串not-equal，否则就进入休眠。如果Atomics.wake()方法唤醒，就返回字符串ok；如果因为超时唤醒，就返回字符串timed-out。\n\nAtomics.wake()方法的使用格式如下。\n\nAtomics.wake(sharedArray, index, count)\n\n\n1\n\n\n它的三个参数含义如下。\n\n * sharedArray：共享内存的视图数组。\n * index：视图数据的位置（从0开始）。\n * count：需要唤醒的 Worker 线程的数量，默认为Infinity。\n\nAtomics.wake()方法一旦唤醒休眠的 Worker 线程，就会让它继续往下运行。\n\n请看一个例子。\n\n// 主线程\nconsole.log(ia[37]);  // 163\nAtomics.store(ia, 37, 123456);\nAtomics.wake(ia, 37, 1);\n\n// Worker 线程\nAtomics.wait(ia, 37, 163);\nconsole.log(ia[37]);  // 123456\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，视图数组ia的第 37 号位置，原来的值是163。Worker 线程使用Atomics.wait()方法，指定只要ia[37]等于163，就进入休眠状态。主线程使用Atomics.store()方法，将123456写入ia[37]，然后使用Atomics.wake()方法唤醒 Worker 线程。\n\n另外，基于wait和wake这两个方法的锁内存实现，可以看 Lars T Hansen 的 js-lock-and-condition 这个库。\n\n注意，浏览器的主线程不宜设置休眠，这会导致用户失去响应。而且，主线程实际上会拒绝进入休眠。\n\n（4）运算方法\n\n共享内存上面的某些运算是不能被打断的，即不能在运算过程中，让其他线程改写内存上面的值。Atomics 对象提供了一些运算方法，防止数据被改写。\n\nAtomics.add(sharedArray, index, value)\n\n\n1\n\n\nAtomics.add用于将value加到sharedArray[index]，返回sharedArray[index]旧的值。\n\nAtomics.sub(sharedArray, index, value)\n\n\n1\n\n\nAtomics.sub用于将value从sharedArray[index]减去，返回sharedArray[index]旧的值。\n\nAtomics.and(sharedArray, index, value)\n\n\n1\n\n\nAtomics.and用于将value与sharedArray[index]进行位运算and，放入sharedArray[index]，并返回旧的值。\n\nAtomics.or(sharedArray, index, value)\n\n\n1\n\n\nAtomics.or用于将value与sharedArray[index]进行位运算or，放入sharedArray[index]，并返回旧的值。\n\nAtomics.xor(sharedArray, index, value)\n\n\n1\n\n\nAtomic.xor用于将vaule与sharedArray[index]进行位运算xor，放入sharedArray[index]，并返回旧的值。\n\n（5）其他方法\n\nAtomics对象还有以下方法。\n\n * Atomics.compareExchange(sharedArray, index, oldval, newval)：如果sharedArray[index]等于oldval，就写入newval，返回oldval。\n * Atomics.isLockFree(size)：返回一个布尔值，表示Atomics对象是否可以处理某个size的内存锁定。如果返回false，应用程序就需要自己来实现锁定。\n\nAtomics.compareExchange的一个用途是，从 SharedArrayBuffer 读取一个值，然后对该值进行某个操作，操作结束以后，检查一下 SharedArrayBuffer 里面原来那个值是否发生变化（即被其他线程改写过）。如果没有改写过，就将它写回原来的位置，否则读取新的值，再重头进行一次操作。",normalizedContent:"# arraybuffer\n\narraybuffer对象、typedarray视图和dataview视图是 javascript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），es6 将它们纳入了 ecmascript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。 这个接口的原始设计目的，与 webgl 项目有关。所谓 webgl，就是指浏览器与显卡之间的通信接口，为了满足 javascript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 javascript 脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像 c 语言那样，直接操作字节，将 4 个字节的 32 位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。\n\n二进制数组就是在这种背景下诞生的。它很像 c 语言的数组，允许开发者以数组下标的形式，直接操作内存，大大增强了 javascript 处理二进制数据的能力，使得开发者有可能通过 javascript 与操作系统的原生接口进行二进制通信。\n\n二进制数组由三类对象组成。\n\n（1）arraybuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。\n\n（2）typedarray视图：共包括 9 种类型的视图，比如uint8array（无符号 8 位整数）数组视图, int16array（16 位整数）数组视图, float32array（32 位浮点数）数组视图等等。\n\n（3）dataview视图：可以自定义复合格式的视图，比如第一个字节是 uint8（无符号 8 位整数）、第二、三个字节是 int16（16 位整数）、第四个字节开始是 float32（32 位浮点数）等等，此外还可以自定义字节序。\n\n简单说，arraybuffer对象代表原始的二进制数据，typedarray视图用来读写简单类型的二进制数据，dataview视图用来读写复杂类型的二进制数据。\n\ntypedarray视图支持的数据类型一共有 9 种（dataview视图支持除uint8c以外的其他 8 种）。\n\n数据类型      字节长度   含义                  对应的 c 语言类型\nint8      1      8 位带符号整数            signed char\nuint8     1      8 位不带符号整数           unsigned char\nuint8c    1      8 位不带符号整数（自动过滤溢出）   unsigned char\nint16     2      16 位带符号整数           short\nuint16    2      16 位不带符号整数          unsigned short\nint32     4      32 位带符号整数           int\nuint32    4      32 位不带符号的整数         unsigned int\nfloat32   4      32 位浮点数             float\nfloat64   8      64 位浮点数             double\n\n注意，二进制数组并不是真正的数组，而是类似数组的对象。\n\n很多浏览器操作的 api，用到了二进制数组操作二进制数据，下面是其中的几个。\n\n * canvas\n * fetch api\n * file api\n * websockets\n * xmlhttprequest\n\n\n# arraybuffer 对象\n\n\n# 概述\n\narraybuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（typedarray视图和dataview视图)来读写，视图的作用是以指定格式解读二进制数据。\n\narraybuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。\n\nconst buf = new arraybuffer(32);\n\n\n1\n\n\n上面代码生成了一段 32 字节的内存区域，每个字节的值默认都是 0。可以看到，arraybuffer构造函数的参数是所需要的内存大小（单位字节）。\n\n为了读写这段内容，需要为它指定视图。dataview视图的创建，需要提供arraybuffer对象实例作为参数。\n\nconst buf = new arraybuffer(32);\nconst dataview = new dataview(buf);\ndataview.getuint8(0) // 0\n\n\n1\n2\n3\n\n\n上面代码对一段 32 字节的内存，建立dataview视图，然后以不带符号的 8 位整数格式，从头读取 8 位二进制数据，结果得到 0，因为原始内存的arraybuffer对象，默认所有位都是 0。\n\n另一种typedarray视图，与dataview视图的一个区别是，它不是一个构造函数，而是一组构造函数，代表不同的数据格式。\n\nconst buffer = new arraybuffer(12);\n\nconst x1 = new int32array(buffer);\nx1[0] = 1;\nconst x2 = new uint8array(buffer);\nx2[0]  = 2;\n\nx1[0] // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码对同一段内存，分别建立两种视图：32 位带符号整数（int32array构造函数）和 8 位不带符号整数（uint8array构造函数）。由于两个视图对应的是同一段内存，一个视图修改底层内存，会影响到另一个视图。\n\ntypedarray视图的构造函数，除了接受arraybuffer实例作为参数，还可以接受普通数组作为参数，直接分配内存生成底层的arraybuffer实例，并同时完成对这段内存的赋值。\n\nconst typedarray = new uint8array([0,1,2]);\ntypedarray.length // 3\n\ntypedarray[0] = 5;\ntypedarray // [5, 1, 2]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码使用typedarray视图的uint8array构造函数，新建一个不带符号的 8 位整数视图。可以看到，uint8array直接使用普通数组作为参数，对底层内存的赋值同时完成。\n\n\n# arraybuffer.prototype.bytelength\n\narraybuffer实例的bytelength属性，返回所分配的内存区域的字节长度。\n\nconst buffer = new arraybuffer(32);\nbuffer.bytelength\n// 32\n\n\n1\n2\n3\n\n\n如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。\n\nif (buffer.bytelength === n) {\n  // 成功\n} else {\n  // 失败\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# arraybuffer.prototype.slice()\n\narraybuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的arraybuffer对象。\n\nconst buffer = new arraybuffer(8);\nconst newbuffer = buffer.slice(0, 3);\n\n\n1\n2\n\n\n上面代码拷贝buffer对象的前 3 个字节（从 0 开始，到第 3 个字节前面结束），生成一个新的arraybuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个arraybuffer对象拷贝过去。\n\nslice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原arraybuffer对象的结尾。\n\n除了slice方法，arraybuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。\n\n\n# arraybuffer.isview()\n\narraybuffer有一个静态方法isview，返回一个布尔值，表示参数是否为arraybuffer的视图实例。这个方法大致相当于判断参数，是否为typedarray实例或dataview实例。\n\nconst buffer = new arraybuffer(8);\narraybuffer.isview(buffer) // false\n\nconst v = new int32array(buffer);\narraybuffer.isview(v) // true\n\n\n1\n2\n3\n4\n5\n\n\n\n# typedarray 视图\n\n\n# 概述\n\narraybuffer对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view）。arraybuffer有两种视图，一种是typedarray视图，另一种是dataview视图。前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。\n\n目前，typedarray视图一共包括 9 种类型，每一种视图都是一种构造函数。\n\n * int8array：8 位有符号整数，长度 1 个字节。\n * uint8array：8 位无符号整数，长度 1 个字节。\n * uint8clampedarray：8 位无符号整数，长度 1 个字节，溢出处理不同。\n * int16array：16 位有符号整数，长度 2 个字节。\n * uint16array：16 位无符号整数，长度 2 个字节。\n * int32array：32 位有符号整数，长度 4 个字节。\n * uint32array：32 位无符号整数，长度 4 个字节。\n * float32array：32 位浮点数，长度 4 个字节。\n * float64array：64 位浮点数，长度 8 个字节。\n\n这 9 个构造函数生成的数组，统称为typedarray视图。它们很像普通数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在它们上面都能使用。普通数组与 typedarray 数组的差异主要在以下方面。\n\n * typedarray 数组的所有成员，都是同一种类型。\n * typedarray 数组的成员是连续的，不会有空位。\n * typedarray 数组成员的默认值为 0。比如，new array(10)返回一个普通数组，里面没有任何成员，只是 10 个空位；new uint8array(10)返回一个 typedarray 数组，里面 10 个成员都是 0。\n * typedarray 数组只是一层视图，本身不储存数据，它的数据都储存在底层的arraybuffer对象之中，要获取底层对象必须使用buffer属性。\n\n\n# 构造函数\n\ntypedarray 数组提供 9 种构造函数，用来生成相应类型的数组实例。\n\n构造函数有多种用法。\n\n（1）typedarray(buffer, byteoffset=0, length?)\n\n同一个arraybuffer对象之上，可以根据不同的数据类型，建立多个视图。\n\n// 创建一个8字节的arraybuffer\nconst b = new arraybuffer(8);\n\n// 创建一个指向b的int32视图，开始于字节0，直到缓冲区的末尾\nconst v1 = new int32array(b);\n\n// 创建一个指向b的uint8视图，开始于字节2，直到缓冲区的末尾\nconst v2 = new uint8array(b, 2);\n\n// 创建一个指向b的int16视图，开始于字节2，长度为2\nconst v3 = new int16array(b, 2, 2);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码在一段长度为 8 个字节的内存（b）之上，生成了三个视图：v1、v2和v3。\n\n视图的构造函数可以接受三个参数：\n\n * 第一个参数（必需）：视图对应的底层arraybuffer对象。\n * 第二个参数（可选）：视图开始的字节序号，默认从 0 开始。\n * 第三个参数（可选）：视图包含的数据个数，默认直到本段内存区域结束。\n\n因此，v1、v2和v3是重叠的：v1[0]是一个 32 位整数，指向字节 0 ～字节 3；v2[0]是一个 8 位无符号整数，指向字节 2；v3[0]是一个 16 位整数，指向字节 2 ～字节 3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。\n\n注意，byteoffset必须与所要建立的数据类型一致，否则会报错。\n\nconst buffer = new arraybuffer(8);\nconst i16 = new int16array(buffer, 1);\n// uncaught rangeerror: start offset of int16array should be a multiple of 2\n\n\n1\n2\n3\n\n\n上面代码中，新生成一个 8 个字节的arraybuffer对象，然后在这个对象的第一个字节，建立带符号的 16 位整数视图，结果报错。因为，带符号的 16 位整数需要两个字节，所以byteoffset参数必须能够被 2 整除。\n\n如果想从任意字节开始解读arraybuffer对象，必须使用dataview视图，因为typedarray视图只提供 9 种固定的解读格式。\n\n（2）typedarray(length)\n\n视图还可以不通过arraybuffer对象，直接分配内存而生成。\n\nconst f64a = new float64array(8);\nf64a[0] = 10;\nf64a[1] = 20;\nf64a[2] = f64a[0] + f64a[1];\n\n\n1\n2\n3\n4\n\n\n上面代码生成一个 8 个成员的float64array数组（共 64 字节），然后依次对每个成员赋值。这时，视图构造函数的参数就是成员的个数。可以看到，视图数组的赋值操作与普通数组的操作毫无两样。\n\n（3）typedarray(typedarray)\n\ntypedarray 数组的构造函数，可以接受另一个typedarray实例作为参数。\n\nconst typedarray = new int8array(new uint8array(4));\n\n\n1\n\n\n上面代码中，int8array构造函数接受一个uint8array实例作为参数。\n\n注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。\n\nconst x = new int8array([1, 1]);\nconst y = new int8array(x);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。\n\n如果想基于同一段内存，构造不同的视图，可以采用下面的写法。\n\nconst x = new int8array([1, 1]);\nconst y = new int8array(x.buffer);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（4）typedarray(arraylikeobject)\n\n构造函数的参数也可以是一个普通数组，然后直接生成typedarray实例。\n\nconst typedarray = new uint8array([1, 2, 3, 4]);\n\n\n1\n\n\n注意，这时typedarray视图会重新开辟内存，不会在原数组的内存上建立视图。\n\n上面代码从一个普通的数组，生成一个 8 位无符号整数的typedarray实例。\n\ntypedarray 数组也可以转换回普通数组。\n\nconst normalarray = [...typedarray];\n// or\nconst normalarray = array.from(typedarray);\n// or\nconst normalarray = array.prototype.slice.call(typedarray);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 数组方法\n\n普通数组的操作方法和属性，对 typedarray 数组完全适用。\n\n * typedarray.prototype.copywithin(target, start[, end = this.length])\n * typedarray.prototype.entries()\n * typedarray.prototype.every(callbackfn, thisarg?)\n * typedarray.prototype.fill(value, start=0, end=this.length)\n * typedarray.prototype.filter(callbackfn, thisarg?)\n * typedarray.prototype.find(predicate, thisarg?)\n * typedarray.prototype.findindex(predicate, thisarg?)\n * typedarray.prototype.foreach(callbackfn, thisarg?)\n * typedarray.prototype.indexof(searchelement, fromindex=0)\n * typedarray.prototype.join(separator)\n * typedarray.prototype.keys()\n * typedarray.prototype.lastindexof(searchelement, fromindex?)\n * typedarray.prototype.map(callbackfn, thisarg?)\n * typedarray.prototype.reduce(callbackfn, initialvalue?)\n * typedarray.prototype.reduceright(callbackfn, initialvalue?)\n * typedarray.prototype.reverse()\n * typedarray.prototype.slice(start=0, end=this.length)\n * typedarray.prototype.some(callbackfn, thisarg?)\n * typedarray.prototype.sort(comparefn)\n * typedarray.prototype.tolocalestring(reserved1?, reserved2?)\n * typedarray.prototype.tostring()\n * typedarray.prototype.values()\n\n上面所有方法的用法，请参阅数组方法的介绍，这里不再重复了。\n\n注意，typedarray 数组没有concat方法。如果想要合并多个 typedarray 数组，可以用下面这个函数。\n\nfunction concatenate(resultconstructor, ...arrays) {\n  let totallength = 0;\n  for (let arr of arrays) {\n    totallength += arr.length;\n  }\n  let result = new resultconstructor(totallength);\n  let offset = 0;\n  for (let arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\n\nconcatenate(uint8array, uint8array.of(1, 2), uint8array.of(3, 4))\n// uint8array [1, 2, 3, 4]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n另外，typedarray 数组与普通数组一样，部署了 iterator 接口，所以可以被遍历。\n\nlet ui8 = uint8array.of(0, 1, 2);\nfor (let byte of ui8) {\n  console.log(byte);\n}\n// 0\n// 1\n// 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 字节序\n\n字节序指的是数值在内存中的表示方式。\n\nconst buffer = new arraybuffer(16);\nconst int32view = new int32array(buffer);\n\nfor (let i = 0; i < int32view.length; i++) {\n  int32view[i] = i * 2;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码生成一个 16 字节的arraybuffer对象，然后在它的基础上，建立了一个 32 位整数的视图。由于每个 32 位整数占据 4 个字节，所以一共可以写入 4 个整数，依次为 0，2，4，6。\n\n如果在这段数据上接着建立一个 16 位整数的视图，则可以读出完全不一样的结果。\n\nconst int16view = new int16array(buffer);\n\nfor (let i = 0; i < int16view.length; i++) {\n  console.log(\"entry \" + i + \": \" + int16view[i]);\n}\n// entry 0: 0\n// entry 1: 0\n// entry 2: 2\n// entry 3: 0\n// entry 4: 4\n// entry 5: 0\n// entry 6: 6\n// entry 7: 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n由于每个 16 位整数占据 2 个字节，所以整个arraybuffer对象现在分成 8 段。然后，由于 x86 体系的计算机都采用小端字节序（little endian），相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址，所以就得到了上面的结果。\n\n比如，一个占据四个字节的 16 进制数0x12345678，决定其大小的最重要的字节是“12”，最不重要的是“78”。小端字节序将最不重要的字节排在前面，储存顺序就是78563412；大端字节序则完全相反，将最重要的字节排在前面，储存顺序就是12345678。目前，所有个人电脑几乎都是小端字节序，所以 typedarray 数组内部也采用小端字节序读写数据，或者更准确的说，按照本机操作系统设定的字节序读写数据。\n\n这并不意味大端字节序不重要，事实上，很多网络设备和特定的操作系统采用的是大端字节序。这就带来一个严重的问题：如果一段数据是大端字节序，typedarray 数组将无法正确解析，因为它只能处理小端字节序！为了解决这个问题，javascript 引入dataview对象，可以设定字节序，下文会详细介绍。\n\n下面是另一个例子。\n\n// 假定某段buffer包含如下字节 [0x02, 0x01, 0x03, 0x07]\nconst buffer = new arraybuffer(4);\nconst v1 = new uint8array(buffer);\nv1[0] = 2;\nv1[1] = 1;\nv1[2] = 3;\nv1[3] = 7;\n\nconst uint16view = new uint16array(buffer);\n\n// 计算机采用小端字节序\n// 所以头两个字节等于258\nif (uint16view[0] === 258) {\n  console.log('ok'); // \"ok\"\n}\n\n// 赋值运算\nuint16view[0] = 255;    // 字节变为[0xff, 0x00, 0x03, 0x07]\nuint16view[0] = 0xff05; // 字节变为[0x05, 0xff, 0x03, 0x07]\nuint16view[1] = 0x0210; // 字节变为[0x05, 0xff, 0x10, 0x02]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n下面的函数可以用来判断，当前视图是小端字节序，还是大端字节序。\n\nconst big_endian = symbol('big_endian');\nconst little_endian = symbol('little_endian');\n\nfunction getplatformendianness() {\n  let arr32 = uint32array.of(0x12345678);\n  let arr8 = new uint8array(arr32.buffer);\n  switch ((arr8[0]*0x1000000) + (arr8[1]*0x10000) + (arr8[2]*0x100) + (arr8[3])) {\n    case 0x12345678:\n      return big_endian;\n    case 0x78563412:\n      return little_endian;\n    default:\n      throw new error('unknown endianness');\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n总之，与普通数组相比，typedarray 数组的最大优点就是可以直接操作内存，不需要数据类型转换，所以速度快得多。\n\n\n# bytes_per_element 属性\n\n每一种视图的构造函数，都有一个bytes_per_element属性，表示这种数据类型占据的字节数。\n\nint8array.bytes_per_element // 1\nuint8array.bytes_per_element // 1\nuint8clampedarray.bytes_per_element // 1\nint16array.bytes_per_element // 2\nuint16array.bytes_per_element // 2\nint32array.bytes_per_element // 4\nuint32array.bytes_per_element // 4\nfloat32array.bytes_per_element // 4\nfloat64array.bytes_per_element // 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这个属性在typedarray实例上也能获取，即有typedarray.prototype.bytes_per_element。\n\n\n# arraybuffer 与字符串的互相转换\n\narraybuffer 和字符串的相互转换，使用原生 textencoder 和 textdecoder 方法。为了便于说明用法，下面的代码都按照 typescript 的用法，给出了类型签名。\n\n/**\n * convert arraybuffer/typedarray to string via textdecoder\n *\n * @see https://developer.mozilla.org/en-us/docs/web/api/textdecoder\n */\nfunction ab2str(\n  input: arraybuffer | uint8array | int8array | uint16array | int16array | uint32array | int32array,\n  outputencoding: string = 'utf8',\n): string {\n  const decoder = new textdecoder(outputencoding)\n  return decoder.decode(input)\n}\n\n/**\n * convert string to arraybuffer via textencoder\n *\n * @see https://developer.mozilla.org/zh-cn/docs/web/api/textencoder\n */\nfunction str2ab(input: string): arraybuffer {\n  const view = str2uint8array(input)\n  return view.buffer\n}\n\n/** convert string to uint8array */\nfunction str2uint8array(input: string): uint8array {\n  const encoder = new textencoder()\n  const view = encoder.encode(input)\n  return view\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面代码中，ab2str()的第二个参数outputencoding给出了输出编码的编码，一般保持默认值（utf-8），其他可选值参见官方文档或 node.js 文档。\n\n\n# 溢出\n\n不同的视图类型，所能容纳的数值范围是确定的。超出这个范围，就会出现溢出。比如，8 位视图只能容纳一个 8 位的二进制值，如果放入一个 9 位的值，就会溢出。\n\ntypedarray 数组的溢出处理规则，简单来说，就是抛弃溢出的位，然后按照视图类型进行解释。\n\nconst uint8 = new uint8array(1);\n\nuint8[0] = 256;\nuint8[0] // 0\n\nuint8[0] = -1;\nuint8[0] // 255\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，uint8是一个 8 位视图，而 256 的二进制形式是一个 9 位的值100000000，这时就会发生溢出。根据规则，只会保留后 8 位，即00000000。uint8视图的解释规则是无符号的 8 位整数，所以00000000就是0。\n\n负数在计算机内部采用“2 的补码”表示，也就是说，将对应的正数值进行否运算，然后加1。比如，-1对应的正值是1，进行否运算以后，得到11111110，再加上1就是补码形式11111111。uint8按照无符号的 8 位整数解释11111111，返回结果就是255。\n\n一个简单转换规则，可以这样表示。\n\n * 正向溢出（overflow）：当输入值大于当前数据类型的最大值，结果等于当前数据类型的最小值加上余值，再减去 1。\n * 负向溢出（underflow）：当输入值小于当前数据类型的最小值，结果等于当前数据类型的最大值减去余值的绝对值，再加上 1。\n\n上面的“余值”就是模运算的结果，即 javascript 里面的%运算符的结果。\n\n12 % 4 // 0\n12 % 5 // 2\n\n\n1\n2\n\n\n上面代码中，12 除以 4 是没有余值的，而除以 5 会得到余值 2。\n\n请看下面的例子。\n\nconst int8 = new int8array(1);\n\nint8[0] = 128;\nint8[0] // -128\n\nint8[0] = -129;\nint8[0] // 127\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面例子中，int8是一个带符号的 8 位整数视图，它的最大值是 127，最小值是-128。输入值为128时，相当于正向溢出1，根据“最小值加上余值（128 除以 127 的余值是 1），再减去 1”的规则，就会返回-128；输入值为-129时，相当于负向溢出1，根据“最大值减去余值的绝对值（-129 除以-128 的余值的绝对值是 1），再加上 1”的规则，就会返回127。\n\nuint8clampedarray视图的溢出规则，与上面的规则不同。它规定，凡是发生正向溢出，该值一律等于当前数据类型的最大值，即 255；如果发生负向溢出，该值一律等于当前数据类型的最小值，即 0。\n\nconst uint8c = new uint8clampedarray(1);\n\nuint8c[0] = 256;\nuint8c[0] // 255\n\nuint8c[0] = -1;\nuint8c[0] // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面例子中，uint8c是一个uint8clampedarray视图，正向溢出时都返回 255，负向溢出都返回 0。\n\n\n# typedarray.prototype.buffer\n\ntypedarray实例的buffer属性，返回整段内存区域对应的arraybuffer对象。该属性为只读属性。\n\nconst a = new float32array(64);\nconst b = new uint8array(a.buffer);\n\n\n1\n2\n\n\n上面代码的a视图对象和b视图对象，对应同一个arraybuffer对象，即同一段内存。\n\n\n# typedarray.prototype.bytelength，typedarray.prototype.byteoffset\n\nbytelength属性返回 typedarray 数组占据的内存长度，单位为字节。byteoffset属性返回 typedarray 数组从底层arraybuffer对象的哪个字节开始。这两个属性都是只读属性。\n\nconst b = new arraybuffer(8);\n\nconst v1 = new int32array(b);\nconst v2 = new uint8array(b, 2);\nconst v3 = new int16array(b, 2, 2);\n\nv1.bytelength // 8\nv2.bytelength // 6\nv3.bytelength // 4\n\nv1.byteoffset // 0\nv2.byteoffset // 2\nv3.byteoffset // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# typedarray.prototype.length\n\nlength属性表示 typedarray 数组含有多少个成员。注意将 length 属性和 bytelength 属性区分，前者是成员长度，后者是字节长度。\n\nconst a = new int16array(8);\n\na.length // 8\na.bytelength // 16\n\n\n1\n2\n3\n4\n\n\n\n# typedarray.prototype.set()\n\ntypedarray 数组的set方法用于复制数组（普通数组或 typedarray 数组），也就是将一段内容完全复制到另一段内存。\n\nconst a = new uint8array(8);\nconst b = new uint8array(8);\n\nb.set(a);\n\n\n1\n2\n3\n4\n\n\n上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。\n\nset方法还可以接受第二个参数，表示从b对象的哪一个成员开始复制a对象。\n\nconst a = new uint16array(8);\nconst b = new uint16array(10);\n\nb.set(a, 2)\n\n\n1\n2\n3\n4\n\n\n上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。\n\n\n# typedarray.prototype.subarray()\n\nsubarray方法是对于 typedarray 数组的一部分，再建立一个新的视图。\n\nconst a = new uint16array(8);\nconst b = a.subarray(2,3);\n\na.bytelength // 16\nb.bytelength // 2\n\n\n1\n2\n3\n4\n5\n\n\nsubarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着 b 只包含a[2]一个成员，字节长度为 2。\n\n\n# typedarray.prototype.slice()\n\ntypearray 实例的slice方法，可以返回一个指定位置的新的typedarray实例。\n\nlet ui8 = uint8array.of(0, 1, 2);\nui8.slice(-1)\n// uint8array [ 2 ]\n\n\n1\n2\n3\n\n\n上面代码中，ui8是 8 位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。\n\nslice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1 为倒数第一个位置，-2 表示倒数第二个位置，以此类推。\n\n\n# typedarray.of()\n\ntypedarray 数组的所有构造函数，都有一个静态方法of，用于将参数转为一个typedarray实例。\n\nfloat32array.of(0.151, -8, 3.7)\n// float32array [ 0.151, -8, 3.7 ]\n\n\n1\n2\n\n\n下面三种方法都会生成同样一个 typedarray 数组。\n\n// 方法一\nlet tarr = new uint8array([1,2,3]);\n\n// 方法二\nlet tarr = uint8array.of(1,2,3);\n\n// 方法三\nlet tarr = new uint8array(3);\ntarr[0] = 1;\ntarr[1] = 2;\ntarr[2] = 3;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# typedarray.from()\n\n静态方法from接受一个可遍历的数据结构（比如数组）作为参数，返回一个基于这个结构的typedarray实例。\n\nuint16array.from([0, 1, 2])\n// uint16array [ 0, 1, 2 ]\n\n\n1\n2\n\n\n这个方法还可以将一种typedarray实例，转为另一种。\n\nconst ui16 = uint16array.from(uint8array.of(0, 1, 2));\nui16 instanceof uint16array // true\n\n\n1\n2\n\n\nfrom方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。\n\nint8array.of(127, 126, 125).map(x => 2 * x)\n// int8array [ -2, -4, -6 ]\n\nint16array.from(int8array.of(127, 126, 125), x => 2 * x)\n// int16array [ 254, 252, 250 ]\n\n\n1\n2\n3\n4\n5\n\n\n上面的例子中，from方法没有发生溢出，这说明遍历不是针对原来的 8 位整数数组。也就是说，from会将第一个参数指定的 typedarray 数组，拷贝到另一段内存之中，处理之后再将结果转成指定的数组格式。\n\n\n# 复合视图\n\n由于视图的构造函数可以指定起始位置和长度，所以在同一段内存之中，可以依次存放不同类型的数据，这叫做“复合视图”。\n\nconst buffer = new arraybuffer(24);\n\nconst idview = new uint32array(buffer, 0, 1);\nconst usernameview = new uint8array(buffer, 4, 16);\nconst amountdueview = new float32array(buffer, 20, 1);\n\n\n1\n2\n3\n4\n5\n\n\n上面代码将一个 24 字节长度的arraybuffer对象，分成三个部分：\n\n * 字节 0 到字节 3：1 个 32 位无符号整数\n * 字节 4 到字节 19：16 个 8 位整数\n * 字节 20 到字节 23：1 个 32 位浮点数\n\n这种数据结构可以用如下的 c 语言描述：\n\nstruct somestruct {\n  unsigned long id;\n  char username[16];\n  float amountdue;\n};\n\n\n1\n2\n3\n4\n5\n\n\n\n# dataview 视图\n\n如果一段数据包括多种类型（比如服务器传来的 http 数据），这时除了建立arraybuffer对象的复合视图以外，还可以通过dataview视图进行操作。\n\ndataview视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，arraybuffer对象的各种typedarray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而dataview视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。\n\ndataview视图本身也是构造函数，接受一个arraybuffer对象作为参数，生成视图。\n\ndataview(arraybuffer buffer [, 字节起始位置 [, 长度]]);\n\n\n1\n\n\n下面是一个例子。\n\nconst buffer = new arraybuffer(24);\nconst dv = new dataview(buffer);\n\n\n1\n2\n\n\ndataview实例有以下属性，含义与typedarray实例的同名方法相同。\n\n * dataview.prototype.buffer：返回对应的 arraybuffer 对象\n * dataview.prototype.bytelength：返回占据的内存字节长度\n * dataview.prototype.byteoffset：返回当前视图从对应的 arraybuffer 对象的哪个字节开始\n\ndataview实例提供 8 个方法读取内存。\n\n * getint8：读取 1 个字节，返回一个 8 位整数。\n * getuint8：读取 1 个字节，返回一个无符号的 8 位整数。\n * getint16：读取 2 个字节，返回一个 16 位整数。\n * getuint16：读取 2 个字节，返回一个无符号的 16 位整数。\n * getint32：读取 4 个字节，返回一个 32 位整数。\n * getuint32：读取 4 个字节，返回一个无符号的 32 位整数。\n * getfloat32：读取 4 个字节，返回一个 32 位浮点数。\n * getfloat64：读取 8 个字节，返回一个 64 位浮点数。\n\n这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。\n\nconst buffer = new arraybuffer(24);\nconst dv = new dataview(buffer);\n\n// 从第1个字节读取一个8位无符号整数\nconst v1 = dv.getuint8(0);\n\n// 从第2个字节读取一个16位无符号整数\nconst v2 = dv.getuint16(1);\n\n// 从第4个字节读取一个16位无符号整数\nconst v3 = dv.getuint16(3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码读取了arraybuffer对象的前 5 个字节，其中有一个 8 位整数和两个十六位整数。\n\n如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，dataview的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。\n\n// 小端字节序\nconst v1 = dv.getuint16(1, true);\n\n// 大端字节序\nconst v2 = dv.getuint16(3, false);\n\n// 大端字节序\nconst v3 = dv.getuint16(3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ndataview 视图提供 8 个方法写入内存。\n\n * setint8：写入 1 个字节的 8 位整数。\n * setuint8：写入 1 个字节的 8 位无符号整数。\n * setint16：写入 2 个字节的 16 位整数。\n * setuint16：写入 2 个字节的 16 位无符号整数。\n * setint32：写入 4 个字节的 32 位整数。\n * setuint32：写入 4 个字节的 32 位无符号整数。\n * setfloat32：写入 4 个字节的 32 位浮点数。\n * setfloat64：写入 8 个字节的 64 位浮点数。\n\n这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。\n\n// 在第1个字节，以大端字节序写入值为25的32位整数\ndv.setint32(0, 25, false);\n\n// 在第5个字节，以大端字节序写入值为25的32位整数\ndv.setint32(4, 25);\n\n// 在第9个字节，以小端字节序写入值为2.5的32位浮点数\ndv.setfloat32(8, 2.5, true);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。\n\nconst littleendian = (function() {\n  const buffer = new arraybuffer(2);\n  new dataview(buffer).setint16(0, 256, true);\n  return new int16array(buffer)[0] === 256;\n})();\n\n\n1\n2\n3\n4\n5\n\n\n如果返回true，就是小端字节序；如果返回false，就是大端字节序。\n\n\n# 二进制数组的应用\n\n大量的 web api 用到了arraybuffer对象和它的视图对象。\n\n\n# ajax\n\n传统上，服务器通过 ajax 操作只能返回文本数据，即responsetype属性默认为text。xmlhttprequest第二版xhr2允许服务器返回二进制数据，这时分成两种情况。如果明确知道返回的二进制数据类型，可以把返回类型（responsetype）设为arraybuffer；如果不知道，就设为blob。\n\nlet xhr = new xmlhttprequest();\nxhr.open('get', someurl);\nxhr.responsetype = 'arraybuffer';\n\nxhr.onload = function () {\n  let arraybuffer = xhr.response;\n  // ···\n};\n\nxhr.send();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果知道传回来的是 32 位整数，可以像下面这样处理。\n\nxhr.onreadystatechange = function () {\n  if (req.readystate === 4 ) {\n    const arrayresponse = xhr.response;\n    const dataview = new dataview(arrayresponse);\n    const ints = new uint32array(dataview.bytelength / 4);\n\n    xhrdiv.style.backgroundcolor = \"#00ff00\";\n    xhrdiv.innertext = \"array is \" + ints.length + \"uints long\";\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# canvas\n\n网页canvas元素输出的二进制像素数据，就是 typedarray 数组。\n\nconst canvas = document.getelementbyid('mycanvas');\nconst ctx = canvas.getcontext('2d');\n\nconst imagedata = ctx.getimagedata(0, 0, canvas.width, canvas.height);\nconst uint8clampedarray = imagedata.data;\n\n\n1\n2\n3\n4\n5\n\n\n需要注意的是，上面代码的uint8clampedarray虽然是一个 typedarray 数组，但是它的视图类型是一种针对canvas元素的专有类型uint8clampedarray。这个视图类型的特点，就是专门针对颜色，把每个字节解读为无符号的 8 位整数，即只能取值 0 ～ 255，而且发生运算的时候自动过滤高位溢出。这为图像处理带来了巨大的方便。\n\n举例来说，如果把像素的颜色值设为uint8array类型，那么乘以一个 gamma 值的时候，就必须这样计算：\n\nu8[i] = math.min(255, math.max(0, u8[i] * gamma));\n\n\n1\n\n\n因为uint8array类型对于大于 255 的运算结果（比如0xff+1），会自动变为0x00，所以图像处理必须要像上面这样算。这样做很麻烦，而且影响性能。如果将颜色值设为uint8clampedarray类型，计算就简化许多。\n\npixels[i] *= gamma;\n\n\n1\n\n\nuint8clampedarray类型确保将小于 0 的值设为 0，将大于 255 的值设为 255。注意，ie 10 不支持该类型。\n\n\n# websocket\n\nwebsocket可以通过arraybuffer，发送或接收二进制数据。\n\nlet socket = new websocket('ws://127.0.0.1:8081');\nsocket.binarytype = 'arraybuffer';\n\n// wait until socket is open\nsocket.addeventlistener('open', function (event) {\n  // send binary data\n  const typedarray = new uint8array(4);\n  socket.send(typedarray.buffer);\n});\n\n// receive binary data\nsocket.addeventlistener('message', function (event) {\n  const arraybuffer = event.data;\n  // ···\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# fetch api\n\nfetch api 取回的数据，就是arraybuffer对象。\n\nfetch(url)\n.then(function(response){\n  return response.arraybuffer()\n})\n.then(function(arraybuffer){\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# file api\n\n如果知道一个文件的二进制数据类型，也可以将这个文件读取为arraybuffer对象。\n\nconst fileinput = document.getelementbyid('fileinput');\nconst file = fileinput.files[0];\nconst reader = new filereader();\nreader.readasarraybuffer(file);\nreader.onload = function () {\n  const arraybuffer = reader.result;\n  // ···\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面以处理 bmp 文件为例。假定file变量是一个指向 bmp 文件的文件对象，首先读取文件。\n\nconst reader = new filereader();\nreader.addeventlistener(\"load\", processimage, false);\nreader.readasarraybuffer(file);\n\n\n1\n2\n3\n\n\n然后，定义处理图像的回调函数：先在二进制数据之上建立一个dataview视图，再建立一个bitmap对象，用于存放处理后的数据，最后将图像展示在canvas元素之中。\n\nfunction processimage(e) {\n  const buffer = e.target.result;\n  const datav = new dataview(buffer);\n  const bitmap = {};\n  // 具体的处理步骤\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n具体处理图像数据时，先处理 bmp 的文件头。具体每个文件头的格式和定义，请参阅有关资料。\n\nbitmap.fileheader = {};\nbitmap.fileheader.bftype = datav.getuint16(0, true);\nbitmap.fileheader.bfsize = datav.getuint32(2, true);\nbitmap.fileheader.bfreserved1 = datav.getuint16(6, true);\nbitmap.fileheader.bfreserved2 = datav.getuint16(8, true);\nbitmap.fileheader.bfoffbits = datav.getuint32(10, true);\n\n\n1\n2\n3\n4\n5\n6\n\n\n接着处理图像元信息部分。\n\nbitmap.infoheader = {};\nbitmap.infoheader.bisize = datav.getuint32(14, true);\nbitmap.infoheader.biwidth = datav.getuint32(18, true);\nbitmap.infoheader.biheight = datav.getuint32(22, true);\nbitmap.infoheader.biplanes = datav.getuint16(26, true);\nbitmap.infoheader.bibitcount = datav.getuint16(28, true);\nbitmap.infoheader.bicompression = datav.getuint32(30, true);\nbitmap.infoheader.bisizeimage = datav.getuint32(34, true);\nbitmap.infoheader.bixpelspermeter = datav.getuint32(38, true);\nbitmap.infoheader.biypelspermeter = datav.getuint32(42, true);\nbitmap.infoheader.biclrused = datav.getuint32(46, true);\nbitmap.infoheader.biclrimportant = datav.getuint32(50, true);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n最后处理图像本身的像素信息。\n\nconst start = bitmap.fileheader.bfoffbits;\nbitmap.pixels = new uint8array(buffer, start);\n\n\n1\n2\n\n\n至此，图像文件的数据全部处理完成。下一步，可以根据需要，进行图像变形，或者转换格式，或者展示在canvas网页元素之中。\n\n\n# sharedarraybuffer\n\njavascript 是单线程的，web worker 引入了多线程：主线程用来与用户互动，worker 线程用来承担计算任务。每个线程的数据都是隔离的，通过postmessage()通信。下面是一个例子。\n\n// 主线程\nconst w = new worker('myworker.js');\n\n\n1\n2\n\n\n上面代码中，主线程新建了一个 worker 线程。该线程与主线程之间会有一个通信渠道，主线程通过w.postmessage向 worker 线程发消息，同时通过message事件监听 worker 线程的回应。\n\n// 主线程\nw.postmessage('hi');\nw.onmessage = function (ev) {\n  console.log(ev.data);\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，主线程先发一个消息hi，然后在监听到 worker 线程的回应后，就将其打印出来。\n\nworker 线程也是通过监听message事件，来获取主线程发来的消息，并作出反应。\n\n// worker 线程\nonmessage = function (ev) {\n  console.log(ev.data);\n  postmessage('ho');\n}\n\n\n1\n2\n3\n4\n5\n\n\n线程之间的数据交换可以是各种格式，不仅仅是字符串，也可以是二进制数据。这种交换采用的是复制机制，即一个进程将需要分享的数据复制一份，通过postmessage方法交给另一个进程。如果数据量比较大，这种通信的效率显然比较低。很容易想到，这时可以留出一块内存区域，由主线程与 worker 线程共享，两方都可以读写，那么就会大大提高效率，协作起来也会比较简单（不像postmessage那么麻烦）。\n\nes2017 引入sharedarraybuffer，允许 worker 线程与主线程共享同一块内存。sharedarraybuffer的 api 与arraybuffer一模一样，唯一的区别是后者无法共享数据。\n\n// 主线程\n\n// 新建 1kb 共享内存\nconst sharedbuffer = new sharedarraybuffer(1024);\n\n// 主线程将共享内存的地址发送出去\nw.postmessage(sharedbuffer);\n\n// 在共享内存上建立视图，供写入数据\nconst sharedarray = new int32array(sharedbuffer);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，postmessage方法的参数是sharedarraybuffer对象。\n\nworker 线程从事件的data属性上面取到数据。\n\n// worker 线程\nonmessage = function (ev) {\n  // 主线程共享的数据，就是 1kb 的共享内存\n  const sharedbuffer = ev.data;\n\n  // 在共享内存上建立视图，方便读写\n  const sharedarray = new int32array(sharedbuffer);\n\n  // ...\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n共享内存也可以在 worker 线程创建，发给主线程。\n\nsharedarraybuffer与arraybuffer一样，本身是无法读写的，必须在上面建立视图，然后通过视图读写。\n\n// 分配 10 万个 32 位整数占据的内存空间\nconst sab = new sharedarraybuffer(int32array.bytes_per_element * 100000);\n\n// 建立 32 位整数视图\nconst ia = new int32array(sab);  // ia.length == 100000\n\n// 新建一个质数生成器\nconst primes = new primegenerator();\n\n// 将 10 万个质数，写入这段内存空间\nfor ( let i=0 ; i < ia.length ; i++ )\n  ia[i] = primes.next();\n\n// 向 worker 线程发送这段共享内存\nw.postmessage(ia);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nworker 线程收到数据后的处理如下。\n\n// worker 线程\nlet ia;\nonmessage = function (ev) {\n  ia = ev.data;\n  console.log(ia.length); // 100000\n  console.log(ia[37]); // 输出 163，因为这是第38个质数\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# atomics 对象\n\n多线程共享内存，最大的问题就是如何防止两个线程同时修改某个地址，或者说，当一个线程修改共享内存以后，必须有一个机制让其他线程同步。sharedarraybuffer api 提供atomics对象，保证所有共享内存的操作都是“原子性”的，并且可以在所有线程内同步。\n\n什么叫“原子性操作”呢？现代编程语言中，一条普通的命令被编译器处理以后，会变成多条机器指令。如果是单线程运行，这是没有问题的；多线程环境并且共享内存时，就会出问题，因为这一组机器指令的运行期间，可能会插入其他线程的指令，从而导致运行结果出错。请看下面的例子。\n\n// 主线程\nia[42] = 314159;  // 原先的值 191\nia[37] = 123456;  // 原先的值 163\n\n// worker 线程\nconsole.log(ia[37]);\nconsole.log(ia[42]);\n// 可能的结果\n// 123456\n// 191\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，主线程的原始顺序是先对 42 号位置赋值，再对 37 号位置赋值。但是，编译器和 cpu 为了优化，可能会改变这两个操作的执行顺序（因为它们之间互不依赖），先对 37 号位置赋值，再对 42 号位置赋值。而执行到一半的时候，worker 线程可能就会来读取数据，导致打印出123456和191。\n\n下面是另一个例子。\n\n// 主线程\nconst sab = new sharedarraybuffer(int32array.bytes_per_element * 100000);\nconst ia = new int32array(sab);\n\nfor (let i = 0; i < ia.length; i++) {\n  ia[i] = primes.next(); // 将质数放入 ia\n}\n\n// worker 线程\nia[112]++; // 错误\natomics.add(ia, 112, 1); // 正确\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，worker 线程直接改写共享内存ia[112]++是不正确的。因为这行语句会被编译成多条机器指令，这些指令之间无法保证不会插入其他进程的指令。请设想如果两个线程同时ia[112]++，很可能它们得到的结果都是不正确的。\n\natomics对象就是为了解决这个问题而提出，它可以保证一个操作所对应的多条机器指令，一定是作为一个整体运行的，中间不会被打断。也就是说，它所涉及的操作都可以看作是原子性的单操作，这可以避免线程竞争，提高多线程共享内存时的操作安全。所以，ia[112]++要改写成atomics.add(ia, 112, 1)。\n\natomics对象提供多种方法。\n\n（1）atomics.store()，atomics.load()\n\nstore()方法用来向共享内存写入数据，load()方法用来从共享内存读出数据。比起直接的读写操作，它们的好处是保证了读写操作的原子性。\n\n此外，它们还用来解决一个问题：多个线程使用共享内存的某个位置作为开关（flag），一旦该位置的值变了，就执行特定操作。这时，必须保证该位置的赋值操作，一定是在它前面的所有可能会改写内存的操作结束后执行；而该位置的取值操作，一定是在它后面所有可能会读取该位置的操作开始之前执行。store方法和load方法就能做到这一点，编译器不会为了优化，而打乱机器指令的执行顺序。\n\natomics.load(array, index)\natomics.store(array, index, value)\n\n\n1\n2\n\n\nstore方法接受三个参数：sharedbuffer 的视图、位置索引和值，返回sharedarray[index]的值。load方法只接受两个参数：sharedbuffer 的视图和位置索引，也是返回sharedarray[index]的值。\n\n// 主线程 main.js\nia[42] = 314159;  // 原先的值 191\natomics.store(ia, 37, 123456);  // 原先的值是 163\n\n// worker 线程 worker.js\nwhile (atomics.load(ia, 37) == 163);\nconsole.log(ia[37]);  // 123456\nconsole.log(ia[42]);  // 314159\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，主线程的atomics.store向 42 号位置的赋值，一定是早于 37 位置的赋值。只要 37 号位置等于 163，worker 线程就不会终止循环，而对 37 号位置和 42 号位置的取值，一定是在atomics.load操作之后。\n\n下面是另一个例子。\n\n// 主线程\nconst worker = new worker('worker.js');\nconst length = 10;\nconst size = int32array.bytes_per_element * length;\n// 新建一段共享内存\nconst sharedbuffer = new sharedarraybuffer(size);\nconst sharedarray = new int32array(sharedbuffer);\nfor (let i = 0; i < 10; i++) {\n  // 向共享内存写入 10 个整数\n  atomics.store(sharedarray, i, 0);\n}\nworker.postmessage(sharedbuffer);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，主线程用atomics.store()方法写入数据。下面是 worker 线程用atomics.load()方法读取数据。\n\n// worker.js\nself.addeventlistener('message', (event) => {\n  const sharedarray = new int32array(event.data);\n  for (let i = 0; i < 10; i++) {\n    const arrayvalue = atomics.load(sharedarray, i);\n    console.log(`the item at array index ${i} is ${arrayvalue}`);\n  }\n}, false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n（2）atomics.exchange()\n\nworker 线程如果要写入数据，可以使用上面的atomics.store()方法，也可以使用atomics.exchange()方法。它们的区别是，atomics.store()返回写入的值，而atomics.exchange()返回被替换的值。\n\n// worker 线程\nself.addeventlistener('message', (event) => {\n  const sharedarray = new int32array(event.data);\n  for (let i = 0; i < 10; i++) {\n    if (i % 2 === 0) {\n      const storedvalue = atomics.store(sharedarray, i, 1);\n      console.log(`the item at array index ${i} is now ${storedvalue}`);\n    } else {\n      const exchangedvalue = atomics.exchange(sharedarray, i, 2);\n      console.log(`the item at array index ${i} was ${exchangedvalue}, now 2`);\n    }\n  }\n}, false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码将共享内存的偶数位置的值改成1，奇数位置的值改成2。\n\n（3）atomics.wait()，atomics.wake()\n\n使用while循环等待主线程的通知，不是很高效，如果用在主线程，就会造成卡顿，atomics对象提供了wait()和wake()两个方法用于等待通知。这两个方法相当于锁内存，即在一个线程进行操作时，让其他线程休眠（建立锁），等到操作结束，再唤醒那些休眠的线程（解除锁）。\n\n// worker 线程\nself.addeventlistener('message', (event) => {\n  const sharedarray = new int32array(event.data);\n  const arrayindex = 0;\n  const expectedstoredvalue = 50;\n  atomics.wait(sharedarray, arrayindex, expectedstoredvalue);\n  console.log(atomics.load(sharedarray, arrayindex));\n}, false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，atomics.wait()方法等同于告诉 worker 线程，只要满足给定条件（sharedarray的0号位置等于50），就在这一行 worker 线程进入休眠。\n\n主线程一旦更改了指定位置的值，就可以唤醒 worker 线程。\n\n// 主线程\nconst newarrayvalue = 100;\natomics.store(sharedarray, 0, newarrayvalue);\nconst arrayindex = 0;\nconst queuepos = 1;\natomics.wake(sharedarray, arrayindex, queuepos);\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，sharedarray的0号位置改为100，然后就执行atomics.wake()方法，唤醒在sharedarray的0号位置休眠队列里的一个线程。\n\natomics.wait()方法的使用格式如下。\n\natomics.wait(sharedarray, index, value, timeout)\n\n\n1\n\n\n它的四个参数含义如下。\n\n * sharedarray：共享内存的视图数组。\n * index：视图数据的位置（从0开始）。\n * value：该位置的预期值。一旦实际值等于预期值，就进入休眠。\n * timeout：整数，表示过了这个时间以后，就自动唤醒，单位毫秒。该参数可选，默认值是infinity，即无限期的休眠，只有通过atomics.wake()方法才能唤醒。\n\natomics.wait()的返回值是一个字符串，共有三种可能的值。如果sharedarray[index]不等于value，就返回字符串not-equal，否则就进入休眠。如果atomics.wake()方法唤醒，就返回字符串ok；如果因为超时唤醒，就返回字符串timed-out。\n\natomics.wake()方法的使用格式如下。\n\natomics.wake(sharedarray, index, count)\n\n\n1\n\n\n它的三个参数含义如下。\n\n * sharedarray：共享内存的视图数组。\n * index：视图数据的位置（从0开始）。\n * count：需要唤醒的 worker 线程的数量，默认为infinity。\n\natomics.wake()方法一旦唤醒休眠的 worker 线程，就会让它继续往下运行。\n\n请看一个例子。\n\n// 主线程\nconsole.log(ia[37]);  // 163\natomics.store(ia, 37, 123456);\natomics.wake(ia, 37, 1);\n\n// worker 线程\natomics.wait(ia, 37, 163);\nconsole.log(ia[37]);  // 123456\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，视图数组ia的第 37 号位置，原来的值是163。worker 线程使用atomics.wait()方法，指定只要ia[37]等于163，就进入休眠状态。主线程使用atomics.store()方法，将123456写入ia[37]，然后使用atomics.wake()方法唤醒 worker 线程。\n\n另外，基于wait和wake这两个方法的锁内存实现，可以看 lars t hansen 的 js-lock-and-condition 这个库。\n\n注意，浏览器的主线程不宜设置休眠，这会导致用户失去响应。而且，主线程实际上会拒绝进入休眠。\n\n（4）运算方法\n\n共享内存上面的某些运算是不能被打断的，即不能在运算过程中，让其他线程改写内存上面的值。atomics 对象提供了一些运算方法，防止数据被改写。\n\natomics.add(sharedarray, index, value)\n\n\n1\n\n\natomics.add用于将value加到sharedarray[index]，返回sharedarray[index]旧的值。\n\natomics.sub(sharedarray, index, value)\n\n\n1\n\n\natomics.sub用于将value从sharedarray[index]减去，返回sharedarray[index]旧的值。\n\natomics.and(sharedarray, index, value)\n\n\n1\n\n\natomics.and用于将value与sharedarray[index]进行位运算and，放入sharedarray[index]，并返回旧的值。\n\natomics.or(sharedarray, index, value)\n\n\n1\n\n\natomics.or用于将value与sharedarray[index]进行位运算or，放入sharedarray[index]，并返回旧的值。\n\natomics.xor(sharedarray, index, value)\n\n\n1\n\n\natomic.xor用于将vaule与sharedarray[index]进行位运算xor，放入sharedarray[index]，并返回旧的值。\n\n（5）其他方法\n\natomics对象还有以下方法。\n\n * atomics.compareexchange(sharedarray, index, oldval, newval)：如果sharedarray[index]等于oldval，就写入newval，返回oldval。\n * atomics.islockfree(size)：返回一个布尔值，表示atomics对象是否可以处理某个size的内存锁定。如果返回false，应用程序就需要自己来实现锁定。\n\natomics.compareexchange的一个用途是，从 sharedarraybuffer 读取一个值，然后对该值进行某个操作，操作结束以后，检查一下 sharedarraybuffer 里面原来那个值是否发生变化（即被其他线程改写过）。如果没有改写过，就将它写回原来的位置，否则读取新的值，再重头进行一次操作。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"最新提案",frontmatter:{title:"最新提案",date:"2020-02-09T16:00:30.000Z",permalink:"/pages/7188882b8d65af1b",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/29.%E6%9C%80%E6%96%B0%E6%8F%90%E6%A1%88.html",relativePath:"《ES6 教程》笔记/29.最新提案.md",key:"v-733dba34",path:"/pages/7188882b8d65af1b/",headers:[{level:2,title:"do 表达式",slug:"do-表达式",normalizedTitle:"do 表达式",charIndex:37},{level:2,title:"throw 表达式",slug:"throw-表达式",normalizedTitle:"throw 表达式",charIndex:1009},{level:2,title:"函数的部分执行",slug:"函数的部分执行",normalizedTitle:"函数的部分执行",charIndex:1983},{level:3,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:724},{level:3,title:"注意点",slug:"注意点",normalizedTitle:"注意点",charIndex:2862},{level:2,title:"管道运算符",slug:"管道运算符",normalizedTitle:"管道运算符",charIndex:3777},{level:2,title:"数值分隔符",slug:"数值分隔符",normalizedTitle:"数值分隔符",charIndex:5042},{level:2,title:"Math.signbit()",slug:"math-signbit",normalizedTitle:"math.signbit()",charIndex:6012},{level:2,title:"双冒号运算符",slug:"双冒号运算符",normalizedTitle:"双冒号运算符",charIndex:6558},{level:2,title:"Realm API",slug:"realm-api",normalizedTitle:"realm api",charIndex:7418},{level:2,title:"#!命令",slug:"命令",normalizedTitle:"#!命令",charIndex:9349},{level:2,title:"import.meta",slug:"import-meta",normalizedTitle:"import.meta",charIndex:9834}],excerpt:'<h1 id="最新提案"><a class="header-anchor" href="#最新提案">#</a> 最新提案</h1>\n<p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p>\n<h2 id="do-表达式"><a class="header-anchor" href="#do-表达式">#</a> do 表达式</h2>\n<p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>\n\x3c!--beforebegin--\x3e<div class="language-javascript line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-javascript"><code><span class="token punctuation">{</span>\n  <span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  t <span class="token operator">=</span> t <span class="token operator">*</span> t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"do 表达式 throw 表达式 函数的部分执行 语法 注意点 管道运算符 数值分隔符 Math.signbit() 双冒号运算符 Realm API #!命令 import.meta",content:"# 最新提案\n\n本章介绍一些尚未进入标准、但很有希望的最新提案。\n\n\n# do 表达式\n\n本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。\n\n{\n  let t = f();\n  t = t * t + 1;\n}\n\n\n1\n2\n3\n4\n\n\n上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。\n\n现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式，然后就会返回内部最后执行的表达式的值。\n\nlet x = do {\n  let t = f();\n  t * t + 1;\n};\n\n\n1\n2\n3\n4\n\n\n上面代码中，变量x会得到整个块级作用域的返回值（t * t + 1）。\n\ndo表达式的逻辑非常简单：封装的是什么，就会返回什么。\n\n// 等同于 <表达式>\ndo { <表达式>; }\n\n// 等同于 <语句>\ndo { <语句> }\n\n\n1\n2\n3\n4\n5\n\n\ndo表达式的好处是可以封装多个语句，让程序更加模块化，就像乐高积木那样一块块拼装起来。\n\nlet x = do {\n  if (foo()) { f() }\n  else if (bar()) { g() }\n  else { h() }\n};\n\n\n1\n2\n3\n4\n5\n\n\n上面代码的本质，就是根据函数foo的执行结果，调用不同的函数，将返回结果赋给变量x。使用do表达式，就将这个操作的意图表达得非常简洁清晰。而且，do块级作用域提供了单独的作用域，内部操作可以与全局作用域隔绝。\n\n值得一提的是，do表达式在 JSX 语法中非常好用。\n\nreturn (\n  <nav>\n    <Home />\n    {\n      do {\n        if (loggedIn) {\n          <LogoutButton />\n        } else {\n          <LoginButton />\n        }\n      }\n    }\n  </nav>\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，如果不用do表达式，就只能用三元判断运算符（?:）。那样的话，一旦判断逻辑复杂，代码就会变得很不易读。\n\n\n# throw 表达式\n\nJavaScript 语法规定throw是一个命令，用来抛出错误，不能用于表达式之中。\n\n// 报错\nconsole.log(throw new Error());\n\n\n1\n2\n\n\n上面代码中，console.log的参数必须是一个表达式，如果是一个throw语句就会报错。\n\n现在有一个提案，允许throw用于表达式。\n\n// 参数的默认值\nfunction save(filename = throw new TypeError(\"Argument required\")) {\n}\n\n// 箭头函数的返回值\nlint(ast, {\n  with: () => throw new Error(\"avoid using 'with' statements.\")\n});\n\n// 条件表达式\nfunction getEncoder(encoding) {\n  const encoder = encoding === \"utf8\" ?\n    new UTF8Encoder() :\n    encoding === \"utf16le\" ?\n      new UTF16Encoder(false) :\n      encoding === \"utf16be\" ?\n        new UTF16Encoder(true) :\n        throw new Error(\"Unsupported encoding\");\n}\n\n// 逻辑表达式\nclass Product {\n  get id() {\n    return this._id;\n  }\n  set id(value) {\n    this._id = value || throw new Error(\"Invalid value\");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面代码中，throw都出现在表达式里面。\n\n语法上，throw表达式里面的throw不再是一个命令，而是一个运算符。为了避免与throw命令混淆，规定throw出现在行首，一律解释为throw语句，而不是throw表达式。\n\n\n# 函数的部分执行\n\n\n# 语法\n\n多参数的函数有时需要绑定其中的一个或多个参数，然后返回一个新函数。\n\nfunction add(x, y) { return x + y; }\nfunction add7(x) { return x + 7; }\n\n\n1\n2\n\n\n上面代码中，add7函数其实是add函数的一个特殊版本，通过将一个参数绑定为7，就可以从add得到add7。\n\n// bind 方法\nconst add7 = add.bind(null, 7);\n\n// 箭头函数\nconst add7 = x => add(x, 7);\n\n\n1\n2\n3\n4\n5\n\n\n上面两种写法都有些冗余。其中，bind方法的局限更加明显，它必须提供this，并且只能从前到后一个个绑定参数，无法只绑定非头部的参数。\n\n现在有一个提案，使得绑定参数并返回一个新函数更加容易。这叫做函数的部分执行（partial application）。\n\nconst add = (x, y) => x + y;\nconst addOne = add(1, ?);\n\nconst maxGreaterThanZero = Math.max(0, ...);\n\n\n1\n2\n3\n4\n\n\n根据新提案，?是单个参数的占位符，...是多个参数的占位符。以下的形式都属于函数的部分执行。\n\nf(x, ?)\nf(x, ...)\nf(?, x)\nf(..., x)\nf(?, x, ?)\nf(..., x, ...)\n\n\n1\n2\n3\n4\n5\n6\n\n\n?和...只能出现在函数的调用之中，并且会返回一个新函数。\n\nconst g = f(?, 1, ...);\n// 等同于\nconst g = (x, ...y) => f(x, 1, ...y);\n\n\n1\n2\n3\n\n\n函数的部分执行，也可以用于对象的方法。\n\nlet obj = {\n  f(x, y) { return x + y; },\n};\n\nconst g = obj.f(?, 3);\ng(1) // 4\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 注意点\n\n函数的部分执行有一些特别注意的地方。\n\n（1）函数的部分执行是基于原函数的。如果原函数发生变化，部分执行生成的新函数也会立即反映这种变化。\n\nlet f = (x, y) => x + y;\n\nconst g = f(?, 3);\ng(1); // 4\n\n// 替换函数 f\nf = (x, y) => x * y;\n\ng(1); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，定义了函数的部分执行以后，更换原函数会立即影响到新函数。\n\n（2）如果预先提供的那个值是一个表达式，那么这个表达式并不会在定义时求值，而是在每次调用时求值。\n\nlet a = 3;\nconst f = (x, y) => x + y;\n\nconst g = f(?, a);\ng(1); // 4\n\n// 改变 a 的值\na = 10;\ng(1); // 11\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，预先提供的参数是变量a，那么每次调用函数g的时候，才会对a进行求值。\n\n（3）如果新函数的参数多于占位符的数量，那么多余的参数将被忽略。\n\nconst f = (x, ...y) => [x, ...y];\nconst g = f(?, 1);\ng(2, 3, 4); // [2, 1]\n\n\n1\n2\n3\n\n\n上面代码中，函数g只有一个占位符，也就意味着它只能接受一个参数，多余的参数都会被忽略。\n\n写成下面这样，多余的参数就没有问题。\n\nconst f = (x, ...y) => [x, ...y];\nconst g = f(?, 1, ...);\ng(2, 3, 4); // [2, 1, 3, 4];\n\n\n1\n2\n3\n\n\n（4）...只会被采集一次，如果函数的部分执行使用了多个...，那么每个...的值都将相同。\n\nconst f = (...x) => x;\nconst g = f(..., 9, ...);\ng(1, 2, 3); // [1, 2, 3, 9, 1, 2, 3]\n\n\n1\n2\n3\n\n\n上面代码中，g定义了两个...占位符，真正执行的时候，它们的值是一样的。\n\n\n# 管道运算符\n\nUnix 操作系统有一个管道机制（pipeline），可以把前一个操作的值传给后一个操作。这个机制非常有用，使得简单的操作可以组合成为复杂的操作。许多语言都有管道的实现，现在有一个提案，让 JavaScript 也拥有管道机制。\n\nJavaScript 的管道是一个运算符，写作|>。它的左边是一个表达式，右边是一个函数。管道运算符把左边表达式的值，传入右边的函数进行求值。\n\nx |> f\n// 等同于\nf(x)\n\n\n1\n2\n3\n\n\n管道运算符最大的好处，就是可以把嵌套的函数，写成从左到右的链式表达式。\n\nfunction doubleSay (str) {\n  return str + \", \" + str;\n}\n\nfunction capitalize (str) {\n  return str[0].toUpperCase() + str.substring(1);\n}\n\nfunction exclaim (str) {\n  return str + '!';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面是三个简单的函数。如果要嵌套执行，传统的写法和管道的写法分别如下。\n\n// 传统的写法\nexclaim(capitalize(doubleSay('hello')))\n// \"Hello, hello!\"\n\n// 管道的写法\n'hello'\n  |> doubleSay\n  |> capitalize\n  |> exclaim\n// \"Hello, hello!\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n管道运算符只能传递一个值，这意味着它右边的函数必须是一个单参数函数。如果是多参数函数，就必须进行柯里化，改成单参数的版本。\n\nfunction double (x) { return x + x; }\nfunction add (x, y) { return x + y; }\n\nlet person = { score: 25 };\nperson.score\n  |> double\n  |> (_ => add(7, _))\n// 57\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，add函数需要两个参数。但是，管道运算符只能传入一个值，因此需要事先提供另一个参数，并将其改成单参数的箭头函数_ => add(7, _)。这个函数里面的下划线并没有特别的含义，可以用其他符号代替，使用下划线只是因为，它能够形象地表示这里是占位符。\n\n管道运算符对于await函数也适用。\n\nx |> await f\n// 等同于\nawait f(x)\n\nconst userAge = userId |> await fetchUserById |> getAgeFromUser;\n// 等同于\nconst userAge = getAgeFromUser(await fetchUserById(userId));\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 数值分隔符\n\n欧美语言中，较长的数值允许每三位添加一个分隔符（通常是一个逗号），增加数值的可读性。比如，1000可以写作1,000。\n\n现在有一个提案，允许 JavaScript 的数值使用下划线（_）作为分隔符。\n\nlet budget = 1_000_000_000_000;\nbudget === 10 ** 12 // true\n\n\n1\n2\n\n\nJavaScript 的数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。\n\n123_00 === 12_300 // true\n\n12345_00 === 123_4500 // true\n12345_00 === 1_234_500 // true\n\n\n1\n2\n3\n4\n\n\n小数和科学计数法也可以使用数值分隔符。\n\n// 小数\n0.000_001\n// 科学计数法\n1e10_000\n\n\n1\n2\n3\n4\n\n\n数值分隔符有几个使用注意点。\n\n * 不能在数值的最前面（leading）或最后面（trailing）。\n * 不能两个或两个以上的分隔符连在一起。\n * 小数点的前后不能有分隔符。\n * 科学计数法里面，表示指数的e或E前后不能有分隔符。\n\n下面的写法都会报错。\n\n// 全部报错\n3_.141\n3._141\n1_e12\n1e_12\n123__456\n_1464301\n1464301_\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n除了十进制，其他进制的数值也可以使用分隔符。\n\n// 二进制\n0b1010_0001_1000_0101\n// 十六进制\n0xA0_B0_C0\n\n\n1\n2\n3\n4\n\n\n注意，分隔符不能紧跟着进制的前缀0b、0B、0o、0O、0x、0X。\n\n// 报错\n0_b111111000\n0b_111111000\n\n\n1\n2\n3\n\n\n下面三个将字符串转成数值的函数，不支持数值分隔符。主要原因是提案的设计者认为，数值分隔符主要是为了编码时书写数值的方便，而不是为了处理外部输入的数据。\n\n * Number()\n * parseInt()\n * parseFloat()\n\nNumber('123_456') // NaN\nparseInt('123_456') // 123\n\n\n1\n2\n\n\n\n# Math.signbit()\n\nMath.sign()用来判断一个值的正负，但是如果参数是-0，它会返回-0。\n\nMath.sign(-0) // -0\n\n\n1\n\n\n这导致对于判断符号位的正负，Math.sign()不是很有用。JavaScript 内部使用 64 位浮点数（国际标准 IEEE 754）表示数值，IEEE 754 规定第一位是符号位，0表示正数，1表示负数。所以会有两种零，+0是符号位为0时的零值，-0是符号位为1时的零值。实际编程中，判断一个值是+0还是-0非常麻烦，因为它们是相等的。\n\n+0 === -0 // true\n\n\n1\n\n\n目前，有一个提案，引入了Math.signbit()方法判断一个数的符号位是否设置了。\n\nMath.signbit(2) //false\nMath.signbit(-2) //true\nMath.signbit(0) //false\nMath.signbit(-0) //true\n\n\n1\n2\n3\n4\n\n\n可以看到，该方法正确返回了-0的符号位是设置了的。\n\n该方法的算法如下。\n\n * 如果参数是NaN，返回false\n * 如果参数是-0，返回true\n * 如果参数是负值，返回true\n * 其他情况返回false\n\n\n# 双冒号运算符\n\n箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。\n\n函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。\n\nfoo::bar;\n// 等同于\nbar.bind(foo);\n\nfoo::bar(...arguments);\n// 等同于\nbar.apply(foo, arguments);\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return obj::hasOwnProperty(key);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。\n\nvar method = obj::obj.foo;\n// 等同于\nvar method = ::obj.foo;\n\nlet log = ::console.log;\n// 等同于\nvar log = console.log.bind(console);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。\n\nimport { map, takeWhile, forEach } from \"iterlib\";\n\ngetPlayers()\n::map(x => x.character())\n::takeWhile(x => x.strength > 100)\n::forEach(x => console.log(x));\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Realm API\n\nRealm API 提供沙箱功能（sandbox），允许隔离代码，防止那些被隔离的代码拿到全局对象。\n\n以前，经常使用<iframe>作为沙箱。\n\nconst globalOne = window;\nlet iframe = document.createElement('iframe');\ndocument.body.appendChild(iframe);\nconst globalTwo = iframe.contentWindow;\n\n\n1\n2\n3\n4\n\n\n上面代码中，<iframe>的全局对象是独立的（iframe.contentWindow）。Realm API 可以取代这个功能。\n\nconst globalOne = window;\nconst globalTwo = new Realm().global;\n\n\n1\n2\n\n\n上面代码中，Realm API单独提供了一个全局对象new Realm().global。\n\nRealm API 提供一个Realm()构造函数，用来生成一个 Realm 对象。该对象的global属性指向一个新的顶层对象，这个顶层对象跟原始的顶层对象类似。\n\nconst globalOne = window;\nconst globalTwo = new Realm().global;\n\nglobalOne.evaluate('1 + 2') // 3\nglobalTwo.evaluate('1 + 2') // 3\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，Realm 生成的顶层对象的evaluate()方法，可以运行代码。\n\n下面的代码可以证明，Realm 顶层对象与原始顶层对象是两个对象。\n\nlet a1 = globalOne.evaluate('[1,2,3]');\nlet a2 = globalTwo.evaluate('[1,2,3]');\na1.prototype === a2.prototype; // false\na1 instanceof globalTwo.Array; // false\na2 instanceof globalOne.Array; // false\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，Realm 沙箱里面的数组的原型对象，跟原始环境里面的数组是不一样的。\n\nRealm 沙箱里面只能运行 ECMAScript 语法提供的 API，不能运行宿主环境提供的 API。\n\nglobalTwo.evaluate('console.log(1)')\n// throw an error: console is undefined\n\n\n1\n2\n\n\n上面代码中，Realm 沙箱里面没有console对象，导致报错。因为console不是语法标准，是宿主环境提供的。\n\n如果要解决这个问题，可以使用下面的代码。\n\nglobalTwo.console = globalOne.console;\n\n\n1\n\n\nRealm()构造函数可以接受一个参数对象，该参数对象的intrinsics属性可以指定 Realm 沙箱继承原始顶层对象的方法。\n\nconst r1 = new Realm();\nr1.global === this;\nr1.global.JSON === JSON; // false\n\nconst r2 = new Realm({ intrinsics: 'inherit' });\nr2.global === this; // false\nr2.global.JSON === JSON; // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，正常情况下，沙箱的JSON方法不同于原始的JSON对象。但是，Realm()构造函数接受{ intrinsics: 'inherit' }作为参数以后，就会继承原始顶层对象的方法。\n\n用户可以自己定义Realm的子类，用来定制自己的沙箱。\n\nclass FakeWindow extends Realm {\n  init() {\n    super.init();\n    let global = this.global;\n\n    global.document = new FakeDocument(...);\n    global.alert = new Proxy(fakeAlert, { ... });\n    // ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，FakeWindow模拟了一个假的顶层对象window。\n\n\n# #!命令\n\nUnix 的命令行脚本都支持#!命令，又称为 Shebang 或 Hashbang。这个命令放在脚本的第一行，用来指定脚本的执行器。\n\n比如 Bash 脚本的第一行。\n\n#!/bin/sh\n\n\n1\n\n\nPython 脚本的第一行。\n\n#!/usr/bin/env python\n\n\n1\n\n\n现在有一个提案，为 JavaScript 脚本引入了#!命令，写在脚本文件或者模块文件的第一行。\n\n// 写在脚本文件第一行\n#!/usr/bin/env node\n'use strict';\nconsole.log(1);\n\n// 写在模块文件第一行\n#!/usr/bin/env node\nexport {};\nconsole.log(1);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n有了这一行以后，Unix 命令行就可以直接执行脚本。\n\n# 以前执行脚本的方式\n$ node hello.js\n\n# hashbang 的方式\n$ hello.js\n\n\n1\n2\n3\n4\n5\n\n\n对于 JavaScript 引擎来说，会把#!理解成注释，忽略掉这一行。\n\n\n# import.meta\n\n开发者使用一个模块时，有时需要知道模板本身的一些信息（比如模块的路径）。现在有一个提案，为 import 命令添加了一个元属性import.beta，返回当前模块的元信息。\n\nimport.meta只能在模块内部使用，如果在模块外部使用会报错。\n\n这个属性返回一个对象，该对象的各种属性就是当前运行的脚本的元信息。具体包含哪些属性，标准没有规定，由各个运行环境自行决定。一般来说，import.meta至少会有下面两个属性。\n\n（1）import.meta.url\n\nimport.meta.url返回当前模块的 URL 路径。举例来说，当前模块主文件的路径是https://foo.com/main.js，import.meta.url就返回这个路径。如果模块里面还有一个数据文件data.txt，那么就可以用下面的代码，获取这个数据文件的路径。\n\nnew URL('data.txt', import.meta.url)\n\n\n1\n\n\n注意，Node.js 环境中，import.meta.url返回的总是本地路径，即是file:URL协议的字符串，比如file:///home/user/foo.js。\n\n（2）import.meta.scriptElement\n\nimport.meta.scriptElement是浏览器特有的元属性，返回加载模块的那个<script>元素，相当于document.currentScript属性。\n\n// HTML 代码为\n// <script type=\"module\" src=\"my-module.js\" data-foo=\"abc\"><\/script>\n\n// my-module.js 内部执行下面的代码\nimport.meta.scriptElement.dataset.foo\n// \"abc\"\n\n\n1\n2\n3\n4\n5\n6\n",normalizedContent:"# 最新提案\n\n本章介绍一些尚未进入标准、但很有希望的最新提案。\n\n\n# do 表达式\n\n本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。\n\n{\n  let t = f();\n  t = t * t + 1;\n}\n\n\n1\n2\n3\n4\n\n\n上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。\n\n现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式，然后就会返回内部最后执行的表达式的值。\n\nlet x = do {\n  let t = f();\n  t * t + 1;\n};\n\n\n1\n2\n3\n4\n\n\n上面代码中，变量x会得到整个块级作用域的返回值（t * t + 1）。\n\ndo表达式的逻辑非常简单：封装的是什么，就会返回什么。\n\n// 等同于 <表达式>\ndo { <表达式>; }\n\n// 等同于 <语句>\ndo { <语句> }\n\n\n1\n2\n3\n4\n5\n\n\ndo表达式的好处是可以封装多个语句，让程序更加模块化，就像乐高积木那样一块块拼装起来。\n\nlet x = do {\n  if (foo()) { f() }\n  else if (bar()) { g() }\n  else { h() }\n};\n\n\n1\n2\n3\n4\n5\n\n\n上面代码的本质，就是根据函数foo的执行结果，调用不同的函数，将返回结果赋给变量x。使用do表达式，就将这个操作的意图表达得非常简洁清晰。而且，do块级作用域提供了单独的作用域，内部操作可以与全局作用域隔绝。\n\n值得一提的是，do表达式在 jsx 语法中非常好用。\n\nreturn (\n  <nav>\n    <home />\n    {\n      do {\n        if (loggedin) {\n          <logoutbutton />\n        } else {\n          <loginbutton />\n        }\n      }\n    }\n  </nav>\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，如果不用do表达式，就只能用三元判断运算符（?:）。那样的话，一旦判断逻辑复杂，代码就会变得很不易读。\n\n\n# throw 表达式\n\njavascript 语法规定throw是一个命令，用来抛出错误，不能用于表达式之中。\n\n// 报错\nconsole.log(throw new error());\n\n\n1\n2\n\n\n上面代码中，console.log的参数必须是一个表达式，如果是一个throw语句就会报错。\n\n现在有一个提案，允许throw用于表达式。\n\n// 参数的默认值\nfunction save(filename = throw new typeerror(\"argument required\")) {\n}\n\n// 箭头函数的返回值\nlint(ast, {\n  with: () => throw new error(\"avoid using 'with' statements.\")\n});\n\n// 条件表达式\nfunction getencoder(encoding) {\n  const encoder = encoding === \"utf8\" ?\n    new utf8encoder() :\n    encoding === \"utf16le\" ?\n      new utf16encoder(false) :\n      encoding === \"utf16be\" ?\n        new utf16encoder(true) :\n        throw new error(\"unsupported encoding\");\n}\n\n// 逻辑表达式\nclass product {\n  get id() {\n    return this._id;\n  }\n  set id(value) {\n    this._id = value || throw new error(\"invalid value\");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面代码中，throw都出现在表达式里面。\n\n语法上，throw表达式里面的throw不再是一个命令，而是一个运算符。为了避免与throw命令混淆，规定throw出现在行首，一律解释为throw语句，而不是throw表达式。\n\n\n# 函数的部分执行\n\n\n# 语法\n\n多参数的函数有时需要绑定其中的一个或多个参数，然后返回一个新函数。\n\nfunction add(x, y) { return x + y; }\nfunction add7(x) { return x + 7; }\n\n\n1\n2\n\n\n上面代码中，add7函数其实是add函数的一个特殊版本，通过将一个参数绑定为7，就可以从add得到add7。\n\n// bind 方法\nconst add7 = add.bind(null, 7);\n\n// 箭头函数\nconst add7 = x => add(x, 7);\n\n\n1\n2\n3\n4\n5\n\n\n上面两种写法都有些冗余。其中，bind方法的局限更加明显，它必须提供this，并且只能从前到后一个个绑定参数，无法只绑定非头部的参数。\n\n现在有一个提案，使得绑定参数并返回一个新函数更加容易。这叫做函数的部分执行（partial application）。\n\nconst add = (x, y) => x + y;\nconst addone = add(1, ?);\n\nconst maxgreaterthanzero = math.max(0, ...);\n\n\n1\n2\n3\n4\n\n\n根据新提案，?是单个参数的占位符，...是多个参数的占位符。以下的形式都属于函数的部分执行。\n\nf(x, ?)\nf(x, ...)\nf(?, x)\nf(..., x)\nf(?, x, ?)\nf(..., x, ...)\n\n\n1\n2\n3\n4\n5\n6\n\n\n?和...只能出现在函数的调用之中，并且会返回一个新函数。\n\nconst g = f(?, 1, ...);\n// 等同于\nconst g = (x, ...y) => f(x, 1, ...y);\n\n\n1\n2\n3\n\n\n函数的部分执行，也可以用于对象的方法。\n\nlet obj = {\n  f(x, y) { return x + y; },\n};\n\nconst g = obj.f(?, 3);\ng(1) // 4\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 注意点\n\n函数的部分执行有一些特别注意的地方。\n\n（1）函数的部分执行是基于原函数的。如果原函数发生变化，部分执行生成的新函数也会立即反映这种变化。\n\nlet f = (x, y) => x + y;\n\nconst g = f(?, 3);\ng(1); // 4\n\n// 替换函数 f\nf = (x, y) => x * y;\n\ng(1); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，定义了函数的部分执行以后，更换原函数会立即影响到新函数。\n\n（2）如果预先提供的那个值是一个表达式，那么这个表达式并不会在定义时求值，而是在每次调用时求值。\n\nlet a = 3;\nconst f = (x, y) => x + y;\n\nconst g = f(?, a);\ng(1); // 4\n\n// 改变 a 的值\na = 10;\ng(1); // 11\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，预先提供的参数是变量a，那么每次调用函数g的时候，才会对a进行求值。\n\n（3）如果新函数的参数多于占位符的数量，那么多余的参数将被忽略。\n\nconst f = (x, ...y) => [x, ...y];\nconst g = f(?, 1);\ng(2, 3, 4); // [2, 1]\n\n\n1\n2\n3\n\n\n上面代码中，函数g只有一个占位符，也就意味着它只能接受一个参数，多余的参数都会被忽略。\n\n写成下面这样，多余的参数就没有问题。\n\nconst f = (x, ...y) => [x, ...y];\nconst g = f(?, 1, ...);\ng(2, 3, 4); // [2, 1, 3, 4];\n\n\n1\n2\n3\n\n\n（4）...只会被采集一次，如果函数的部分执行使用了多个...，那么每个...的值都将相同。\n\nconst f = (...x) => x;\nconst g = f(..., 9, ...);\ng(1, 2, 3); // [1, 2, 3, 9, 1, 2, 3]\n\n\n1\n2\n3\n\n\n上面代码中，g定义了两个...占位符，真正执行的时候，它们的值是一样的。\n\n\n# 管道运算符\n\nunix 操作系统有一个管道机制（pipeline），可以把前一个操作的值传给后一个操作。这个机制非常有用，使得简单的操作可以组合成为复杂的操作。许多语言都有管道的实现，现在有一个提案，让 javascript 也拥有管道机制。\n\njavascript 的管道是一个运算符，写作|>。它的左边是一个表达式，右边是一个函数。管道运算符把左边表达式的值，传入右边的函数进行求值。\n\nx |> f\n// 等同于\nf(x)\n\n\n1\n2\n3\n\n\n管道运算符最大的好处，就是可以把嵌套的函数，写成从左到右的链式表达式。\n\nfunction doublesay (str) {\n  return str + \", \" + str;\n}\n\nfunction capitalize (str) {\n  return str[0].touppercase() + str.substring(1);\n}\n\nfunction exclaim (str) {\n  return str + '!';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面是三个简单的函数。如果要嵌套执行，传统的写法和管道的写法分别如下。\n\n// 传统的写法\nexclaim(capitalize(doublesay('hello')))\n// \"hello, hello!\"\n\n// 管道的写法\n'hello'\n  |> doublesay\n  |> capitalize\n  |> exclaim\n// \"hello, hello!\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n管道运算符只能传递一个值，这意味着它右边的函数必须是一个单参数函数。如果是多参数函数，就必须进行柯里化，改成单参数的版本。\n\nfunction double (x) { return x + x; }\nfunction add (x, y) { return x + y; }\n\nlet person = { score: 25 };\nperson.score\n  |> double\n  |> (_ => add(7, _))\n// 57\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，add函数需要两个参数。但是，管道运算符只能传入一个值，因此需要事先提供另一个参数，并将其改成单参数的箭头函数_ => add(7, _)。这个函数里面的下划线并没有特别的含义，可以用其他符号代替，使用下划线只是因为，它能够形象地表示这里是占位符。\n\n管道运算符对于await函数也适用。\n\nx |> await f\n// 等同于\nawait f(x)\n\nconst userage = userid |> await fetchuserbyid |> getagefromuser;\n// 等同于\nconst userage = getagefromuser(await fetchuserbyid(userid));\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 数值分隔符\n\n欧美语言中，较长的数值允许每三位添加一个分隔符（通常是一个逗号），增加数值的可读性。比如，1000可以写作1,000。\n\n现在有一个提案，允许 javascript 的数值使用下划线（_）作为分隔符。\n\nlet budget = 1_000_000_000_000;\nbudget === 10 ** 12 // true\n\n\n1\n2\n\n\njavascript 的数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。\n\n123_00 === 12_300 // true\n\n12345_00 === 123_4500 // true\n12345_00 === 1_234_500 // true\n\n\n1\n2\n3\n4\n\n\n小数和科学计数法也可以使用数值分隔符。\n\n// 小数\n0.000_001\n// 科学计数法\n1e10_000\n\n\n1\n2\n3\n4\n\n\n数值分隔符有几个使用注意点。\n\n * 不能在数值的最前面（leading）或最后面（trailing）。\n * 不能两个或两个以上的分隔符连在一起。\n * 小数点的前后不能有分隔符。\n * 科学计数法里面，表示指数的e或e前后不能有分隔符。\n\n下面的写法都会报错。\n\n// 全部报错\n3_.141\n3._141\n1_e12\n1e_12\n123__456\n_1464301\n1464301_\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n除了十进制，其他进制的数值也可以使用分隔符。\n\n// 二进制\n0b1010_0001_1000_0101\n// 十六进制\n0xa0_b0_c0\n\n\n1\n2\n3\n4\n\n\n注意，分隔符不能紧跟着进制的前缀0b、0b、0o、0o、0x、0x。\n\n// 报错\n0_b111111000\n0b_111111000\n\n\n1\n2\n3\n\n\n下面三个将字符串转成数值的函数，不支持数值分隔符。主要原因是提案的设计者认为，数值分隔符主要是为了编码时书写数值的方便，而不是为了处理外部输入的数据。\n\n * number()\n * parseint()\n * parsefloat()\n\nnumber('123_456') // nan\nparseint('123_456') // 123\n\n\n1\n2\n\n\n\n# math.signbit()\n\nmath.sign()用来判断一个值的正负，但是如果参数是-0，它会返回-0。\n\nmath.sign(-0) // -0\n\n\n1\n\n\n这导致对于判断符号位的正负，math.sign()不是很有用。javascript 内部使用 64 位浮点数（国际标准 ieee 754）表示数值，ieee 754 规定第一位是符号位，0表示正数，1表示负数。所以会有两种零，+0是符号位为0时的零值，-0是符号位为1时的零值。实际编程中，判断一个值是+0还是-0非常麻烦，因为它们是相等的。\n\n+0 === -0 // true\n\n\n1\n\n\n目前，有一个提案，引入了math.signbit()方法判断一个数的符号位是否设置了。\n\nmath.signbit(2) //false\nmath.signbit(-2) //true\nmath.signbit(0) //false\nmath.signbit(-0) //true\n\n\n1\n2\n3\n4\n\n\n可以看到，该方法正确返回了-0的符号位是设置了的。\n\n该方法的算法如下。\n\n * 如果参数是nan，返回false\n * 如果参数是-0，返回true\n * 如果参数是负值，返回true\n * 其他情况返回false\n\n\n# 双冒号运算符\n\n箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。\n\n函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。\n\nfoo::bar;\n// 等同于\nbar.bind(foo);\n\nfoo::bar(...arguments);\n// 等同于\nbar.apply(foo, arguments);\n\nconst hasownproperty = object.prototype.hasownproperty;\nfunction hasown(obj, key) {\n  return obj::hasownproperty(key);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。\n\nvar method = obj::obj.foo;\n// 等同于\nvar method = ::obj.foo;\n\nlet log = ::console.log;\n// 等同于\nvar log = console.log.bind(console);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。\n\nimport { map, takewhile, foreach } from \"iterlib\";\n\ngetplayers()\n::map(x => x.character())\n::takewhile(x => x.strength > 100)\n::foreach(x => console.log(x));\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# realm api\n\nrealm api 提供沙箱功能（sandbox），允许隔离代码，防止那些被隔离的代码拿到全局对象。\n\n以前，经常使用<iframe>作为沙箱。\n\nconst globalone = window;\nlet iframe = document.createelement('iframe');\ndocument.body.appendchild(iframe);\nconst globaltwo = iframe.contentwindow;\n\n\n1\n2\n3\n4\n\n\n上面代码中，<iframe>的全局对象是独立的（iframe.contentwindow）。realm api 可以取代这个功能。\n\nconst globalone = window;\nconst globaltwo = new realm().global;\n\n\n1\n2\n\n\n上面代码中，realm api单独提供了一个全局对象new realm().global。\n\nrealm api 提供一个realm()构造函数，用来生成一个 realm 对象。该对象的global属性指向一个新的顶层对象，这个顶层对象跟原始的顶层对象类似。\n\nconst globalone = window;\nconst globaltwo = new realm().global;\n\nglobalone.evaluate('1 + 2') // 3\nglobaltwo.evaluate('1 + 2') // 3\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，realm 生成的顶层对象的evaluate()方法，可以运行代码。\n\n下面的代码可以证明，realm 顶层对象与原始顶层对象是两个对象。\n\nlet a1 = globalone.evaluate('[1,2,3]');\nlet a2 = globaltwo.evaluate('[1,2,3]');\na1.prototype === a2.prototype; // false\na1 instanceof globaltwo.array; // false\na2 instanceof globalone.array; // false\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，realm 沙箱里面的数组的原型对象，跟原始环境里面的数组是不一样的。\n\nrealm 沙箱里面只能运行 ecmascript 语法提供的 api，不能运行宿主环境提供的 api。\n\nglobaltwo.evaluate('console.log(1)')\n// throw an error: console is undefined\n\n\n1\n2\n\n\n上面代码中，realm 沙箱里面没有console对象，导致报错。因为console不是语法标准，是宿主环境提供的。\n\n如果要解决这个问题，可以使用下面的代码。\n\nglobaltwo.console = globalone.console;\n\n\n1\n\n\nrealm()构造函数可以接受一个参数对象，该参数对象的intrinsics属性可以指定 realm 沙箱继承原始顶层对象的方法。\n\nconst r1 = new realm();\nr1.global === this;\nr1.global.json === json; // false\n\nconst r2 = new realm({ intrinsics: 'inherit' });\nr2.global === this; // false\nr2.global.json === json; // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，正常情况下，沙箱的json方法不同于原始的json对象。但是，realm()构造函数接受{ intrinsics: 'inherit' }作为参数以后，就会继承原始顶层对象的方法。\n\n用户可以自己定义realm的子类，用来定制自己的沙箱。\n\nclass fakewindow extends realm {\n  init() {\n    super.init();\n    let global = this.global;\n\n    global.document = new fakedocument(...);\n    global.alert = new proxy(fakealert, { ... });\n    // ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，fakewindow模拟了一个假的顶层对象window。\n\n\n# #!命令\n\nunix 的命令行脚本都支持#!命令，又称为 shebang 或 hashbang。这个命令放在脚本的第一行，用来指定脚本的执行器。\n\n比如 bash 脚本的第一行。\n\n#!/bin/sh\n\n\n1\n\n\npython 脚本的第一行。\n\n#!/usr/bin/env python\n\n\n1\n\n\n现在有一个提案，为 javascript 脚本引入了#!命令，写在脚本文件或者模块文件的第一行。\n\n// 写在脚本文件第一行\n#!/usr/bin/env node\n'use strict';\nconsole.log(1);\n\n// 写在模块文件第一行\n#!/usr/bin/env node\nexport {};\nconsole.log(1);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n有了这一行以后，unix 命令行就可以直接执行脚本。\n\n# 以前执行脚本的方式\n$ node hello.js\n\n# hashbang 的方式\n$ hello.js\n\n\n1\n2\n3\n4\n5\n\n\n对于 javascript 引擎来说，会把#!理解成注释，忽略掉这一行。\n\n\n# import.meta\n\n开发者使用一个模块时，有时需要知道模板本身的一些信息（比如模块的路径）。现在有一个提案，为 import 命令添加了一个元属性import.beta，返回当前模块的元信息。\n\nimport.meta只能在模块内部使用，如果在模块外部使用会报错。\n\n这个属性返回一个对象，该对象的各种属性就是当前运行的脚本的元信息。具体包含哪些属性，标准没有规定，由各个运行环境自行决定。一般来说，import.meta至少会有下面两个属性。\n\n（1）import.meta.url\n\nimport.meta.url返回当前模块的 url 路径。举例来说，当前模块主文件的路径是https://foo.com/main.js，import.meta.url就返回这个路径。如果模块里面还有一个数据文件data.txt，那么就可以用下面的代码，获取这个数据文件的路径。\n\nnew url('data.txt', import.meta.url)\n\n\n1\n\n\n注意，node.js 环境中，import.meta.url返回的总是本地路径，即是file:url协议的字符串，比如file:///home/user/foo.js。\n\n（2）import.meta.scriptelement\n\nimport.meta.scriptelement是浏览器特有的元属性，返回加载模块的那个<script>元素，相当于document.currentscript属性。\n\n// html 代码为\n// <script type=\"module\" src=\"my-module.js\" data-foo=\"abc\"><\/script>\n\n// my-module.js 内部执行下面的代码\nimport.meta.scriptelement.dataset.foo\n// \"abc\"\n\n\n1\n2\n3\n4\n5\n6\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"装饰器",frontmatter:{title:"装饰器",date:"2020-02-09T16:00:30.000Z",permalink:"/pages/e97bc1e5626b082c",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/30.%E8%A3%85%E9%A5%B0%E5%99%A8.html",relativePath:"《ES6 教程》笔记/30.装饰器.md",key:"v-3b44ff9b",path:"/pages/e97bc1e5626b082c/",headers:[{level:2,title:"类的装饰",slug:"类的装饰",normalizedTitle:"类的装饰",charIndex:436},{level:2,title:"方法的装饰",slug:"方法的装饰",normalizedTitle:"方法的装饰",charIndex:2627},{level:2,title:"为什么装饰器不能用于函数？",slug:"为什么装饰器不能用于函数",normalizedTitle:"为什么装饰器不能用于函数？",charIndex:5164},{level:2,title:"core-decorators.js",slug:"core-decorators-js",normalizedTitle:"core-decorators.js",charIndex:6159},{level:2,title:"使用装饰器实现自动发布事件",slug:"使用装饰器实现自动发布事件",normalizedTitle:"使用装饰器实现自动发布事件",charIndex:8524},{level:2,title:"Mixin",slug:"mixin",normalizedTitle:"mixin",charIndex:9811},{level:2,title:"Trait",slug:"trait",normalizedTitle:"trait",charIndex:12076}],excerpt:'<h1 id="装饰器"><a class="header-anchor" href="#装饰器">#</a> 装饰器</h1>\n<p>[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。</p>\n<p>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个<a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="noopener noreferrer">提案<OutboundLink/></a>将其引入了 ECMAScript。</p>\n',headersStr:"类的装饰 方法的装饰 为什么装饰器不能用于函数？ core-decorators.js 使用装饰器实现自动发布事件 Mixin Trait",content:"# 装饰器\n\n[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。\n\n装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个提案将其引入了 ECMAScript。 装饰器是一种函数，写成@ + 函数名。它可以放在类和类方法的定义前面。\n\n@frozen class Foo {\n  @configurable(false)\n  @enumerable(true)\n  method() {}\n\n  @throttle(500)\n  expensiveMethod() {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码一共使用了四个装饰器，一个用在类本身，另外三个用在类方法。它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。\n\n\n# 类的装饰\n\n装饰器可以用来装饰整个类。\n\n@testable\nclass MyTestableClass {\n  // ...\n}\n\nfunction testable(target) {\n  target.isTestable = true;\n}\n\nMyTestableClass.isTestable // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，@testable就是一个装饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。testable函数的参数target是MyTestableClass类本身。\n\n基本上，装饰器的行为就是下面这样。\n\n@decorator\nclass A {}\n\n// 等同于\n\nclass A {}\nA = decorator(A) || A;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。\n\nfunction testable(target) {\n  // ...\n}\n\n\n1\n2\n3\n\n\n上面代码中，testable函数的参数target，就是会被装饰的类。\n\n如果觉得一个参数不够用，可以在装饰器外面再封装一层函数。\n\nfunction testable(isTestable) {\n  return function(target) {\n    target.isTestable = isTestable;\n  }\n}\n\n@testable(true)\nclass MyTestableClass {}\nMyTestableClass.isTestable // true\n\n@testable(false)\nclass MyClass {}\nMyClass.isTestable // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，装饰器testable可以接受参数，这就等于可以修改装饰器的行为。\n\n注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。\n\n前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作。\n\nfunction testable(target) {\n  target.prototype.isTestable = true;\n}\n\n@testable\nclass MyTestableClass {}\n\nlet obj = new MyTestableClass();\nobj.isTestable // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，装饰器函数testable是在目标类的prototype对象上添加属性，因此就可以在实例上调用。\n\n下面是另外一个例子。\n\n// mixins.js\nexport function mixins(...list) {\n  return function (target) {\n    Object.assign(target.prototype, ...list)\n  }\n}\n\n// main.js\nimport { mixins } from './mixins'\n\nconst Foo = {\n  foo() { console.log('foo') }\n};\n\n@mixins(Foo)\nclass MyClass {}\n\nlet obj = new MyClass();\nobj.foo() // 'foo'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码通过装饰器mixins，把Foo对象的方法添加到了MyClass的实例上面。可以用Object.assign()模拟这个功能。\n\nconst Foo = {\n  foo() { console.log('foo') }\n};\n\nclass MyClass {}\n\nObject.assign(MyClass.prototype, Foo);\n\nlet obj = new MyClass();\nobj.foo() // 'foo'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。\n\nclass MyReactComponent extends React.Component {}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);\n\n\n1\n2\n3\n\n\n有了装饰器，就可以改写上面的代码。\n\n@connect(mapStateToProps, mapDispatchToProps)\nexport default class MyReactComponent extends React.Component {}\n\n\n1\n2\n\n\n相对来说，后一种写法看上去更容易理解。\n\n\n# 方法的装饰\n\n装饰器不仅可以装饰类，还可以装饰类的属性。\n\nclass Person {\n  @readonly\n  name() { return `${this.first} ${this.last}` }\n}\n\n\n1\n2\n3\n4\n\n\n上面代码中，装饰器readonly用来装饰“类”的name方法。\n\n装饰器函数readonly一共可以接受三个参数。\n\nfunction readonly(target, name, descriptor){\n  // descriptor对象原来的值如下\n  // {\n  //   value: specifiedFunction,\n  //   enumerable: false,\n  //   configurable: true,\n  //   writable: true\n  // };\n  descriptor.writable = false;\n  return descriptor;\n}\n\nreadonly(Person.prototype, 'name', descriptor);\n// 类似于\nObject.defineProperty(Person.prototype, 'name', descriptor);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n装饰器第一个参数是类的原型对象，上例是Person.prototype，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时target参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。\n\n另外，上面代码说明，装饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。\n\n下面是另一个例子，修改属性描述对象的enumerable属性，使得该属性不可遍历。\n\nclass Person {\n  @nonenumerable\n  get kidCount() { return this.children.length; }\n}\n\nfunction nonenumerable(target, name, descriptor) {\n  descriptor.enumerable = false;\n  return descriptor;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n下面的@log装饰器，可以起到输出日志的作用。\n\nclass Math {\n  @log\n  add(a, b) {\n    return a + b;\n  }\n}\n\nfunction log(target, name, descriptor) {\n  var oldValue = descriptor.value;\n\n  descriptor.value = function() {\n    console.log(`Calling ${name} with`, arguments);\n    return oldValue.apply(this, arguments);\n  };\n\n  return descriptor;\n}\n\nconst math = new Math();\n\n// passed parameters should get logged now\nmath.add(2, 4);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n上面代码中，@log装饰器的作用就是在执行原始的操作之前，执行一次console.log，从而达到输出日志的目的。\n\n装饰器有注释的作用。\n\n@testable\nclass Person {\n  @readonly\n  @nonenumerable\n  name() { return `${this.first} ${this.last}` }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n从上面代码中，我们一眼就能看出，Person类是可测试的，而name方法是只读和不可枚举的。\n\n下面是使用 Decorator 写法的组件，看上去一目了然。\n\n@Component({\n  tag: 'my-component',\n  styleUrl: 'my-component.scss'\n})\nexport class MyComponent {\n  @Prop() first: string;\n  @Prop() last: string;\n  @State() isVisible: boolean = true;\n\n  render() {\n    return (\n      <p>Hello, my name is {this.first} {this.last}</p>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。\n\nfunction dec(id){\n  console.log('evaluated', id);\n  return (target, property, descriptor) => console.log('executed', id);\n}\n\nclass Example {\n    @dec(1)\n    @dec(2)\n    method(){}\n}\n// evaluated 1\n// evaluated 2\n// executed 2\n// executed 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，外层装饰器@dec(1)先进入，但是内层装饰器@dec(2)先执行。\n\n除了注释，装饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。\n\n\n# 为什么装饰器不能用于函数？\n\n装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。\n\nvar counter = 0;\n\nvar add = function () {\n  counter++;\n};\n\n@add\nfunction foo() {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的代码，意图是执行后counter等于 1，但是实际上结果是counter等于 0。因为函数提升，使得实际执行的代码是下面这样。\n\n@add\nfunction foo() {\n}\n\nvar counter;\nvar add;\n\ncounter = 0;\n\nadd = function () {\n  counter++;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n下面是另一个例子。\n\nvar readOnly = require(\"some-decorator\");\n\n@readOnly\nfunction foo() {\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码也有问题，因为实际执行是下面这样。\n\nvar readOnly;\n\n@readOnly\nfunction foo() {\n}\n\nreadOnly = require(\"some-decorator\");\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n总之，由于存在函数提升，使得装饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。\n\n另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行。\n\nfunction doSomething(name) {\n  console.log('Hello, ' + name);\n}\n\nfunction loggingDecorator(wrapped) {\n  return function() {\n    console.log('Starting');\n    const result = wrapped.apply(this, arguments);\n    console.log('Finished');\n    return result;\n  }\n}\n\nconst wrapped = loggingDecorator(doSomething);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# core-decorators.js\n\ncore-decorators.js是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器。\n\n（1）@autobind\n\nautobind装饰器使得方法中的this对象，绑定原始对象。\n\nimport { autobind } from 'core-decorators';\n\nclass Person {\n  @autobind\n  getPerson() {\n    return this;\n  }\n}\n\nlet person = new Person();\nlet getPerson = person.getPerson;\n\ngetPerson() === person;\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n（2）@readonly\n\nreadonly装饰器使得属性或方法不可写。\n\nimport { readonly } from 'core-decorators';\n\nclass Meal {\n  @readonly\n  entree = 'steak';\n}\n\nvar dinner = new Meal();\ndinner.entree = 'salmon';\n// Cannot assign to read only property 'entree' of [object Object]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n（3）@override\n\noverride装饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。\n\nimport { override } from 'core-decorators';\n\nclass Parent {\n  speak(first, second) {}\n}\n\nclass Child extends Parent {\n  @override\n  speak() {}\n  // SyntaxError: Child#speak() does not properly override Parent#speak(first, second)\n}\n\n// or\n\nclass Child extends Parent {\n  @override\n  speaks() {}\n  // SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.\n  //\n  //   Did you mean \"speak\"?\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n（4）@deprecate (别名@deprecated)\n\ndeprecate或deprecated装饰器在控制台显示一条警告，表示该方法将废除。\n\nimport { deprecate } from 'core-decorators';\n\nclass Person {\n  @deprecate\n  facepalm() {}\n\n  @deprecate('We stopped facepalming')\n  facepalmHard() {}\n\n  @deprecate('We stopped facepalming', { url: 'http://knowyourmeme.com/memes/facepalm' })\n  facepalmHarder() {}\n}\n\nlet person = new Person();\n\nperson.facepalm();\n// DEPRECATION Person#facepalm: This function will be removed in future versions.\n\nperson.facepalmHard();\n// DEPRECATION Person#facepalmHard: We stopped facepalming\n\nperson.facepalmHarder();\n// DEPRECATION Person#facepalmHarder: We stopped facepalming\n//\n//     See http://knowyourmeme.com/memes/facepalm for more details.\n//\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n（5）@suppressWarnings\n\nsuppressWarnings装饰器抑制deprecated装饰器导致的console.warn()调用。但是，异步代码发出的调用除外。\n\nimport { suppressWarnings } from 'core-decorators';\n\nclass Person {\n  @deprecated\n  facepalm() {}\n\n  @suppressWarnings\n  facepalmWithoutWarning() {\n    this.facepalm();\n  }\n}\n\nlet person = new Person();\n\nperson.facepalmWithoutWarning();\n// no warning is logged\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 使用装饰器实现自动发布事件\n\n我们可以使用装饰器，使得对象的方法被调用时，自动发出一个事件。\n\nconst postal = require(\"postal/lib/postal.lodash\");\n\nexport default function publish(topic, channel) {\n  const channelName = channel || '/';\n  const msgChannel = postal.channel(channelName);\n  msgChannel.subscribe(topic, v => {\n    console.log('频道: ', channelName);\n    console.log('事件: ', topic);\n    console.log('数据: ', v);\n  });\n\n  return function(target, name, descriptor) {\n    const fn = descriptor.value;\n\n    descriptor.value = function() {\n      let value = fn.apply(this, arguments);\n      msgChannel.publish(topic, value);\n    };\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n上面代码定义了一个名为publish的装饰器，它通过改写descriptor.value，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是Postal.js。\n\n它的用法如下。\n\n// index.js\nimport publish from './publish';\n\nclass FooComponent {\n  @publish('foo.some.message', 'component')\n  someMethod() {\n    return { my: 'data' };\n  }\n  @publish('foo.some.other')\n  anotherMethod() {\n    // ...\n  }\n}\n\nlet foo = new FooComponent();\n\nfoo.someMethod();\nfoo.anotherMethod();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n以后，只要调用someMethod或者anotherMethod，就会自动发出一个事件。\n\n$ bash-node index.js\n频道:  component\n事件:  foo.some.message\n数据:  { my: 'data' }\n\n频道:  /\n事件:  foo.some.other\n数据:  undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Mixin\n\n在装饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。\n\n请看下面的例子。\n\nconst Foo = {\n  foo() { console.log('foo') }\n};\n\nclass MyClass {}\n\nObject.assign(MyClass.prototype, Foo);\n\nlet obj = new MyClass();\nobj.foo() // 'foo'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码之中，对象Foo有一个foo方法，通过Object.assign方法，可以将foo方法“混入”MyClass类，导致MyClass的实例obj对象都具有foo方法。这就是“混入”模式的一个简单实现。\n\n下面，我们部署一个通用脚本mixins.js，将 Mixin 写成一个装饰器。\n\nexport function mixins(...list) {\n  return function (target) {\n    Object.assign(target.prototype, ...list);\n  };\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后，就可以使用上面这个装饰器，为类“混入”各种方法。\n\nimport { mixins } from './mixins';\n\nconst Foo = {\n  foo() { console.log('foo') }\n};\n\n@mixins(Foo)\nclass MyClass {}\n\nlet obj = new MyClass();\nobj.foo() // \"foo\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n通过mixins这个装饰器，实现了在MyClass类上面“混入”Foo对象的foo方法。\n\n不过，上面的方法会改写MyClass类的prototype对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin。\n\nclass MyClass extends MyBaseClass {\n  /* ... */\n}\n\n\n1\n2\n3\n\n\n上面代码中，MyClass继承了MyBaseClass。如果我们想在MyClass里面“混入”一个foo方法，一个办法是在MyClass和MyBaseClass之间插入一个混入类，这个类具有foo方法，并且继承了MyBaseClass的所有方法，然后MyClass再继承这个类。\n\nlet MyMixin = (superclass) => class extends superclass {\n  foo() {\n    console.log('foo from MyMixin');\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，MyMixin是一个混入类生成器，接受superclass作为参数，然后返回一个继承superclass的子类，该子类包含一个foo方法。\n\n接着，目标类再去继承这个混入类，就达到了“混入”foo方法的目的。\n\nclass MyClass extends MyMixin(MyBaseClass) {\n  /* ... */\n}\n\nlet c = new MyClass();\nc.foo(); // \"foo from MyMixin\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果需要“混入”多个方法，就生成多个混入类。\n\nclass MyClass extends Mixin1(Mixin2(MyBaseClass)) {\n  /* ... */\n}\n\n\n1\n2\n3\n\n\n这种写法的一个好处，是可以调用super，因此可以避免在“混入”过程中覆盖父类的同名方法。\n\nlet Mixin1 = (superclass) => class extends superclass {\n  foo() {\n    console.log('foo from Mixin1');\n    if (super.foo) super.foo();\n  }\n};\n\nlet Mixin2 = (superclass) => class extends superclass {\n  foo() {\n    console.log('foo from Mixin2');\n    if (super.foo) super.foo();\n  }\n};\n\nclass S {\n  foo() {\n    console.log('foo from S');\n  }\n}\n\nclass C extends Mixin1(Mixin2(S)) {\n  foo() {\n    console.log('foo from C');\n    super.foo();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n上面代码中，每一次混入发生时，都调用了父类的super.foo方法，导致父类的同名方法没有被覆盖，行为被保留了下来。\n\nnew C().foo()\n// foo from C\n// foo from Mixin1\n// foo from Mixin2\n// foo from S\n\n\n1\n2\n3\n4\n5\n\n\n\n# Trait\n\nTrait 也是一种装饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。\n\n下面采用traits-decorator这个第三方模块作为例子。这个模块提供的traits装饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。\n\nimport { traits } from 'traits-decorator';\n\nclass TFoo {\n  foo() { console.log('foo') }\n}\n\nconst TBar = {\n  bar() { console.log('bar') }\n};\n\n@traits(TFoo, TBar)\nclass MyClass { }\n\nlet obj = new MyClass();\nobj.foo() // foo\nobj.bar() // bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，通过traits装饰器，在MyClass类上面“混入”了TFoo类的foo方法和TBar对象的bar方法。\n\nTrait 不允许“混入”同名方法。\n\nimport { traits } from 'traits-decorator';\n\nclass TFoo {\n  foo() { console.log('foo') }\n}\n\nconst TBar = {\n  bar() { console.log('bar') },\n  foo() { console.log('foo') }\n};\n\n@traits(TFoo, TBar)\nclass MyClass { }\n// 报错\n// throw new Error('Method named: ' + methodName + ' is defined twice.');\n//        ^\n// Error: Method named: foo is defined twice.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，TFoo和TBar都有foo方法，结果traits装饰器报错。\n\n一种解决方法是排除TBar的foo方法。\n\nimport { traits, excludes } from 'traits-decorator';\n\nclass TFoo {\n  foo() { console.log('foo') }\n}\n\nconst TBar = {\n  bar() { console.log('bar') },\n  foo() { console.log('foo') }\n};\n\n@traits(TFoo, TBar::excludes('foo'))\nclass MyClass { }\n\nlet obj = new MyClass();\nobj.foo() // foo\nobj.bar() // bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码使用绑定运算符（::）在TBar上排除foo方法，混入时就不会报错了。\n\n另一种方法是为TBar的foo方法起一个别名。\n\nimport { traits, alias } from 'traits-decorator';\n\nclass TFoo {\n  foo() { console.log('foo') }\n}\n\nconst TBar = {\n  bar() { console.log('bar') },\n  foo() { console.log('foo') }\n};\n\n@traits(TFoo, TBar::alias({foo: 'aliasFoo'}))\nclass MyClass { }\n\nlet obj = new MyClass();\nobj.foo() // foo\nobj.aliasFoo() // foo\nobj.bar() // bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码为TBar的foo方法起了别名aliasFoo，于是MyClass也可以混入TBar的foo方法了。\n\nalias和excludes方法，可以结合起来使用。\n\n@traits(TExample::excludes('foo','bar')::alias({baz:'exampleBaz'}))\nclass MyClass {}\n\n\n1\n2\n\n\n上面代码排除了TExample的foo方法和bar方法，为baz方法起了别名exampleBaz。\n\nas方法则为上面的代码提供了另一种写法。\n\n@traits(TExample::as({excludes:['foo', 'bar'], alias: {baz: 'exampleBaz'}}))\nclass MyClass {}\n\n\n1\n2\n",normalizedContent:"# 装饰器\n\n[说明] decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。\n\n装饰器（decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个提案将其引入了 ecmascript。 装饰器是一种函数，写成@ + 函数名。它可以放在类和类方法的定义前面。\n\n@frozen class foo {\n  @configurable(false)\n  @enumerable(true)\n  method() {}\n\n  @throttle(500)\n  expensivemethod() {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码一共使用了四个装饰器，一个用在类本身，另外三个用在类方法。它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。\n\n\n# 类的装饰\n\n装饰器可以用来装饰整个类。\n\n@testable\nclass mytestableclass {\n  // ...\n}\n\nfunction testable(target) {\n  target.istestable = true;\n}\n\nmytestableclass.istestable // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，@testable就是一个装饰器。它修改了mytestableclass这个类的行为，为它加上了静态属性istestable。testable函数的参数target是mytestableclass类本身。\n\n基本上，装饰器的行为就是下面这样。\n\n@decorator\nclass a {}\n\n// 等同于\n\nclass a {}\na = decorator(a) || a;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。\n\nfunction testable(target) {\n  // ...\n}\n\n\n1\n2\n3\n\n\n上面代码中，testable函数的参数target，就是会被装饰的类。\n\n如果觉得一个参数不够用，可以在装饰器外面再封装一层函数。\n\nfunction testable(istestable) {\n  return function(target) {\n    target.istestable = istestable;\n  }\n}\n\n@testable(true)\nclass mytestableclass {}\nmytestableclass.istestable // true\n\n@testable(false)\nclass myclass {}\nmyclass.istestable // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，装饰器testable可以接受参数，这就等于可以修改装饰器的行为。\n\n注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。\n\n前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作。\n\nfunction testable(target) {\n  target.prototype.istestable = true;\n}\n\n@testable\nclass mytestableclass {}\n\nlet obj = new mytestableclass();\nobj.istestable // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，装饰器函数testable是在目标类的prototype对象上添加属性，因此就可以在实例上调用。\n\n下面是另外一个例子。\n\n// mixins.js\nexport function mixins(...list) {\n  return function (target) {\n    object.assign(target.prototype, ...list)\n  }\n}\n\n// main.js\nimport { mixins } from './mixins'\n\nconst foo = {\n  foo() { console.log('foo') }\n};\n\n@mixins(foo)\nclass myclass {}\n\nlet obj = new myclass();\nobj.foo() // 'foo'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上面代码通过装饰器mixins，把foo对象的方法添加到了myclass的实例上面。可以用object.assign()模拟这个功能。\n\nconst foo = {\n  foo() { console.log('foo') }\n};\n\nclass myclass {}\n\nobject.assign(myclass.prototype, foo);\n\nlet obj = new myclass();\nobj.foo() // 'foo'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n实际开发中，react 与 redux 库结合使用时，常常需要写成下面这样。\n\nclass myreactcomponent extends react.component {}\n\nexport default connect(mapstatetoprops, mapdispatchtoprops)(myreactcomponent);\n\n\n1\n2\n3\n\n\n有了装饰器，就可以改写上面的代码。\n\n@connect(mapstatetoprops, mapdispatchtoprops)\nexport default class myreactcomponent extends react.component {}\n\n\n1\n2\n\n\n相对来说，后一种写法看上去更容易理解。\n\n\n# 方法的装饰\n\n装饰器不仅可以装饰类，还可以装饰类的属性。\n\nclass person {\n  @readonly\n  name() { return `${this.first} ${this.last}` }\n}\n\n\n1\n2\n3\n4\n\n\n上面代码中，装饰器readonly用来装饰“类”的name方法。\n\n装饰器函数readonly一共可以接受三个参数。\n\nfunction readonly(target, name, descriptor){\n  // descriptor对象原来的值如下\n  // {\n  //   value: specifiedfunction,\n  //   enumerable: false,\n  //   configurable: true,\n  //   writable: true\n  // };\n  descriptor.writable = false;\n  return descriptor;\n}\n\nreadonly(person.prototype, 'name', descriptor);\n// 类似于\nobject.defineproperty(person.prototype, 'name', descriptor);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n装饰器第一个参数是类的原型对象，上例是person.prototype，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时target参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。\n\n另外，上面代码说明，装饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。\n\n下面是另一个例子，修改属性描述对象的enumerable属性，使得该属性不可遍历。\n\nclass person {\n  @nonenumerable\n  get kidcount() { return this.children.length; }\n}\n\nfunction nonenumerable(target, name, descriptor) {\n  descriptor.enumerable = false;\n  return descriptor;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n下面的@log装饰器，可以起到输出日志的作用。\n\nclass math {\n  @log\n  add(a, b) {\n    return a + b;\n  }\n}\n\nfunction log(target, name, descriptor) {\n  var oldvalue = descriptor.value;\n\n  descriptor.value = function() {\n    console.log(`calling ${name} with`, arguments);\n    return oldvalue.apply(this, arguments);\n  };\n\n  return descriptor;\n}\n\nconst math = new math();\n\n// passed parameters should get logged now\nmath.add(2, 4);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n上面代码中，@log装饰器的作用就是在执行原始的操作之前，执行一次console.log，从而达到输出日志的目的。\n\n装饰器有注释的作用。\n\n@testable\nclass person {\n  @readonly\n  @nonenumerable\n  name() { return `${this.first} ${this.last}` }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n从上面代码中，我们一眼就能看出，person类是可测试的，而name方法是只读和不可枚举的。\n\n下面是使用 decorator 写法的组件，看上去一目了然。\n\n@component({\n  tag: 'my-component',\n  styleurl: 'my-component.scss'\n})\nexport class mycomponent {\n  @prop() first: string;\n  @prop() last: string;\n  @state() isvisible: boolean = true;\n\n  render() {\n    return (\n      <p>hello, my name is {this.first} {this.last}</p>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。\n\nfunction dec(id){\n  console.log('evaluated', id);\n  return (target, property, descriptor) => console.log('executed', id);\n}\n\nclass example {\n    @dec(1)\n    @dec(2)\n    method(){}\n}\n// evaluated 1\n// evaluated 2\n// executed 2\n// executed 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，外层装饰器@dec(1)先进入，但是内层装饰器@dec(2)先执行。\n\n除了注释，装饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 javascript 代码静态分析的重要工具。\n\n\n# 为什么装饰器不能用于函数？\n\n装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。\n\nvar counter = 0;\n\nvar add = function () {\n  counter++;\n};\n\n@add\nfunction foo() {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的代码，意图是执行后counter等于 1，但是实际上结果是counter等于 0。因为函数提升，使得实际执行的代码是下面这样。\n\n@add\nfunction foo() {\n}\n\nvar counter;\nvar add;\n\ncounter = 0;\n\nadd = function () {\n  counter++;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n下面是另一个例子。\n\nvar readonly = require(\"some-decorator\");\n\n@readonly\nfunction foo() {\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面代码也有问题，因为实际执行是下面这样。\n\nvar readonly;\n\n@readonly\nfunction foo() {\n}\n\nreadonly = require(\"some-decorator\");\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n总之，由于存在函数提升，使得装饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。\n\n另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行。\n\nfunction dosomething(name) {\n  console.log('hello, ' + name);\n}\n\nfunction loggingdecorator(wrapped) {\n  return function() {\n    console.log('starting');\n    const result = wrapped.apply(this, arguments);\n    console.log('finished');\n    return result;\n  }\n}\n\nconst wrapped = loggingdecorator(dosomething);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# core-decorators.js\n\ncore-decorators.js是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器。\n\n（1）@autobind\n\nautobind装饰器使得方法中的this对象，绑定原始对象。\n\nimport { autobind } from 'core-decorators';\n\nclass person {\n  @autobind\n  getperson() {\n    return this;\n  }\n}\n\nlet person = new person();\nlet getperson = person.getperson;\n\ngetperson() === person;\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n（2）@readonly\n\nreadonly装饰器使得属性或方法不可写。\n\nimport { readonly } from 'core-decorators';\n\nclass meal {\n  @readonly\n  entree = 'steak';\n}\n\nvar dinner = new meal();\ndinner.entree = 'salmon';\n// cannot assign to read only property 'entree' of [object object]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n（3）@override\n\noverride装饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。\n\nimport { override } from 'core-decorators';\n\nclass parent {\n  speak(first, second) {}\n}\n\nclass child extends parent {\n  @override\n  speak() {}\n  // syntaxerror: child#speak() does not properly override parent#speak(first, second)\n}\n\n// or\n\nclass child extends parent {\n  @override\n  speaks() {}\n  // syntaxerror: no descriptor matching child#speaks() was found on the prototype chain.\n  //\n  //   did you mean \"speak\"?\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n（4）@deprecate (别名@deprecated)\n\ndeprecate或deprecated装饰器在控制台显示一条警告，表示该方法将废除。\n\nimport { deprecate } from 'core-decorators';\n\nclass person {\n  @deprecate\n  facepalm() {}\n\n  @deprecate('we stopped facepalming')\n  facepalmhard() {}\n\n  @deprecate('we stopped facepalming', { url: 'http://knowyourmeme.com/memes/facepalm' })\n  facepalmharder() {}\n}\n\nlet person = new person();\n\nperson.facepalm();\n// deprecation person#facepalm: this function will be removed in future versions.\n\nperson.facepalmhard();\n// deprecation person#facepalmhard: we stopped facepalming\n\nperson.facepalmharder();\n// deprecation person#facepalmharder: we stopped facepalming\n//\n//     see http://knowyourmeme.com/memes/facepalm for more details.\n//\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n（5）@suppresswarnings\n\nsuppresswarnings装饰器抑制deprecated装饰器导致的console.warn()调用。但是，异步代码发出的调用除外。\n\nimport { suppresswarnings } from 'core-decorators';\n\nclass person {\n  @deprecated\n  facepalm() {}\n\n  @suppresswarnings\n  facepalmwithoutwarning() {\n    this.facepalm();\n  }\n}\n\nlet person = new person();\n\nperson.facepalmwithoutwarning();\n// no warning is logged\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 使用装饰器实现自动发布事件\n\n我们可以使用装饰器，使得对象的方法被调用时，自动发出一个事件。\n\nconst postal = require(\"postal/lib/postal.lodash\");\n\nexport default function publish(topic, channel) {\n  const channelname = channel || '/';\n  const msgchannel = postal.channel(channelname);\n  msgchannel.subscribe(topic, v => {\n    console.log('频道: ', channelname);\n    console.log('事件: ', topic);\n    console.log('数据: ', v);\n  });\n\n  return function(target, name, descriptor) {\n    const fn = descriptor.value;\n\n    descriptor.value = function() {\n      let value = fn.apply(this, arguments);\n      msgchannel.publish(topic, value);\n    };\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n上面代码定义了一个名为publish的装饰器，它通过改写descriptor.value，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是postal.js。\n\n它的用法如下。\n\n// index.js\nimport publish from './publish';\n\nclass foocomponent {\n  @publish('foo.some.message', 'component')\n  somemethod() {\n    return { my: 'data' };\n  }\n  @publish('foo.some.other')\n  anothermethod() {\n    // ...\n  }\n}\n\nlet foo = new foocomponent();\n\nfoo.somemethod();\nfoo.anothermethod();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n以后，只要调用somemethod或者anothermethod，就会自动发出一个事件。\n\n$ bash-node index.js\n频道:  component\n事件:  foo.some.message\n数据:  { my: 'data' }\n\n频道:  /\n事件:  foo.some.other\n数据:  undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# mixin\n\n在装饰器的基础上，可以实现mixin模式。所谓mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。\n\n请看下面的例子。\n\nconst foo = {\n  foo() { console.log('foo') }\n};\n\nclass myclass {}\n\nobject.assign(myclass.prototype, foo);\n\nlet obj = new myclass();\nobj.foo() // 'foo'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码之中，对象foo有一个foo方法，通过object.assign方法，可以将foo方法“混入”myclass类，导致myclass的实例obj对象都具有foo方法。这就是“混入”模式的一个简单实现。\n\n下面，我们部署一个通用脚本mixins.js，将 mixin 写成一个装饰器。\n\nexport function mixins(...list) {\n  return function (target) {\n    object.assign(target.prototype, ...list);\n  };\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后，就可以使用上面这个装饰器，为类“混入”各种方法。\n\nimport { mixins } from './mixins';\n\nconst foo = {\n  foo() { console.log('foo') }\n};\n\n@mixins(foo)\nclass myclass {}\n\nlet obj = new myclass();\nobj.foo() // \"foo\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n通过mixins这个装饰器，实现了在myclass类上面“混入”foo对象的foo方法。\n\n不过，上面的方法会改写myclass类的prototype对象，如果不喜欢这一点，也可以通过类的继承实现 mixin。\n\nclass myclass extends mybaseclass {\n  /* ... */\n}\n\n\n1\n2\n3\n\n\n上面代码中，myclass继承了mybaseclass。如果我们想在myclass里面“混入”一个foo方法，一个办法是在myclass和mybaseclass之间插入一个混入类，这个类具有foo方法，并且继承了mybaseclass的所有方法，然后myclass再继承这个类。\n\nlet mymixin = (superclass) => class extends superclass {\n  foo() {\n    console.log('foo from mymixin');\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，mymixin是一个混入类生成器，接受superclass作为参数，然后返回一个继承superclass的子类，该子类包含一个foo方法。\n\n接着，目标类再去继承这个混入类，就达到了“混入”foo方法的目的。\n\nclass myclass extends mymixin(mybaseclass) {\n  /* ... */\n}\n\nlet c = new myclass();\nc.foo(); // \"foo from mymixin\"\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果需要“混入”多个方法，就生成多个混入类。\n\nclass myclass extends mixin1(mixin2(mybaseclass)) {\n  /* ... */\n}\n\n\n1\n2\n3\n\n\n这种写法的一个好处，是可以调用super，因此可以避免在“混入”过程中覆盖父类的同名方法。\n\nlet mixin1 = (superclass) => class extends superclass {\n  foo() {\n    console.log('foo from mixin1');\n    if (super.foo) super.foo();\n  }\n};\n\nlet mixin2 = (superclass) => class extends superclass {\n  foo() {\n    console.log('foo from mixin2');\n    if (super.foo) super.foo();\n  }\n};\n\nclass s {\n  foo() {\n    console.log('foo from s');\n  }\n}\n\nclass c extends mixin1(mixin2(s)) {\n  foo() {\n    console.log('foo from c');\n    super.foo();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n上面代码中，每一次混入发生时，都调用了父类的super.foo方法，导致父类的同名方法没有被覆盖，行为被保留了下来。\n\nnew c().foo()\n// foo from c\n// foo from mixin1\n// foo from mixin2\n// foo from s\n\n\n1\n2\n3\n4\n5\n\n\n\n# trait\n\ntrait 也是一种装饰器，效果与 mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。\n\n下面采用traits-decorator这个第三方模块作为例子。这个模块提供的traits装饰器，不仅可以接受对象，还可以接受 es6 类作为参数。\n\nimport { traits } from 'traits-decorator';\n\nclass tfoo {\n  foo() { console.log('foo') }\n}\n\nconst tbar = {\n  bar() { console.log('bar') }\n};\n\n@traits(tfoo, tbar)\nclass myclass { }\n\nlet obj = new myclass();\nobj.foo() // foo\nobj.bar() // bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，通过traits装饰器，在myclass类上面“混入”了tfoo类的foo方法和tbar对象的bar方法。\n\ntrait 不允许“混入”同名方法。\n\nimport { traits } from 'traits-decorator';\n\nclass tfoo {\n  foo() { console.log('foo') }\n}\n\nconst tbar = {\n  bar() { console.log('bar') },\n  foo() { console.log('foo') }\n};\n\n@traits(tfoo, tbar)\nclass myclass { }\n// 报错\n// throw new error('method named: ' + methodname + ' is defined twice.');\n//        ^\n// error: method named: foo is defined twice.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，tfoo和tbar都有foo方法，结果traits装饰器报错。\n\n一种解决方法是排除tbar的foo方法。\n\nimport { traits, excludes } from 'traits-decorator';\n\nclass tfoo {\n  foo() { console.log('foo') }\n}\n\nconst tbar = {\n  bar() { console.log('bar') },\n  foo() { console.log('foo') }\n};\n\n@traits(tfoo, tbar::excludes('foo'))\nclass myclass { }\n\nlet obj = new myclass();\nobj.foo() // foo\nobj.bar() // bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码使用绑定运算符（::）在tbar上排除foo方法，混入时就不会报错了。\n\n另一种方法是为tbar的foo方法起一个别名。\n\nimport { traits, alias } from 'traits-decorator';\n\nclass tfoo {\n  foo() { console.log('foo') }\n}\n\nconst tbar = {\n  bar() { console.log('bar') },\n  foo() { console.log('foo') }\n};\n\n@traits(tfoo, tbar::alias({foo: 'aliasfoo'}))\nclass myclass { }\n\nlet obj = new myclass();\nobj.foo() // foo\nobj.aliasfoo() // foo\nobj.bar() // bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码为tbar的foo方法起了别名aliasfoo，于是myclass也可以混入tbar的foo方法了。\n\nalias和excludes方法，可以结合起来使用。\n\n@traits(texample::excludes('foo','bar')::alias({baz:'examplebaz'}))\nclass myclass {}\n\n\n1\n2\n\n\n上面代码排除了texample的foo方法和bar方法，为baz方法起了别名examplebaz。\n\nas方法则为上面的代码提供了另一种写法。\n\n@traits(texample::as({excludes:['foo', 'bar'], alias: {baz: 'examplebaz'}}))\nclass myclass {}\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"读懂 ECMAScript 规格",frontmatter:{title:"读懂 ECMAScript 规格",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/32c35f7651d6e58e",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/26.%E8%AF%BB%E6%87%82%20ECMAScript%20%E8%A7%84%E6%A0%BC.html",relativePath:"《ES6 教程》笔记/26.读懂 ECMAScript 规格.md",key:"v-4248c6f3",path:"/pages/32c35f7651d6e58e/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:23},{level:2,title:"术语",slug:"术语",normalizedTitle:"术语",charIndex:819},{level:3,title:"抽象操作",slug:"抽象操作",normalizedTitle:"抽象操作",charIndex:718},{level:3,title:"Record 和 field",slug:"record-和-field",normalizedTitle:"record 和 field",charIndex:1122},{level:3,title:"[[Notation]]",slug:"notation",normalizedTitle:"[[notation]]",charIndex:1264},{level:3,title:"Completion Record",slug:"completion-record",normalizedTitle:"completion record",charIndex:1668},{level:2,title:"抽象操作的标准流程",slug:"抽象操作的标准流程",normalizedTitle:"抽象操作的标准流程",charIndex:2e3},{level:2,title:"相等运算符",slug:"相等运算符",normalizedTitle:"相等运算符",charIndex:2930},{level:2,title:"数组的空位",slug:"数组的空位",normalizedTitle:"数组的空位",charIndex:4941},{level:2,title:"数组的 map 方法",slug:"数组的-map-方法",normalizedTitle:"数组的 map 方法",charIndex:6543}],excerpt:'<h1 id="读懂-ecmascript-规格"><a class="header-anchor" href="#读懂-ecmascript-规格">#</a> 读懂 ECMAScript 规格</h1>\n<h2 id="概述"><a class="header-anchor" href="#概述">#</a> 概述</h2>\n<p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。</p>\n<p>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p>\n',headersStr:"概述 术语 抽象操作 Record 和 field [[Notation]] Completion Record 抽象操作的标准流程 相等运算符 数组的空位 数组的 map 方法",content:'# 读懂 ECMAScript 规格\n\n\n# 概述\n\n规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。\n\n一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。 这对 JavaScript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。\n\n本章介绍如何读懂 ECMAScript 6 的规格文件。\n\nECMAScript 6 的规格，可以在 ECMA 国际标准组织的官方网站（www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。\n\n这个规格文件相当庞大，一共有 26 章，A4 打印的话，足足有 545 页。它的特点就是规定得非常细致，每一个语法行为、每一个函数的实现都做了详尽的清晰的描述。基本上，编译器作者只要把每一步翻译成代码就可以了。这很大程度上，保证了所有 ES6 实现都有一致的行为。\n\nECMAScript 6 规格的 26 章之中，第 1 章到第 3 章是对文件本身的介绍，与语言关系不大。第 4 章是对这门语言总体设计的描述，有兴趣的读者可以读一下。第 5 章到第 8 章是语言宏观层面的描述。第 5 章是规格的名词解释和写法的介绍，第 6 章介绍数据类型，第 7 章介绍语言内部用到的抽象操作，第 8 章介绍代码如何运行。第 9 章到第 26 章介绍具体的语法。\n\n对于一般用户来说，除了第 4 章，其他章节都涉及某一方面的细节，不用通读，只要在用到的时候，查阅相关章节即可。\n\n\n# 术语\n\nES6 规格使用了一些专门的术语，了解这些术语，可以帮助你读懂规格。本节介绍其中的几个。\n\n\n# 抽象操作\n\n所谓“抽象操作”（abstract operations）就是引擎的一些内部方法，外部不能调用。规格定义了一系列的抽象操作，规定了它们的行为，留给各种引擎自己去实现。\n\n举例来说，Boolean(value)的算法，第一步是这样的。\n\n>  1. Let b be ToBoolean(value).\n\n这里的ToBoolean就是一个抽象操作，是引擎内部求出布尔值的算法。\n\n许多函数的算法都会多次用到同样的步骤，所以 ES6 规格将它们抽出来，定义成“抽象操作”，方便描述。\n\n\n# Record 和 field\n\nES6 规格将键值对（key-value map）的数据结构称为 Record，其中的每一组键值对称为 field。这就是说，一个 Record 由多个 field 组成，而每个 field 都包含一个键名（key）和一个键值（value）。\n\n\n# [[Notation]]\n\nES6 规格大量使用[[Notation]]这种书写法，比如[[Value]]、[[Writable]]、[[Get]]、[[Set]]等等。它用来指代 field 的键名。\n\n举例来说，obj是一个 Record，它有一个Prototype属性。ES6 规格不会写obj.Prototype，而是写obj.[[Prototype]]。一般来说，使用[[Notation]]这种书写法的属性，都是对象的内部属性。\n\n所有的 JavaScript 函数都有一个内部属性[[Call]]，用来运行该函数。\n\nF.[[Call]](V, argumentsList)\n\n\n1\n\n\n上面代码中，F是一个函数对象，[[Call]]是它的内部方法，F.[[call]]()表示运行该函数，V表示[[Call]]运行时this的值，argumentsList则是调用时传入函数的参数。\n\n\n# Completion Record\n\n每一个语句都会返回一个 Completion Record，表示运行结果。每个 Completion Record 有一个[[Type]]属性，表示运行结果的类型。\n\n[[Type]]属性有五种可能的值。\n\n * normal\n * return\n * throw\n * break\n * continue\n\n如果[[Type]]的值是normal，就称为 normal completion，表示运行正常。其他的值，都称为 abrupt completion。其中，开发者只需要关注[[Type]]为throw的情况，即运行出错；break、continue、return这三个值都只出现在特定场景，可以不用考虑。\n\n\n# 抽象操作的标准流程\n\n抽象操作的运行流程，一般是下面这样。\n\n>  1. Let resultCompletionRecord be AbstractOp().\n>  2. If resultCompletionRecord is an abrupt completion, return resultCompletionRecord.\n>  3. Let result be resultCompletionRecord.[[Value]].\n>  4. return result.\n\n上面的第一步是调用抽象操作AbstractOp()，得到resultCompletionRecord，这是一个 Completion Record。第二步，如果这个 Record 属于 abrupt completion，就将resultCompletionRecord返回给用户。如果此处没有返回，就表示运行结果正常，所得的值存放在resultCompletionRecord.[[Value]]属性。第三步，将这个值记为result。第四步，将result返回给用户。\n\nES6 规格将这个标准流程，使用简写的方式表达。\n\n>  1. Let result be AbstractOp().\n>  2. ReturnIfAbrupt(result).\n>  3. return result.\n\n这个简写方式里面的ReturnIfAbrupt(result)，就代表了上面的第二步和第三步，即如果有报错，就返回错误，否则取出值。\n\n甚至还有进一步的简写格式。\n\n>  1. Let result be ? AbstractOp().\n>  2. return result.\n\n上面流程的?，就代表AbstractOp()可能会报错。一旦报错，就返回错误，否则取出值。\n\n除了?，ES 6 规格还使用另一个简写符号!。\n\n>  1. Let result be ! AbstractOp().\n>  2. return result.\n\n上面流程的!，代表AbstractOp()不会报错，返回的一定是 normal completion，总是可以取出值。\n\n\n# 相等运算符\n\n下面通过一些例子，介绍如何使用这份规格。\n\n相等运算符（==）是一个很让人头痛的运算符，它的语法行为多变，不符合直觉。这个小节就看看规格怎么规定它的行为。\n\n请看下面这个表达式，请问它的值是多少。\n\n0 == null\n\n\n1\n\n\n如果你不确定答案，或者想知道语言内部怎么处理，就可以去查看规格，7.2.12 小节是对相等运算符（==）的描述。\n\n规格对每一种语法行为的描述，都分成两部分：先是总体的行为描述，然后是实现的算法细节。相等运算符的总体描述，只有一句话。\n\n> “The comparison x == y, where x and y are values, produces true or false.”\n\n上面这句话的意思是，相等运算符用于比较两个值，返回true或false。\n\n下面是算法细节。\n\n>  1.  ReturnIfAbrupt(x).\n>  2.  ReturnIfAbrupt(y).\n>  3.  If Type(x) is the same as Type(y), then\n>      1. Return the result of performing Strict Equality Comparison x === y.\n>  4.  If x is null and y is undefined, return true.\n>  5.  If x is undefined and y is null, return true.\n>  6.  If Type(x) is Number and Type(y) is String, return the result of the comparison x == ToNumber(y).\n>  7.  If Type(x) is String and Type(y) is Number, return the result of the comparison ToNumber(x) == y.\n>  8.  If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.\n>  9.  If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).\n>  10. If Type(x) is either String, Number, or Symbol and Type(y) is Object, then return the result of the comparison x == ToPrimitive(y).\n>  11. If Type(x) is Object and Type(y) is either String, Number, or Symbol, then return the result of the comparison ToPrimitive(x) == y.\n>  12. Return false.\n\n上面这段算法，一共有 12 步，翻译如下。\n\n>  1.  如果x不是正常值（比如抛出一个错误），中断执行。\n>  2.  如果y不是正常值，中断执行。\n>  3.  如果Type(x)与Type(y)相同，执行严格相等运算x === y。\n>  4.  如果x是null，y是undefined，返回true。\n>  5.  如果x是undefined，y是null，返回true。\n>  6.  如果Type(x)是数值，Type(y)是字符串，返回x == ToNumber(y)的结果。\n>  7.  如果Type(x)是字符串，Type(y)是数值，返回ToNumber(x) == y的结果。\n>  8.  如果Type(x)是布尔值，返回ToNumber(x) == y的结果。\n>  9.  如果Type(y)是布尔值，返回x == ToNumber(y)的结果。\n>  10. 如果Type(x)是字符串或数值或Symbol值，Type(y)是对象，返回x == ToPrimitive(y)的结果。\n>  11. 如果Type(x)是对象，Type(y)是字符串或数值或Symbol值，返回ToPrimitive(x) == y的结果。\n>  12. 返回false。\n\n由于0的类型是数值，null的类型是 Null（这是规格4.3.13 小节的规定，是内部 Type 运算的结果，跟typeof运算符无关）。因此上面的前 11 步都得不到结果，要到第 12 步才能得到false。\n\n0 == null // false\n\n\n1\n\n\n\n# 数组的空位\n\n下面再看另一个例子。\n\nconst a1 = [undefined, undefined, undefined];\nconst a2 = [, , ,];\n\na1.length // 3\na2.length // 3\n\na1[0] // undefined\na2[0] // undefined\n\na1[0] === a2[0] // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，数组a1的成员是三个undefined，数组a2的成员是三个空位。这两个数组很相似，长度都是 3，每个位置的成员读取出来都是undefined。\n\n但是，它们实际上存在重大差异。\n\n0 in a1 // true\n0 in a2 // false\n\na1.hasOwnProperty(0) // true\na2.hasOwnProperty(0) // false\n\nObject.keys(a1) // ["0", "1", "2"]\nObject.keys(a2) // []\n\na1.map(n => 1) // [1, 1, 1]\na2.map(n => 1) // [, , ,]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码一共列出了四种运算，数组a1和a2的结果都不一样。前三种运算（in运算符、数组的hasOwnProperty方法、Object.keys方法）都说明，数组a2取不到属性名。最后一种运算（数组的map方法）说明，数组a2没有发生遍历。\n\n为什么a1与a2成员的行为不一致？数组的成员是undefined或空位，到底有什么不同？\n\n规格的12.2.5 小节《数组的初始化》给出了答案。\n\n> “Array elements may be elided at the beginning, middle or end of the element list. Whenever a comma in the element list is not preceded by an AssignmentExpression (i.e., a comma at the beginning or after another comma), the missing array element contributes to the length of the Array and increases the index of subsequent elements. Elided array elements are not defined. If an element is elided at the end of an array, that element does not contribute to the length of the Array.”\n\n翻译如下。\n\n> "数组成员可以省略。只要逗号前面没有任何表达式，数组的length属性就会加 1，并且相应增加其后成员的位置索引。被省略的成员不会被定义。如果被省略的成员是数组最后一个成员，则不会导致数组length属性增加。”\n\n上面的规格说得很清楚，数组的空位会反映在length属性，也就是说空位有自己的位置，但是这个位置的值是未定义，即这个值是不存在的。如果一定要读取，结果就是undefined（因为undefined在 JavaScript 语言中表示不存在）。\n\n这就解释了为什么in运算符、数组的hasOwnProperty方法、Object.keys方法，都取不到空位的属性名。因为这个属性名根本就不存在，规格里面没说要为空位分配属性名(位置索引），只说要为下一个元素的位置索引加 1。\n\n至于为什么数组的map方法会跳过空位，请看下一节。\n\n\n# 数组的 map 方法\n\n规格的22.1.3.15 小节定义了数组的map方法。该小节先是总体描述map方法的行为，里面没有提到数组空位。\n\n后面的算法描述是这样的。\n\n>  1.  Let O be ToObject(this value).\n>  2.  ReturnIfAbrupt(O).\n>  3.  Let len be ToLength(Get(O, "length")).\n>  4.  ReturnIfAbrupt(len).\n>  5.  If IsCallable(callbackfn) is false, throw a TypeError exception.\n>  6.  If thisArg was supplied, let T be thisArg; else let T be undefined.\n>  7.  Let A be ArraySpeciesCreate(O, len).\n>  8.  ReturnIfAbrupt(A).\n>  9.  Let k be 0.\n>  10. Repeat, while k < len\n>      1. Let Pk be ToString(k).\n>      2. Let kPresent be HasProperty(O, Pk).\n>      3. ReturnIfAbrupt(kPresent).\n>      4. If kPresent is true, then\n>         1. Let kValue be Get(O, Pk).\n>         2. ReturnIfAbrupt(kValue).\n>         3. Let mappedValue be Call(callbackfn, T, «kValue, k, O»).\n>         4. ReturnIfAbrupt(mappedValue).\n>         5. Let status be CreateDataPropertyOrThrow (A, Pk, mappedValue).\n>         6. ReturnIfAbrupt(status).\n>      5. Increase k by 1.\n>  11. Return A.\n\n翻译如下。\n\n>  1.  得到当前数组的this对象\n>  2.  如果报错就返回\n>  3.  求出当前数组的length属性\n>  4.  如果报错就返回\n>  5.  如果 map 方法的参数callbackfn不可执行，就报错\n>  6.  如果 map 方法的参数之中，指定了this，就让T等于该参数，否则T为undefined\n>  7.  生成一个新的数组A，跟当前数组的length属性保持一致\n>  8.  如果报错就返回\n>  9.  设定k等于 0\n>  10. 只要k小于当前数组的length属性，就重复下面步骤\n>      1. 设定Pk等于ToString(k)，即将K转为字符串\n>      2. 设定kPresent等于HasProperty(O, Pk)，即求当前数组有没有指定属性\n>      3. 如果报错就返回\n>      4. 如果kPresent等于true，则进行下面步骤\n>         1. 设定kValue等于Get(O, Pk)，取出当前数组的指定属性\n>         2. 如果报错就返回\n>         3. 设定mappedValue等于Call(callbackfn, T, «kValue, k, O»)，即执行回调函数\n>         4. 如果报错就返回\n>         5. 设定status等于CreateDataPropertyOrThrow (A, Pk, mappedValue)，即将回调函数的值放入A数组的指定位置\n>         6. 如果报错就返回\n>      5. k增加 1\n>  11. 返回A\n\n仔细查看上面的算法，可以发现，当处理一个全是空位的数组时，前面步骤都没有问题。进入第 10 步中第 2 步时，kPresent会报错，因为空位对应的属性名，对于数组来说是不存在的，因此就会返回，不会进行后面的步骤。\n\nconst arr = [, , ,];\narr.map(n => {\n  console.log(n);\n  return 1;\n}) // [, , ,]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，arr是一个全是空位的数组，map方法遍历成员时，发现是空位，就直接跳过，不会进入回调函数。因此，回调函数里面的console.log语句根本不会执行，整个map方法返回一个全是空位的新数组。\n\nV8 引擎对map方法的实现如下，可以看到跟规格的算法描述完全一致。\n\nfunction ArrayMap(f, receiver) {\n  CHECK_OBJECT_COERCIBLE(this, "Array.prototype.map");\n\n  // Pull out the length so that modifications to the length in the\n  // loop will not affect the looping and side effects are visible.\n  var array = TO_OBJECT(this);\n  var length = TO_LENGTH_OR_UINT32(array.length);\n  return InnerArrayMap(f, receiver, array, length);\n}\n\nfunction InnerArrayMap(f, receiver, array, length) {\n  if (!IS_CALLABLE(f)) throw MakeTypeError(kCalledNonCallable, f);\n\n  var accumulator = new InternalArray(length);\n  var is_array = IS_ARRAY(array);\n  var stepping = DEBUG_IS_STEPPING(f);\n  for (var i = 0; i < length; i++) {\n    if (HAS_INDEX(array, i, is_array)) {\n      var element = array[i];\n      // Prepare break slots for debugger step in.\n      if (stepping) %DebugPrepareStepInIfStepping(f);\n      accumulator[i] = %_Call(f, receiver, element, i, array);\n    }\n  }\n  var result = new GlobalArray();\n  %MoveArrayContents(accumulator, result);\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n',normalizedContent:'# 读懂 ecmascript 规格\n\n\n# 概述\n\n规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。\n\n一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。 这对 javascript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。\n\n本章介绍如何读懂 ecmascript 6 的规格文件。\n\necmascript 6 的规格，可以在 ecma 国际标准组织的官方网站（www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。\n\n这个规格文件相当庞大，一共有 26 章，a4 打印的话，足足有 545 页。它的特点就是规定得非常细致，每一个语法行为、每一个函数的实现都做了详尽的清晰的描述。基本上，编译器作者只要把每一步翻译成代码就可以了。这很大程度上，保证了所有 es6 实现都有一致的行为。\n\necmascript 6 规格的 26 章之中，第 1 章到第 3 章是对文件本身的介绍，与语言关系不大。第 4 章是对这门语言总体设计的描述，有兴趣的读者可以读一下。第 5 章到第 8 章是语言宏观层面的描述。第 5 章是规格的名词解释和写法的介绍，第 6 章介绍数据类型，第 7 章介绍语言内部用到的抽象操作，第 8 章介绍代码如何运行。第 9 章到第 26 章介绍具体的语法。\n\n对于一般用户来说，除了第 4 章，其他章节都涉及某一方面的细节，不用通读，只要在用到的时候，查阅相关章节即可。\n\n\n# 术语\n\nes6 规格使用了一些专门的术语，了解这些术语，可以帮助你读懂规格。本节介绍其中的几个。\n\n\n# 抽象操作\n\n所谓“抽象操作”（abstract operations）就是引擎的一些内部方法，外部不能调用。规格定义了一系列的抽象操作，规定了它们的行为，留给各种引擎自己去实现。\n\n举例来说，boolean(value)的算法，第一步是这样的。\n\n>  1. let b be toboolean(value).\n\n这里的toboolean就是一个抽象操作，是引擎内部求出布尔值的算法。\n\n许多函数的算法都会多次用到同样的步骤，所以 es6 规格将它们抽出来，定义成“抽象操作”，方便描述。\n\n\n# record 和 field\n\nes6 规格将键值对（key-value map）的数据结构称为 record，其中的每一组键值对称为 field。这就是说，一个 record 由多个 field 组成，而每个 field 都包含一个键名（key）和一个键值（value）。\n\n\n# [[notation]]\n\nes6 规格大量使用[[notation]]这种书写法，比如[[value]]、[[writable]]、[[get]]、[[set]]等等。它用来指代 field 的键名。\n\n举例来说，obj是一个 record，它有一个prototype属性。es6 规格不会写obj.prototype，而是写obj.[[prototype]]。一般来说，使用[[notation]]这种书写法的属性，都是对象的内部属性。\n\n所有的 javascript 函数都有一个内部属性[[call]]，用来运行该函数。\n\nf.[[call]](v, argumentslist)\n\n\n1\n\n\n上面代码中，f是一个函数对象，[[call]]是它的内部方法，f.[[call]]()表示运行该函数，v表示[[call]]运行时this的值，argumentslist则是调用时传入函数的参数。\n\n\n# completion record\n\n每一个语句都会返回一个 completion record，表示运行结果。每个 completion record 有一个[[type]]属性，表示运行结果的类型。\n\n[[type]]属性有五种可能的值。\n\n * normal\n * return\n * throw\n * break\n * continue\n\n如果[[type]]的值是normal，就称为 normal completion，表示运行正常。其他的值，都称为 abrupt completion。其中，开发者只需要关注[[type]]为throw的情况，即运行出错；break、continue、return这三个值都只出现在特定场景，可以不用考虑。\n\n\n# 抽象操作的标准流程\n\n抽象操作的运行流程，一般是下面这样。\n\n>  1. let resultcompletionrecord be abstractop().\n>  2. if resultcompletionrecord is an abrupt completion, return resultcompletionrecord.\n>  3. let result be resultcompletionrecord.[[value]].\n>  4. return result.\n\n上面的第一步是调用抽象操作abstractop()，得到resultcompletionrecord，这是一个 completion record。第二步，如果这个 record 属于 abrupt completion，就将resultcompletionrecord返回给用户。如果此处没有返回，就表示运行结果正常，所得的值存放在resultcompletionrecord.[[value]]属性。第三步，将这个值记为result。第四步，将result返回给用户。\n\nes6 规格将这个标准流程，使用简写的方式表达。\n\n>  1. let result be abstractop().\n>  2. returnifabrupt(result).\n>  3. return result.\n\n这个简写方式里面的returnifabrupt(result)，就代表了上面的第二步和第三步，即如果有报错，就返回错误，否则取出值。\n\n甚至还有进一步的简写格式。\n\n>  1. let result be ? abstractop().\n>  2. return result.\n\n上面流程的?，就代表abstractop()可能会报错。一旦报错，就返回错误，否则取出值。\n\n除了?，es 6 规格还使用另一个简写符号!。\n\n>  1. let result be ! abstractop().\n>  2. return result.\n\n上面流程的!，代表abstractop()不会报错，返回的一定是 normal completion，总是可以取出值。\n\n\n# 相等运算符\n\n下面通过一些例子，介绍如何使用这份规格。\n\n相等运算符（==）是一个很让人头痛的运算符，它的语法行为多变，不符合直觉。这个小节就看看规格怎么规定它的行为。\n\n请看下面这个表达式，请问它的值是多少。\n\n0 == null\n\n\n1\n\n\n如果你不确定答案，或者想知道语言内部怎么处理，就可以去查看规格，7.2.12 小节是对相等运算符（==）的描述。\n\n规格对每一种语法行为的描述，都分成两部分：先是总体的行为描述，然后是实现的算法细节。相等运算符的总体描述，只有一句话。\n\n> “the comparison x == y, where x and y are values, produces true or false.”\n\n上面这句话的意思是，相等运算符用于比较两个值，返回true或false。\n\n下面是算法细节。\n\n>  1.  returnifabrupt(x).\n>  2.  returnifabrupt(y).\n>  3.  if type(x) is the same as type(y), then\n>      1. return the result of performing strict equality comparison x === y.\n>  4.  if x is null and y is undefined, return true.\n>  5.  if x is undefined and y is null, return true.\n>  6.  if type(x) is number and type(y) is string, return the result of the comparison x == tonumber(y).\n>  7.  if type(x) is string and type(y) is number, return the result of the comparison tonumber(x) == y.\n>  8.  if type(x) is boolean, return the result of the comparison tonumber(x) == y.\n>  9.  if type(y) is boolean, return the result of the comparison x == tonumber(y).\n>  10. if type(x) is either string, number, or symbol and type(y) is object, then return the result of the comparison x == toprimitive(y).\n>  11. if type(x) is object and type(y) is either string, number, or symbol, then return the result of the comparison toprimitive(x) == y.\n>  12. return false.\n\n上面这段算法，一共有 12 步，翻译如下。\n\n>  1.  如果x不是正常值（比如抛出一个错误），中断执行。\n>  2.  如果y不是正常值，中断执行。\n>  3.  如果type(x)与type(y)相同，执行严格相等运算x === y。\n>  4.  如果x是null，y是undefined，返回true。\n>  5.  如果x是undefined，y是null，返回true。\n>  6.  如果type(x)是数值，type(y)是字符串，返回x == tonumber(y)的结果。\n>  7.  如果type(x)是字符串，type(y)是数值，返回tonumber(x) == y的结果。\n>  8.  如果type(x)是布尔值，返回tonumber(x) == y的结果。\n>  9.  如果type(y)是布尔值，返回x == tonumber(y)的结果。\n>  10. 如果type(x)是字符串或数值或symbol值，type(y)是对象，返回x == toprimitive(y)的结果。\n>  11. 如果type(x)是对象，type(y)是字符串或数值或symbol值，返回toprimitive(x) == y的结果。\n>  12. 返回false。\n\n由于0的类型是数值，null的类型是 null（这是规格4.3.13 小节的规定，是内部 type 运算的结果，跟typeof运算符无关）。因此上面的前 11 步都得不到结果，要到第 12 步才能得到false。\n\n0 == null // false\n\n\n1\n\n\n\n# 数组的空位\n\n下面再看另一个例子。\n\nconst a1 = [undefined, undefined, undefined];\nconst a2 = [, , ,];\n\na1.length // 3\na2.length // 3\n\na1[0] // undefined\na2[0] // undefined\n\na1[0] === a2[0] // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，数组a1的成员是三个undefined，数组a2的成员是三个空位。这两个数组很相似，长度都是 3，每个位置的成员读取出来都是undefined。\n\n但是，它们实际上存在重大差异。\n\n0 in a1 // true\n0 in a2 // false\n\na1.hasownproperty(0) // true\na2.hasownproperty(0) // false\n\nobject.keys(a1) // ["0", "1", "2"]\nobject.keys(a2) // []\n\na1.map(n => 1) // [1, 1, 1]\na2.map(n => 1) // [, , ,]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码一共列出了四种运算，数组a1和a2的结果都不一样。前三种运算（in运算符、数组的hasownproperty方法、object.keys方法）都说明，数组a2取不到属性名。最后一种运算（数组的map方法）说明，数组a2没有发生遍历。\n\n为什么a1与a2成员的行为不一致？数组的成员是undefined或空位，到底有什么不同？\n\n规格的12.2.5 小节《数组的初始化》给出了答案。\n\n> “array elements may be elided at the beginning, middle or end of the element list. whenever a comma in the element list is not preceded by an assignmentexpression (i.e., a comma at the beginning or after another comma), the missing array element contributes to the length of the array and increases the index of subsequent elements. elided array elements are not defined. if an element is elided at the end of an array, that element does not contribute to the length of the array.”\n\n翻译如下。\n\n> "数组成员可以省略。只要逗号前面没有任何表达式，数组的length属性就会加 1，并且相应增加其后成员的位置索引。被省略的成员不会被定义。如果被省略的成员是数组最后一个成员，则不会导致数组length属性增加。”\n\n上面的规格说得很清楚，数组的空位会反映在length属性，也就是说空位有自己的位置，但是这个位置的值是未定义，即这个值是不存在的。如果一定要读取，结果就是undefined（因为undefined在 javascript 语言中表示不存在）。\n\n这就解释了为什么in运算符、数组的hasownproperty方法、object.keys方法，都取不到空位的属性名。因为这个属性名根本就不存在，规格里面没说要为空位分配属性名(位置索引），只说要为下一个元素的位置索引加 1。\n\n至于为什么数组的map方法会跳过空位，请看下一节。\n\n\n# 数组的 map 方法\n\n规格的22.1.3.15 小节定义了数组的map方法。该小节先是总体描述map方法的行为，里面没有提到数组空位。\n\n后面的算法描述是这样的。\n\n>  1.  let o be toobject(this value).\n>  2.  returnifabrupt(o).\n>  3.  let len be tolength(get(o, "length")).\n>  4.  returnifabrupt(len).\n>  5.  if iscallable(callbackfn) is false, throw a typeerror exception.\n>  6.  if thisarg was supplied, let t be thisarg; else let t be undefined.\n>  7.  let a be arrayspeciescreate(o, len).\n>  8.  returnifabrupt(a).\n>  9.  let k be 0.\n>  10. repeat, while k < len\n>      1. let pk be tostring(k).\n>      2. let kpresent be hasproperty(o, pk).\n>      3. returnifabrupt(kpresent).\n>      4. if kpresent is true, then\n>         1. let kvalue be get(o, pk).\n>         2. returnifabrupt(kvalue).\n>         3. let mappedvalue be call(callbackfn, t, «kvalue, k, o»).\n>         4. returnifabrupt(mappedvalue).\n>         5. let status be createdatapropertyorthrow (a, pk, mappedvalue).\n>         6. returnifabrupt(status).\n>      5. increase k by 1.\n>  11. return a.\n\n翻译如下。\n\n>  1.  得到当前数组的this对象\n>  2.  如果报错就返回\n>  3.  求出当前数组的length属性\n>  4.  如果报错就返回\n>  5.  如果 map 方法的参数callbackfn不可执行，就报错\n>  6.  如果 map 方法的参数之中，指定了this，就让t等于该参数，否则t为undefined\n>  7.  生成一个新的数组a，跟当前数组的length属性保持一致\n>  8.  如果报错就返回\n>  9.  设定k等于 0\n>  10. 只要k小于当前数组的length属性，就重复下面步骤\n>      1. 设定pk等于tostring(k)，即将k转为字符串\n>      2. 设定kpresent等于hasproperty(o, pk)，即求当前数组有没有指定属性\n>      3. 如果报错就返回\n>      4. 如果kpresent等于true，则进行下面步骤\n>         1. 设定kvalue等于get(o, pk)，取出当前数组的指定属性\n>         2. 如果报错就返回\n>         3. 设定mappedvalue等于call(callbackfn, t, «kvalue, k, o»)，即执行回调函数\n>         4. 如果报错就返回\n>         5. 设定status等于createdatapropertyorthrow (a, pk, mappedvalue)，即将回调函数的值放入a数组的指定位置\n>         6. 如果报错就返回\n>      5. k增加 1\n>  11. 返回a\n\n仔细查看上面的算法，可以发现，当处理一个全是空位的数组时，前面步骤都没有问题。进入第 10 步中第 2 步时，kpresent会报错，因为空位对应的属性名，对于数组来说是不存在的，因此就会返回，不会进行后面的步骤。\n\nconst arr = [, , ,];\narr.map(n => {\n  console.log(n);\n  return 1;\n}) // [, , ,]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，arr是一个全是空位的数组，map方法遍历成员时，发现是空位，就直接跳过，不会进入回调函数。因此，回调函数里面的console.log语句根本不会执行，整个map方法返回一个全是空位的新数组。\n\nv8 引擎对map方法的实现如下，可以看到跟规格的算法描述完全一致。\n\nfunction arraymap(f, receiver) {\n  check_object_coercible(this, "array.prototype.map");\n\n  // pull out the length so that modifications to the length in the\n  // loop will not affect the looping and side effects are visible.\n  var array = to_object(this);\n  var length = to_length_or_uint32(array.length);\n  return innerarraymap(f, receiver, array, length);\n}\n\nfunction innerarraymap(f, receiver, array, length) {\n  if (!is_callable(f)) throw maketypeerror(kcallednoncallable, f);\n\n  var accumulator = new internalarray(length);\n  var is_array = is_array(array);\n  var stepping = debug_is_stepping(f);\n  for (var i = 0; i < length; i++) {\n    if (has_index(array, i, is_array)) {\n      var element = array[i];\n      // prepare break slots for debugger step in.\n      if (stepping) %debugpreparestepinifstepping(f);\n      accumulator[i] = %_call(f, receiver, element, i, array);\n    }\n  }\n  var result = new globalarray();\n  %movearraycontents(accumulator, result);\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"函数式编程",frontmatter:{title:"函数式编程",date:"2020-02-09T16:00:30.000Z",permalink:"/pages/1cf50330655efc69",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/31.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html",relativePath:"《ES6 教程》笔记/31.函数式编程.md",key:"v-0bfabf3c",path:"/pages/1cf50330655efc69/",headers:[{level:2,title:"柯里化",slug:"柯里化",normalizedTitle:"柯里化",charIndex:206},{level:2,title:"函数合成",slug:"函数合成",normalizedTitle:"函数合成",charIndex:608},{level:2,title:"参数倒置",slug:"参数倒置",normalizedTitle:"参数倒置",charIndex:865},{level:2,title:"执行边界",slug:"执行边界",normalizedTitle:"执行边界",charIndex:1317},{level:2,title:"队列操作",slug:"队列操作",normalizedTitle:"队列操作",charIndex:1852},{level:2,title:"合并操作",slug:"合并操作",normalizedTitle:"合并操作",charIndex:2317},{level:2,title:"配对操作",slug:"配对操作",normalizedTitle:"配对操作",charIndex:2660},{level:2,title:"参考链接",slug:"参考链接",normalizedTitle:"参考链接",charIndex:3461}],excerpt:'<h1 id="函数式编程"><a class="header-anchor" href="#函数式编程">#</a> 函数式编程</h1>\n<p>JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。</p>\n',headersStr:"柯里化 函数合成 参数倒置 执行边界 队列操作 合并操作 配对操作 参考链接",content:"# 函数式编程\n\nJavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。 ES6 的种种新增功能，使得函数式编程变得更方便、更强大。本章介绍 ES6 如何进行函数式编程。\n\n\n# 柯里化\n\n柯里化（currying）指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数（unary）。\n\nfunction add (a, b) {\n  return a + b;\n}\n\nadd(1, 1) // 2\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，函数add接受两个参数a和b。\n\n柯里化就是将上面的函数拆分成两个函数，每个函数都只接受一个参数。\n\nfunction add (a) {\n  return function (b) {\n    return a + b;\n  }\n}\n// 或者采用箭头函数写法\nconst add = x => y => x + y;\n\nconst f = add(1);\nf(1) // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，函数add只接受一个参数a，返回一个函数f。函数f也只接受一个参数b。\n\n\n# 函数合成\n\n函数合成（function composition）指的是，将多个函数合成一个函数。\n\nconst compose = f => g => x => f(g(x));\n\nconst f = compose (x => x * 4) (x => x + 3);\nf(2) // 20\n\n\n1\n2\n3\n4\n\n\n上面代码中，compose就是一个函数合成器，用于将两个函数合成一个函数。\n\n可以发现，柯里化与函数合成有着密切的联系。前者用于将一个函数拆成多个函数，后者用于将多个函数合并成一个函数。\n\n\n# 参数倒置\n\n参数倒置（flip）指的是改变函数前两个参数的顺序。\n\nvar divide = (a, b) => a / b;\nvar flip = f.flip(divide);\n\nflip(10, 5) // 0.5\nflip(1, 10) // 10\n\nvar three = (a, b, c) => [a, b, c];\nvar flip = f.flip(three);\nflip(1, 2, 3); // => [2, 1, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，如果按照正常的参数顺序，10 除以 5 等于 2。但是，参数倒置以后得到的新函数，结果就是 5 除以 10，结果得到 0.5。如果原函数有 3 个参数，则只颠倒前两个参数的位置。\n\n参数倒置的代码非常简单。\n\nlet f = {};\nf.flip =\n  fn =>\n    (a, b, ...args) => fn(b, a, ...args.reverse());\n\n\n1\n2\n3\n4\n\n\n\n# 执行边界\n\n执行边界（until）指的是函数执行到满足条件为止。\n\nlet condition = x => x > 100;\nlet inc = x => x + 1;\nlet until = f.until(condition, inc);\n\nuntil(0) // 101\n\ncondition = x => x === 5;\nuntil = f.until(condition, inc);\n\nuntil(3) // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，第一段的条件是执行到x大于 100 为止，所以x初值为 0 时，会一直执行到 101。第二段的条件是执行到等于 5 为止，所以x最后的值是 5。\n\n执行边界的实现如下。\n\nlet f = {};\nf.until = (condition, f) =>\n  (...args) => {\n    var r = f.apply(null, args);\n    return condition(r) ? r : f.until(condition, f)(r);\n  };\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的关键就是，如果满足条件就返回结果，否则不断递归执行。\n\n\n# 队列操作\n\n队列（list）操作包括以下几种。\n\n * head： 取出队列的第一个非空成员。\n * last： 取出有限队列的最后一个非空成员。\n * tail： 取出除了“队列头”以外的其他非空成员。\n * init： 取出除了“队列尾”以外的其他非空成员。\n\n下面是例子。\n\nf.head(5, 27, 3, 1) // 5\nf.last(5, 27, 3, 1) // 1\nf.tail(5, 27, 3, 1) // [27, 3, 1]\nf.init(5, 27, 3, 1) // [5, 27, 3]\n\n\n1\n2\n3\n4\n\n\n这些方法的实现如下。\n\nlet f = {};\nf.head = (...xs) => xs[0];\nf.last = (...xs) => xs.slice(-1);\nf.tail = (...xs) => Array.prototype.slice.call(xs, 1);\nf.init = (...xs) => xs.slice(0, -1);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 合并操作\n\n合并操作分为concat和concatMap两种。前者就是将多个数组合成一个，后者则是先处理一下参数，然后再将处理结果合成一个数组。\n\nf.concat([5], [27], [3]) // [5, 27, 3]\nf.concatMap(x => 'hi ' + x, 1, [[2]], 3) // ['hi 1', 'hi 2', 'hi 3']\n\n\n1\n2\n\n\n这两种方法的实现代码如下。\n\nlet f = {};\nf.concat =\n  (...xs) => xs.reduce((a, b) => a.concat(b));\nf.concatMap =\n  (f, ...xs) => f.concat(xs.map(f));\n\n\n1\n2\n3\n4\n5\n\n\n\n# 配对操作\n\n配对操作分为zip和zipWith两种方法。zip操作将两个队列的成员，一一配对，合成一个新的队列。如果两个队列不等长，较长的那个队列多出来的成员，会被忽略。zipWith操作的第一个参数是一个函数，然后会将后面的队列成员一一配对，输入该函数，返回值就组成一个新的队列。\n\n下面是例子。\n\nlet a = [0, 1, 2];\nlet b = [3, 4, 5];\nlet c = [6, 7, 8];\n\nf.zip(a, b) // [[0, 3], [1, 4], [2, 5]]\nf.zipWith((a, b) => a + b, a, b, c) // [9, 12, 15]\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，zipWith方法的第一个参数是一个求和函数，它将后面三个队列的成员，一一配对进行相加。\n\n这两个方法的实现如下。\n\nlet f = {};\n\nf.zip = (...xs) => {\n  let r = [];\n  let nple = [];\n  let length = Math.min.apply(null, xs.map(x => x.length));\n\n  for (var i = 0; i < length; i++) {\n    xs.forEach(\n      x => nple.push(x[i])\n    );\n\n    r.push(nple);\n    nple = [];\n  }\n\n  return r;\n};\n\nf.zipWith = (op, ...xs) =>\n  f.zip.apply(null, xs).map(\n    (x) => x.reduce(op)\n  );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 参考链接\n\n * Mateo Gianolio, Haskell in ES6: Part 1",normalizedContent:"# 函数式编程\n\njavascript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 javascript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，javascript 是有史以来第一种被大规模采用的函数式编程语言。 es6 的种种新增功能，使得函数式编程变得更方便、更强大。本章介绍 es6 如何进行函数式编程。\n\n\n# 柯里化\n\n柯里化（currying）指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数（unary）。\n\nfunction add (a, b) {\n  return a + b;\n}\n\nadd(1, 1) // 2\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，函数add接受两个参数a和b。\n\n柯里化就是将上面的函数拆分成两个函数，每个函数都只接受一个参数。\n\nfunction add (a) {\n  return function (b) {\n    return a + b;\n  }\n}\n// 或者采用箭头函数写法\nconst add = x => y => x + y;\n\nconst f = add(1);\nf(1) // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，函数add只接受一个参数a，返回一个函数f。函数f也只接受一个参数b。\n\n\n# 函数合成\n\n函数合成（function composition）指的是，将多个函数合成一个函数。\n\nconst compose = f => g => x => f(g(x));\n\nconst f = compose (x => x * 4) (x => x + 3);\nf(2) // 20\n\n\n1\n2\n3\n4\n\n\n上面代码中，compose就是一个函数合成器，用于将两个函数合成一个函数。\n\n可以发现，柯里化与函数合成有着密切的联系。前者用于将一个函数拆成多个函数，后者用于将多个函数合并成一个函数。\n\n\n# 参数倒置\n\n参数倒置（flip）指的是改变函数前两个参数的顺序。\n\nvar divide = (a, b) => a / b;\nvar flip = f.flip(divide);\n\nflip(10, 5) // 0.5\nflip(1, 10) // 10\n\nvar three = (a, b, c) => [a, b, c];\nvar flip = f.flip(three);\nflip(1, 2, 3); // => [2, 1, 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，如果按照正常的参数顺序，10 除以 5 等于 2。但是，参数倒置以后得到的新函数，结果就是 5 除以 10，结果得到 0.5。如果原函数有 3 个参数，则只颠倒前两个参数的位置。\n\n参数倒置的代码非常简单。\n\nlet f = {};\nf.flip =\n  fn =>\n    (a, b, ...args) => fn(b, a, ...args.reverse());\n\n\n1\n2\n3\n4\n\n\n\n# 执行边界\n\n执行边界（until）指的是函数执行到满足条件为止。\n\nlet condition = x => x > 100;\nlet inc = x => x + 1;\nlet until = f.until(condition, inc);\n\nuntil(0) // 101\n\ncondition = x => x === 5;\nuntil = f.until(condition, inc);\n\nuntil(3) // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，第一段的条件是执行到x大于 100 为止，所以x初值为 0 时，会一直执行到 101。第二段的条件是执行到等于 5 为止，所以x最后的值是 5。\n\n执行边界的实现如下。\n\nlet f = {};\nf.until = (condition, f) =>\n  (...args) => {\n    var r = f.apply(null, args);\n    return condition(r) ? r : f.until(condition, f)(r);\n  };\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码的关键就是，如果满足条件就返回结果，否则不断递归执行。\n\n\n# 队列操作\n\n队列（list）操作包括以下几种。\n\n * head： 取出队列的第一个非空成员。\n * last： 取出有限队列的最后一个非空成员。\n * tail： 取出除了“队列头”以外的其他非空成员。\n * init： 取出除了“队列尾”以外的其他非空成员。\n\n下面是例子。\n\nf.head(5, 27, 3, 1) // 5\nf.last(5, 27, 3, 1) // 1\nf.tail(5, 27, 3, 1) // [27, 3, 1]\nf.init(5, 27, 3, 1) // [5, 27, 3]\n\n\n1\n2\n3\n4\n\n\n这些方法的实现如下。\n\nlet f = {};\nf.head = (...xs) => xs[0];\nf.last = (...xs) => xs.slice(-1);\nf.tail = (...xs) => array.prototype.slice.call(xs, 1);\nf.init = (...xs) => xs.slice(0, -1);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 合并操作\n\n合并操作分为concat和concatmap两种。前者就是将多个数组合成一个，后者则是先处理一下参数，然后再将处理结果合成一个数组。\n\nf.concat([5], [27], [3]) // [5, 27, 3]\nf.concatmap(x => 'hi ' + x, 1, [[2]], 3) // ['hi 1', 'hi 2', 'hi 3']\n\n\n1\n2\n\n\n这两种方法的实现代码如下。\n\nlet f = {};\nf.concat =\n  (...xs) => xs.reduce((a, b) => a.concat(b));\nf.concatmap =\n  (f, ...xs) => f.concat(xs.map(f));\n\n\n1\n2\n3\n4\n5\n\n\n\n# 配对操作\n\n配对操作分为zip和zipwith两种方法。zip操作将两个队列的成员，一一配对，合成一个新的队列。如果两个队列不等长，较长的那个队列多出来的成员，会被忽略。zipwith操作的第一个参数是一个函数，然后会将后面的队列成员一一配对，输入该函数，返回值就组成一个新的队列。\n\n下面是例子。\n\nlet a = [0, 1, 2];\nlet b = [3, 4, 5];\nlet c = [6, 7, 8];\n\nf.zip(a, b) // [[0, 3], [1, 4], [2, 5]]\nf.zipwith((a, b) => a + b, a, b, c) // [9, 12, 15]\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，zipwith方法的第一个参数是一个求和函数，它将后面三个队列的成员，一一配对进行相加。\n\n这两个方法的实现如下。\n\nlet f = {};\n\nf.zip = (...xs) => {\n  let r = [];\n  let nple = [];\n  let length = math.min.apply(null, xs.map(x => x.length));\n\n  for (var i = 0; i < length; i++) {\n    xs.foreach(\n      x => nple.push(x[i])\n    );\n\n    r.push(nple);\n    nple = [];\n  }\n\n  return r;\n};\n\nf.zipwith = (op, ...xs) =>\n  f.zip.apply(null, xs).map(\n    (x) => x.reduce(op)\n  );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 参考链接\n\n * mateo gianolio, haskell in es6: part 1",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Mixin",frontmatter:{title:"Mixin",date:"2020-02-09T16:00:30.000Z",permalink:"/pages/6a8e2dc558da1b39",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/32.Mixin.html",relativePath:"《ES6 教程》笔记/32.Mixin.md",key:"v-8b56fb8c",path:"/pages/6a8e2dc558da1b39/",headers:[{level:2,title:"含义",slug:"含义",normalizedTitle:"含义",charIndex:835},{level:2,title:"Trait",slug:"trait",normalizedTitle:"trait",charIndex:2127}],excerpt:'<h1 id="mixin"><a class="header-anchor" href="#mixin">#</a> Mixin</h1>\n<p>JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank" rel="noopener noreferrer">网状结构<OutboundLink/></a>。</p>\n',headersStr:"含义 Trait",content:"# Mixin\n\nJavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的网状结构。 但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。\n\n各种单一继承的编程语言，有不同的多重继承解决方案。比如，Java 语言也是子类只能继承一个父类，但是还允许继承多个界面（interface），这样就间接实现了多重继承。Interface 与父类一样，也是一个类，只不过它只定义接口（method signature），不定义实现，因此又被称为“抽象类”。凡是继承于 Interface 的方法，都必须自己定义实现，否则就会报错。这样就避免了多重继承的最大问题：多个父类的同名方法的碰撞（naming collision）。\n\nJavaScript 语言没有采用 Interface 的方案，而是通过代理（delegation）实现了从其他类引入方法。\n\nvar Enumerable_first = function () {\n  this.first = function () {\n    return this[0];\n  };\n};\n\nvar list = [\"foo\", \"bar\", \"baz\"];\nEnumerable_first.call(list); // explicit delegation\nlist.first() // \"foo\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，list是一个数组，本身并没有first方法。通过call方法，可以把Enumerable_first里面的方法，绑定到list，从而list就具有first方法。这就叫做“代理”（delegation），list对象代理了Enumerable_first的first方法。\n\n\n# 含义\n\nMixin 这个名字来自于冰淇淋，在基本口味的冰淇淋上面混入其他口味，这就叫做 Mix-in。\n\n它允许向一个类里面注入一些代码，使得一个类的功能能够“混入”另一个类。实质上是多重继承的一种解决方案，但是避免了多重继承的复杂性，而且有利于代码复用。\n\nMixin 就是一个正常的类，不仅定义了接口，还定义了接口的实现。\n\n子类通过在this对象上面绑定方法，达到多重继承的目的。\n\n很多库提供了 Mixin 功能。下面以 Lodash 为例。\n\nfunction vowels(string) {\n  return /[aeiou]/i.test(this.value);\n}\n\nvar obj = { value: 'hello' };\n_.mixin(obj, {vowels: vowels})\nobj.vowels() // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码通过 Lodash 库的_.mixin方法，让obj对象继承了vowels方法。\n\nUnderscore 的类似方法是_.extend。\n\nvar Person = function (fName, lName) {\n  this.firstName = fName;\n  this.lastName = lName;\n}\n\nvar sam = new Person('Sam', 'Lowry');\n\nvar NameMixin = {\n  fullName: function () {\n    return this.firstName + ' ' + this.lastName;\n  },\n  rename: function(first, last) {\n    this.firstName = first;\n    this.lastName = last;\n    return this;\n  }\n};\n_.extend(Person.prototype, NameMixin);\nsam.rename('Samwise', 'Gamgee');\nsam.fullName() // \"Samwise Gamgee\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n上面代码通过_.extend方法，在sam对象上面（准确说是它的原型对象Person.prototype上面），混入了NameMixin类。\n\nextend方法的实现非常简单。\n\nfunction extend(destination, source) {\n  for (var k in source) {\n    if (source.hasOwnProperty(k)) {\n      destination[k] = source[k];\n    }\n  }\n  return destination;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码将source对象的所有方法，添加到destination对象。\n\n\n# Trait\n\nTrait 是另外一种多重继承的解决方案。它与 Mixin 很相似，但是有一些细微的差别。\n\n * Mixin 可以包含状态（state），Trait 不包含，即 Trait 里面的方法都是互不相干，可以线性包含的。比如，Trait1包含方法A和B，Trait2继承了Trait1，同时还包含一个自己的方法C，实际上就等同于直接包含方法A、B、C。\n * 对于同名方法的碰撞，Mixin 包含了解决规则，Trait 则是报错。",normalizedContent:"# mixin\n\njavascript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的网状结构。 但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。\n\n各种单一继承的编程语言，有不同的多重继承解决方案。比如，java 语言也是子类只能继承一个父类，但是还允许继承多个界面（interface），这样就间接实现了多重继承。interface 与父类一样，也是一个类，只不过它只定义接口（method signature），不定义实现，因此又被称为“抽象类”。凡是继承于 interface 的方法，都必须自己定义实现，否则就会报错。这样就避免了多重继承的最大问题：多个父类的同名方法的碰撞（naming collision）。\n\njavascript 语言没有采用 interface 的方案，而是通过代理（delegation）实现了从其他类引入方法。\n\nvar enumerable_first = function () {\n  this.first = function () {\n    return this[0];\n  };\n};\n\nvar list = [\"foo\", \"bar\", \"baz\"];\nenumerable_first.call(list); // explicit delegation\nlist.first() // \"foo\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，list是一个数组，本身并没有first方法。通过call方法，可以把enumerable_first里面的方法，绑定到list，从而list就具有first方法。这就叫做“代理”（delegation），list对象代理了enumerable_first的first方法。\n\n\n# 含义\n\nmixin 这个名字来自于冰淇淋，在基本口味的冰淇淋上面混入其他口味，这就叫做 mix-in。\n\n它允许向一个类里面注入一些代码，使得一个类的功能能够“混入”另一个类。实质上是多重继承的一种解决方案，但是避免了多重继承的复杂性，而且有利于代码复用。\n\nmixin 就是一个正常的类，不仅定义了接口，还定义了接口的实现。\n\n子类通过在this对象上面绑定方法，达到多重继承的目的。\n\n很多库提供了 mixin 功能。下面以 lodash 为例。\n\nfunction vowels(string) {\n  return /[aeiou]/i.test(this.value);\n}\n\nvar obj = { value: 'hello' };\n_.mixin(obj, {vowels: vowels})\nobj.vowels() // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码通过 lodash 库的_.mixin方法，让obj对象继承了vowels方法。\n\nunderscore 的类似方法是_.extend。\n\nvar person = function (fname, lname) {\n  this.firstname = fname;\n  this.lastname = lname;\n}\n\nvar sam = new person('sam', 'lowry');\n\nvar namemixin = {\n  fullname: function () {\n    return this.firstname + ' ' + this.lastname;\n  },\n  rename: function(first, last) {\n    this.firstname = first;\n    this.lastname = last;\n    return this;\n  }\n};\n_.extend(person.prototype, namemixin);\nsam.rename('samwise', 'gamgee');\nsam.fullname() // \"samwise gamgee\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n上面代码通过_.extend方法，在sam对象上面（准确说是它的原型对象person.prototype上面），混入了namemixin类。\n\nextend方法的实现非常简单。\n\nfunction extend(destination, source) {\n  for (var k in source) {\n    if (source.hasownproperty(k)) {\n      destination[k] = source[k];\n    }\n  }\n  return destination;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码将source对象的所有方法，添加到destination对象。\n\n\n# trait\n\ntrait 是另外一种多重继承的解决方案。它与 mixin 很相似，但是有一些细微的差别。\n\n * mixin 可以包含状态（state），trait 不包含，即 trait 里面的方法都是互不相干，可以线性包含的。比如，trait1包含方法a和b，trait2继承了trait1，同时还包含一个自己的方法c，实际上就等同于直接包含方法a、b、c。\n * 对于同名方法的碰撞，mixin 包含了解决规则，trait 则是报错。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"SIMD",frontmatter:{title:"SIMD",date:"2020-02-09T16:00:30.000Z",permalink:"/pages/8e8f80f69b775a56",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/33.SIMD.html",relativePath:"《ES6 教程》笔记/33.SIMD.md",key:"v-07dc7dde",path:"/pages/8e8f80f69b775a56/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:11},{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:1231},{level:2,title:"静态方法：数学运算",slug:"静态方法-数学运算",normalizedTitle:"静态方法：数学运算",charIndex:2023},{level:3,title:"SIMD.%type%.abs()，SIMD.%type%.neg()",slug:"simd-type-abs-simd-type-neg",normalizedTitle:"simd.%type%.abs()，simd.%type%.neg()",charIndex:2064},{level:3,title:"SIMD.%type%.add()，SIMD.%type%.addSaturate()",slug:"simd-type-add-simd-type-addsaturate",normalizedTitle:"simd.%type%.add()，simd.%type%.addsaturate()",charIndex:2504},{level:3,title:"SIMD.%type%.sub()，SIMD.%type%.subSaturate()",slug:"simd-type-sub-simd-type-subsaturate",normalizedTitle:"simd.%type%.sub()，simd.%type%.subsaturate()",charIndex:3410},{level:3,title:"SIMD.%type%.mul()，SIMD.%type%.div()，SIMD.%type%.sqrt()",slug:"simd-type-mul-simd-type-div-simd-type-sqrt",normalizedTitle:"simd.%type%.mul()，simd.%type%.div()，simd.%type%.sqrt()",charIndex:4166},{level:3,title:"SIMD.%FloatType%.reciprocalApproximation()，SIMD.%type%.reciprocalSqrtApproximation()",slug:"simd-floattype-reciprocalapproximation-simd-type-reciprocalsqrtapproximation",normalizedTitle:"simd.%floattype%.reciprocalapproximation()，simd.%type%.reciprocalsqrtapproximation()",charIndex:4756},{level:3,title:"SIMD.%IntegerType%.shiftLeftByScalar()",slug:"simd-integertype-shiftleftbyscalar",normalizedTitle:"simd.%integertype%.shiftleftbyscalar()",charIndex:5323},{level:3,title:"SIMD.%IntegerType%.shiftRightByScalar()",slug:"simd-integertype-shiftrightbyscalar",normalizedTitle:"simd.%integertype%.shiftrightbyscalar()",charIndex:5717},{level:2,title:"静态方法：通道处理",slug:"静态方法-通道处理",normalizedTitle:"静态方法：通道处理",charIndex:6275},{level:3,title:"SIMD.%type%.check()",slug:"simd-type-check",normalizedTitle:"simd.%type%.check()",charIndex:6289},{level:3,title:"SIMD.%type%.extractLane()，SIMD.%type%.replaceLane()",slug:"simd-type-extractlane-simd-type-replacelane",normalizedTitle:"simd.%type%.extractlane()，simd.%type%.replacelane()",charIndex:6577},{level:3,title:"SIMD.%type%.load()",slug:"simd-type-load",normalizedTitle:"simd.%type%.load()",charIndex:6948},{level:3,title:"SIMD.%type%.store()",slug:"simd-type-store",normalizedTitle:"simd.%type%.store()",charIndex:7721},{level:3,title:"SIMD.%type%.splat()",slug:"simd-type-splat",normalizedTitle:"simd.%type%.splat()",charIndex:8433},{level:3,title:"SIMD.%type%.swizzle()",slug:"simd-type-swizzle",normalizedTitle:"simd.%type%.swizzle()",charIndex:8654},{level:3,title:"SIMD.%type%.shuffle()",slug:"simd-type-shuffle",normalizedTitle:"simd.%type%.shuffle()",charIndex:9366},{level:2,title:"静态方法：比较运算",slug:"静态方法-比较运算",normalizedTitle:"静态方法：比较运算",charIndex:9657},{level:3,title:"SIMD.%type%.equal()，SIMD.%type%.notEqual()",slug:"simd-type-equal-simd-type-notequal",normalizedTitle:"simd.%type%.equal()，simd.%type%.notequal()",charIndex:9671},{level:3,title:"SIMD.%type%.greaterThan()，SIMD.%type%.greaterThanOrEqual()",slug:"simd-type-greaterthan-simd-type-greaterthanorequal",normalizedTitle:"simd.%type%.greaterthan()，simd.%type%.greaterthanorequal()",charIndex:10071},{level:3,title:"SIMD.%type%.lessThan()，SIMD.%type%.lessThanOrEqual()",slug:"simd-type-lessthan-simd-type-lessthanorequal",normalizedTitle:"simd.%type%.lessthan()，simd.%type%.lessthanorequal()",charIndex:10507},{level:3,title:"SIMD.%type%.select()",slug:"simd-type-select",normalizedTitle:"simd.%type%.select()",charIndex:10928},{level:3,title:"SIMD.%BooleanType%.allTrue()，SIMD.%BooleanType%.anyTrue()",slug:"simd-booleantype-alltrue-simd-booleantype-anytrue",normalizedTitle:"simd.%booleantype%.alltrue()，simd.%booleantype%.anytrue()",charIndex:11633},{level:3,title:"SIMD.%type%.min()，SIMD.%type%.minNum()",slug:"simd-type-min-simd-type-minnum",normalizedTitle:"simd.%type%.min()，simd.%type%.minnum()",charIndex:12502},{level:3,title:"SIMD.%type%.max()，SIMD.%type%.maxNum()",slug:"simd-type-max-simd-type-maxnum",normalizedTitle:"simd.%type%.max()，simd.%type%.maxnum()",charIndex:13214},{level:2,title:"静态方法：位运算",slug:"静态方法-位运算",normalizedTitle:"静态方法：位运算",charIndex:13814},{level:3,title:"SIMD.%type%.and()，SIMD.%type%.or()，SIMD.%type%.xor()，SIMD.%type%.not()",slug:"simd-type-and-simd-type-or-simd-type-xor-simd-type-not",normalizedTitle:"simd.%type%.and()，simd.%type%.or()，simd.%type%.xor()，simd.%type%.not()",charIndex:13827},{level:2,title:"静态方法：数据类型转换",slug:"静态方法-数据类型转换",normalizedTitle:"静态方法：数据类型转换",charIndex:14798},{level:2,title:"实例方法",slug:"实例方法",normalizedTitle:"实例方法",charIndex:15804},{level:3,title:"SIMD.%type%.prototype.toString()",slug:"simd-type-prototype-tostring",normalizedTitle:"simd.%type%.prototype.tostring()",charIndex:15813},{level:2,title:"实例：求平均值",slug:"实例-求平均值",normalizedTitle:"实例：求平均值",charIndex:15977}],excerpt:'<h1 id="simd"><a class="header-anchor" href="#simd">#</a> SIMD</h1>\n<h2 id="概述"><a class="header-anchor" href="#概述">#</a> 概述</h2>\n<p>SIMD（发音<code>/sim-dee/</code>）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。</p>\n',headersStr:"概述 数据类型 静态方法：数学运算 SIMD.%type%.abs()，SIMD.%type%.neg() SIMD.%type%.add()，SIMD.%type%.addSaturate() SIMD.%type%.sub()，SIMD.%type%.subSaturate() SIMD.%type%.mul()，SIMD.%type%.div()，SIMD.%type%.sqrt() SIMD.%FloatType%.reciprocalApproximation()，SIMD.%type%.reciprocalSqrtApproximation() SIMD.%IntegerType%.shiftLeftByScalar() SIMD.%IntegerType%.shiftRightByScalar() 静态方法：通道处理 SIMD.%type%.check() SIMD.%type%.extractLane()，SIMD.%type%.replaceLane() SIMD.%type%.load() SIMD.%type%.store() SIMD.%type%.splat() SIMD.%type%.swizzle() SIMD.%type%.shuffle() 静态方法：比较运算 SIMD.%type%.equal()，SIMD.%type%.notEqual() SIMD.%type%.greaterThan()，SIMD.%type%.greaterThanOrEqual() SIMD.%type%.lessThan()，SIMD.%type%.lessThanOrEqual() SIMD.%type%.select() SIMD.%BooleanType%.allTrue()，SIMD.%BooleanType%.anyTrue() SIMD.%type%.min()，SIMD.%type%.minNum() SIMD.%type%.max()，SIMD.%type%.maxNum() 静态方法：位运算 SIMD.%type%.and()，SIMD.%type%.or()，SIMD.%type%.xor()，SIMD.%type%.not() 静态方法：数据类型转换 实例方法 SIMD.%type%.prototype.toString() 实例：求平均值",content:"# SIMD\n\n\n# 概述\n\nSIMD（发音/sim-dee/）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。 SIMD 的含义是使用一个指令，完成多个数据的运算；SISD 的含义是使用一个指令，完成单个数据的运算，这是 JavaScript 的默认运算模式。显而易见，SIMD 的执行效率要高于 SISD，所以被广泛用于 3D 图形运算、物理模拟等运算量超大的项目之中。\n\n为了理解 SIMD，请看下面的例子。\n\nvar a = [1, 2, 3, 4];\nvar b = [5, 6, 7, 8];\nvar c = [];\n\nc[0] = a[0] + b[0];\nc[1] = a[1] + b[1];\nc[2] = a[2] + b[2];\nc[3] = a[3] + b[3];\nc // Array[6, 8, 10, 12]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，数组a和b的对应成员相加，结果放入数组c。它的运算模式是依次处理每个数组成员，一共有四个数组成员，所以需要运算 4 次。\n\n如果采用 SIMD 模式，只要运算一次就够了。\n\nvar a = SIMD.Float32x4(1, 2, 3, 4);\nvar b = SIMD.Float32x4(5, 6, 7, 8);\nvar c = SIMD.Float32x4.add(a, b); // Float32x4[6, 8, 10, 12]\n\n\n1\n2\n3\n\n\n上面代码之中，数组a和b的四个成员的各自相加，只用一条指令就完成了。因此，速度比上一种写法提高了 4 倍。\n\n一次 SIMD 运算，可以处理多个数据，这些数据被称为“通道”（lane）。上面代码中，一次运算了四个数据，因此就是四个通道。\n\nSIMD 通常用于矢量运算。\n\nv + w = 〈v1, …, vn〉+ 〈w1, …, wn〉\n      = 〈v1+w1, …, vn+wn〉\n\n\n1\n2\n\n\n上面代码中，v和w是两个多元矢量。它们的加运算，在 SIMD 下是一个指令、而不是 n 个指令完成的，这就大大提高了效率。这对于 3D 动画、图像处理、信号处理、数值处理、加密等运算是非常重要的。比如，Canvas 的getImageData()会将图像文件读成一个二进制数组，SIMD 就很适合对于这种数组的处理。\n\n总的来说，SIMD 是数据并行处理（parallelism）的一种手段，可以加速一些运算密集型操作的速度。将来与 WebAssembly 结合以后，可以让 JavaScript 达到二进制代码的运行速度。\n\n\n# 数据类型\n\nSIMD 提供 12 种数据类型，总长度都是 128 个二进制位。\n\n * Float32x4：四个 32 位浮点数\n * Float64x2：两个 64 位浮点数\n * Int32x4：四个 32 位整数\n * Int16x8：八个 16 位整数\n * Int8x16：十六个 8 位整数\n * Uint32x4：四个无符号的 32 位整数\n * Uint16x8：八个无符号的 16 位整数\n * Uint8x16：十六个无符号的 8 位整数\n * Bool32x4：四个 32 位布尔值\n * Bool16x8：八个 16 位布尔值\n * Bool8x16：十六个 8 位布尔值\n * Bool64x2：两个 64 位布尔值\n\n每种数据类型被x符号分隔成两部分，后面的部分表示通道数，前面的部分表示每个通道的宽度和类型。比如，Float32x4就表示这个值有 4 个通道，每个通道是一个 32 位浮点数。\n\n每个通道之中，可以放置四种数据。\n\n * 浮点数（float，比如 1.0）\n * 带符号的整数（Int，比如-1）\n * 无符号的整数（Uint，比如 1）\n * 布尔值（Bool，包含true和false两种值）\n\n每种 SIMD 的数据类型都是一个函数方法，可以传入参数，生成对应的值。\n\nvar a = SIMD.Float32x4(1.0, 2.0, 3.0, 4.0);\n\n\n1\n\n\n上面代码中，变量a就是一个 128 位、包含四个 32 位浮点数（即四个通道）的值。\n\n注意，这些数据类型方法都不是构造函数，前面不能加new，否则会报错。\n\nvar v = new SIMD.Float32x4(0, 1, 2, 3);\n// TypeError: SIMD.Float32x4 is not a constructor\n\n\n1\n2\n\n\n\n# 静态方法：数学运算\n\n每种数据类型都有一系列运算符，支持基本的数学运算。\n\n\n# SIMD.%type%.abs()，SIMD.%type%.neg()\n\nabs方法接受一个 SIMD 值作为参数，将它的每个通道都转成绝对值，作为一个新的 SIMD 值返回。\n\nvar a = SIMD.Float32x4(-1, -2, 0, NaN);\nSIMD.Float32x4.abs(a)\n// Float32x4[1, 2, 0, NaN]\n\n\n1\n2\n3\n\n\nneg方法接受一个 SIMD 值作为参数，将它的每个通道都转成负值，作为一个新的 SIMD 值返回。\n\nvar a = SIMD.Float32x4(-1, -2, 3, 0);\nSIMD.Float32x4.neg(a)\n// Float32x4[1, 2, -3, -0]\n\nvar b = SIMD.Float64x2(NaN, Infinity);\nSIMD.Float64x2.neg(b)\n// Float64x2[NaN, -Infinity]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# SIMD.%type%.add()，SIMD.%type%.addSaturate()\n\nadd方法接受两个 SIMD 值作为参数，将它们的每个通道相加，作为一个新的 SIMD 值返回。\n\nvar a = SIMD.Float32x4(1.0, 2.0, 3.0, 4.0);\nvar b = SIMD.Float32x4(5.0, 10.0, 15.0, 20.0);\nvar c = SIMD.Float32x4.add(a, b);\n\n\n1\n2\n3\n\n\n上面代码中，经过加法运算，新的 SIMD 值为(6.0, 12.0, 18.0. 24.0)。\n\naddSaturate方法跟add方法的作用相同，都是两个通道相加，但是溢出的处理不一致。对于add方法，如果两个值相加发生溢出，溢出的二进制位会被丢弃; addSaturate方法则是返回该数据类型的最大值。\n\nvar a = SIMD.Uint16x8(65533, 65534, 65535, 65535, 1, 1, 1, 1);\nvar b = SIMD.Uint16x8(1, 1, 1, 5000, 1, 1, 1, 1);\nSIMD.Uint16x8.addSaturate(a, b);\n// Uint16x8[65534, 65535, 65535, 65535, 2, 2, 2, 2]\n\nvar c = SIMD.Int16x8(32765, 32766, 32767, 32767, 1, 1, 1, 1);\nvar d = SIMD.Int16x8(1, 1, 1, 5000, 1, 1, 1, 1);\nSIMD.Int16x8.addSaturate(c, d);\n// Int16x8[32766, 32767, 32767, 32767, 2, 2, 2, 2]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，Uint16的最大值是 65535，Int16的最大值是 32767。一旦发生溢出，就返回这两个值。\n\n注意，Uint32x4和Int32x4这两种数据类型没有addSaturate方法。\n\n\n# SIMD.%type%.sub()，SIMD.%type%.subSaturate()\n\nsub方法接受两个 SIMD 值作为参数，将它们的每个通道相减，作为一个新的 SIMD 值返回。\n\nvar a = SIMD.Float32x4(-1, -2, 3, 4);\nvar b = SIMD.Float32x4(3, 3, 3, 3);\nSIMD.Float32x4.sub(a, b)\n// Float32x4[-4, -5, 0, 1]\n\n\n1\n2\n3\n4\n\n\nsubSaturate方法跟sub方法的作用相同，都是两个通道相减，但是溢出的处理不一致。对于sub方法，如果两个值相减发生溢出，溢出的二进制位会被丢弃; subSaturate方法则是返回该数据类型的最小值。\n\nvar a = SIMD.Uint16x8(5, 1, 1, 1, 1, 1, 1, 1);\nvar b = SIMD.Uint16x8(10, 1, 1, 1, 1, 1, 1, 1);\nSIMD.Uint16x8.subSaturate(a, b)\n// Uint16x8[0, 0, 0, 0, 0, 0, 0, 0]\n\nvar c = SIMD.Int16x8(-100, 0, 0, 0, 0, 0, 0, 0);\nvar d = SIMD.Int16x8(32767, 0, 0, 0, 0, 0, 0, 0);\nSIMD.Int16x8.subSaturate(c, d)\n// Int16x8[-32768, 0, 0, 0, 0, 0, 0, 0, 0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，Uint16的最小值是0，Int16的最小值是-32678。一旦运算发生溢出，就返回最小值。\n\n\n# SIMD.%type%.mul()，SIMD.%type%.div()，SIMD.%type%.sqrt()\n\nmul方法接受两个 SIMD 值作为参数，将它们的每个通道相乘，作为一个新的 SIMD 值返回。\n\nvar a = SIMD.Float32x4(-1, -2, 3, 4);\nvar b = SIMD.Float32x4(3, 3, 3, 3);\nSIMD.Float32x4.mul(a, b)\n// Float32x4[-3, -6, 9, 12]\n\n\n1\n2\n3\n4\n\n\ndiv方法接受两个 SIMD 值作为参数，将它们的每个通道相除，作为一个新的 SIMD 值返回。\n\nvar a = SIMD.Float32x4(2, 2, 2, 2);\nvar b = SIMD.Float32x4(4, 4, 4, 4);\nSIMD.Float32x4.div(a, b)\n// Float32x4[0.5, 0.5, 0.5, 0.5]\n\n\n1\n2\n3\n4\n\n\nsqrt方法接受一个 SIMD 值作为参数，求出每个通道的平方根，作为一个新的 SIMD 值返回。\n\nvar b = SIMD.Float64x2(4, 8);\nSIMD.Float64x2.sqrt(b)\n// Float64x2[2, 2.8284271247461903]\n\n\n1\n2\n3\n\n\n\n# SIMD.%FloatType%.reciprocalApproximation()，SIMD.%type%.reciprocalSqrtApproximation()\n\nreciprocalApproximation方法接受一个 SIMD 值作为参数，求出每个通道的倒数（1 / x），作为一个新的 SIMD 值返回。\n\nvar a = SIMD.Float32x4(1, 2, 3, 4);\nSIMD.Float32x4.reciprocalApproximation(a);\n// Float32x4[1, 0.5, 0.3333333432674408, 0.25]\n\n\n1\n2\n3\n\n\nreciprocalSqrtApproximation方法接受一个 SIMD 值作为参数，求出每个通道的平方根的倒数（1 / (x^0.5)），作为一个新的 SIMD 值返回。\n\nvar a = SIMD.Float32x4(1, 2, 3, 4);\nSIMD.Float32x4.reciprocalSqrtApproximation(a)\n// Float32x4[1, 0.7071067690849304, 0.5773502588272095, 0.5]\n\n\n1\n2\n3\n\n\n注意，只有浮点数的数据类型才有这两个方法。\n\n\n# SIMD.%IntegerType%.shiftLeftByScalar()\n\nshiftLeftByScalar方法接受一个 SIMD 值作为参数，然后将每个通道的值左移指定的位数，作为一个新的 SIMD 值返回。\n\nvar a = SIMD.Int32x4(1, 2, 4, 8);\nSIMD.Int32x4.shiftLeftByScalar(a, 1);\n// Int32x4[2, 4, 8, 16]\n\n\n1\n2\n3\n\n\n如果左移后，新的值超出了当前数据类型的位数，溢出的部分会被丢弃。\n\nvar ix4 = SIMD.Int32x4(1, 2, 3, 4);\nvar jx4 = SIMD.Int32x4.shiftLeftByScalar(ix4, 32);\n// Int32x4[0, 0, 0, 0]\n\n\n1\n2\n3\n\n\n注意，只有整数的数据类型才有这个方法。\n\n\n# SIMD.%IntegerType%.shiftRightByScalar()\n\nshiftRightByScalar方法接受一个 SIMD 值作为参数，然后将每个通道的值右移指定的位数，返回一个新的 SIMD 值。\n\nvar a = SIMD.Int32x4(1, 2, 4, -8);\nSIMD.Int32x4.shiftRightByScalar(a, 1);\n// Int32x4[0, 1, 2, -4]\n\n\n1\n2\n3\n\n\n如果原来通道的值是带符号的值，则符号位保持不变，不受右移影响。如果是不带符号位的值，则右移后头部会补0。\n\nvar a = SIMD.Uint32x4(1, 2, 4, -8);\nSIMD.Uint32x4.shiftRightByScalar(a, 1);\n// Uint32x4[0, 1, 2, 2147483644]\n\n\n1\n2\n3\n\n\n上面代码中，-8右移一位变成了2147483644，是因为对于 32 位无符号整数来说，-8的二进制形式是11111111111111111111111111111000，右移一位就变成了01111111111111111111111111111100，相当于2147483644。\n\n注意，只有整数的数据类型才有这个方法。\n\n\n# 静态方法：通道处理\n\n\n# SIMD.%type%.check()\n\ncheck方法用于检查一个值是否为当前类型的 SIMD 值。如果是的，就返回这个值，否则就报错。\n\nvar a = SIMD.Float32x4(1, 2, 3, 9);\n\nSIMD.Float32x4.check(a);\n// Float32x4[1, 2, 3, 9]\n\nSIMD.Float32x4.check([1,2,3,4]) // 报错\nSIMD.Int32x4.check(a) // 报错\nSIMD.Int32x4.check('hello world') // 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# SIMD.%type%.extractLane()，SIMD.%type%.replaceLane()\n\nextractLane方法用于返回给定通道的值。它接受两个参数，分别是 SIMD 值和通道编号。\n\nvar t = SIMD.Float32x4(1, 2, 3, 4);\nSIMD.Float32x4.extractLane(t, 2) // 3\n\n\n1\n2\n\n\nreplaceLane方法用于替换指定通道的值，并返回一个新的 SIMD 值。它接受三个参数，分别是原来的 SIMD 值、通道编号和新的通道值。\n\nvar t = SIMD.Float32x4(1, 2, 3, 4);\nSIMD.Float32x4.replaceLane(t, 2, 42)\n// Float32x4[1, 2, 42, 4]\n\n\n1\n2\n3\n\n\n\n# SIMD.%type%.load()\n\nload方法用于从二进制数组读入数据，生成一个新的 SIMD 值。\n\nvar a = new Int32Array([1,2,3,4,5,6,7,8]);\nSIMD.Int32x4.load(a, 0);\n// Int32x4[1, 2, 3, 4]\n\nvar b = new Int32Array([1,2,3,4,5,6,7,8]);\nSIMD.Int32x4.load(a, 2);\n// Int32x4[3, 4, 5, 6]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nload方法接受两个参数：一个二进制数组和开始读取的位置（从 0 开始）。如果位置不合法（比如-1或者超出二进制数组的大小），就会抛出一个错误。\n\n这个方法还有三个变种load1()、load2()、load3()，表示从指定位置开始，只加载一个通道、二个通道、三个通道的值。\n\n// 格式\nSIMD.Int32x4.load(tarray, index)\nSIMD.Int32x4.load1(tarray, index)\nSIMD.Int32x4.load2(tarray, index)\nSIMD.Int32x4.load3(tarray, index)\n\n// 实例\nvar a = new Int32Array([1,2,3,4,5,6,7,8]);\nSIMD.Int32x4.load1(a, 0);\n// Int32x4[1, 0, 0, 0]\nSIMD.Int32x4.load2(a, 0);\n// Int32x4[1, 2, 0, 0]\nSIMD.Int32x4.load3(a, 0);\n// Int32x4[1, 2, 3,0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# SIMD.%type%.store()\n\nstore方法用于将一个 SIMD 值，写入一个二进制数组。它接受三个参数，分别是二进制数组、开始写入的数组位置、SIMD 值。它返回写入值以后的二进制数组。\n\nvar t1 = new Int32Array(8);\nvar v1 = SIMD.Int32x4(1, 2, 3, 4);\nSIMD.Int32x4.store(t1, 0, v1)\n// Int32Array[1, 2, 3, 4, 0, 0, 0, 0]\n\nvar t2 = new Int32Array(8);\nvar v2 = SIMD.Int32x4(1, 2, 3, 4);\nSIMD.Int32x4.store(t2, 2, v2)\n// Int32Array[0, 0, 1, 2, 3, 4, 0, 0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，t1是一个二进制数组，v1是一个 SIMD 值，只有四个通道。所以写入t1以后，只有前四个位置有值，后四个位置都是 0。而t2是从 2 号位置开始写入，所以前两个位置和后两个位置都是 0。\n\n这个方法还有三个变种store1()、store2()和store3()，表示只写入一个通道、二个通道和三个通道的值。\n\nvar tarray = new Int32Array(8);\nvar value = SIMD.Int32x4(1, 2, 3, 4);\nSIMD.Int32x4.store1(tarray, 0, value);\n// Int32Array[1, 0, 0, 0, 0, 0, 0, 0]\n\n\n1\n2\n3\n4\n\n\n\n# SIMD.%type%.splat()\n\nsplat方法返回一个新的 SIMD 值，该值的所有通道都会设成同一个预先给定的值。\n\nSIMD.Float32x4.splat(3);\n// Float32x4[3, 3, 3, 3]\nSIMD.Float64x2.splat(3);\n// Float64x2[3, 3]\n\n\n1\n2\n3\n4\n\n\n如果省略参数，所有整数型的 SIMD 值都会设定0，浮点型的 SIMD 值都会设成NaN。\n\n\n# SIMD.%type%.swizzle()\n\nswizzle方法返回一个新的 SIMD 值，重新排列原有的 SIMD 值的通道顺序。\n\nvar t = SIMD.Float32x4(1, 2, 3, 4);\nSIMD.Float32x4.swizzle(t, 1, 2, 0, 3);\n// Float32x4[2,3,1,4]\n\n\n1\n2\n3\n\n\n上面代码中，swizzle方法的第一个参数是原有的 SIMD 值，后面的参数对应将要返回的 SIMD 值的四个通道。它的意思是新的 SIMD 的四个通道，依次是原来 SIMD 值的 1 号通道、2 号通道、0 号通道、3 号通道。由于 SIMD 值最多可以有 16 个通道，所以swizzle方法除了第一个参数以外，最多还可以接受 16 个参数。\n\n下面是另一个例子。\n\nvar a = SIMD.Float32x4(1.0, 2.0, 3.0, 4.0);\n// Float32x4[1.0, 2.0, 3.0, 4.0]\n\nvar b = SIMD.Float32x4.swizzle(a, 0, 0, 1, 1);\n// Float32x4[1.0, 1.0, 2.0, 2.0]\n\nvar c = SIMD.Float32x4.swizzle(a, 3, 3, 3, 3);\n// Float32x4[4.0, 4.0, 4.0, 4.0]\n\nvar d = SIMD.Float32x4.swizzle(a, 3, 2, 1, 0);\n// Float32x4[4.0, 3.0, 2.0, 1.0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# SIMD.%type%.shuffle()\n\nshuffle方法从两个 SIMD 值之中取出指定通道，返回一个新的 SIMD 值。\n\nvar a = SIMD.Float32x4(1, 2, 3, 4);\nvar b = SIMD.Float32x4(5, 6, 7, 8);\n\nSIMD.Float32x4.shuffle(a, b, 1, 5, 7, 2);\n// Float32x4[2, 6, 8, 3]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，a和b一共有 8 个通道，依次编号为 0 到 7。shuffle根据编号，取出相应的通道，返回一个新的 SIMD 值。\n\n\n# 静态方法：比较运算\n\n\n# SIMD.%type%.equal()，SIMD.%type%.notEqual()\n\nequal方法用来比较两个 SIMD 值a和b的每一个通道，根据两者是否精确相等（a === b），得到一个布尔值。最后，所有通道的比较结果，组成一个新的 SIMD 值，作为掩码返回。notEqual方法则是比较两个通道是否不相等（a !== b）。\n\nvar a = SIMD.Float32x4(1, 2, 3, 9);\nvar b = SIMD.Float32x4(1, 4, 7, 9);\n\nSIMD.Float32x4.equal(a,b)\n// Bool32x4[true, false, false, true]\n\nSIMD.Float32x4.notEqual(a,b);\n// Bool32x4[false, true, true, false]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# SIMD.%type%.greaterThan()，SIMD.%type%.greaterThanOrEqual()\n\ngreatThan方法用来比较两个 SIMD 值a和b的每一个通道，如果在该通道中，a较大就得到true，否则得到false。最后，所有通道的比较结果，组成一个新的 SIMD 值，作为掩码返回。greaterThanOrEqual则是比较a是否大于等于b。\n\nvar a = SIMD.Float32x4(1, 6, 3, 11);\nvar b = SIMD.Float32x4(1, 4, 7, 9);\n\nSIMD.Float32x4.greaterThan(a, b)\n// Bool32x4[false, true, false, true]\n\nSIMD.Float32x4.greaterThanOrEqual(a, b)\n// Bool32x4[true, true, false, true]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# SIMD.%type%.lessThan()，SIMD.%type%.lessThanOrEqual()\n\nlessThan方法用来比较两个 SIMD 值a和b的每一个通道，如果在该通道中，a较小就得到true，否则得到false。最后，所有通道的比较结果，会组成一个新的 SIMD 值，作为掩码返回。lessThanOrEqual方法则是比较a是否等于b。\n\nvar a = SIMD.Float32x4(1, 2, 3, 11);\nvar b = SIMD.Float32x4(1, 4, 7, 9);\n\nSIMD.Float32x4.lessThan(a, b)\n// Bool32x4[false, true, true, false]\n\nSIMD.Float32x4.lessThanOrEqual(a, b)\n// Bool32x4[true, true, true, false]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# SIMD.%type%.select()\n\nselect方法通过掩码生成一个新的 SIMD 值。它接受三个参数，分别是掩码和两个 SIMD 值。\n\nvar a = SIMD.Float32x4(1, 2, 3, 4);\nvar b = SIMD.Float32x4(5, 6, 7, 8);\n\nvar mask = SIMD.Bool32x4(true, false, false, true);\n\nSIMD.Float32x4.select(mask, a, b);\n// Float32x4[1, 6, 7, 4]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，select方法接受掩码和两个 SIMD 值作为参数。当某个通道对应的掩码为true时，会选择第一个 SIMD 值的对应通道，否则选择第二个 SIMD 值的对应通道。\n\n这个方法通常与比较运算符结合使用。\n\nvar a = SIMD.Float32x4(0, 12, 3, 4);\nvar b = SIMD.Float32x4(0, 6, 7, 50);\n\nvar mask = SIMD.Float32x4.lessThan(a,b);\n// Bool32x4[false, false, true, true]\n\nvar result = SIMD.Float32x4.select(mask, a, b);\n// Float32x4[0, 6, 3, 4]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，先通过lessThan方法生成一个掩码，然后通过select方法生成一个由每个通道的较小值组成的新的 SIMD 值。\n\n\n# SIMD.%BooleanType%.allTrue()，SIMD.%BooleanType%.anyTrue()\n\nallTrue方法接受一个 SIMD 值作为参数，然后返回一个布尔值，表示该 SIMD 值的所有通道是否都为true。\n\nvar a = SIMD.Bool32x4(true, true, true, true);\nvar b = SIMD.Bool32x4(true, false, true, true);\n\nSIMD.Bool32x4.allTrue(a); // true\nSIMD.Bool32x4.allTrue(b); // false\n\n\n1\n2\n3\n4\n5\n\n\nanyTrue方法则是只要有一个通道为true，就返回true，否则返回false。\n\nvar a = SIMD.Bool32x4(false, false, false, false);\nvar b = SIMD.Bool32x4(false, false, true, false);\n\nSIMD.Bool32x4.anyTrue(a); // false\nSIMD.Bool32x4.anyTrue(b); // true\n\n\n1\n2\n3\n4\n5\n\n\n注意，只有四种布尔值数据类型（Bool32x4、Bool16x8、Bool8x16、Bool64x2）才有这两个方法。\n\n这两个方法通常与比较运算符结合使用。\n\nvar ax4    = SIMD.Float32x4(1.0, 2.0, 3.0, 4.0);\nvar bx4    = SIMD.Float32x4(0.0, 6.0, 7.0, 8.0);\nvar ix4    = SIMD.Float32x4.lessThan(ax4, bx4);\nvar b1     = SIMD.Int32x4.allTrue(ix4); // false\nvar b2     = SIMD.Int32x4.anyTrue(ix4); // true\n\n\n1\n2\n3\n4\n5\n\n\n\n# SIMD.%type%.min()，SIMD.%type%.minNum()\n\nmin方法接受两个 SIMD 值作为参数，将两者的对应通道的较小值，组成一个新的 SIMD 值返回。\n\nvar a = SIMD.Float32x4(-1, -2, 3, 5.2);\nvar b = SIMD.Float32x4(0, -4, 6, 5.5);\nSIMD.Float32x4.min(a, b);\n// Float32x4[-1, -4, 3, 5.2]\n\n\n1\n2\n3\n4\n\n\n如果有一个通道的值是NaN，则会优先返回NaN。\n\nvar c = SIMD.Float64x2(NaN, Infinity)\nvar d = SIMD.Float64x2(1337, 42);\nSIMD.Float64x2.min(c, d);\n// Float64x2[NaN, 42]\n\n\n1\n2\n3\n4\n\n\nminNum方法与min的作用一模一样，唯一的区别是如果有一个通道的值是NaN，则会优先返回另一个通道的值。\n\nvar ax4 = SIMD.Float32x4(1.0, 2.0, NaN, NaN);\nvar bx4 = SIMD.Float32x4(2.0, 1.0, 3.0, NaN);\nvar cx4 = SIMD.Float32x4.min(ax4, bx4);\n// Float32x4[1.0, 1.0, NaN, NaN]\nvar dx4 = SIMD.Float32x4.minNum(ax4, bx4);\n// Float32x4[1.0, 1.0, 3.0, NaN]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# SIMD.%type%.max()，SIMD.%type%.maxNum()\n\nmax方法接受两个 SIMD 值作为参数，将两者的对应通道的较大值，组成一个新的 SIMD 值返回。\n\nvar a = SIMD.Float32x4(-1, -2, 3, 5.2);\nvar b = SIMD.Float32x4(0, -4, 6, 5.5);\nSIMD.Float32x4.max(a, b);\n// Float32x4[0, -2, 6, 5.5]\n\n\n1\n2\n3\n4\n\n\n如果有一个通道的值是NaN，则会优先返回NaN。\n\nvar c = SIMD.Float64x2(NaN, Infinity)\nvar d = SIMD.Float64x2(1337, 42);\nSIMD.Float64x2.max(c, d)\n// Float64x2[NaN, Infinity]\n\n\n1\n2\n3\n4\n\n\nmaxNum方法与max的作用一模一样，唯一的区别是如果有一个通道的值是NaN，则会优先返回另一个通道的值。\n\nvar c = SIMD.Float64x2(NaN, Infinity)\nvar d = SIMD.Float64x2(1337, 42);\nSIMD.Float64x2.maxNum(c, d)\n// Float64x2[1337, Infinity]\n\n\n1\n2\n3\n4\n\n\n\n# 静态方法：位运算\n\n\n# SIMD.%type%.and()，SIMD.%type%.or()，SIMD.%type%.xor()，SIMD.%type%.not()\n\nand方法接受两个 SIMD 值作为参数，返回两者对应的通道进行二进制AND运算（&）后得到的新的 SIMD 值。\n\nvar a = SIMD.Int32x4(1, 2, 4, 8);\nvar b = SIMD.Int32x4(5, 5, 5, 5);\nSIMD.Int32x4.and(a, b)\n// Int32x4[1, 0, 4, 0]\n\n\n1\n2\n3\n4\n\n\n上面代码中，以通道0为例，1的二进制形式是0001，5的二进制形式是01001，所以进行AND运算以后，得到0001。\n\nor方法接受两个 SIMD 值作为参数，返回两者对应的通道进行二进制OR运算（|）后得到的新的 SIMD 值。\n\nvar a = SIMD.Int32x4(1, 2, 4, 8);\nvar b = SIMD.Int32x4(5, 5, 5, 5);\nSIMD.Int32x4.or(a, b)\n// Int32x4[5, 7, 5, 13]\n\n\n1\n2\n3\n4\n\n\nxor方法接受两个 SIMD 值作为参数，返回两者对应的通道进行二进制“异或”运算（^）后得到的新的 SIMD 值。\n\nvar a = SIMD.Int32x4(1, 2, 4, 8);\nvar b = SIMD.Int32x4(5, 5, 5, 5);\nSIMD.Int32x4.xor(a, b)\n// Int32x4[4, 7, 1, 13]\n\n\n1\n2\n3\n4\n\n\nnot方法接受一个 SIMD 值作为参数，返回每个通道进行二进制“否”运算（~）后得到的新的 SIMD 值。\n\nvar a = SIMD.Int32x4(1, 2, 4, 8);\nSIMD.Int32x4.not(a)\n// Int32x4[-2, -3, -5, -9]\n\n\n1\n2\n3\n\n\n上面代码中，1的否运算之所以得到-2，是因为在计算机内部，负数采用”2 的补码“这种形式进行表示。也就是说，整数n的负数形式-n，是对每一个二进制位取反以后，再加上 1。因此，直接取反就相当于负数形式再减去 1，比如1的负数形式是-1，再减去 1，就得到了-2。\n\n\n# 静态方法：数据类型转换\n\nSIMD 提供以下方法，用来将一种数据类型转为另一种数据类型。\n\n * SIMD.%type%.fromFloat32x4()\n * SIMD.%type%.fromFloat32x4Bits()\n * SIMD.%type%.fromFloat64x2Bits()\n * SIMD.%type%.fromInt32x4()\n * SIMD.%type%.fromInt32x4Bits()\n * SIMD.%type%.fromInt16x8Bits()\n * SIMD.%type%.fromInt8x16Bits()\n * SIMD.%type%.fromUint32x4()\n * SIMD.%type%.fromUint32x4Bits()\n * SIMD.%type%.fromUint16x8Bits()\n * SIMD.%type%.fromUint8x16Bits()\n\n带有Bits后缀的方法，会原封不动地将二进制位拷贝到新的数据类型；不带后缀的方法，则会进行数据类型转换。\n\nvar t = SIMD.Float32x4(1.0, 2.0, 3.0, 4.0);\nSIMD.Int32x4.fromFloat32x4(t);\n// Int32x4[1, 2, 3, 4]\n\nSIMD.Int32x4.fromFloat32x4Bits(t);\n// Int32x4[1065353216, 1073741824, 1077936128, 1082130432]\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，fromFloat32x4是将浮点数转为整数，然后存入新的数据类型；fromFloat32x4Bits则是将二进制位原封不动地拷贝进入新的数据类型，然后进行解读。\n\nBits后缀的方法，还可以用于通道数目不对等的拷贝。\n\nvar t = SIMD.Float32x4(1.0, 2.0, 3.0, 4.0);\nSIMD.Int16x8.fromFloat32x4Bits(t);\n// Int16x8[0, 16256, 0, 16384, 0, 16448, 0, 16512]\n\n\n1\n2\n3\n\n\n上面代码中，原始 SIMD 值t是 4 通道的，而目标值是 8 通道的。\n\n如果数据转换时，原通道的数据大小，超过了目标通道的最大宽度，就会报错。\n\n\n# 实例方法\n\n\n# SIMD.%type%.prototype.toString()\n\ntoString方法返回一个 SIMD 值的字符串形式。\n\nvar a = SIMD.Float32x4(11, 22, 33, 44);\na.toString() // \"SIMD.Float32x4(11, 22, 33, 44)\"\n\n\n1\n2\n\n\n\n# 实例：求平均值\n\n正常模式下，计算n个值的平均值，需要运算n次。\n\nfunction average(list) {\n  var n = list.length;\n  var sum = 0.0;\n  for (var i = 0; i < n; i++) {\n    sum += list[i];\n  }\n  return sum / n;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用 SIMD，可以将计算次数减少到n次的四分之一。\n\nfunction average(list) {\n  var n = list.length;\n  var sum = SIMD.Float32x4.splat(0.0);\n  for (var i = 0; i < n; i += 4) {\n    sum = SIMD.Float32x4.add(\n      sum,\n      SIMD.Float32x4.load(list, i)\n    );\n  }\n  var total = SIMD.Float32x4.extractLane(sum, 0) +\n              SIMD.Float32x4.extractLane(sum, 1) +\n              SIMD.Float32x4.extractLane(sum, 2) +\n              SIMD.Float32x4.extractLane(sum, 3);\n  return total / n;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码先是每隔四位，将所有的值读入一个 SIMD，然后立刻累加。然后，得到累加值四个通道的总和，再除以n就可以了。",normalizedContent:"# simd\n\n\n# 概述\n\nsimd（发音/sim-dee/）是“single instruction/multiple data”的缩写，意为“单指令，多数据”。它是 javascript 操作 cpu 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 sisd（“single instruction/single data”），即“单指令，单数据”。 simd 的含义是使用一个指令，完成多个数据的运算；sisd 的含义是使用一个指令，完成单个数据的运算，这是 javascript 的默认运算模式。显而易见，simd 的执行效率要高于 sisd，所以被广泛用于 3d 图形运算、物理模拟等运算量超大的项目之中。\n\n为了理解 simd，请看下面的例子。\n\nvar a = [1, 2, 3, 4];\nvar b = [5, 6, 7, 8];\nvar c = [];\n\nc[0] = a[0] + b[0];\nc[1] = a[1] + b[1];\nc[2] = a[2] + b[2];\nc[3] = a[3] + b[3];\nc // array[6, 8, 10, 12]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，数组a和b的对应成员相加，结果放入数组c。它的运算模式是依次处理每个数组成员，一共有四个数组成员，所以需要运算 4 次。\n\n如果采用 simd 模式，只要运算一次就够了。\n\nvar a = simd.float32x4(1, 2, 3, 4);\nvar b = simd.float32x4(5, 6, 7, 8);\nvar c = simd.float32x4.add(a, b); // float32x4[6, 8, 10, 12]\n\n\n1\n2\n3\n\n\n上面代码之中，数组a和b的四个成员的各自相加，只用一条指令就完成了。因此，速度比上一种写法提高了 4 倍。\n\n一次 simd 运算，可以处理多个数据，这些数据被称为“通道”（lane）。上面代码中，一次运算了四个数据，因此就是四个通道。\n\nsimd 通常用于矢量运算。\n\nv + w = 〈v1, …, vn〉+ 〈w1, …, wn〉\n      = 〈v1+w1, …, vn+wn〉\n\n\n1\n2\n\n\n上面代码中，v和w是两个多元矢量。它们的加运算，在 simd 下是一个指令、而不是 n 个指令完成的，这就大大提高了效率。这对于 3d 动画、图像处理、信号处理、数值处理、加密等运算是非常重要的。比如，canvas 的getimagedata()会将图像文件读成一个二进制数组，simd 就很适合对于这种数组的处理。\n\n总的来说，simd 是数据并行处理（parallelism）的一种手段，可以加速一些运算密集型操作的速度。将来与 webassembly 结合以后，可以让 javascript 达到二进制代码的运行速度。\n\n\n# 数据类型\n\nsimd 提供 12 种数据类型，总长度都是 128 个二进制位。\n\n * float32x4：四个 32 位浮点数\n * float64x2：两个 64 位浮点数\n * int32x4：四个 32 位整数\n * int16x8：八个 16 位整数\n * int8x16：十六个 8 位整数\n * uint32x4：四个无符号的 32 位整数\n * uint16x8：八个无符号的 16 位整数\n * uint8x16：十六个无符号的 8 位整数\n * bool32x4：四个 32 位布尔值\n * bool16x8：八个 16 位布尔值\n * bool8x16：十六个 8 位布尔值\n * bool64x2：两个 64 位布尔值\n\n每种数据类型被x符号分隔成两部分，后面的部分表示通道数，前面的部分表示每个通道的宽度和类型。比如，float32x4就表示这个值有 4 个通道，每个通道是一个 32 位浮点数。\n\n每个通道之中，可以放置四种数据。\n\n * 浮点数（float，比如 1.0）\n * 带符号的整数（int，比如-1）\n * 无符号的整数（uint，比如 1）\n * 布尔值（bool，包含true和false两种值）\n\n每种 simd 的数据类型都是一个函数方法，可以传入参数，生成对应的值。\n\nvar a = simd.float32x4(1.0, 2.0, 3.0, 4.0);\n\n\n1\n\n\n上面代码中，变量a就是一个 128 位、包含四个 32 位浮点数（即四个通道）的值。\n\n注意，这些数据类型方法都不是构造函数，前面不能加new，否则会报错。\n\nvar v = new simd.float32x4(0, 1, 2, 3);\n// typeerror: simd.float32x4 is not a constructor\n\n\n1\n2\n\n\n\n# 静态方法：数学运算\n\n每种数据类型都有一系列运算符，支持基本的数学运算。\n\n\n# simd.%type%.abs()，simd.%type%.neg()\n\nabs方法接受一个 simd 值作为参数，将它的每个通道都转成绝对值，作为一个新的 simd 值返回。\n\nvar a = simd.float32x4(-1, -2, 0, nan);\nsimd.float32x4.abs(a)\n// float32x4[1, 2, 0, nan]\n\n\n1\n2\n3\n\n\nneg方法接受一个 simd 值作为参数，将它的每个通道都转成负值，作为一个新的 simd 值返回。\n\nvar a = simd.float32x4(-1, -2, 3, 0);\nsimd.float32x4.neg(a)\n// float32x4[1, 2, -3, -0]\n\nvar b = simd.float64x2(nan, infinity);\nsimd.float64x2.neg(b)\n// float64x2[nan, -infinity]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# simd.%type%.add()，simd.%type%.addsaturate()\n\nadd方法接受两个 simd 值作为参数，将它们的每个通道相加，作为一个新的 simd 值返回。\n\nvar a = simd.float32x4(1.0, 2.0, 3.0, 4.0);\nvar b = simd.float32x4(5.0, 10.0, 15.0, 20.0);\nvar c = simd.float32x4.add(a, b);\n\n\n1\n2\n3\n\n\n上面代码中，经过加法运算，新的 simd 值为(6.0, 12.0, 18.0. 24.0)。\n\naddsaturate方法跟add方法的作用相同，都是两个通道相加，但是溢出的处理不一致。对于add方法，如果两个值相加发生溢出，溢出的二进制位会被丢弃; addsaturate方法则是返回该数据类型的最大值。\n\nvar a = simd.uint16x8(65533, 65534, 65535, 65535, 1, 1, 1, 1);\nvar b = simd.uint16x8(1, 1, 1, 5000, 1, 1, 1, 1);\nsimd.uint16x8.addsaturate(a, b);\n// uint16x8[65534, 65535, 65535, 65535, 2, 2, 2, 2]\n\nvar c = simd.int16x8(32765, 32766, 32767, 32767, 1, 1, 1, 1);\nvar d = simd.int16x8(1, 1, 1, 5000, 1, 1, 1, 1);\nsimd.int16x8.addsaturate(c, d);\n// int16x8[32766, 32767, 32767, 32767, 2, 2, 2, 2]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，uint16的最大值是 65535，int16的最大值是 32767。一旦发生溢出，就返回这两个值。\n\n注意，uint32x4和int32x4这两种数据类型没有addsaturate方法。\n\n\n# simd.%type%.sub()，simd.%type%.subsaturate()\n\nsub方法接受两个 simd 值作为参数，将它们的每个通道相减，作为一个新的 simd 值返回。\n\nvar a = simd.float32x4(-1, -2, 3, 4);\nvar b = simd.float32x4(3, 3, 3, 3);\nsimd.float32x4.sub(a, b)\n// float32x4[-4, -5, 0, 1]\n\n\n1\n2\n3\n4\n\n\nsubsaturate方法跟sub方法的作用相同，都是两个通道相减，但是溢出的处理不一致。对于sub方法，如果两个值相减发生溢出，溢出的二进制位会被丢弃; subsaturate方法则是返回该数据类型的最小值。\n\nvar a = simd.uint16x8(5, 1, 1, 1, 1, 1, 1, 1);\nvar b = simd.uint16x8(10, 1, 1, 1, 1, 1, 1, 1);\nsimd.uint16x8.subsaturate(a, b)\n// uint16x8[0, 0, 0, 0, 0, 0, 0, 0]\n\nvar c = simd.int16x8(-100, 0, 0, 0, 0, 0, 0, 0);\nvar d = simd.int16x8(32767, 0, 0, 0, 0, 0, 0, 0);\nsimd.int16x8.subsaturate(c, d)\n// int16x8[-32768, 0, 0, 0, 0, 0, 0, 0, 0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，uint16的最小值是0，int16的最小值是-32678。一旦运算发生溢出，就返回最小值。\n\n\n# simd.%type%.mul()，simd.%type%.div()，simd.%type%.sqrt()\n\nmul方法接受两个 simd 值作为参数，将它们的每个通道相乘，作为一个新的 simd 值返回。\n\nvar a = simd.float32x4(-1, -2, 3, 4);\nvar b = simd.float32x4(3, 3, 3, 3);\nsimd.float32x4.mul(a, b)\n// float32x4[-3, -6, 9, 12]\n\n\n1\n2\n3\n4\n\n\ndiv方法接受两个 simd 值作为参数，将它们的每个通道相除，作为一个新的 simd 值返回。\n\nvar a = simd.float32x4(2, 2, 2, 2);\nvar b = simd.float32x4(4, 4, 4, 4);\nsimd.float32x4.div(a, b)\n// float32x4[0.5, 0.5, 0.5, 0.5]\n\n\n1\n2\n3\n4\n\n\nsqrt方法接受一个 simd 值作为参数，求出每个通道的平方根，作为一个新的 simd 值返回。\n\nvar b = simd.float64x2(4, 8);\nsimd.float64x2.sqrt(b)\n// float64x2[2, 2.8284271247461903]\n\n\n1\n2\n3\n\n\n\n# simd.%floattype%.reciprocalapproximation()，simd.%type%.reciprocalsqrtapproximation()\n\nreciprocalapproximation方法接受一个 simd 值作为参数，求出每个通道的倒数（1 / x），作为一个新的 simd 值返回。\n\nvar a = simd.float32x4(1, 2, 3, 4);\nsimd.float32x4.reciprocalapproximation(a);\n// float32x4[1, 0.5, 0.3333333432674408, 0.25]\n\n\n1\n2\n3\n\n\nreciprocalsqrtapproximation方法接受一个 simd 值作为参数，求出每个通道的平方根的倒数（1 / (x^0.5)），作为一个新的 simd 值返回。\n\nvar a = simd.float32x4(1, 2, 3, 4);\nsimd.float32x4.reciprocalsqrtapproximation(a)\n// float32x4[1, 0.7071067690849304, 0.5773502588272095, 0.5]\n\n\n1\n2\n3\n\n\n注意，只有浮点数的数据类型才有这两个方法。\n\n\n# simd.%integertype%.shiftleftbyscalar()\n\nshiftleftbyscalar方法接受一个 simd 值作为参数，然后将每个通道的值左移指定的位数，作为一个新的 simd 值返回。\n\nvar a = simd.int32x4(1, 2, 4, 8);\nsimd.int32x4.shiftleftbyscalar(a, 1);\n// int32x4[2, 4, 8, 16]\n\n\n1\n2\n3\n\n\n如果左移后，新的值超出了当前数据类型的位数，溢出的部分会被丢弃。\n\nvar ix4 = simd.int32x4(1, 2, 3, 4);\nvar jx4 = simd.int32x4.shiftleftbyscalar(ix4, 32);\n// int32x4[0, 0, 0, 0]\n\n\n1\n2\n3\n\n\n注意，只有整数的数据类型才有这个方法。\n\n\n# simd.%integertype%.shiftrightbyscalar()\n\nshiftrightbyscalar方法接受一个 simd 值作为参数，然后将每个通道的值右移指定的位数，返回一个新的 simd 值。\n\nvar a = simd.int32x4(1, 2, 4, -8);\nsimd.int32x4.shiftrightbyscalar(a, 1);\n// int32x4[0, 1, 2, -4]\n\n\n1\n2\n3\n\n\n如果原来通道的值是带符号的值，则符号位保持不变，不受右移影响。如果是不带符号位的值，则右移后头部会补0。\n\nvar a = simd.uint32x4(1, 2, 4, -8);\nsimd.uint32x4.shiftrightbyscalar(a, 1);\n// uint32x4[0, 1, 2, 2147483644]\n\n\n1\n2\n3\n\n\n上面代码中，-8右移一位变成了2147483644，是因为对于 32 位无符号整数来说，-8的二进制形式是11111111111111111111111111111000，右移一位就变成了01111111111111111111111111111100，相当于2147483644。\n\n注意，只有整数的数据类型才有这个方法。\n\n\n# 静态方法：通道处理\n\n\n# simd.%type%.check()\n\ncheck方法用于检查一个值是否为当前类型的 simd 值。如果是的，就返回这个值，否则就报错。\n\nvar a = simd.float32x4(1, 2, 3, 9);\n\nsimd.float32x4.check(a);\n// float32x4[1, 2, 3, 9]\n\nsimd.float32x4.check([1,2,3,4]) // 报错\nsimd.int32x4.check(a) // 报错\nsimd.int32x4.check('hello world') // 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# simd.%type%.extractlane()，simd.%type%.replacelane()\n\nextractlane方法用于返回给定通道的值。它接受两个参数，分别是 simd 值和通道编号。\n\nvar t = simd.float32x4(1, 2, 3, 4);\nsimd.float32x4.extractlane(t, 2) // 3\n\n\n1\n2\n\n\nreplacelane方法用于替换指定通道的值，并返回一个新的 simd 值。它接受三个参数，分别是原来的 simd 值、通道编号和新的通道值。\n\nvar t = simd.float32x4(1, 2, 3, 4);\nsimd.float32x4.replacelane(t, 2, 42)\n// float32x4[1, 2, 42, 4]\n\n\n1\n2\n3\n\n\n\n# simd.%type%.load()\n\nload方法用于从二进制数组读入数据，生成一个新的 simd 值。\n\nvar a = new int32array([1,2,3,4,5,6,7,8]);\nsimd.int32x4.load(a, 0);\n// int32x4[1, 2, 3, 4]\n\nvar b = new int32array([1,2,3,4,5,6,7,8]);\nsimd.int32x4.load(a, 2);\n// int32x4[3, 4, 5, 6]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nload方法接受两个参数：一个二进制数组和开始读取的位置（从 0 开始）。如果位置不合法（比如-1或者超出二进制数组的大小），就会抛出一个错误。\n\n这个方法还有三个变种load1()、load2()、load3()，表示从指定位置开始，只加载一个通道、二个通道、三个通道的值。\n\n// 格式\nsimd.int32x4.load(tarray, index)\nsimd.int32x4.load1(tarray, index)\nsimd.int32x4.load2(tarray, index)\nsimd.int32x4.load3(tarray, index)\n\n// 实例\nvar a = new int32array([1,2,3,4,5,6,7,8]);\nsimd.int32x4.load1(a, 0);\n// int32x4[1, 0, 0, 0]\nsimd.int32x4.load2(a, 0);\n// int32x4[1, 2, 0, 0]\nsimd.int32x4.load3(a, 0);\n// int32x4[1, 2, 3,0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# simd.%type%.store()\n\nstore方法用于将一个 simd 值，写入一个二进制数组。它接受三个参数，分别是二进制数组、开始写入的数组位置、simd 值。它返回写入值以后的二进制数组。\n\nvar t1 = new int32array(8);\nvar v1 = simd.int32x4(1, 2, 3, 4);\nsimd.int32x4.store(t1, 0, v1)\n// int32array[1, 2, 3, 4, 0, 0, 0, 0]\n\nvar t2 = new int32array(8);\nvar v2 = simd.int32x4(1, 2, 3, 4);\nsimd.int32x4.store(t2, 2, v2)\n// int32array[0, 0, 1, 2, 3, 4, 0, 0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，t1是一个二进制数组，v1是一个 simd 值，只有四个通道。所以写入t1以后，只有前四个位置有值，后四个位置都是 0。而t2是从 2 号位置开始写入，所以前两个位置和后两个位置都是 0。\n\n这个方法还有三个变种store1()、store2()和store3()，表示只写入一个通道、二个通道和三个通道的值。\n\nvar tarray = new int32array(8);\nvar value = simd.int32x4(1, 2, 3, 4);\nsimd.int32x4.store1(tarray, 0, value);\n// int32array[1, 0, 0, 0, 0, 0, 0, 0]\n\n\n1\n2\n3\n4\n\n\n\n# simd.%type%.splat()\n\nsplat方法返回一个新的 simd 值，该值的所有通道都会设成同一个预先给定的值。\n\nsimd.float32x4.splat(3);\n// float32x4[3, 3, 3, 3]\nsimd.float64x2.splat(3);\n// float64x2[3, 3]\n\n\n1\n2\n3\n4\n\n\n如果省略参数，所有整数型的 simd 值都会设定0，浮点型的 simd 值都会设成nan。\n\n\n# simd.%type%.swizzle()\n\nswizzle方法返回一个新的 simd 值，重新排列原有的 simd 值的通道顺序。\n\nvar t = simd.float32x4(1, 2, 3, 4);\nsimd.float32x4.swizzle(t, 1, 2, 0, 3);\n// float32x4[2,3,1,4]\n\n\n1\n2\n3\n\n\n上面代码中，swizzle方法的第一个参数是原有的 simd 值，后面的参数对应将要返回的 simd 值的四个通道。它的意思是新的 simd 的四个通道，依次是原来 simd 值的 1 号通道、2 号通道、0 号通道、3 号通道。由于 simd 值最多可以有 16 个通道，所以swizzle方法除了第一个参数以外，最多还可以接受 16 个参数。\n\n下面是另一个例子。\n\nvar a = simd.float32x4(1.0, 2.0, 3.0, 4.0);\n// float32x4[1.0, 2.0, 3.0, 4.0]\n\nvar b = simd.float32x4.swizzle(a, 0, 0, 1, 1);\n// float32x4[1.0, 1.0, 2.0, 2.0]\n\nvar c = simd.float32x4.swizzle(a, 3, 3, 3, 3);\n// float32x4[4.0, 4.0, 4.0, 4.0]\n\nvar d = simd.float32x4.swizzle(a, 3, 2, 1, 0);\n// float32x4[4.0, 3.0, 2.0, 1.0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# simd.%type%.shuffle()\n\nshuffle方法从两个 simd 值之中取出指定通道，返回一个新的 simd 值。\n\nvar a = simd.float32x4(1, 2, 3, 4);\nvar b = simd.float32x4(5, 6, 7, 8);\n\nsimd.float32x4.shuffle(a, b, 1, 5, 7, 2);\n// float32x4[2, 6, 8, 3]\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，a和b一共有 8 个通道，依次编号为 0 到 7。shuffle根据编号，取出相应的通道，返回一个新的 simd 值。\n\n\n# 静态方法：比较运算\n\n\n# simd.%type%.equal()，simd.%type%.notequal()\n\nequal方法用来比较两个 simd 值a和b的每一个通道，根据两者是否精确相等（a === b），得到一个布尔值。最后，所有通道的比较结果，组成一个新的 simd 值，作为掩码返回。notequal方法则是比较两个通道是否不相等（a !== b）。\n\nvar a = simd.float32x4(1, 2, 3, 9);\nvar b = simd.float32x4(1, 4, 7, 9);\n\nsimd.float32x4.equal(a,b)\n// bool32x4[true, false, false, true]\n\nsimd.float32x4.notequal(a,b);\n// bool32x4[false, true, true, false]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# simd.%type%.greaterthan()，simd.%type%.greaterthanorequal()\n\ngreatthan方法用来比较两个 simd 值a和b的每一个通道，如果在该通道中，a较大就得到true，否则得到false。最后，所有通道的比较结果，组成一个新的 simd 值，作为掩码返回。greaterthanorequal则是比较a是否大于等于b。\n\nvar a = simd.float32x4(1, 6, 3, 11);\nvar b = simd.float32x4(1, 4, 7, 9);\n\nsimd.float32x4.greaterthan(a, b)\n// bool32x4[false, true, false, true]\n\nsimd.float32x4.greaterthanorequal(a, b)\n// bool32x4[true, true, false, true]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# simd.%type%.lessthan()，simd.%type%.lessthanorequal()\n\nlessthan方法用来比较两个 simd 值a和b的每一个通道，如果在该通道中，a较小就得到true，否则得到false。最后，所有通道的比较结果，会组成一个新的 simd 值，作为掩码返回。lessthanorequal方法则是比较a是否等于b。\n\nvar a = simd.float32x4(1, 2, 3, 11);\nvar b = simd.float32x4(1, 4, 7, 9);\n\nsimd.float32x4.lessthan(a, b)\n// bool32x4[false, true, true, false]\n\nsimd.float32x4.lessthanorequal(a, b)\n// bool32x4[true, true, true, false]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# simd.%type%.select()\n\nselect方法通过掩码生成一个新的 simd 值。它接受三个参数，分别是掩码和两个 simd 值。\n\nvar a = simd.float32x4(1, 2, 3, 4);\nvar b = simd.float32x4(5, 6, 7, 8);\n\nvar mask = simd.bool32x4(true, false, false, true);\n\nsimd.float32x4.select(mask, a, b);\n// float32x4[1, 6, 7, 4]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，select方法接受掩码和两个 simd 值作为参数。当某个通道对应的掩码为true时，会选择第一个 simd 值的对应通道，否则选择第二个 simd 值的对应通道。\n\n这个方法通常与比较运算符结合使用。\n\nvar a = simd.float32x4(0, 12, 3, 4);\nvar b = simd.float32x4(0, 6, 7, 50);\n\nvar mask = simd.float32x4.lessthan(a,b);\n// bool32x4[false, false, true, true]\n\nvar result = simd.float32x4.select(mask, a, b);\n// float32x4[0, 6, 3, 4]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，先通过lessthan方法生成一个掩码，然后通过select方法生成一个由每个通道的较小值组成的新的 simd 值。\n\n\n# simd.%booleantype%.alltrue()，simd.%booleantype%.anytrue()\n\nalltrue方法接受一个 simd 值作为参数，然后返回一个布尔值，表示该 simd 值的所有通道是否都为true。\n\nvar a = simd.bool32x4(true, true, true, true);\nvar b = simd.bool32x4(true, false, true, true);\n\nsimd.bool32x4.alltrue(a); // true\nsimd.bool32x4.alltrue(b); // false\n\n\n1\n2\n3\n4\n5\n\n\nanytrue方法则是只要有一个通道为true，就返回true，否则返回false。\n\nvar a = simd.bool32x4(false, false, false, false);\nvar b = simd.bool32x4(false, false, true, false);\n\nsimd.bool32x4.anytrue(a); // false\nsimd.bool32x4.anytrue(b); // true\n\n\n1\n2\n3\n4\n5\n\n\n注意，只有四种布尔值数据类型（bool32x4、bool16x8、bool8x16、bool64x2）才有这两个方法。\n\n这两个方法通常与比较运算符结合使用。\n\nvar ax4    = simd.float32x4(1.0, 2.0, 3.0, 4.0);\nvar bx4    = simd.float32x4(0.0, 6.0, 7.0, 8.0);\nvar ix4    = simd.float32x4.lessthan(ax4, bx4);\nvar b1     = simd.int32x4.alltrue(ix4); // false\nvar b2     = simd.int32x4.anytrue(ix4); // true\n\n\n1\n2\n3\n4\n5\n\n\n\n# simd.%type%.min()，simd.%type%.minnum()\n\nmin方法接受两个 simd 值作为参数，将两者的对应通道的较小值，组成一个新的 simd 值返回。\n\nvar a = simd.float32x4(-1, -2, 3, 5.2);\nvar b = simd.float32x4(0, -4, 6, 5.5);\nsimd.float32x4.min(a, b);\n// float32x4[-1, -4, 3, 5.2]\n\n\n1\n2\n3\n4\n\n\n如果有一个通道的值是nan，则会优先返回nan。\n\nvar c = simd.float64x2(nan, infinity)\nvar d = simd.float64x2(1337, 42);\nsimd.float64x2.min(c, d);\n// float64x2[nan, 42]\n\n\n1\n2\n3\n4\n\n\nminnum方法与min的作用一模一样，唯一的区别是如果有一个通道的值是nan，则会优先返回另一个通道的值。\n\nvar ax4 = simd.float32x4(1.0, 2.0, nan, nan);\nvar bx4 = simd.float32x4(2.0, 1.0, 3.0, nan);\nvar cx4 = simd.float32x4.min(ax4, bx4);\n// float32x4[1.0, 1.0, nan, nan]\nvar dx4 = simd.float32x4.minnum(ax4, bx4);\n// float32x4[1.0, 1.0, 3.0, nan]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# simd.%type%.max()，simd.%type%.maxnum()\n\nmax方法接受两个 simd 值作为参数，将两者的对应通道的较大值，组成一个新的 simd 值返回。\n\nvar a = simd.float32x4(-1, -2, 3, 5.2);\nvar b = simd.float32x4(0, -4, 6, 5.5);\nsimd.float32x4.max(a, b);\n// float32x4[0, -2, 6, 5.5]\n\n\n1\n2\n3\n4\n\n\n如果有一个通道的值是nan，则会优先返回nan。\n\nvar c = simd.float64x2(nan, infinity)\nvar d = simd.float64x2(1337, 42);\nsimd.float64x2.max(c, d)\n// float64x2[nan, infinity]\n\n\n1\n2\n3\n4\n\n\nmaxnum方法与max的作用一模一样，唯一的区别是如果有一个通道的值是nan，则会优先返回另一个通道的值。\n\nvar c = simd.float64x2(nan, infinity)\nvar d = simd.float64x2(1337, 42);\nsimd.float64x2.maxnum(c, d)\n// float64x2[1337, infinity]\n\n\n1\n2\n3\n4\n\n\n\n# 静态方法：位运算\n\n\n# simd.%type%.and()，simd.%type%.or()，simd.%type%.xor()，simd.%type%.not()\n\nand方法接受两个 simd 值作为参数，返回两者对应的通道进行二进制and运算（&）后得到的新的 simd 值。\n\nvar a = simd.int32x4(1, 2, 4, 8);\nvar b = simd.int32x4(5, 5, 5, 5);\nsimd.int32x4.and(a, b)\n// int32x4[1, 0, 4, 0]\n\n\n1\n2\n3\n4\n\n\n上面代码中，以通道0为例，1的二进制形式是0001，5的二进制形式是01001，所以进行and运算以后，得到0001。\n\nor方法接受两个 simd 值作为参数，返回两者对应的通道进行二进制or运算（|）后得到的新的 simd 值。\n\nvar a = simd.int32x4(1, 2, 4, 8);\nvar b = simd.int32x4(5, 5, 5, 5);\nsimd.int32x4.or(a, b)\n// int32x4[5, 7, 5, 13]\n\n\n1\n2\n3\n4\n\n\nxor方法接受两个 simd 值作为参数，返回两者对应的通道进行二进制“异或”运算（^）后得到的新的 simd 值。\n\nvar a = simd.int32x4(1, 2, 4, 8);\nvar b = simd.int32x4(5, 5, 5, 5);\nsimd.int32x4.xor(a, b)\n// int32x4[4, 7, 1, 13]\n\n\n1\n2\n3\n4\n\n\nnot方法接受一个 simd 值作为参数，返回每个通道进行二进制“否”运算（~）后得到的新的 simd 值。\n\nvar a = simd.int32x4(1, 2, 4, 8);\nsimd.int32x4.not(a)\n// int32x4[-2, -3, -5, -9]\n\n\n1\n2\n3\n\n\n上面代码中，1的否运算之所以得到-2，是因为在计算机内部，负数采用”2 的补码“这种形式进行表示。也就是说，整数n的负数形式-n，是对每一个二进制位取反以后，再加上 1。因此，直接取反就相当于负数形式再减去 1，比如1的负数形式是-1，再减去 1，就得到了-2。\n\n\n# 静态方法：数据类型转换\n\nsimd 提供以下方法，用来将一种数据类型转为另一种数据类型。\n\n * simd.%type%.fromfloat32x4()\n * simd.%type%.fromfloat32x4bits()\n * simd.%type%.fromfloat64x2bits()\n * simd.%type%.fromint32x4()\n * simd.%type%.fromint32x4bits()\n * simd.%type%.fromint16x8bits()\n * simd.%type%.fromint8x16bits()\n * simd.%type%.fromuint32x4()\n * simd.%type%.fromuint32x4bits()\n * simd.%type%.fromuint16x8bits()\n * simd.%type%.fromuint8x16bits()\n\n带有bits后缀的方法，会原封不动地将二进制位拷贝到新的数据类型；不带后缀的方法，则会进行数据类型转换。\n\nvar t = simd.float32x4(1.0, 2.0, 3.0, 4.0);\nsimd.int32x4.fromfloat32x4(t);\n// int32x4[1, 2, 3, 4]\n\nsimd.int32x4.fromfloat32x4bits(t);\n// int32x4[1065353216, 1073741824, 1077936128, 1082130432]\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，fromfloat32x4是将浮点数转为整数，然后存入新的数据类型；fromfloat32x4bits则是将二进制位原封不动地拷贝进入新的数据类型，然后进行解读。\n\nbits后缀的方法，还可以用于通道数目不对等的拷贝。\n\nvar t = simd.float32x4(1.0, 2.0, 3.0, 4.0);\nsimd.int16x8.fromfloat32x4bits(t);\n// int16x8[0, 16256, 0, 16384, 0, 16448, 0, 16512]\n\n\n1\n2\n3\n\n\n上面代码中，原始 simd 值t是 4 通道的，而目标值是 8 通道的。\n\n如果数据转换时，原通道的数据大小，超过了目标通道的最大宽度，就会报错。\n\n\n# 实例方法\n\n\n# simd.%type%.prototype.tostring()\n\ntostring方法返回一个 simd 值的字符串形式。\n\nvar a = simd.float32x4(11, 22, 33, 44);\na.tostring() // \"simd.float32x4(11, 22, 33, 44)\"\n\n\n1\n2\n\n\n\n# 实例：求平均值\n\n正常模式下，计算n个值的平均值，需要运算n次。\n\nfunction average(list) {\n  var n = list.length;\n  var sum = 0.0;\n  for (var i = 0; i < n; i++) {\n    sum += list[i];\n  }\n  return sum / n;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用 simd，可以将计算次数减少到n次的四分之一。\n\nfunction average(list) {\n  var n = list.length;\n  var sum = simd.float32x4.splat(0.0);\n  for (var i = 0; i < n; i += 4) {\n    sum = simd.float32x4.add(\n      sum,\n      simd.float32x4.load(list, i)\n    );\n  }\n  var total = simd.float32x4.extractlane(sum, 0) +\n              simd.float32x4.extractlane(sum, 1) +\n              simd.float32x4.extractlane(sum, 2) +\n              simd.float32x4.extractlane(sum, 3);\n  return total / n;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码先是每隔四位，将所有的值读入一个 simd，然后立刻累加。然后，得到累加值四个通道的总和，再除以n就可以了。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"参考链接",frontmatter:{title:"参考链接",date:"2020-02-09T16:00:30.000Z",permalink:"/pages/ea6f3b870f6dab69",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/34.%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5.html",relativePath:"《ES6 教程》笔记/34.参考链接.md",key:"v-21627c86",path:"/pages/ea6f3b870f6dab69/",headers:[{level:2,title:"官方文件",slug:"官方文件",normalizedTitle:"官方文件",charIndex:11},{level:2,title:"综合介绍",slug:"综合介绍",normalizedTitle:"综合介绍",charIndex:570},{level:2,title:"let 和 const",slug:"let-和-const",normalizedTitle:"let 和 const",charIndex:1739},{level:2,title:"解构赋值",slug:"解构赋值",normalizedTitle:"解构赋值",charIndex:2258},{level:2,title:"字符串",slug:"字符串",normalizedTitle:"字符串",charIndex:2398},{level:2,title:"正则",slug:"正则",normalizedTitle:"正则",charIndex:2769},{level:2,title:"数值",slug:"数值",normalizedTitle:"数值",charIndex:3150},{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:3345},{level:2,title:"函数",slug:"函数",normalizedTitle:"函数",charIndex:2097},{level:2,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:2149},{level:2,title:"Symbol",slug:"symbol",normalizedTitle:"symbol",charIndex:4956},{level:2,title:"Set 和 Map",slug:"set-和-map",normalizedTitle:"set 和 map",charIndex:5402},{level:2,title:"Proxy 和 Reflect",slug:"proxy-和-reflect",normalizedTitle:"proxy 和 reflect",charIndex:5747},{level:2,title:"Promise 对象",slug:"promise-对象",normalizedTitle:"promise 对象",charIndex:6553},{level:2,title:"Iterator",slug:"iterator",normalizedTitle:"iterator",charIndex:7246},{level:2,title:"Generator",slug:"generator",normalizedTitle:"generator",charIndex:7525},{level:2,title:"异步操作和 Async 函数",slug:"异步操作和-async-函数",normalizedTitle:"异步操作和 async 函数",charIndex:8819},{level:2,title:"Class",slug:"class",normalizedTitle:"class",charIndex:9667},{level:2,title:"Decorator",slug:"decorator",normalizedTitle:"decorator",charIndex:10254},{level:2,title:"Module",slug:"module",normalizedTitle:"module",charIndex:10701},{level:2,title:"二进制数组",slug:"二进制数组",normalizedTitle:"二进制数组",charIndex:11437},{level:2,title:"SIMD",slug:"simd",normalizedTitle:"simd",charIndex:11977},{level:2,title:"工具",slug:"工具",normalizedTitle:"工具",charIndex:12105}],headersStr:"官方文件 综合介绍 let 和 const 解构赋值 字符串 正则 数值 数组 函数 对象 Symbol Set 和 Map Proxy 和 Reflect Promise 对象 Iterator Generator 异步操作和 Async 函数 Class Decorator Module 二进制数组 SIMD 工具",content:"# 参考链接\n\n\n# 官方文件\n\n * ECMAScript® 2015 Language Specification: ECMAScript 2015 规格\n * ECMAScript® 2016 Language Specification: ECMAScript 2016 规格\n * ECMAScript® 2017 Language Specification：ECMAScript 2017 规格（草案）\n * ECMAScript Current Proposals: ECMAScript 当前的所有提案\n * ECMAScript Active Proposals: 已经进入正式流程的提案\n * ECMAScript proposals：从阶段 0 到阶段 4 的所有提案列表\n * TC39 meeting agendas: TC39 委员会历年的会议记录\n * ECMAScript Daily: TC39 委员会的动态\n * The TC39 Process: 提案进入正式规格的流程\n * TC39: A Process Sketch, Stages 0 and 1: Stage 0 和 Stage 1 的含义\n * TC39 Process Sketch, Stage 2: Stage 2 的含义\n\n\n# 综合介绍\n\n * Axel Rauschmayer, Exploring ES6: Upgrade to the next version of JavaScript: ES6 的专著，本书的许多代码实例来自该书\n * Sayanee Basu, Use ECMAScript 6 Today\n * Ariya Hidayat, Toward Modern Web Apps with ECMAScript 6\n * Dale Schouten, 10 Ecmascript-6 tricks you can perform right now\n * Colin Toh, Lightweight ES6 Features That Pack A Punch: ES6 的一些“轻量级”的特性介绍\n * Domenic Denicola, ES6: The Awesome Parts\n * Nicholas C. Zakas, Understanding ECMAScript 6\n * Justin Drake, ECMAScript 6 in Node.JS\n * Ryan Dao, Summary of ECMAScript 6 major features\n * Luke Hoban, ES6 features: ES6 新语法点的罗列\n * Traceur-compiler, Language Features: Traceur 文档列出的一些 ES6 例子\n * Axel Rauschmayer, ECMAScript 6: what’s next for JavaScript?: 关于 ES6 新增语法的综合介绍，有很多例子\n * Axel Rauschmayer, Getting started with ECMAScript 6: ES6 语法点的综合介绍\n * Toby Ho, ES6 in io.js\n * Guillermo Rauch, ECMAScript 6\n * Benjamin De Cock, Frontend Guidelines: ES6 最佳实践\n * Jani Hartikainen, ES6: What are the benefits of the new features in practice?\n * kangax, JavaScript quiz. ES6 edition: ES6 小测试\n * Jeremy Fairbank, HTML5DevConf ES7 and Beyond!: ES7 新增语法点介绍\n * Timothy Gu, How to Read the ECMAScript Specification: 如何读懂 ES6 规格\n\n\n# let 和 const\n\n * Kyle Simpson, For and against let: 讨论 let 命令的作用域\n * kangax, Why typeof is no longer “safe”: 讨论在块级作用域内，let 命令的变量声明和赋值的行为\n * Axel Rauschmayer, Variables and scoping in ECMAScript 6: 讨论块级作用域与 let 和 const 的行为\n * Nicolas Bevacqua, ES6 Let, Const and the “Temporal Dead Zone” (TDZ) in Depth\n * acorn, Function statements in strict mode: 块级作用域对严格模式的函数声明的影响\n * Axel Rauschmayer, ES proposal: global: 顶层对象global\n * Mathias Bynens, A horrifying globalThis polyfill in universal JavaScript：如何写 globalThis 的垫片库\n\n\n# 解构赋值\n\n * Nick Fitzgerald, Destructuring Assignment in ECMAScript 6: 详细介绍解构赋值的用法\n * Nicholas C. Zakas, ECMAScript 6 destructuring gotcha\n\n\n# 字符串\n\n * Nicholas C. Zakas, A critical review of ECMAScript 6 quasi-literals\n * Mozilla Developer Network, Template strings\n * Addy Osmani, Getting Literal With ES6 Template Strings: 模板字符串的介绍\n * Blake Winton, ES6 Templates: 模板字符串的介绍\n * Peter Jaszkowiak, How to write a template compiler in JavaScript: 使用模板字符串，编写一个模板编译函数\n * Axel Rauschmayer, ES.stage3: string padding\n\n\n# 正则\n\n * Mathias Bynens, Unicode-aware regular expressions in ES6: 详细介绍正则表达式的 u 修饰符\n * Axel Rauschmayer, New regular expression features in ECMAScript 6：ES6 正则特性的详细介绍\n * Yang Guo, RegExp lookbehind assertions：介绍后行断言\n * Axel Rauschmayer, ES proposal: RegExp named capture groups: 具名组匹配的介绍\n * Mathias Bynens, ECMAScript regular expressions are getting better!: 介绍 ES2018 添加的多项正则语法\n\n\n# 数值\n\n * Nicolas Bevacqua, ES6 Number Improvements in Depth\n * Axel Rauschmayer, ES proposal: arbitrary precision integers\n * Mathias Bynens, BigInt: arbitrary-precision integers in JavaScript\n\n\n# 数组\n\n * Axel Rauschmayer, ECMAScript 6’s new array methods: 对 ES6 新增的数组方法的全面介绍\n * TC39, Array.prototype.includes: 数组的 includes 方法的规格\n * Axel Rauschmayer, ECMAScript 6: holes in Arrays: 数组的空位问题\n\n\n# 函数\n\n * Nicholas C. Zakas, Understanding ECMAScript 6 arrow functions\n * Jack Franklin, Real Life ES6 - Arrow Functions\n * Axel Rauschmayer, Handling required parameters in ECMAScript 6\n * Dmitry Soshnikov, ES6 Notes: Default values of parameters: 介绍参数的默认值\n * Ragan Wald, Destructuring and Recursion in ES6: rest 参数和扩展运算符的详细介绍\n * Axel Rauschmayer, The names of functions in ES6: 函数的 name 属性的详细介绍\n * Kyle Simpson, Arrow This: 箭头函数并没有自己的 this\n * Derick Bailey, Do ES6 Arrow Functions Really Solve “this” In JavaScript?：使用箭头函数处理 this 指向，必须非常小心\n * Mark McDonnell, Understanding recursion in functional JavaScript programming: 如何自己实现尾递归优化\n * Nicholas C. Zakas, The ECMAScript 2016 change you probably don't know: 使用参数默认值时，不能在函数内部显式开启严格模式\n * Axel Rauschmayer, ES proposal: optional catch binding\n * Cynthia Lee, When you should use ES6 arrow functions — and when you shouldn’t: 讨论箭头函数的适用场合\n * Eric Elliott, What is this?: 箭头函数内部的 this 的解释。\n\n\n# 对象\n\n * Addy Osmani, Data-binding Revolutions with Object.observe(): 介绍 Object.observe()的概念\n * Sella Rafaeli, Native JavaScript Data-Binding: 如何使用 Object.observe 方法，实现数据对象与 DOM 对象的双向绑定\n * Axel Rauschmayer, __proto__ in ECMAScript 6\n * Axel Rauschmayer, Enumerability in ECMAScript 6\n * Axel Rauschmayer, ES proposal: Object.getOwnPropertyDescriptors()\n * TC39, Object.getOwnPropertyDescriptors Proposal\n * David Titarenco, How Spread Syntax Breaks JavaScript: 扩展运算符的一些不合理的地方\n\n\n# Symbol\n\n * Axel Rauschmayer, Symbols in ECMAScript 6: Symbol 简介\n * MDN, Symbol: Symbol 类型的详细介绍\n * Jason Orendorff, ES6 In Depth: Symbols\n * Keith Cirkel, Metaprogramming in ES6: Symbols and why they're awesome: Symbol 的深入介绍\n * Axel Rauschmayer, Customizing ES6 via well-known symbols\n * Derick Bailey, Creating A True Singleton In Node.js, With ES6 Symbols\n * Das Surma, How to read web specs Part IIa – Or: ECMAScript Symbols: 介绍 Symbol 的规格\n\n\n# Set 和 Map\n\n * Mozilla Developer Network, WeakSet：介绍 WeakSet 数据结构\n * Dwayne Charrington, What Are Weakmaps In ES6?: WeakMap 数据结构介绍\n * Axel Rauschmayer, ECMAScript 6: maps and sets: Set 和 Map 结构的详细介绍\n * Jason Orendorff, ES6 In Depth: Collections：Set 和 Map 结构的设计思想\n * Axel Rauschmayer, Converting ES6 Maps to and from JSON: 如何将 Map 与其他数据结构互相转换\n\n\n# Proxy 和 Reflect\n\n * Nicholas C. Zakas, Creating defensive objects with ES6 proxies\n * Axel Rauschmayer, Meta programming with ECMAScript 6 proxies: Proxy 详解\n * Daniel Zautner, Meta-programming JavaScript Using Proxies: 使用 Proxy 实现元编程\n * Tom Van Cutsem, Harmony-reflect: Reflect 对象的设计目的\n * Tom Van Cutsem, Proxy Traps: Proxy 拦截操作一览\n * Tom Van Cutsem, Reflect API\n * Tom Van Cutsem, Proxy Handler API\n * Nicolas Bevacqua, ES6 Proxies in Depth\n * Nicolas Bevacqua, ES6 Proxy Traps in Depth\n * Nicolas Bevacqua, More ES6 Proxy Traps in Depth\n * Axel Rauschmayer, Pitfall: not all objects can be wrapped transparently by proxies\n * Bertalan Miklos, Writing a JavaScript Framework - Data Binding with ES6 Proxies: 使用 Proxy 实现观察者模式\n * Keith Cirkel, Metaprogramming in ES6: Part 2 - Reflect: Reflect API 的详细介绍\n\n\n# Promise 对象\n\n * Jake Archibald, JavaScript Promises: There and back again\n * Jake Archibald, Tasks, microtasks, queues and schedules\n * Tilde, rsvp.js\n * Sandeep Panda, An Overview of JavaScript Promises: ES6 Promise 入门介绍\n * Dave Atchley, ES6 Promises: Promise 的语法介绍\n * Axel Rauschmayer, ECMAScript 6 promises (2/2): the API: 对 ES6 Promise 规格和用法的详细介绍\n * Jack Franklin, Embracing Promises in JavaScript: catch 方法的例子\n * Ronald Chen, How to escape Promise Hell: 如何使用Promise.all方法的一些很好的例子\n * Jordan Harband, proposal-promise-try: Promise.try() 方法的提案\n * Sven Slootweg, What is Promise.try, and why does it matter?: Promise.try() 方法的优点\n * Yehuda Katz, TC39: Promises, Promises: Promise.try() 的用处\n\n\n# Iterator\n\n * Mozilla Developer Network, Iterators and generators\n * Mozilla Developer Network, The Iterator protocol\n * Jason Orendorff, ES6 In Depth: Iterators and the for-of loop: 遍历器与 for...of 循环的介绍\n * Axel Rauschmayer, Iterators and generators in ECMAScript 6: 探讨 Iterator 和 Generator 的设计目的\n * Axel Rauschmayer, Iterables and iterators in ECMAScript 6: Iterator 的详细介绍\n * Kyle Simpson, Iterating ES6 Numbers: 在数值对象上部署遍历器\n\n\n# Generator\n\n * Matt Baker, Replacing callbacks with ES6 Generators\n * Steven Sanderson, Experiments with Koa and JavaScript Generators\n * jmar777, What's the Big Deal with Generators?\n * Marc Harter, Generators in Node.js: Common Misconceptions and Three Good Use Cases: 讨论 Generator 函数的作用\n * StackOverflow, ES6 yield : what happens to the arguments of the first call next()?: 第一次使用 next 方法时不能带有参数\n * Kyle Simpson, ES6 Generators: Complete Series: 由浅入深探讨 Generator 的系列文章，共四篇\n * Gajus Kuizinas, The Definitive Guide to the JavaScript Generators: 对 Generator 的综合介绍\n * Jan Krems, Generators Are Like Arrays: 讨论 Generator 可以被当作数据结构看待\n * Harold Cooper, Coroutine Event Loops in JavaScript: Generator 用于实现状态机\n * Ruslan Ismagilov, learn-generators: 编程练习，共 6 道题\n * Steven Sanderson, Experiments with Koa and JavaScript Generators: Generator 入门介绍，以 Koa 框架为例\n * Mahdi Dibaiee, ES7 Array and Generator comprehensions：ES7 的 Generator 推导\n * Nicolas Bevacqua, ES6 Generators in Depth\n * Axel Rauschmayer, ES6 generators in depth: Generator 规格的详尽讲解\n * Derick Bailey, Using ES6 Generators To Short-Circuit Hierarchical Data Iteration：使用 for...of 循环完成预定的操作步骤\n\n\n# 异步操作和 Async 函数\n\n * Luke Hoban, Async Functions for ECMAScript: Async 函数的设计思想，与 Promise、Gernerator 函数的关系\n * Jafar Husain, Asynchronous Generators for ES7: Async 函数的深入讨论\n * Nolan Lawson, Taming the asynchronous beast with ES7: async 函数通俗的实例讲解\n * Jafar Husain, Async Generators: 对 async 与 Generator 混合使用的一些讨论\n * Daniel Brain, Understand promises before you start using async/await: 讨论 async/await 与 Promise 的关系\n * Jake Archibald, Async functions - making promises friendly\n * Axel Rauschmayer, ES proposal: asynchronous iteration: 异步遍历器的详细介绍\n * Dima Grossman, How to write async await without try-catch blocks in JavaScript: 除了 try/catch 以外的 async 函数内部捕捉错误的方法\n * Mostafa Gaafa, 6 Reasons Why JavaScript’s Async/Await Blows Promises Away: Async 函数的6个好处\n * Mathias Bynens, Asynchronous stack traces: why await beats Promise#then(): async 函数可以保留错误堆栈\n\n\n# Class\n\n * Sebastian Porto, ES6 classes and JavaScript prototypes: ES6 Class 的写法与 ES5 Prototype 的写法对比\n * Jack Franklin, An introduction to ES6 classes: ES6 class 的入门介绍\n * Axel Rauschmayer, ECMAScript 6: new OOP features besides classes\n * Axel Rauschmayer, Classes in ECMAScript 6 (final semantics): Class 语法的详细介绍和设计思想分析\n * Eric Faust, ES6 In Depth: Subclassing: Class 语法的深入介绍\n * Nicolás Bevacqua, Binding Methods to Class Instance Objects: 如何绑定类的实例中的 this\n * Jamie Kyle, JavaScript's new #private class fields：私有属性的介绍。\n * Mathias Bynens, Public and private class fields：实例属性的新写法的介绍。\n\n\n# Decorator\n\n * Maximiliano Fierro, Declarative vs Imperative: Decorators 和 Mixin 介绍\n * Justin Fagnani, \"Real\" Mixins with JavaScript Classes: 使用类的继承实现 Mixin\n * Addy Osmani, Exploring ES2016 Decorators: Decorator 的深入介绍\n * Sebastian McKenzie, Allow decorators for functions as well: 为什么修饰器不能用于函数\n * Maximiliano Fierro, Traits with ES7 Decorators: Trait 的用法介绍\n * Jonathan Creamer: Using ES2016 Decorators to Publish on an Event Bus: 使用修饰器实现自动发布事件\n\n\n# Module\n\n * Jack Franklin, JavaScript Modules the ES6 Way: ES6 模块入门\n * Axel Rauschmayer, ECMAScript 6 modules: the final syntax: ES6 模块的介绍，以及与 CommonJS 规格的详细比较\n * Dave Herman, Static module resolution: ES6 模块的静态化设计思想\n * Jason Orendorff, ES6 In Depth: Modules: ES6 模块设计思想的介绍\n * Ben Newman, The Importance of import and export: ES6 模块的设计思想\n * ESDiscuss, Why is \"export default var a = 1;\" invalid syntax?\n * Bradley Meck, ES6 Module Interoperability: 介绍 Node 如何处理 ES6 语法加载 CommonJS 模块\n * Axel Rauschmayer, Making transpiled ES modules more spec-compliant: ES6 模块编译成 CommonJS 模块的详细介绍\n * Axel Rauschmayer, ES proposal: import() – dynamically importing ES modules: import() 的用法\n * Node EPS, ES Module Interoperability: Node 对 ES6 模块的处理规格\n\n\n# 二进制数组\n\n * Ilmari Heikkinen, Typed Arrays: Binary Data in the Browser\n * Khronos, Typed Array Specification\n * Ian Elliot, Reading A BMP File In JavaScript\n * Renato Mangini, How to convert ArrayBuffer to and from String\n * Axel Rauschmayer, Typed Arrays in ECMAScript 6\n * Axel Rauschmayer, ES proposal: Shared memory and atomics\n * Lin Clark, Avoiding race conditions in SharedArrayBuffers with Atomics: Atomics 对象使用场景的解释\n * Lars T Hansen, Shared memory - a brief tutorial\n * James Milner, The Return of SharedArrayBuffers and Atomics\n\n\n# SIMD\n\n * TC39, SIMD.js Stage 2\n * MDN, SIMD\n * TC39, ECMAScript SIMD\n * Axel Rauschmayer, JavaScript gains support for SIMD\n\n\n# 工具\n\n * Babel, Babel Handbook: Babel 的用法介绍\n * Google, traceur-compiler: Traceur 编译器\n * Casper Beyer, ECMAScript 6 Features and Tools\n * Stoyan Stefanov, Writing ES6 today with jstransform\n * ES6 Module Loader, ES6 Module Loader Polyfill: 在浏览器和 node.js 加载 ES6 模块的一个库，文档里对 ES6 模块有详细解释\n * Paul Miller, es6-shim: 一个针对老式浏览器，模拟 ES6 部分功能的垫片库（shim）\n * army8735, JavaScript Downcast: 国产的 ES6 到 ES5 的转码器\n * esnext, ES6 Module Transpiler：基于 node.js 的将 ES6 模块转为 ES5 代码的命令行工具\n * Sebastian McKenzie, BabelJS: ES6 转译器\n * SystemJS, SystemJS: 在浏览器中加载 AMD、CJS、ES6 模块的一个垫片库\n * Modernizr, HTML5 Cross Browser Polyfills: ES6 垫片库清单\n * Facebook, regenerator: 将 Generator 函数转为 ES5 的转码器",normalizedContent:"# 参考链接\n\n\n# 官方文件\n\n * ecmascript® 2015 language specification: ecmascript 2015 规格\n * ecmascript® 2016 language specification: ecmascript 2016 规格\n * ecmascript® 2017 language specification：ecmascript 2017 规格（草案）\n * ecmascript current proposals: ecmascript 当前的所有提案\n * ecmascript active proposals: 已经进入正式流程的提案\n * ecmascript proposals：从阶段 0 到阶段 4 的所有提案列表\n * tc39 meeting agendas: tc39 委员会历年的会议记录\n * ecmascript daily: tc39 委员会的动态\n * the tc39 process: 提案进入正式规格的流程\n * tc39: a process sketch, stages 0 and 1: stage 0 和 stage 1 的含义\n * tc39 process sketch, stage 2: stage 2 的含义\n\n\n# 综合介绍\n\n * axel rauschmayer, exploring es6: upgrade to the next version of javascript: es6 的专著，本书的许多代码实例来自该书\n * sayanee basu, use ecmascript 6 today\n * ariya hidayat, toward modern web apps with ecmascript 6\n * dale schouten, 10 ecmascript-6 tricks you can perform right now\n * colin toh, lightweight es6 features that pack a punch: es6 的一些“轻量级”的特性介绍\n * domenic denicola, es6: the awesome parts\n * nicholas c. zakas, understanding ecmascript 6\n * justin drake, ecmascript 6 in node.js\n * ryan dao, summary of ecmascript 6 major features\n * luke hoban, es6 features: es6 新语法点的罗列\n * traceur-compiler, language features: traceur 文档列出的一些 es6 例子\n * axel rauschmayer, ecmascript 6: what’s next for javascript?: 关于 es6 新增语法的综合介绍，有很多例子\n * axel rauschmayer, getting started with ecmascript 6: es6 语法点的综合介绍\n * toby ho, es6 in io.js\n * guillermo rauch, ecmascript 6\n * benjamin de cock, frontend guidelines: es6 最佳实践\n * jani hartikainen, es6: what are the benefits of the new features in practice?\n * kangax, javascript quiz. es6 edition: es6 小测试\n * jeremy fairbank, html5devconf es7 and beyond!: es7 新增语法点介绍\n * timothy gu, how to read the ecmascript specification: 如何读懂 es6 规格\n\n\n# let 和 const\n\n * kyle simpson, for and against let: 讨论 let 命令的作用域\n * kangax, why typeof is no longer “safe”: 讨论在块级作用域内，let 命令的变量声明和赋值的行为\n * axel rauschmayer, variables and scoping in ecmascript 6: 讨论块级作用域与 let 和 const 的行为\n * nicolas bevacqua, es6 let, const and the “temporal dead zone” (tdz) in depth\n * acorn, function statements in strict mode: 块级作用域对严格模式的函数声明的影响\n * axel rauschmayer, es proposal: global: 顶层对象global\n * mathias bynens, a horrifying globalthis polyfill in universal javascript：如何写 globalthis 的垫片库\n\n\n# 解构赋值\n\n * nick fitzgerald, destructuring assignment in ecmascript 6: 详细介绍解构赋值的用法\n * nicholas c. zakas, ecmascript 6 destructuring gotcha\n\n\n# 字符串\n\n * nicholas c. zakas, a critical review of ecmascript 6 quasi-literals\n * mozilla developer network, template strings\n * addy osmani, getting literal with es6 template strings: 模板字符串的介绍\n * blake winton, es6 templates: 模板字符串的介绍\n * peter jaszkowiak, how to write a template compiler in javascript: 使用模板字符串，编写一个模板编译函数\n * axel rauschmayer, es.stage3: string padding\n\n\n# 正则\n\n * mathias bynens, unicode-aware regular expressions in es6: 详细介绍正则表达式的 u 修饰符\n * axel rauschmayer, new regular expression features in ecmascript 6：es6 正则特性的详细介绍\n * yang guo, regexp lookbehind assertions：介绍后行断言\n * axel rauschmayer, es proposal: regexp named capture groups: 具名组匹配的介绍\n * mathias bynens, ecmascript regular expressions are getting better!: 介绍 es2018 添加的多项正则语法\n\n\n# 数值\n\n * nicolas bevacqua, es6 number improvements in depth\n * axel rauschmayer, es proposal: arbitrary precision integers\n * mathias bynens, bigint: arbitrary-precision integers in javascript\n\n\n# 数组\n\n * axel rauschmayer, ecmascript 6’s new array methods: 对 es6 新增的数组方法的全面介绍\n * tc39, array.prototype.includes: 数组的 includes 方法的规格\n * axel rauschmayer, ecmascript 6: holes in arrays: 数组的空位问题\n\n\n# 函数\n\n * nicholas c. zakas, understanding ecmascript 6 arrow functions\n * jack franklin, real life es6 - arrow functions\n * axel rauschmayer, handling required parameters in ecmascript 6\n * dmitry soshnikov, es6 notes: default values of parameters: 介绍参数的默认值\n * ragan wald, destructuring and recursion in es6: rest 参数和扩展运算符的详细介绍\n * axel rauschmayer, the names of functions in es6: 函数的 name 属性的详细介绍\n * kyle simpson, arrow this: 箭头函数并没有自己的 this\n * derick bailey, do es6 arrow functions really solve “this” in javascript?：使用箭头函数处理 this 指向，必须非常小心\n * mark mcdonnell, understanding recursion in functional javascript programming: 如何自己实现尾递归优化\n * nicholas c. zakas, the ecmascript 2016 change you probably don't know: 使用参数默认值时，不能在函数内部显式开启严格模式\n * axel rauschmayer, es proposal: optional catch binding\n * cynthia lee, when you should use es6 arrow functions — and when you shouldn’t: 讨论箭头函数的适用场合\n * eric elliott, what is this?: 箭头函数内部的 this 的解释。\n\n\n# 对象\n\n * addy osmani, data-binding revolutions with object.observe(): 介绍 object.observe()的概念\n * sella rafaeli, native javascript data-binding: 如何使用 object.observe 方法，实现数据对象与 dom 对象的双向绑定\n * axel rauschmayer, __proto__ in ecmascript 6\n * axel rauschmayer, enumerability in ecmascript 6\n * axel rauschmayer, es proposal: object.getownpropertydescriptors()\n * tc39, object.getownpropertydescriptors proposal\n * david titarenco, how spread syntax breaks javascript: 扩展运算符的一些不合理的地方\n\n\n# symbol\n\n * axel rauschmayer, symbols in ecmascript 6: symbol 简介\n * mdn, symbol: symbol 类型的详细介绍\n * jason orendorff, es6 in depth: symbols\n * keith cirkel, metaprogramming in es6: symbols and why they're awesome: symbol 的深入介绍\n * axel rauschmayer, customizing es6 via well-known symbols\n * derick bailey, creating a true singleton in node.js, with es6 symbols\n * das surma, how to read web specs part iia – or: ecmascript symbols: 介绍 symbol 的规格\n\n\n# set 和 map\n\n * mozilla developer network, weakset：介绍 weakset 数据结构\n * dwayne charrington, what are weakmaps in es6?: weakmap 数据结构介绍\n * axel rauschmayer, ecmascript 6: maps and sets: set 和 map 结构的详细介绍\n * jason orendorff, es6 in depth: collections：set 和 map 结构的设计思想\n * axel rauschmayer, converting es6 maps to and from json: 如何将 map 与其他数据结构互相转换\n\n\n# proxy 和 reflect\n\n * nicholas c. zakas, creating defensive objects with es6 proxies\n * axel rauschmayer, meta programming with ecmascript 6 proxies: proxy 详解\n * daniel zautner, meta-programming javascript using proxies: 使用 proxy 实现元编程\n * tom van cutsem, harmony-reflect: reflect 对象的设计目的\n * tom van cutsem, proxy traps: proxy 拦截操作一览\n * tom van cutsem, reflect api\n * tom van cutsem, proxy handler api\n * nicolas bevacqua, es6 proxies in depth\n * nicolas bevacqua, es6 proxy traps in depth\n * nicolas bevacqua, more es6 proxy traps in depth\n * axel rauschmayer, pitfall: not all objects can be wrapped transparently by proxies\n * bertalan miklos, writing a javascript framework - data binding with es6 proxies: 使用 proxy 实现观察者模式\n * keith cirkel, metaprogramming in es6: part 2 - reflect: reflect api 的详细介绍\n\n\n# promise 对象\n\n * jake archibald, javascript promises: there and back again\n * jake archibald, tasks, microtasks, queues and schedules\n * tilde, rsvp.js\n * sandeep panda, an overview of javascript promises: es6 promise 入门介绍\n * dave atchley, es6 promises: promise 的语法介绍\n * axel rauschmayer, ecmascript 6 promises (2/2): the api: 对 es6 promise 规格和用法的详细介绍\n * jack franklin, embracing promises in javascript: catch 方法的例子\n * ronald chen, how to escape promise hell: 如何使用promise.all方法的一些很好的例子\n * jordan harband, proposal-promise-try: promise.try() 方法的提案\n * sven slootweg, what is promise.try, and why does it matter?: promise.try() 方法的优点\n * yehuda katz, tc39: promises, promises: promise.try() 的用处\n\n\n# iterator\n\n * mozilla developer network, iterators and generators\n * mozilla developer network, the iterator protocol\n * jason orendorff, es6 in depth: iterators and the for-of loop: 遍历器与 for...of 循环的介绍\n * axel rauschmayer, iterators and generators in ecmascript 6: 探讨 iterator 和 generator 的设计目的\n * axel rauschmayer, iterables and iterators in ecmascript 6: iterator 的详细介绍\n * kyle simpson, iterating es6 numbers: 在数值对象上部署遍历器\n\n\n# generator\n\n * matt baker, replacing callbacks with es6 generators\n * steven sanderson, experiments with koa and javascript generators\n * jmar777, what's the big deal with generators?\n * marc harter, generators in node.js: common misconceptions and three good use cases: 讨论 generator 函数的作用\n * stackoverflow, es6 yield : what happens to the arguments of the first call next()?: 第一次使用 next 方法时不能带有参数\n * kyle simpson, es6 generators: complete series: 由浅入深探讨 generator 的系列文章，共四篇\n * gajus kuizinas, the definitive guide to the javascript generators: 对 generator 的综合介绍\n * jan krems, generators are like arrays: 讨论 generator 可以被当作数据结构看待\n * harold cooper, coroutine event loops in javascript: generator 用于实现状态机\n * ruslan ismagilov, learn-generators: 编程练习，共 6 道题\n * steven sanderson, experiments with koa and javascript generators: generator 入门介绍，以 koa 框架为例\n * mahdi dibaiee, es7 array and generator comprehensions：es7 的 generator 推导\n * nicolas bevacqua, es6 generators in depth\n * axel rauschmayer, es6 generators in depth: generator 规格的详尽讲解\n * derick bailey, using es6 generators to short-circuit hierarchical data iteration：使用 for...of 循环完成预定的操作步骤\n\n\n# 异步操作和 async 函数\n\n * luke hoban, async functions for ecmascript: async 函数的设计思想，与 promise、gernerator 函数的关系\n * jafar husain, asynchronous generators for es7: async 函数的深入讨论\n * nolan lawson, taming the asynchronous beast with es7: async 函数通俗的实例讲解\n * jafar husain, async generators: 对 async 与 generator 混合使用的一些讨论\n * daniel brain, understand promises before you start using async/await: 讨论 async/await 与 promise 的关系\n * jake archibald, async functions - making promises friendly\n * axel rauschmayer, es proposal: asynchronous iteration: 异步遍历器的详细介绍\n * dima grossman, how to write async await without try-catch blocks in javascript: 除了 try/catch 以外的 async 函数内部捕捉错误的方法\n * mostafa gaafa, 6 reasons why javascript’s async/await blows promises away: async 函数的6个好处\n * mathias bynens, asynchronous stack traces: why await beats promise#then(): async 函数可以保留错误堆栈\n\n\n# class\n\n * sebastian porto, es6 classes and javascript prototypes: es6 class 的写法与 es5 prototype 的写法对比\n * jack franklin, an introduction to es6 classes: es6 class 的入门介绍\n * axel rauschmayer, ecmascript 6: new oop features besides classes\n * axel rauschmayer, classes in ecmascript 6 (final semantics): class 语法的详细介绍和设计思想分析\n * eric faust, es6 in depth: subclassing: class 语法的深入介绍\n * nicolas bevacqua, binding methods to class instance objects: 如何绑定类的实例中的 this\n * jamie kyle, javascript's new #private class fields：私有属性的介绍。\n * mathias bynens, public and private class fields：实例属性的新写法的介绍。\n\n\n# decorator\n\n * maximiliano fierro, declarative vs imperative: decorators 和 mixin 介绍\n * justin fagnani, \"real\" mixins with javascript classes: 使用类的继承实现 mixin\n * addy osmani, exploring es2016 decorators: decorator 的深入介绍\n * sebastian mckenzie, allow decorators for functions as well: 为什么修饰器不能用于函数\n * maximiliano fierro, traits with es7 decorators: trait 的用法介绍\n * jonathan creamer: using es2016 decorators to publish on an event bus: 使用修饰器实现自动发布事件\n\n\n# module\n\n * jack franklin, javascript modules the es6 way: es6 模块入门\n * axel rauschmayer, ecmascript 6 modules: the final syntax: es6 模块的介绍，以及与 commonjs 规格的详细比较\n * dave herman, static module resolution: es6 模块的静态化设计思想\n * jason orendorff, es6 in depth: modules: es6 模块设计思想的介绍\n * ben newman, the importance of import and export: es6 模块的设计思想\n * esdiscuss, why is \"export default var a = 1;\" invalid syntax?\n * bradley meck, es6 module interoperability: 介绍 node 如何处理 es6 语法加载 commonjs 模块\n * axel rauschmayer, making transpiled es modules more spec-compliant: es6 模块编译成 commonjs 模块的详细介绍\n * axel rauschmayer, es proposal: import() – dynamically importing es modules: import() 的用法\n * node eps, es module interoperability: node 对 es6 模块的处理规格\n\n\n# 二进制数组\n\n * ilmari heikkinen, typed arrays: binary data in the browser\n * khronos, typed array specification\n * ian elliot, reading a bmp file in javascript\n * renato mangini, how to convert arraybuffer to and from string\n * axel rauschmayer, typed arrays in ecmascript 6\n * axel rauschmayer, es proposal: shared memory and atomics\n * lin clark, avoiding race conditions in sharedarraybuffers with atomics: atomics 对象使用场景的解释\n * lars t hansen, shared memory - a brief tutorial\n * james milner, the return of sharedarraybuffers and atomics\n\n\n# simd\n\n * tc39, simd.js stage 2\n * mdn, simd\n * tc39, ecmascript simd\n * axel rauschmayer, javascript gains support for simd\n\n\n# 工具\n\n * babel, babel handbook: babel 的用法介绍\n * google, traceur-compiler: traceur 编译器\n * casper beyer, ecmascript 6 features and tools\n * stoyan stefanov, writing es6 today with jstransform\n * es6 module loader, es6 module loader polyfill: 在浏览器和 node.js 加载 es6 模块的一个库，文档里对 es6 模块有详细解释\n * paul miller, es6-shim: 一个针对老式浏览器，模拟 es6 部分功能的垫片库（shim）\n * army8735, javascript downcast: 国产的 es6 到 es5 的转码器\n * esnext, es6 module transpiler：基于 node.js 的将 es6 模块转为 es5 代码的命令行工具\n * sebastian mckenzie, babeljs: es6 转译器\n * systemjs, systemjs: 在浏览器中加载 amd、cjs、es6 模块的一个垫片库\n * modernizr, html5 cross browser polyfills: es6 垫片库清单\n * facebook, regenerator: 将 generator 函数转为 es5 的转码器",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"常用Git命令清单",frontmatter:{title:"常用Git命令清单",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/8292d8/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%89%8B%E5%86%8C/00.%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html",relativePath:"《Git》学习笔记/10.手册/00.常用Git命令清单.md",key:"v-16bacf9d",path:"/pages/8292d8/",headers:[{level:2,title:"一、新建代码库",slug:"一、新建代码库",normalizedTitle:"一、新建代码库",charIndex:187},{level:2,title:"二、配置",slug:"二、配置",normalizedTitle:"二、配置",charIndex:334},{level:2,title:"三、增加/删除文件",slug:"三、增加-删除文件",normalizedTitle:"三、增加/删除文件",charIndex:605},{level:2,title:"四、代码提交",slug:"四、代码提交",normalizedTitle:"四、代码提交",charIndex:1005},{level:2,title:"五、分支",slug:"五、分支",normalizedTitle:"五、分支",charIndex:1406},{level:2,title:"六、标签",slug:"六、标签",normalizedTitle:"六、标签",charIndex:2199},{level:2,title:"七、查看信息",slug:"七、查看信息",normalizedTitle:"七、查看信息",charIndex:2616},{level:2,title:"八、远程同步",slug:"八、远程同步",normalizedTitle:"八、远程同步",charIndex:3725},{level:2,title:"九、撤销",slug:"九、撤销",normalizedTitle:"九、撤销",charIndex:4147},{level:2,title:"十、常用操作组合",slug:"十、常用操作组合",normalizedTitle:"十、常用操作组合",charIndex:4799},{level:3,title:"1. 修改本地分支名和远程分支名",slug:"_1-修改本地分支名和远程分支名",normalizedTitle:"1. 修改本地分支名和远程分支名",charIndex:4812}],headersStr:"一、新建代码库 二、配置 三、增加/删除文件 四、代码提交 五、分支 六、标签 七、查看信息 八、远程同步 九、撤销 十、常用操作组合 1. 修改本地分支名和远程分支名",content:'# 常用Git命令清单\n\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n\n\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\n\n>  * Workspace：工作区\n>  * Index / Stage：暂存区\n>  * Repository：仓库区（或本地仓库）\n>  * Remote：远程仓库\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\nGit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 十、常用操作组合\n\n\n# 1. 修改本地分支名和远程分支名\n\ngit branch -m old_branch new_branch # 重命名本地分支\ngit push origin :old_branch # 删除远程旧分支（分支名前有冒号）\ngit push --set-upstream origin new_branch # 推送新的分支，并设置本地分支跟踪新的远程分支\n\n\n1\n2\n3\n\n\n相关文章：\n\n《如何撤销 Git 操作？》\n\n《git cherry-pick 教程》 复制某分支上的部分提交到另一个分支上（相对于可以选择指定提交的 rebase 操作）。\n\n> 命令清单来源：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html',normalizedContent:'# 常用git命令清单\n\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n\n\n下面是我整理的常用 git 命令清单。几个专用名词的译名如下。\n\n>  * workspace：工作区\n>  * index / stage：暂存区\n>  * repository：仓库区（或本地仓库）\n>  * remote：远程仓库\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个git代码库\n$ git init\n\n# 新建一个目录，将其初始化为git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\ngit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的git配置\n$ git config --list\n\n# 编辑git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagname]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -s [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] head --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] head --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff head\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的head为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前head为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 十、常用操作组合\n\n\n# 1. 修改本地分支名和远程分支名\n\ngit branch -m old_branch new_branch # 重命名本地分支\ngit push origin :old_branch # 删除远程旧分支（分支名前有冒号）\ngit push --set-upstream origin new_branch # 推送新的分支，并设置本地分支跟踪新的远程分支\n\n\n1\n2\n3\n\n\n相关文章：\n\n《如何撤销 git 操作？》\n\n《git cherry-pick 教程》 复制某分支上的部分提交到另一个分支上（相对于可以选择指定提交的 rebase 操作）。\n\n> 命令清单来源：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git命令思维导图",frontmatter:{title:"Git命令思维导图",date:"2020-11-18T17:46:22.000Z",permalink:"/pages/4cbc21/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%89%8B%E5%86%8C/06.Git%E5%91%BD%E4%BB%A4%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",relativePath:"《Git》学习笔记/10.手册/06.Git命令思维导图.md",key:"v-720d8224",path:"/pages/4cbc21/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git变基合并",frontmatter:{title:"Git变基合并",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/c10281/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%89%8B%E5%86%8C/03.Git%E5%8F%98%E5%9F%BA%E5%90%88%E5%B9%B6.html",relativePath:"《Git》学习笔记/10.手册/03.Git变基合并.md",key:"v-52f1734b",path:"/pages/c10281/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:17},{level:3,title:"变基要遵守的准则",slug:"变基要遵守的准则",normalizedTitle:"变基要遵守的准则",charIndex:750},{level:3,title:"变基的实质",slug:"变基的实质",normalizedTitle:"变基的实质",charIndex:815},{level:2,title:"后悔药",slug:"后悔药",normalizedTitle:"后悔药",charIndex:531},{level:2,title:"开发期间的rebase操作",slug:"开发期间的rebase操作",normalizedTitle:"开发期间的rebase操作",charIndex:1887},{level:3,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:1905},{level:3,title:"操作步骤",slug:"操作步骤",normalizedTitle:"操作步骤",charIndex:2159},{level:3,title:"git cherry-pick",slug:"git-cherry-pick",normalizedTitle:"git cherry-pick",charIndex:2524}],headersStr:"说明 变基要遵守的准则 变基的实质 后悔药 开发期间的rebase操作 背景 操作步骤 git cherry-pick",content:"# rebase分支合并\n\n\n# 说明\n\n以下 v2 是某个需求的开发分支， dev是总的开发分支，v2 是基于dev分支签出的。\n\n当完成v2的开发后，需要把代码合并到dev，我们可以使用rebase进行合并：\n\n# 首先将 v2 push到远程仓库\ngit add .\ngit commit -m 'xxx'\ngit push origin v2\n\n# 切换到 dev 拉取最新代码\ngit checkout dev\ngit pull origin dev\n\n# 切换到 v2\ngit checkout v2\ngit rebase dev # 将 v2 的所有[commit] 变基到(应用到) dev\n\n# 切换到 dev\ngit checkout dev\ngit merge v2  # 将 dev分支 快进合并 （此时 (HEAD -> dev, v2) [commit] 两个分支指向同一个提交）\n\n# 查看 原v2的[commit]记录 是否在dev分支的最前面（变基成功会把v2的提交记录应用到dev分支的最前面）\ngit log\n\n\t# 如果到这一步发现有问题，尝试使用 git --abort中止变基，如果还是有问题的可以在dev分支上使用《后悔药》操作， 再到v2分支上使用《后悔药》操作，即可使两个分支都回退到 rebase变基 之前的状态\n\n# 试运行项目是否有问题\nyarn start\n\ngit status # 查看状态是否有问题\ngit push origin dev # 推送到远程仓库的 dev\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 变基要遵守的准则\n\n几个人同时在一个分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 因此，变基操作过后的分支将不要再使用。\n\n\n# 后悔药\n\n# 查看HEAD指针变动记录\ngit reflog\n# 记录示例(当前分支是v2):\n07c398f (HEAD -> v2, master) HEAD@{0}: checkout: moving from master to v2\n07c398f (HEAD -> v2, master) HEAD@{1}: rebase (finish): returning to refs/heads/master\n07c398f (HEAD -> v2, master) HEAD@{2}: rebase (start): checkout v2\n15a97d8 HEAD@{3}: reset: moving to 15a97d8\n07c398f (HEAD -> v2, master) HEAD@{4}: merge v2: Fast-forward\n15a97d8 HEAD@{5}: checkout: moving from v2 to master\n07c398f (HEAD -> v2, master) HEAD@{6}: rebase (finish): returning to refs/heads/v2\n07c398f (HEAD -> v2, master) HEAD@{7}: rebase (pick): C\n15a97d8 HEAD@{8}: rebase (start): checkout master # 首次rebase\nd278ecd HEAD@{9}: checkout: moving from master to v2 # rebase前的状态\n15a97d8 HEAD@{10}: commit: D\n\n# 可见，示例中最初的 rebase 操作是 HEAD@{8}，想回退到变基前的状态需让指针指向 HEAD@{9}\ngit reset --hard d278ecd  # 重置当前分支的HEAD为指定[commit]，同时重置暂存区和工作区，与指定[commit]一致\n\n# 此时打印 log 查看是否回到之前的状态\ngit log\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n注意：此操作只能回退当前的分支，如其他分支也要回退，需要切换到该分支并执行上面操作。\n\n\n# 开发期间的rebase操作\n\n\n# 背景\n\n有两个分支：\n\ndev\n*v2\n\n\n1\n2\n\n\n2.4-dev 是基于dev切出来的。\n\n提交记录如下：\n\n\t\tdev\na - b - c\n\t\tv2\n\n\n1\n2\n3\n\n\n开发期间，两个分支同时有新的commit ：\n\n\t\t\t\tdev\na - b - c - d - e\n\t\t\\ - f - g\n\t\t\t\tv2\n\n\n1\n2\n3\n4\n\n\n当前你正在v2进行开发，dev也同时进行开发，并有重大的改变，你需要把dev的提交同步到v2。\n\n需求： 把dev中新的提交同步到v2，且不能影响dev分支。\n\n\n# 操作步骤\n\n 1. 基于最新的 dev 切一个新的分支 dev-copy\n    \n    > dev-copy 和 dev 两者的 commit ID 一致。\n\n 2. 在dev-copy中执行rebase，将 dev-copy 的提交变基到 v2\n    \n    git rebase v2 # 将 dev-copy 的提交[commit] 变基到(应用到) v2\n    \n    \n    1\n    \n\n 3. 删除原v2分支，将dev-copy分支名改为v2\n    \n    # 当前在 dev-copy 分支\n    git branch -d v2 # 删除分支\n    git branch -m dev-copy v2 # 重命名\n    \n    \n    1\n    2\n    3\n    \n\n\n# git cherry-pick\n\n来源：《git cherry-pick 教程》\n\n用于将单个或几个[commit]复制到另一个分支。\n\n# 基本应用\n\ngit cherry-pick <commitHash> # 将commitHash应用于当前分支\n\n\n1\n\n\n上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\n\ngit cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。\n\n# 转移多个提交\n\nCherry pick 支持一次转移多个提交。\n\ngit cherry-pick <HashA> <HashB> # A和B提交\n\n\n1\n\n\n上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。\n\n如果想要转移一系列的连续提交，可以使用下面的简便语法。\n\ngit cherry-pick A..B # A到B提交，不包含A\n\n\n1\n\n\n上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。\n\n注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。\n\ngit cherry-pick A^..B # A到B提交，包含A\n\n\n1\n",normalizedContent:"# rebase分支合并\n\n\n# 说明\n\n以下 v2 是某个需求的开发分支， dev是总的开发分支，v2 是基于dev分支签出的。\n\n当完成v2的开发后，需要把代码合并到dev，我们可以使用rebase进行合并：\n\n# 首先将 v2 push到远程仓库\ngit add .\ngit commit -m 'xxx'\ngit push origin v2\n\n# 切换到 dev 拉取最新代码\ngit checkout dev\ngit pull origin dev\n\n# 切换到 v2\ngit checkout v2\ngit rebase dev # 将 v2 的所有[commit] 变基到(应用到) dev\n\n# 切换到 dev\ngit checkout dev\ngit merge v2  # 将 dev分支 快进合并 （此时 (head -> dev, v2) [commit] 两个分支指向同一个提交）\n\n# 查看 原v2的[commit]记录 是否在dev分支的最前面（变基成功会把v2的提交记录应用到dev分支的最前面）\ngit log\n\n\t# 如果到这一步发现有问题，尝试使用 git --abort中止变基，如果还是有问题的可以在dev分支上使用《后悔药》操作， 再到v2分支上使用《后悔药》操作，即可使两个分支都回退到 rebase变基 之前的状态\n\n# 试运行项目是否有问题\nyarn start\n\ngit status # 查看状态是否有问题\ngit push origin dev # 推送到远程仓库的 dev\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 变基要遵守的准则\n\n几个人同时在一个分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 因此，变基操作过后的分支将不要再使用。\n\n\n# 后悔药\n\n# 查看head指针变动记录\ngit reflog\n# 记录示例(当前分支是v2):\n07c398f (head -> v2, master) head@{0}: checkout: moving from master to v2\n07c398f (head -> v2, master) head@{1}: rebase (finish): returning to refs/heads/master\n07c398f (head -> v2, master) head@{2}: rebase (start): checkout v2\n15a97d8 head@{3}: reset: moving to 15a97d8\n07c398f (head -> v2, master) head@{4}: merge v2: fast-forward\n15a97d8 head@{5}: checkout: moving from v2 to master\n07c398f (head -> v2, master) head@{6}: rebase (finish): returning to refs/heads/v2\n07c398f (head -> v2, master) head@{7}: rebase (pick): c\n15a97d8 head@{8}: rebase (start): checkout master # 首次rebase\nd278ecd head@{9}: checkout: moving from master to v2 # rebase前的状态\n15a97d8 head@{10}: commit: d\n\n# 可见，示例中最初的 rebase 操作是 head@{8}，想回退到变基前的状态需让指针指向 head@{9}\ngit reset --hard d278ecd  # 重置当前分支的head为指定[commit]，同时重置暂存区和工作区，与指定[commit]一致\n\n# 此时打印 log 查看是否回到之前的状态\ngit log\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n注意：此操作只能回退当前的分支，如其他分支也要回退，需要切换到该分支并执行上面操作。\n\n\n# 开发期间的rebase操作\n\n\n# 背景\n\n有两个分支：\n\ndev\n*v2\n\n\n1\n2\n\n\n2.4-dev 是基于dev切出来的。\n\n提交记录如下：\n\n\t\tdev\na - b - c\n\t\tv2\n\n\n1\n2\n3\n\n\n开发期间，两个分支同时有新的commit ：\n\n\t\t\t\tdev\na - b - c - d - e\n\t\t\\ - f - g\n\t\t\t\tv2\n\n\n1\n2\n3\n4\n\n\n当前你正在v2进行开发，dev也同时进行开发，并有重大的改变，你需要把dev的提交同步到v2。\n\n需求： 把dev中新的提交同步到v2，且不能影响dev分支。\n\n\n# 操作步骤\n\n 1. 基于最新的 dev 切一个新的分支 dev-copy\n    \n    > dev-copy 和 dev 两者的 commit id 一致。\n\n 2. 在dev-copy中执行rebase，将 dev-copy 的提交变基到 v2\n    \n    git rebase v2 # 将 dev-copy 的提交[commit] 变基到(应用到) v2\n    \n    \n    1\n    \n\n 3. 删除原v2分支，将dev-copy分支名改为v2\n    \n    # 当前在 dev-copy 分支\n    git branch -d v2 # 删除分支\n    git branch -m dev-copy v2 # 重命名\n    \n    \n    1\n    2\n    3\n    \n\n\n# git cherry-pick\n\n来源：《git cherry-pick 教程》\n\n用于将单个或几个[commit]复制到另一个分支。\n\n# 基本应用\n\ngit cherry-pick <commithash> # 将commithash应用于当前分支\n\n\n1\n\n\n上面命令就会将指定的提交commithash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\n\ngit cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。\n\n# 转移多个提交\n\ncherry pick 支持一次转移多个提交。\n\ngit cherry-pick <hasha> <hashb> # a和b提交\n\n\n1\n\n\n上面的命令将 a 和 b 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。\n\n如果想要转移一系列的连续提交，可以使用下面的简便语法。\n\ngit cherry-pick a..b # a到b提交，不包含a\n\n\n1\n\n\n上面的命令可以转移从 a 到 b 的所有提交。它们必须按照正确的顺序放置：提交 a 必须早于提交 b，否则命令将失败，但不会报错。\n\n注意，使用上面的命令，提交 a 将不会包含在 cherry pick 中。如果要包含提交 a，可以使用下面的语法。\n\ngit cherry-pick a^..b # a到b提交，包含a\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"湖南科大计算机网络",frontmatter:{title:"湖南科大计算机网络",date:"2022-02-02T22:35:30.000Z",permalink:"/pages/4bdb82/",categories:["《Git》学习笔记","手册"],tags:[null]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%89%8B%E5%86%8C/07.%E6%B9%96%E5%8D%97%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html",relativePath:"《Git》学习笔记/10.手册/07.湖南科大计算机网络.md",key:"v-449301a8",path:"/pages/4bdb82/",headers:[{level:2,title:"因特网概述",slug:"因特网概述",normalizedTitle:"因特网概述",charIndex:13},{level:3,title:"1. 网络、互联网和因特网",slug:"_1-网络、互联网和因特网",normalizedTitle:"1. 网络、互联网和因特网",charIndex:23},{level:3,title:"2. 因特网服务提供者ISP",slug:"_2-因特网服务提供者isp",normalizedTitle:"2. 因特网服务提供者isp",charIndex:47},{level:3,title:"3. 三种交换方式",slug:"_3-三种交换方式",normalizedTitle:"3. 三种交换方式",charIndex:403},{level:3,title:"4. 计算机网络的性能指标",slug:"_4-计算机网络的性能指标",normalizedTitle:"4. 计算机网络的性能指标",charIndex:464},{level:3,title:"5. 计算机网络体系结构",slug:"_5-计算机网络体系结构",normalizedTitle:"5. 计算机网络体系结构",charIndex:809}],headersStr:"因特网概述 1. 网络、互联网和因特网 2. 因特网服务提供者ISP 3. 三种交换方式 4. 计算机网络的性能指标 5. 计算机网络体系结构",content:"# 第一章 概述\n\n\n# 因特网概述\n\n\n# 1. 网络、互联网和因特网\n\n\n\n\n\n\n\n\n# 2. 因特网服务提供者ISP\n\nISP 可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路，路由器等联网设备，任何机构或者个人只要向ISP缴纳一定的管理费用，就可以得到所需要的IP地址（因特网上的主机必须得通过IP地址进行通信），从而通过该ISP接入因特网。\n\n我国主要的ISP就是三大运营商\n\n\n\n\n\n * 第一层ISP：拥有高速链路和交换设备，第一层ISP之间直接互联。\n\n * 第三层ISP：一般的校园网或企业网，以及住宅用户和无线移动用户，都是第三层ISP的用户。\n\n * 相隔较远的两台主机间的通信可能需要经过多个ISP（图中主机A和主机B）\n\n * 一旦某个用户可以接入因特网，那么他也可以称为一个ISP，所需要做的就是购买一些调制解调器或路由器这样的设备。让其他用户能够和他相连。\n\n\n# 3. 三种交换方式\n\n\n\n\n\n> switch在应用中是开关的意思，其实理解为一系列开关的连通更容易理解\n\n\n\n\n\n\n# 4. 计算机网络的性能指标\n\n# 速率\n\n\n\n\n\n# 带宽\n\n\n\n# 吞吐量\n\n\n\n速率、带宽、吞吐量的单位一样，所以它们属于同一量纲，只是面向的对象不同。\n\n 1. 速率没有具体的面向对象 ，只是表示这一量纲的客观数值大小\n 2. 带宽表示特定通信线路的最高速率\n 3. 吞吐量表示特定通信线路的实际速率（可以理解为平均速率）\n\n# 时延\n\n\n\n发送速率跟网卡发送速率，信道带宽，接口速率都有关系，遵循木桶原理，也就是由这三项中的最小值决定。\n\n\n\n\n\n# 时延带宽积\n\n\n\n通过上面计算时延公式，可以将时延带宽积和分组长度对应起来去理解。\n\n分组长度 = 发送速率 * 发送时延\n\n时延带宽积 = 带宽 * 传播时延\n\n# 往返时间\n\n\n\n# 利用率\n\n\n\n# 丢包率\n\n\n\n\n\n\n# 5. 计算机网络体系结构\n\n\n\n\n\n# 分层必要性\n\n\n\n\n\n\n\n\n\n\n\n",normalizedContent:"# 第一章 概述\n\n\n# 因特网概述\n\n\n# 1. 网络、互联网和因特网\n\n\n\n\n\n\n\n\n# 2. 因特网服务提供者isp\n\nisp 可以从因特网管理机构申请到成块的ip地址，同时拥有通信线路，路由器等联网设备，任何机构或者个人只要向isp缴纳一定的管理费用，就可以得到所需要的ip地址（因特网上的主机必须得通过ip地址进行通信），从而通过该isp接入因特网。\n\n我国主要的isp就是三大运营商\n\n\n\n\n\n * 第一层isp：拥有高速链路和交换设备，第一层isp之间直接互联。\n\n * 第三层isp：一般的校园网或企业网，以及住宅用户和无线移动用户，都是第三层isp的用户。\n\n * 相隔较远的两台主机间的通信可能需要经过多个isp（图中主机a和主机b）\n\n * 一旦某个用户可以接入因特网，那么他也可以称为一个isp，所需要做的就是购买一些调制解调器或路由器这样的设备。让其他用户能够和他相连。\n\n\n# 3. 三种交换方式\n\n\n\n\n\n> switch在应用中是开关的意思，其实理解为一系列开关的连通更容易理解\n\n\n\n\n\n\n# 4. 计算机网络的性能指标\n\n# 速率\n\n\n\n\n\n# 带宽\n\n\n\n# 吞吐量\n\n\n\n速率、带宽、吞吐量的单位一样，所以它们属于同一量纲，只是面向的对象不同。\n\n 1. 速率没有具体的面向对象 ，只是表示这一量纲的客观数值大小\n 2. 带宽表示特定通信线路的最高速率\n 3. 吞吐量表示特定通信线路的实际速率（可以理解为平均速率）\n\n# 时延\n\n\n\n发送速率跟网卡发送速率，信道带宽，接口速率都有关系，遵循木桶原理，也就是由这三项中的最小值决定。\n\n\n\n\n\n# 时延带宽积\n\n\n\n通过上面计算时延公式，可以将时延带宽积和分组长度对应起来去理解。\n\n分组长度 = 发送速率 * 发送时延\n\n时延带宽积 = 带宽 * 传播时延\n\n# 往返时间\n\n\n\n# 利用率\n\n\n\n# 丢包率\n\n\n\n\n\n\n# 5. 计算机网络体系结构\n\n\n\n\n\n# 分层必要性\n\n\n\n\n\n\n\n\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git基础与命令",frontmatter:{title:"Git基础与命令",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/635088/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/10.Git%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%91%BD%E4%BB%A4.html",relativePath:"《Git》学习笔记/20.文档笔记/10.Git基础与命令.md",key:"v-364e812a",path:"/pages/635088/",headers:[{level:2,title:"Git基础",slug:"git基础",normalizedTitle:"git基础",charIndex:2},{level:3,title:"全局配置",slug:"全局配置",normalizedTitle:"全局配置",charIndex:93},{level:3,title:"检查配置信息",slug:"检查配置信息",normalizedTitle:"检查配置信息",charIndex:202},{level:3,title:"获取帮助",slug:"获取帮助",normalizedTitle:"获取帮助",charIndex:237},{level:3,title:"初始化仓库",slug:"初始化仓库",normalizedTitle:"初始化仓库",charIndex:398},{level:3,title:"克隆远程仓库",slug:"克隆远程仓库",normalizedTitle:"克隆远程仓库",charIndex:474},{level:3,title:"检查文件状态",slug:"检查文件状态",normalizedTitle:"检查文件状态",charIndex:623},{level:3,title:"加入暂存区 (跟踪文件)",slug:"加入暂存区-跟踪文件",normalizedTitle:"加入暂存区 (跟踪文件)",charIndex:950},{level:3,title:"忽略文件",slug:"忽略文件",normalizedTitle:"忽略文件",charIndex:1119},{level:3,title:"查看修改的具体内容",slug:"查看修改的具体内容",normalizedTitle:"查看修改的具体内容",charIndex:2105},{level:3,title:"提交更新",slug:"提交更新",normalizedTitle:"提交更新",charIndex:2263},{level:3,title:"跳过使用暂存区域",slug:"跳过使用暂存区域",normalizedTitle:"跳过使用暂存区域",charIndex:2406},{level:2,title:"Git 基础 - 查看提交历史",slug:"git-基础-查看提交历史",normalizedTitle:"git 基础 - 查看提交历史",charIndex:2506},{level:2,title:"Git 基础 - 撤消操作",slug:"git-基础-撤消操作",normalizedTitle:"git 基础 - 撤消操作",charIndex:4022},{level:2,title:"Git 基础 - 远程仓库的使用",slug:"git-基础-远程仓库的使用",normalizedTitle:"git 基础 - 远程仓库的使用",charIndex:4228},{level:3,title:"查看远程仓库",slug:"查看远程仓库",normalizedTitle:"查看远程仓库",charIndex:4249},{level:3,title:"添加远程仓库",slug:"添加远程仓库",normalizedTitle:"添加远程仓库",charIndex:4323},{level:3,title:"从远程仓库中抓取与拉取",slug:"从远程仓库中抓取与拉取",normalizedTitle:"从远程仓库中抓取与拉取",charIndex:4370},{level:3,title:"推送到远程仓库",slug:"推送到远程仓库",normalizedTitle:"推送到远程仓库",charIndex:1106},{level:3,title:"查看某个远程仓库",slug:"查看某个远程仓库",normalizedTitle:"查看某个远程仓库",charIndex:4825},{level:3,title:"远程仓库的重命名与移除",slug:"远程仓库的重命名与移除",normalizedTitle:"远程仓库的重命名与移除",charIndex:4951},{level:2,title:"Git 基础 - 打标签",slug:"git-基础-打标签",normalizedTitle:"git 基础 - 打标签",charIndex:5049},{level:3,title:"列出标签",slug:"列出标签",normalizedTitle:"列出标签",charIndex:5066},{level:3,title:"创建标签",slug:"创建标签",normalizedTitle:"创建标签",charIndex:5164},{level:3,title:"附注标签",slug:"附注标签",normalizedTitle:"附注标签",charIndex:5199},{level:3,title:"轻量标签",slug:"轻量标签",normalizedTitle:"轻量标签",charIndex:5181},{level:3,title:"后期打标签",slug:"后期打标签",normalizedTitle:"后期打标签",charIndex:5893},{level:3,title:"共享标签",slug:"共享标签",normalizedTitle:"共享标签",charIndex:6294},{level:3,title:"删除标签",slug:"删除标签",normalizedTitle:"删除标签",charIndex:6527},{level:3,title:"检出标签",slug:"检出标签",normalizedTitle:"检出标签",charIndex:7014},{level:2,title:"Git 命令别名",slug:"git-命令别名",normalizedTitle:"git 命令别名",charIndex:8135}],headersStr:"Git基础 全局配置 检查配置信息 获取帮助 初始化仓库 克隆远程仓库 检查文件状态 加入暂存区 (跟踪文件) 忽略文件 查看修改的具体内容 提交更新 跳过使用暂存区域 Git 基础 - 查看提交历史 Git 基础 - 撤消操作 Git 基础 - 远程仓库的使用 查看远程仓库 添加远程仓库 从远程仓库中抓取与拉取 推送到远程仓库 查看某个远程仓库 远程仓库的重命名与移除 Git 基础 - 打标签 列出标签 创建标签 附注标签 轻量标签 后期打标签 共享标签 删除标签 检出标签 Git 命令别名",content:"# Git基础与命令\n\n官方文档（中文）：https://git-scm.com/book/zh/v2\n\n> 本文档是根据官方文档来编写的，以官方文档为准。\n\n\n# Git基础\n\n\n# 全局配置\n\ngit config --global user.name 'your name'\ngit config --global user.email 'xxx@xx.com'\n\n\n1\n2\n\n\n自报家门\n\n\n# 检查配置信息\n\ngit config --list\n\n\n1\n\n\n\n# 获取帮助\n\n# 获取全局帮助手册\ngit help\n\n# 获取特定命令的详细版帮助手册 (两个命令是等价的)\ngit help <某个命令>\ngit <某个命令> --help # 两个横杠\n\n# 获取特定命令的简明版帮助手册\ngit <某个命令> -h  # 一个横杠\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 初始化仓库\n\n# 本地目录初始化仓库\ngit init\n\n\n1\n2\n\n\n如果你是从远程仓库clone的项目，则该项目是已经初始化好的git仓库\n\n\n# 克隆远程仓库\n\n# 克隆\ngit clone <url>\n\n# 克隆同时修改目录名\ngit clone <url> <name>\n\n\n1\n2\n3\n4\n5\n\n\n初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们\n\n\n# 检查文件状态\n\n# 查看详细状态说明\ngit status\n\n# 查看简明状态说明\ngit status -s  # -s 或 --short\n M README # 已修改，但未暂存 （M的位置靠右，红色）\nMM Rakefile # 已修改，暂存后又作了修改（有暂存和未暂存）\nA  lib/git.rb # 新添加到暂存区，未提交\nM  lib/simplegit.rb # 已修改，已暂存 （M的位置靠左，绿色）\n?? LICENSE.txt # 新添加，未跟踪\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n * git目录中的文件状态包含：是否跟踪、是否修改、是否已存入暂存区\n\n * 参数的一个横杠表示缩写，两个横杠表示全称。\n\n\n# 加入暂存区 (跟踪文件)\n\n# 文件加入暂存区（跟踪指定文件)\ngit add <files>\n\n\n1\n2\n\n\ngit add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。\n\nadd 命令是将文件加入到暂存区，commit 命令的提交到本地仓库，push 命令是推送到远程仓库。\n\n\n# 忽略文件\n\n添加一个名为 .gitignore 的文件，列出要忽略的文件的模式\n\n*.[oa]  # 忽略以 .o 或 .a 结尾的文件（一般这类文件是编译过程出现）\n*~      # 忽略以 ~ 结尾的文件（一般是文本编辑软件保存的副本）\n\n\n1\n2\n\n\n文件 .gitignore 的格式规范如下：\n\n * 所有空行或者以 # 开头的行都会被 Git 忽略（注释符号）。\n\n * 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。\n   \n   > glob 模式是指 shell 所使用的简化了的正则表达式\n\n * 匹配模式可以以（/）开头防止递归。\n\n * 匹配模式可以以（/）结尾指定目录。\n\n * 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。\n\n----------------------------------------\n\n * 星号（*）匹配零个或多个任意字符\n * [abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）\n * 问号（?）只匹配一个任意字符\n * [0-9] 表示匹配所有 0 到 9 的数字。在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配\n * 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。\n\n# 忽略所有的 .a 文件\n*.a\n\n# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件\n!lib.a\n\n# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO\n/TODO\n\n# 忽略任何目录下名为 build 的文件夹\nbuild/\n\n# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt\ndoc/*.txt\n\n# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件\ndoc/**/*.pdf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nGitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 你可以在 https://github.com/github/gitignore 找到它。\n\n\n# 查看修改的具体内容\n\ngit diff # 比较修改之后还没有暂存起来的变化内容。\n\ngit diff --staged # 查看已暂存的将要添加到下次提交里的内容\n\n\n1\n2\n3\n\n\ngit status 只能查看文件变动的状态，并不能查看具体修改了哪些内容。使用git diff可以看到具体变动的内容。\n\n\n# 提交更新\n\ngit commit # 未带参数的会打开默认文本编辑器让你输入提交说明\n\ngit commit -m '提交说明' # 带-m参数直接输入提交说明\n\n\n1\n2\n3\n\n\n使用git commit提交更新，在此之前，务必确认所有变动已经被git add添加到暂存区。\n\n\n# 跳过使用暂存区域\n\ngit commit -a -m '提交说明'\n\n\n1\n\n\n添加-a选项可以跳过git add 步骤，把已经跟踪过的文件一并提交。\n\n注意：这个操作无法提交未跟踪的文件。\n\n\n# Git 基础 - 查看提交历史\n\ngit log\n\n\n1\n\n\n不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。\n\n此命令打印的数据中有一项是一长串的 SHA-1 校验码。\n\n带入-p或--patch查看提交的具体差异：\n\ngit log -p -2 # -p显示差异  -2显示最近的提交次数\n\n\n1\n\n\n--stat 显示每次提交的差异统计\n\ngit log --stat\n\n\n1\n\n\n--pretty 这个选项可以使用不同于默认格式的方式展示提交历史\n\n这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一：\n\n$ git log --pretty=oneline\nca82a6dff817ec66f44342007202690a93763949 changed the version number\n085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test\na11bef06a3f659402fe7563abf99ad00de2209e6 first commit\n\n\n1\n2\n3\n4\n\n\n最有意思的是 format ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变：\n\n$ git log --pretty=format:\"%h - %an, %ar : %s\"\nca82a6d - Scott Chacon, 6 years ago : changed the version number\n085bb3b - Scott Chacon, 6 years ago : removed unnecessary test\na11bef0 - Scott Chacon, 6 years ago : first commit\n\n\n1\n2\n3\n4\n\n\ngit log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。\n\n当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：\n\n$ git log --pretty=format:\"%h %s\" --graph\n* 2d3acf9 ignore errors from SIGCHLD on trap\n*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit\n|\\\n| * 420eac9 Added a method for getting the current branch.\n* | 30e367c timeout code and tests\n* | 5a09431 add timeout protection to grit\n* | e1193f8 support for heads with slashes in them\n|/\n* d6016bc require time for xmlschema\n*  11d191e Merge branch 'defunkt' into local\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Git 基础 - 撤消操作\n\n你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\n\n$ git commit -m 'initial commit'\n$ git add forgotten_file\n$ git commit --amend # 重新提交，且只有一次提交记录\n\n\n1\n2\n3\n\n\n最终你只会有一个提交——第二次提交将代替第一次提交的结果。\n\n更多撤销操作请了解 reset命令。\n\n\n# Git 基础 - 远程仓库的使用\n\n\n# 查看远程仓库\n\ngit remote # 仅显示远程仓库的名称\ngit remote -v # 显示远程仓库的名称 + 地址\n\n\n1\n2\n\n\n\n# 添加远程仓库\n\n git remote add <远程仓库名> <url>\n\n\n1\n\n\n\n# 从远程仓库中抓取与拉取\n\n就如刚才所见，从远程仓库中获得数据，可以执行：\n\ngit fetch <remote>\n\n\n1\n\n\n这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。\n\n注意： git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。\n\ngit pull\n\n\n1\n\n\n用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\n\n\n# 推送到远程仓库\n\ngit push <remote> <branch> # git push origin master\n\n\n1\n\n\n\n# 查看某个远程仓库\n\n git remote show <remote> # git remote show origin\n\n\n1\n\n\n查看远程仓库的详细信息。这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支\n\n\n# 远程仓库的重命名与移除\n\ngit remote rename <原名> <新名> # 重命名\ngit remote remove paul <remote># 移除远程仓库\n\n\n1\n2\n\n\n\n# Git 基础 - 打标签\n\n\n# 列出标签\n\ngit tag # 完整标签列表\ngit tag -l \"v2.0*\" # 只显示包含 v2.0 的标签。 注意加星号(*)\n\n\n1\n2\n\n\n-l 或 --list 都可以。\n\n\n# 创建标签\n\nGit 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。\n\n轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。\n\n而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。\n\n\n# 附注标签\n\ngit tag -a v1.4 -m \"my version 1.4\" # -a表示add， -m 表示附件信息\n\n\n1\n\n\n通过使用 git show 命令可以看到标签信息和与之对应的提交信息：\n\ngit show v1.4\n\n\n1\n\n\n\n# 轻量标签\n\n轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：\n\ngit tag v1.4-lw # 不需要添加选项\n\n\n1\n\n\n这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：\n\n$ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n\n1\n2\n3\n4\n\n\n\n# 后期打标签\n\n你也可以对过去的提交打标签。 假设提交历史是这样的：\n\n$ git log --pretty=oneline\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\n\n\n1\n2\n3\n4\n\n\n现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：\n\n$ git tag -a v1.2 9fceb02 # 打的标签属于附注标签\n\n\n1\n\n\n\n# 共享标签\n\ngit push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin <tagname>。\n\ngit push origin v1.5 # 显式地推送标签到远程仓库\ngit push origin --tags # 一次性推送所有不在远程仓库上的标签\n\n\n1\n2\n\n\n现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。\n\n\n# 删除标签\n\n要删除掉你本地仓库上的标签，可以使用命令 git tag -d <tagname>。 例如，可以使用以下命令删除一个轻量标签：\n\n$ git tag -d v1.4-lw\nDeleted tag 'v1.4-lw' (was e7d5add)\n\n\n1\n2\n\n\n注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 git push <remote> :refs/tags/<tagname> 来更新你的远程仓库：\n\n第一种变体是 git push <remote> :refs/tags/<tagname> ：\n\n$ git push origin :refs/tags/v1.4-lw\nTo /git@github.com:schacon/simplegit.git\n - [deleted]         v1.4-lw\n\n\n1\n2\n3\n\n\n上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。\n\n第二种更直观的删除远程标签的方式是：\n\n$ git push origin --delete <tagname>\n\n\n1\n\n\n\n# 检出标签\n\n如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：\n\n$ git checkout 2.0.0\nNote: checking out '2.0.0'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b <new-branch>\n\nHEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final\n\n$ git checkout 2.0-beta-0.1\nPrevious HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final\nHEAD is now at df3f601... add atlas.json and cover image\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：\n\n$ git checkout -b version2 v2.0.0\nSwitched to a new branch 'version2'\n\n\n1\n2\n\n\n如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了。\n\n\n# Git 命令别名\n\nGit 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：\n\n$ git config --global alias.co checkout\n$ git config --global alias.br branch\n$ git config --global alias.ci commit\n$ git config --global alias.st status\n\n\n1\n2\n3\n4\n\n\n这意味着，当要输入 git commit 时，只需要输入 git ci。\n\n在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：\n\n$ git config --global alias.unstage 'reset HEAD --'\n\n\n1\n\n\n这会使下面的两个命令等价：\n\n$ git unstage fileA\n$ git reset HEAD -- fileA\n\n\n1\n2\n\n\n这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：\n\n$ git config --global alias.last 'log -1 HEAD'\n\n\n1\n\n\n这样，可以轻松地看到最后一次提交：\n\n$ git last\ncommit 66938dae3329c7aebe598c2246a8e6af90d04646\nAuthor: Josh Goebel <dreamer3@example.com>\nDate:   Tue Aug 26 19:48:51 2008 +0800\n\n    test for current head\n\n    Signed-off-by: Scott Chacon <schacon@example.com>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：\n\n$ git config --global alias.visual '!gitk'\n\n\n1\n",normalizedContent:"# git基础与命令\n\n官方文档（中文）：https://git-scm.com/book/zh/v2\n\n> 本文档是根据官方文档来编写的，以官方文档为准。\n\n\n# git基础\n\n\n# 全局配置\n\ngit config --global user.name 'your name'\ngit config --global user.email 'xxx@xx.com'\n\n\n1\n2\n\n\n自报家门\n\n\n# 检查配置信息\n\ngit config --list\n\n\n1\n\n\n\n# 获取帮助\n\n# 获取全局帮助手册\ngit help\n\n# 获取特定命令的详细版帮助手册 (两个命令是等价的)\ngit help <某个命令>\ngit <某个命令> --help # 两个横杠\n\n# 获取特定命令的简明版帮助手册\ngit <某个命令> -h  # 一个横杠\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 初始化仓库\n\n# 本地目录初始化仓库\ngit init\n\n\n1\n2\n\n\n如果你是从远程仓库clone的项目，则该项目是已经初始化好的git仓库\n\n\n# 克隆远程仓库\n\n# 克隆\ngit clone <url>\n\n# 克隆同时修改目录名\ngit clone <url> <name>\n\n\n1\n2\n3\n4\n5\n\n\n初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 git 刚刚检出了它们， 而你尚未编辑过它们\n\n\n# 检查文件状态\n\n# 查看详细状态说明\ngit status\n\n# 查看简明状态说明\ngit status -s  # -s 或 --short\n m readme # 已修改，但未暂存 （m的位置靠右，红色）\nmm rakefile # 已修改，暂存后又作了修改（有暂存和未暂存）\na  lib/git.rb # 新添加到暂存区，未提交\nm  lib/simplegit.rb # 已修改，已暂存 （m的位置靠左，绿色）\n?? license.txt # 新添加，未跟踪\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n * git目录中的文件状态包含：是否跟踪、是否修改、是否已存入暂存区\n\n * 参数的一个横杠表示缩写，两个横杠表示全称。\n\n\n# 加入暂存区 (跟踪文件)\n\n# 文件加入暂存区（跟踪指定文件)\ngit add <files>\n\n\n1\n2\n\n\ngit add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。\n\nadd 命令是将文件加入到暂存区，commit 命令的提交到本地仓库，push 命令是推送到远程仓库。\n\n\n# 忽略文件\n\n添加一个名为 .gitignore 的文件，列出要忽略的文件的模式\n\n*.[oa]  # 忽略以 .o 或 .a 结尾的文件（一般这类文件是编译过程出现）\n*~      # 忽略以 ~ 结尾的文件（一般是文本编辑软件保存的副本）\n\n\n1\n2\n\n\n文件 .gitignore 的格式规范如下：\n\n * 所有空行或者以 # 开头的行都会被 git 忽略（注释符号）。\n\n * 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。\n   \n   > glob 模式是指 shell 所使用的简化了的正则表达式\n\n * 匹配模式可以以（/）开头防止递归。\n\n * 匹配模式可以以（/）结尾指定目录。\n\n * 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。\n\n----------------------------------------\n\n * 星号（*）匹配零个或多个任意字符\n * [abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）\n * 问号（?）只匹配一个任意字符\n * [0-9] 表示匹配所有 0 到 9 的数字。在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配\n * 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。\n\n# 忽略所有的 .a 文件\n*.a\n\n# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件\n!lib.a\n\n# 只忽略当前目录下的 todo 文件，而不忽略 subdir/todo\n/todo\n\n# 忽略任何目录下名为 build 的文件夹\nbuild/\n\n# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt\ndoc/*.txt\n\n# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件\ndoc/**/*.pdf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\ngithub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 你可以在 https://github.com/github/gitignore 找到它。\n\n\n# 查看修改的具体内容\n\ngit diff # 比较修改之后还没有暂存起来的变化内容。\n\ngit diff --staged # 查看已暂存的将要添加到下次提交里的内容\n\n\n1\n2\n3\n\n\ngit status 只能查看文件变动的状态，并不能查看具体修改了哪些内容。使用git diff可以看到具体变动的内容。\n\n\n# 提交更新\n\ngit commit # 未带参数的会打开默认文本编辑器让你输入提交说明\n\ngit commit -m '提交说明' # 带-m参数直接输入提交说明\n\n\n1\n2\n3\n\n\n使用git commit提交更新，在此之前，务必确认所有变动已经被git add添加到暂存区。\n\n\n# 跳过使用暂存区域\n\ngit commit -a -m '提交说明'\n\n\n1\n\n\n添加-a选项可以跳过git add 步骤，把已经跟踪过的文件一并提交。\n\n注意：这个操作无法提交未跟踪的文件。\n\n\n# git 基础 - 查看提交历史\n\ngit log\n\n\n1\n\n\n不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。\n\n此命令打印的数据中有一项是一长串的 sha-1 校验码。\n\n带入-p或--patch查看提交的具体差异：\n\ngit log -p -2 # -p显示差异  -2显示最近的提交次数\n\n\n1\n\n\n--stat 显示每次提交的差异统计\n\ngit log --stat\n\n\n1\n\n\n--pretty 这个选项可以使用不同于默认格式的方式展示提交历史\n\n这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一：\n\n$ git log --pretty=oneline\nca82a6dff817ec66f44342007202690a93763949 changed the version number\n085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test\na11bef06a3f659402fe7563abf99ad00de2209e6 first commit\n\n\n1\n2\n3\n4\n\n\n最有意思的是 format ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 git 的更新而发生改变：\n\n$ git log --pretty=format:\"%h - %an, %ar : %s\"\nca82a6d - scott chacon, 6 years ago : changed the version number\n085bb3b - scott chacon, 6 years ago : removed unnecessary test\na11bef0 - scott chacon, 6 years ago : first commit\n\n\n1\n2\n3\n4\n\n\ngit log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。\n\n当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ascii 字符串来形象地展示你的分支、合并历史：\n\n$ git log --pretty=format:\"%h %s\" --graph\n* 2d3acf9 ignore errors from sigchld on trap\n*  5e3ee11 merge branch 'master' of git://github.com/dustin/grit\n|\\\n| * 420eac9 added a method for getting the current branch.\n* | 30e367c timeout code and tests\n* | 5a09431 add timeout protection to grit\n* | e1193f8 support for heads with slashes in them\n|/\n* d6016bc require time for xmlschema\n*  11d191e merge branch 'defunkt' into local\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# git 基础 - 撤消操作\n\n你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\n\n$ git commit -m 'initial commit'\n$ git add forgotten_file\n$ git commit --amend # 重新提交，且只有一次提交记录\n\n\n1\n2\n3\n\n\n最终你只会有一个提交——第二次提交将代替第一次提交的结果。\n\n更多撤销操作请了解 reset命令。\n\n\n# git 基础 - 远程仓库的使用\n\n\n# 查看远程仓库\n\ngit remote # 仅显示远程仓库的名称\ngit remote -v # 显示远程仓库的名称 + 地址\n\n\n1\n2\n\n\n\n# 添加远程仓库\n\n git remote add <远程仓库名> <url>\n\n\n1\n\n\n\n# 从远程仓库中抓取与拉取\n\n就如刚才所见，从远程仓库中获得数据，可以执行：\n\ngit fetch <remote>\n\n\n1\n\n\n这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。\n\n注意： git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。\n\ngit pull\n\n\n1\n\n\n用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\n\n\n# 推送到远程仓库\n\ngit push <remote> <branch> # git push origin master\n\n\n1\n\n\n\n# 查看某个远程仓库\n\n git remote show <remote> # git remote show origin\n\n\n1\n\n\n查看远程仓库的详细信息。这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支\n\n\n# 远程仓库的重命名与移除\n\ngit remote rename <原名> <新名> # 重命名\ngit remote remove paul <remote># 移除远程仓库\n\n\n1\n2\n\n\n\n# git 基础 - 打标签\n\n\n# 列出标签\n\ngit tag # 完整标签列表\ngit tag -l \"v2.0*\" # 只显示包含 v2.0 的标签。 注意加星号(*)\n\n\n1\n2\n\n\n-l 或 --list 都可以。\n\n\n# 创建标签\n\ngit 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。\n\n轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。\n\n而附注标签是存储在 git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 gnu privacy guard （gpg）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。\n\n\n# 附注标签\n\ngit tag -a v1.4 -m \"my version 1.4\" # -a表示add， -m 表示附件信息\n\n\n1\n\n\n通过使用 git show 命令可以看到标签信息和与之对应的提交信息：\n\ngit show v1.4\n\n\n1\n\n\n\n# 轻量标签\n\n轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：\n\ngit tag v1.4-lw # 不需要添加选项\n\n\n1\n\n\n这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：\n\n$ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nauthor: scott chacon <schacon@gee-mail.com>\ndate:   mon mar 17 21:52:11 2008 -0700\n\n\n1\n2\n3\n4\n\n\n\n# 后期打标签\n\n你也可以对过去的提交打标签。 假设提交历史是这样的：\n\n$ git log --pretty=oneline\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\n\n\n1\n2\n3\n4\n\n\n现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：\n\n$ git tag -a v1.2 9fceb02 # 打的标签属于附注标签\n\n\n1\n\n\n\n# 共享标签\n\ngit push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin <tagname>。\n\ngit push origin v1.5 # 显式地推送标签到远程仓库\ngit push origin --tags # 一次性推送所有不在远程仓库上的标签\n\n\n1\n2\n\n\n现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。\n\n\n# 删除标签\n\n要删除掉你本地仓库上的标签，可以使用命令 git tag -d <tagname>。 例如，可以使用以下命令删除一个轻量标签：\n\n$ git tag -d v1.4-lw\ndeleted tag 'v1.4-lw' (was e7d5add)\n\n\n1\n2\n\n\n注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 git push <remote> :refs/tags/<tagname> 来更新你的远程仓库：\n\n第一种变体是 git push <remote> :refs/tags/<tagname> ：\n\n$ git push origin :refs/tags/v1.4-lw\nto /git@github.com:schacon/simplegit.git\n - [deleted]         v1.4-lw\n\n\n1\n2\n3\n\n\n上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。\n\n第二种更直观的删除远程标签的方式是：\n\n$ git push origin --delete <tagname>\n\n\n1\n\n\n\n# 检出标签\n\n如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令， 虽然这会使你的仓库处于“分离头指针（detached head）”的状态——这个状态有些不好的副作用：\n\n$ git checkout 2.0.0\nnote: checking out '2.0.0'.\n\nyou are in 'detached head' state. you can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nif you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. example:\n\n  git checkout -b <new-branch>\n\nhead is now at 99ada87... merge pull request #89 from schacon/appendix-final\n\n$ git checkout 2.0-beta-0.1\nprevious head position was 99ada87... merge pull request #89 from schacon/appendix-final\nhead is now at df3f601... add atlas.json and cover image\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：\n\n$ git checkout -b version2 v2.0.0\nswitched to a new branch 'version2'\n\n\n1\n2\n\n\n如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了。\n\n\n# git 命令别名\n\ngit 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：\n\n$ git config --global alias.co checkout\n$ git config --global alias.br branch\n$ git config --global alias.ci commit\n$ git config --global alias.st status\n\n\n1\n2\n3\n4\n\n\n这意味着，当要输入 git commit 时，只需要输入 git ci。\n\n在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 git 中添加你自己的取消暂存别名：\n\n$ git config --global alias.unstage 'reset head --'\n\n\n1\n\n\n这会使下面的两个命令等价：\n\n$ git unstage filea\n$ git reset head -- filea\n\n\n1\n2\n\n\n这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：\n\n$ git config --global alias.last 'log -1 head'\n\n\n1\n\n\n这样，可以轻松地看到最后一次提交：\n\n$ git last\ncommit 66938dae3329c7aebe598c2246a8e6af90d04646\nauthor: josh goebel <dreamer3@example.com>\ndate:   tue aug 26 19:48:51 2008 +0800\n\n    test for current head\n\n    signed-off-by: scott chacon <schacon@example.com>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可以看出，git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：\n\n$ git config --global alias.visual '!gitk'\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git工具-重写历史",frontmatter:{title:"Git工具-重写历史",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/1832fe/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/100.Git%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2.html",relativePath:"《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.md",key:"v-0dd61c07",path:"/pages/1832fe/",headers:[{level:2,title:"修改最后一次提交",slug:"修改最后一次提交",normalizedTitle:"修改最后一次提交",charIndex:453},{level:3,title:"修改提交信息",slug:"修改提交信息",normalizedTitle:"修改提交信息",charIndex:519},{level:3,title:"修改实际内容",slug:"修改实际内容",normalizedTitle:"修改实际内容",charIndex:700},{level:2,title:"修改多个提交信息",slug:"修改多个提交信息",normalizedTitle:"修改多个提交信息",charIndex:1113},{level:2,title:"重新排序提交",slug:"重新排序提交",normalizedTitle:"重新排序提交",charIndex:4034},{level:2,title:"压缩提交",slug:"压缩提交",normalizedTitle:"压缩提交",charIndex:4460},{level:2,title:"拆分提交",slug:"拆分提交",normalizedTitle:"拆分提交",charIndex:6218},{level:2,title:"核武器级选项：filter-branch",slug:"核武器级选项-filter-branch",normalizedTitle:"核武器级选项：filter-branch",charIndex:7244},{level:3,title:"从每一个提交中移除一个文件",slug:"从每一个提交中移除一个文件",normalizedTitle:"从每一个提交中移除一个文件",charIndex:7318},{level:3,title:"使一个子目录做为新的根目录",slug:"使一个子目录做为新的根目录",normalizedTitle:"使一个子目录做为新的根目录",charIndex:8358},{level:3,title:"全局修改邮箱地址",slug:"全局修改邮箱地址",normalizedTitle:"全局修改邮箱地址",charIndex:8684}],headersStr:"修改最后一次提交 修改提交信息 修改实际内容 修改多个提交信息 重新排序提交 压缩提交 拆分提交 核武器级选项：filter-branch 从每一个提交中移除一个文件 使一个子目录做为新的根目录 全局修改邮箱地址",content:"# Git 工具 - 重写历史\n\n许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 git stash 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\n\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\n\nNOTE   在满意之前不要推送你的工作GIT 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 在本地 随便重写历史记录。\n       然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。\n       简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。\n       \n\n\n# 修改最后一次提交\n\n修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：简单地修改提交信息， 或者通过添加、移除或修改文件来更改提交实际的内容。\n\n\n# 修改提交信息\n\n如果，你只是想修改最近一次提交的提交信息，那么很简单：\n\n$ git commit --amend\n\n\n1\n\n\n上面这条命令会将最后一次的提交信息载入到编辑器中供你修改。 当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中，它会成为新的最后一次提交。\n\n\n# 修改实际内容\n\n另一方面，如果你想要修改最后一次提交的实际内容，那么流程很相似：首先作出你想要补上的修改， 暂存它们，然后用 git commit --amend 以新的改进后的提交来 替换 掉旧有的最后一次提交，\n\n使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。\n\nTIP   修补后的提交可能需要修补提交信息当你在修补一次提交时，可以同时修改提交信息和提交内容。\n      如果你修补了提交的内容，那么几乎肯定要更新提交消息以反映修改后的内容。另一方面，如果你的修补是琐碎的（如修改了一个笔误或添加了一个忘记暂存的文件），\n      那么之前的提交信息不必修改，你只需作出更改，暂存它们，然后通过以下命令避免不必要的编辑器环节即可：$ GIT\n      COMMIT --AMEND --NO-EDIT\n      \n\n\n# 修改多个提交信息\n\n为了修改在提交历史中较远的提交，必须使用更复杂的工具。 Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 git rebase 增加 -i 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。\n\n例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息， 将想要修改的最近一次提交的父提交作为参数传递给 git rebase -i 命令，即 HEAD~2^ 或 HEAD~3。 记住 ~3 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：\n\n$ git rebase -i HEAD~3\n\n\n1\n\n\n再次记住这是一个变基命令——在 HEAD~3..HEAD 范围内的每一个修改了提交信息的提交及其 所有后裔 都会被重写。 不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。\n\n运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n# Rebase 710f0f8..a5f4a0d onto 710f0f8\n#\n# Commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current HEAD with a name\n# t, reset <label> = reset HEAD to a label\n# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). Use -c <commit> to reword the commit message.\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n需要重点注意的是相对于正常使用的 log 命令，这些提交显示的顺序是相反的。 运行一次 log 命令，会看到类似这样的东西：\n\n$ git log --pretty=format:\"%h %s\" HEAD~3..HEAD\na5f4a0d added cat-file\n310154e updated README formatting and added blame\nf7f3f6d changed my name a bit\n\n\n1\n2\n3\n4\n\n\n注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（HEAD~3）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。\n\n你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：\n\nedit f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n当保存并退出编辑器时，Git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：\n\n$ git rebase -i HEAD~3\nStopped at f7f3f6d... changed my name a bit\nYou can amend the commit now, with\n\n       git commit --amend\n\nOnce you're satisfied with your changes, run\n\n       git rebase --continue\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这些指令准确地告诉你该做什么。 输入\n\n$ git commit --amend\n\n\n1\n\n\n修改提交信息，然后退出编辑器。 然后，运行\n\n$ git rebase --continue\n\n\n1\n\n\n这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，Git 将会停止，让你修正提交，然后继续直到完成。\n\n\n# 重新排序提交\n\n也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n改为这样：\n\npick 310154e updated README formatting and added blame\npick f7f3f6d changed my name a bit\n\n\n1\n2\n\n\n当保存并退出编辑器时，Git 将你的分支带回这些提交的父提交，应用 310154e 然后应用 f7f3f6d，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。\n\n\n# 压缩提交\n\n通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：\n\n#\n# Commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current HEAD with a name\n# t, reset <label> = reset HEAD to a label\n# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). Use -c <commit> to reword the commit message.\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n如果，指定 “squash” 而不是 “pick” 或 “edit”，Git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：\n\npick f7f3f6d changed my name a bit\nsquash 310154e updated README formatting and added blame\nsquash a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n当保存并退出编辑器时，Git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：\n\n# This is a combination of 3 commits.\n# The first commit's message is:\nchanged my name a bit\n\n# This is the 2nd commit message:\n\nupdated README formatting and added blame\n\n# This is the 3rd commit message:\n\nadded cat-file\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。\n\n\n# 拆分提交\n\n拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated README formatting”，第二个 “added blame” 来代替原来的 “updated README formatting and added blame”。 可以通过修改 rebase -i 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：\n\npick f7f3f6d changed my name a bit\nedit 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n然后，当脚本带你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（f7f3f6d）， 应用第二个提交（310154e），然后让你进入命令行。 那里，可以通过 git reset HEAD^ 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件取消暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 git rebase --continue：\n\n$ git reset HEAD^\n$ git add README\n$ git commit -m 'updated README formatting'\n$ git add lib/simplegit.rb\n$ git commit -m 'added blame'\n$ git rebase --continue\n\n\n1\n2\n3\n4\n5\n6\n\n\nGit 在脚本中应用最后一次提交（a5f4a0d），历史记录看起来像这样：\n\n$ git log -4 --pretty=format:\"%h %s\"\n1c002dd added cat-file\n9b29157 added blame\n35cfb2b updated README formatting\nf3cc40e changed my name a bit\n\n\n1\n2\n3\n4\n5\n\n\n再次强调，这些改动了所有在列表中的提交的 SHA-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。\n\n\n# 核武器级选项：filter-branch\n\n有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 filter-branch，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。\n\nCAUTION   GIT FILTER-BRANCH 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用\n          GIT-FILTER-REPO，它是一个 PYTHON 脚本，相比大多数使用 FILTER-BRANCH\n          的应用来说，它做得要更好。它的文档和源码可访问\n          HTTPS://GITHUB.COM/NEWREN/GIT-FILTER-REPO 获取。\n          \n\n\n# 从每一个提交中移除一个文件\n\n这经常发生。 有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 filter-branch 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 --tree-filter 选项给 filter-branch：\n\n$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD\nRewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)\nRef 'refs/heads/master' was rewritten\n\n\n1\n2\n3\n\n\n--tree-filter 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 git filter-branch --tree-filter 'rm -f *~' HEAD 的命令。\n\n最后将可以看到 Git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 filter-branch 在所有分支上运行，可以给命令传递 --all 选项。\n\n\n# 使一个子目录做为新的根目录\n\n假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：\n\n$ git filter-branch --subdirectory-filter trunk HEAD\nRewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)\nRef 'refs/heads/master' was rewritten\n\n\n1\n2\n3\n\n\n现在新项目根目录是 trunk 子目录了。 Git 会自动移除所有不影响子目录的提交。\n\n\n# 全局修改邮箱地址\n\n另一个常见的情形是在你开始工作时忘记运行 git config 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 --commit-filter：\n\n$ git filter-branch --commit-filter '\n        if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ];\n        then\n                GIT_AUTHOR_NAME=\"Scott Chacon\";\n                GIT_AUTHOR_EMAIL=\"schacon@example.com\";\n                git commit-tree \"$@\";\n        else\n                git commit-tree \"$@\";\n        fi' HEAD\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。",normalizedContent:"# git 工具 - 重写历史\n\n许多时候，在使用 git 时，你可能想要修订提交历史。 git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 git stash 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\n\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\n\nnote   在满意之前不要推送你的工作git 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 在本地 随便重写历史记录。\n       然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。\n       简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。\n       \n\n\n# 修改最后一次提交\n\n修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：简单地修改提交信息， 或者通过添加、移除或修改文件来更改提交实际的内容。\n\n\n# 修改提交信息\n\n如果，你只是想修改最近一次提交的提交信息，那么很简单：\n\n$ git commit --amend\n\n\n1\n\n\n上面这条命令会将最后一次的提交信息载入到编辑器中供你修改。 当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中，它会成为新的最后一次提交。\n\n\n# 修改实际内容\n\n另一方面，如果你想要修改最后一次提交的实际内容，那么流程很相似：首先作出你想要补上的修改， 暂存它们，然后用 git commit --amend 以新的改进后的提交来 替换 掉旧有的最后一次提交，\n\n使用这个技巧的时候需要小心，因为修正会改变提交的 sha-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。\n\ntip   修补后的提交可能需要修补提交信息当你在修补一次提交时，可以同时修改提交信息和提交内容。\n      如果你修补了提交的内容，那么几乎肯定要更新提交消息以反映修改后的内容。另一方面，如果你的修补是琐碎的（如修改了一个笔误或添加了一个忘记暂存的文件），\n      那么之前的提交信息不必修改，你只需作出更改，暂存它们，然后通过以下命令避免不必要的编辑器环节即可：$ git\n      commit --amend --no-edit\n      \n\n\n# 修改多个提交信息\n\n为了修改在提交历史中较远的提交，必须使用更复杂的工具。 git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 head 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 git rebase 增加 -i 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。\n\n例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息， 将想要修改的最近一次提交的父提交作为参数传递给 git rebase -i 命令，即 head~2^ 或 head~3。 记住 ~3 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：\n\n$ git rebase -i head~3\n\n\n1\n\n\n再次记住这是一个变基命令——在 head~3..head 范围内的每一个修改了提交信息的提交及其 所有后裔 都会被重写。 不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。\n\n运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n# rebase 710f0f8..a5f4a0d onto 710f0f8\n#\n# commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current head with a name\n# t, reset <label> = reset head to a label\n# m, merge [-c <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). use -c <commit> to reword the commit message.\n#\n# these lines can be re-ordered; they are executed from top to bottom.\n#\n# if you remove a line here that commit will be lost.\n#\n# however, if you remove everything, the rebase will be aborted.\n#\n# note that empty commits are commented out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n需要重点注意的是相对于正常使用的 log 命令，这些提交显示的顺序是相反的。 运行一次 log 命令，会看到类似这样的东西：\n\n$ git log --pretty=format:\"%h %s\" head~3..head\na5f4a0d added cat-file\n310154e updated readme formatting and added blame\nf7f3f6d changed my name a bit\n\n\n1\n2\n3\n4\n\n\n注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（head~3）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。\n\n你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：\n\nedit f7f3f6d changed my name a bit\npick 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n当保存并退出编辑器时，git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：\n\n$ git rebase -i head~3\nstopped at f7f3f6d... changed my name a bit\nyou can amend the commit now, with\n\n       git commit --amend\n\nonce you're satisfied with your changes, run\n\n       git rebase --continue\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这些指令准确地告诉你该做什么。 输入\n\n$ git commit --amend\n\n\n1\n\n\n修改提交信息，然后退出编辑器。 然后，运行\n\n$ git rebase --continue\n\n\n1\n\n\n这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，git 将会停止，让你修正提交，然后继续直到完成。\n\n\n# 重新排序提交\n\n也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n改为这样：\n\npick 310154e updated readme formatting and added blame\npick f7f3f6d changed my name a bit\n\n\n1\n2\n\n\n当保存并退出编辑器时，git 将你的分支带回这些提交的父提交，应用 310154e 然后应用 f7f3f6d，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。\n\n\n# 压缩提交\n\n通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：\n\n#\n# commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current head with a name\n# t, reset <label> = reset head to a label\n# m, merge [-c <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). use -c <commit> to reword the commit message.\n#\n# these lines can be re-ordered; they are executed from top to bottom.\n#\n# if you remove a line here that commit will be lost.\n#\n# however, if you remove everything, the rebase will be aborted.\n#\n# note that empty commits are commented out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n如果，指定 “squash” 而不是 “pick” 或 “edit”，git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：\n\npick f7f3f6d changed my name a bit\nsquash 310154e updated readme formatting and added blame\nsquash a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n当保存并退出编辑器时，git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：\n\n# this is a combination of 3 commits.\n# the first commit's message is:\nchanged my name a bit\n\n# this is the 2nd commit message:\n\nupdated readme formatting and added blame\n\n# this is the 3rd commit message:\n\nadded cat-file\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。\n\n\n# 拆分提交\n\n拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated readme formatting”，第二个 “added blame” 来代替原来的 “updated readme formatting and added blame”。 可以通过修改 rebase -i 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：\n\npick f7f3f6d changed my name a bit\nedit 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n然后，当脚本带你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，git 带你到列表中第一个提交的父提交，应用第一个提交（f7f3f6d）， 应用第二个提交（310154e），然后让你进入命令行。 那里，可以通过 git reset head^ 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件取消暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 git rebase --continue：\n\n$ git reset head^\n$ git add readme\n$ git commit -m 'updated readme formatting'\n$ git add lib/simplegit.rb\n$ git commit -m 'added blame'\n$ git rebase --continue\n\n\n1\n2\n3\n4\n5\n6\n\n\ngit 在脚本中应用最后一次提交（a5f4a0d），历史记录看起来像这样：\n\n$ git log -4 --pretty=format:\"%h %s\"\n1c002dd added cat-file\n9b29157 added blame\n35cfb2b updated readme formatting\nf3cc40e changed my name a bit\n\n\n1\n2\n3\n4\n5\n\n\n再次强调，这些改动了所有在列表中的提交的 sha-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。\n\n\n# 核武器级选项：filter-branch\n\n有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 filter-branch，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。\n\ncaution   git filter-branch 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用\n          git-filter-repo，它是一个 python 脚本，相比大多数使用 filter-branch\n          的应用来说，它做得要更好。它的文档和源码可访问\n          https://github.com/newren/git-filter-repo 获取。\n          \n\n\n# 从每一个提交中移除一个文件\n\n这经常发生。 有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 filter-branch 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 --tree-filter 选项给 filter-branch：\n\n$ git filter-branch --tree-filter 'rm -f passwords.txt' head\nrewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)\nref 'refs/heads/master' was rewritten\n\n\n1\n2\n3\n\n\n--tree-filter 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 git filter-branch --tree-filter 'rm -f *~' head 的命令。\n\n最后将可以看到 git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 filter-branch 在所有分支上运行，可以给命令传递 --all 选项。\n\n\n# 使一个子目录做为新的根目录\n\n假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：\n\n$ git filter-branch --subdirectory-filter trunk head\nrewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)\nref 'refs/heads/master' was rewritten\n\n\n1\n2\n3\n\n\n现在新项目根目录是 trunk 子目录了。 git 会自动移除所有不影响子目录的提交。\n\n\n# 全局修改邮箱地址\n\n另一个常见的情形是在你开始工作时忘记运行 git config 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 --commit-filter：\n\n$ git filter-branch --commit-filter '\n        if [ \"$git_author_email\" = \"schacon@localhost\" ];\n        then\n                git_author_name=\"scott chacon\";\n                git_author_email=\"schacon@example.com\";\n                git commit-tree \"$@\";\n        else\n                git commit-tree \"$@\";\n        fi' head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 sha-1 校验和，这个命令会修改你的历史中的每一个提交的 sha-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git分支-分支原理",frontmatter:{title:"Git分支-分支原理",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/4bef1a/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/20.Git%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86.html",relativePath:"《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.md",key:"v-59177494",path:"/pages/4bef1a/",headers:[{level:3,title:"首次提交",slug:"首次提交",normalizedTitle:"首次提交",charIndex:130},{level:3,title:"再次提交",slug:"再次提交",normalizedTitle:"再次提交",charIndex:823},{level:3,title:"Git 的分支",slug:"git-的分支",normalizedTitle:"git 的分支",charIndex:896},{level:3,title:"创建分支",slug:"创建分支",normalizedTitle:"创建分支",charIndex:1088},{level:3,title:"当前分支的指针",slug:"当前分支的指针",normalizedTitle:"当前分支的指针",charIndex:1252},{level:3,title:"查看当前所在分支",slug:"查看当前所在分支",normalizedTitle:"查看当前所在分支",charIndex:1432},{level:3,title:"分支切换",slug:"分支切换",normalizedTitle:"分支切换",charIndex:1771},{level:3,title:"创建分支同时切换",slug:"创建分支同时切换",normalizedTitle:"创建分支同时切换",charIndex:3223}],headersStr:"首次提交 再次提交 Git 的分支 创建分支 当前分支的指针 查看当前所在分支 分支切换 创建分支同时切换",content:"# Git分支-分支原理\n\nGit 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\n\n\n# 首次提交\n\n在进行提交操作时，Git 会保存一个提交对象（commit object）。\n\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：\n\n$ git add README test.rb LICENSE\n$ git commit -m 'The initial commit of my project'\n\n\n1\n2\n\n\n当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。\n\n现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树对象 （记录着目录结构和 blob 对象索引）以及一个 提交对象（包含着指向前述树对象的指针和所有提交信息）。\n\n\n\n图1. 首次提交对象及其树结构 ▲\n\n# 小结：\n\n 1. git add 加入暂存操作，会为每个文件创建计算校验和，以及每个文件对应的文件快照（blob对象）。\n\n 2. git commit 提交操作，计算子目录或跟目录的校验和 保存为树对象。随后，创建一个提交对象，包含着指向树对象的指针和所有提交信息。\n\n\n# 再次提交\n\n做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。\n\n\n\n图2. 提交对象及其父对象 ▲\n\n\n# Git 的分支\n\nGit 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支指针会在每次提交时自动向前移动。\n\n> Git 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。\n\n\n\n图3. 分支及其提交历史 ▲\n\n\n# 创建分支\n\nGit 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：\n\n$ git branch testing\n\n\n1\n\n\n这会在当前所在的提交对象上创建一个指针。\n\n\n\n图4. 两个指向相同提交历史的分支 ▲\n\n\n# 当前分支的指针\n\nGit 是怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 HEAD 的特殊指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。\n\n\n\n图5. HEAD 指向当前所在的分支 ▲\n\n\n# 查看当前所在分支\n\n你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。\n\n$ git log --oneline --decorate\nf30ab (HEAD -> master, testing) add feature # f30ab提交对象 (HEAD当前所在分支 -> master分支，testing 分支)\n34ac2 Fixed bug # 34ac2 提交对象\n98ca9 The initial commit of my project # 98ca9 提交对象\n\n\n1\n2\n3\n4\n\n\n正如你所见，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。\n\n\n# 分支切换\n\n$ git checkout testing  # git checkout <分支名>\n\n\n1\n\n\n这样 HEAD 就指向 testing 分支了。\n\n\n\n图6. HEAD 指向当前所在的分支 ▲\n\n那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：\n\n$ vim test.rb\n$ git commit -a -m 'made a change'\n\n\n1\n2\n\n\n\n\n图7. HEAD 分支随着提交操作自动向前移动 ▲\n\n如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：\n\n$ git checkout master\n\n\n1\n\n\n\n\n图8. 检出时 HEAD 随之移动 ▲\n\n这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。\n\n我们不妨再稍微做些修改并提交：\n\n$ vim test.rb\n$ git commit -a -m 'made other changes'\n\n\n1\n2\n\n\n现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。\n\n\n\n图9. 项目分叉历史 ▲\n\n你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。\n\n$ git log --oneline --decorate --graph --all\n* c2b9e (HEAD, master) made other changes\n| * 87ab2 (testing) made a change\n|/\n* f30ab add feature\n* 34ac2 fixed bug\n* 98ca9 initial commit of my project\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？\n\n这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。\n\n\n# 创建分支同时切换\n\n通常我们会在创建一个新分支后立即切换过去，可以使用如下命令：\n\ngit checkout -b <newbranchname>\n\n\n1\n",normalizedContent:"# git分支-分支原理\n\ngit 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\n\n\n# 首次提交\n\n在进行提交操作时，git 会保存一个提交对象（commit object）。\n\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 sha-1 哈希算法），然后会把当前版本的文件快照保存到 git 仓库中 （git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：\n\n$ git add readme test.rb license\n$ git commit -m 'the initial commit of my project'\n\n\n1\n2\n\n\n当使用 git commit 进行提交操作时，git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 git 仓库中这些校验和保存为树对象。随后，git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，git 就可以在需要的时候重现此次保存的快照。\n\n现在，git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树对象 （记录着目录结构和 blob 对象索引）以及一个 提交对象（包含着指向前述树对象的指针和所有提交信息）。\n\n\n\n图1. 首次提交对象及其树结构 ▲\n\n# 小结：\n\n 1. git add 加入暂存操作，会为每个文件创建计算校验和，以及每个文件对应的文件快照（blob对象）。\n\n 2. git commit 提交操作，计算子目录或跟目录的校验和 保存为树对象。随后，创建一个提交对象，包含着指向树对象的指针和所有提交信息。\n\n\n# 再次提交\n\n做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。\n\n\n\n图2. 提交对象及其父对象 ▲\n\n\n# git 的分支\n\ngit 的分支，其实本质上仅仅是指向提交对象的可变指针。 git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支指针会在每次提交时自动向前移动。\n\n> git 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。\n\n\n\n图3. 分支及其提交历史 ▲\n\n\n# 创建分支\n\ngit 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：\n\n$ git branch testing\n\n\n1\n\n\n这会在当前所在的提交对象上创建一个指针。\n\n\n\n图4. 两个指向相同提交历史的分支 ▲\n\n\n# 当前分支的指针\n\ngit 是怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 head 的特殊指针，指向当前所在的本地分支（译注：将 head 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。\n\n\n\n图5. head 指向当前所在的分支 ▲\n\n\n# 查看当前所在分支\n\n你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。\n\n$ git log --oneline --decorate\nf30ab (head -> master, testing) add feature # f30ab提交对象 (head当前所在分支 -> master分支，testing 分支)\n34ac2 fixed bug # 34ac2 提交对象\n98ca9 the initial commit of my project # 98ca9 提交对象\n\n\n1\n2\n3\n4\n\n\n正如你所见，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。\n\n\n# 分支切换\n\n$ git checkout testing  # git checkout <分支名>\n\n\n1\n\n\n这样 head 就指向 testing 分支了。\n\n\n\n图6. head 指向当前所在的分支 ▲\n\n那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：\n\n$ vim test.rb\n$ git commit -a -m 'made a change'\n\n\n1\n2\n\n\n\n\n图7. head 分支随着提交操作自动向前移动 ▲\n\n如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：\n\n$ git checkout master\n\n\n1\n\n\n\n\n图8. 检出时 head 随之移动 ▲\n\n这条命令做了两件事。 一是使 head 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。\n\n我们不妨再稍微做些修改并提交：\n\n$ vim test.rb\n$ git commit -a -m 'made other changes'\n\n\n1\n2\n\n\n现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。\n\n\n\n图9. 项目分叉历史 ▲\n\n你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。\n\n$ git log --oneline --decorate --graph --all\n* c2b9e (head, master) made other changes\n| * 87ab2 (testing) made a change\n|/\n* f30ab add feature\n* 34ac2 fixed bug\n* 98ca9 initial commit of my project\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于 git 的分支实质上仅是包含所指对象校验和（长度为 40 的 sha-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？\n\n这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 git 鼓励开发人员频繁地创建和使用分支。\n\n\n# 创建分支同时切换\n\n通常我们会在创建一个新分支后立即切换过去，可以使用如下命令：\n\ngit checkout -b <newbranchname>\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git分支的新建与合并-分支操作",frontmatter:{title:"Git分支的新建与合并-分支操作",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/ea5a8c/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/30.Git%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6-%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C.html",relativePath:"《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.md",key:"v-7c3437ac",path:"/pages/ea5a8c/",headers:[{level:3,title:"创建分支并切换",slug:"创建分支并切换",normalizedTitle:"创建分支并切换",charIndex:45},{level:3,title:"切换分支",slug:"切换分支",normalizedTitle:"切换分支",charIndex:187},{level:3,title:"合并分支",slug:"合并分支",normalizedTitle:"合并分支",charIndex:575},{level:3,title:"删除分支",slug:"删除分支",normalizedTitle:"删除分支",charIndex:666},{level:3,title:"多次提交之后合并分支",slug:"多次提交之后合并分支",normalizedTitle:"多次提交之后合并分支",charIndex:781},{level:3,title:"遇到冲突时的分支合并",slug:"遇到冲突时的分支合并",normalizedTitle:"遇到冲突时的分支合并",charIndex:1123}],headersStr:"创建分支并切换 切换分支 合并分支 删除分支 多次提交之后合并分支 遇到冲突时的分支合并",content:"# Git分支的新建与合并-分支操作\n\n文档：Git 分支 - 分支的新建与合并\n\n\n# 创建分支并切换\n\n此时有一个需求需要在新的分支iss53上工作：\n\n$ git checkout -b iss53  # b表示branch\n\n\n1\n\n\n它是下面两条命令的简写：\n\n$ git branch iss53\n$ git checkout iss53\n\n\n1\n2\n\n\n\n# 切换分支\n\n突然有一个紧急问题要解决，需要在原来的master分支进行修复：\n\n$ git checkout master\n\n\n1\n\n\n在切换到master之前，需要iss53分支保持好一个干净的状态（修改都已提交）。\n\n注意：切换分支Git 会重置你的工作目录。\n\n> checkout 中文含义 “检出”，checkout <branch> 检出分支 => 检出指定分支的代码 => 重置工作目录并切换分支。\n\n接下来，你要修复这个紧急问题。 建立一个 hotfix 分支，在该分支上工作直到问题解决：\n\n$ git checkout -b hotfix\n\n# 中间过程在hotfix上修改了代码并提交\n$ echo 'test' > ./hotfix.txt\n$ git add .\n$ git commit -m 'fixed'\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 合并分支\n\n$ git checkout master # 首先切回master分支\n$ git merge hotfix # 把 hotfix 分支合并过来\n\n\n1\n2\n\n\n\n# 删除分支\n\n$ git branch -d hotfix # d表示delete\n\n# 然后切回iss53继续工作\n$ git checkout iss53\n\n\n1\n2\n3\n4\n\n\n注意删除分支是在 branch 命令上\n\n\n# 多次提交之后合并分支\n\n假设你已经修正了 #53 问题，打算合并到master分支：\n\n$ git checkout master\n$ git merga iss53\n\n\n1\n2\n\n\n这看似和之前的合并区别不大。此时你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照以及这两个分支的公共祖先，做一个简单的三方合并。\n\n和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。\n\n\n# 遇到冲突时的分支合并\n\n如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，就产生了冲突。\n\n合并过程中出现CONFLICT提升，表示有冲突\n\n$ git merge iss53\nAuto-merging index.html\nCONFLICT (content): Merge conflict in index.html\nAutomatic merge failed; fix conflicts and then commit the result.\n\n\n1\n2\n3\n4\n\n\n使用git status查看未合并状态。\n\n任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：\n\n<<<<<<< HEAD:index.html\n<div id=\"footer\">contact : email.support@github.com</div>\n=======\n<div id=\"footer\">\n please contact us at support@github.com\n</div>\n>>>>>>> iss53:index.html\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n你需要手动解决冲突，解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。\n\n如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。",normalizedContent:"# git分支的新建与合并-分支操作\n\n文档：git 分支 - 分支的新建与合并\n\n\n# 创建分支并切换\n\n此时有一个需求需要在新的分支iss53上工作：\n\n$ git checkout -b iss53  # b表示branch\n\n\n1\n\n\n它是下面两条命令的简写：\n\n$ git branch iss53\n$ git checkout iss53\n\n\n1\n2\n\n\n\n# 切换分支\n\n突然有一个紧急问题要解决，需要在原来的master分支进行修复：\n\n$ git checkout master\n\n\n1\n\n\n在切换到master之前，需要iss53分支保持好一个干净的状态（修改都已提交）。\n\n注意：切换分支git 会重置你的工作目录。\n\n> checkout 中文含义 “检出”，checkout <branch> 检出分支 => 检出指定分支的代码 => 重置工作目录并切换分支。\n\n接下来，你要修复这个紧急问题。 建立一个 hotfix 分支，在该分支上工作直到问题解决：\n\n$ git checkout -b hotfix\n\n# 中间过程在hotfix上修改了代码并提交\n$ echo 'test' > ./hotfix.txt\n$ git add .\n$ git commit -m 'fixed'\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 合并分支\n\n$ git checkout master # 首先切回master分支\n$ git merge hotfix # 把 hotfix 分支合并过来\n\n\n1\n2\n\n\n\n# 删除分支\n\n$ git branch -d hotfix # d表示delete\n\n# 然后切回iss53继续工作\n$ git checkout iss53\n\n\n1\n2\n3\n4\n\n\n注意删除分支是在 branch 命令上\n\n\n# 多次提交之后合并分支\n\n假设你已经修正了 #53 问题，打算合并到master分支：\n\n$ git checkout master\n$ git merga iss53\n\n\n1\n2\n\n\n这看似和之前的合并区别不大。此时你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，git 不得不做一些额外的工作。 出现这种情况的时候，git 会使用两个分支的末端所指的快照以及这两个分支的公共祖先，做一个简单的三方合并。\n\n和之前将分支指针向前推进所不同的是，git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。\n\n\n# 遇到冲突时的分支合并\n\n如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，git 就没法干净的合并它们，就产生了冲突。\n\n合并过程中出现conflict提升，表示有冲突\n\n$ git merge iss53\nauto-merging index.html\nconflict (content): merge conflict in index.html\nautomatic merge failed; fix conflicts and then commit the result.\n\n\n1\n2\n3\n4\n\n\n使用git status查看未合并状态。\n\n任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：\n\n<<<<<<< head:index.html\n<div id=\"footer\">contact : email.support@github.com</div>\n=======\n<div id=\"footer\">\n please contact us at support@github.com\n</div>\n>>>>>>> iss53:index.html\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n你需要手动解决冲突，解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，git 就会将它们标记为冲突已解决。\n\n如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git分支管理-查看分支",frontmatter:{title:"Git分支管理-查看分支",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/a399b3/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/40.Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF.html",relativePath:"《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.md",key:"v-60ad1438",path:"/pages/a399b3/",headers:[{level:3,title:"查看分支",slug:"查看分支",normalizedTitle:"查看分支",charIndex:10},{level:3,title:"查看每个分支的最后提交",slug:"查看每个分支的最后提交",normalizedTitle:"查看每个分支的最后提交",charIndex:152},{level:3,title:"查看已(未)合并的分支",slug:"查看已-未-合并的分支",normalizedTitle:"查看已(未)合并的分支",charIndex:297}],headersStr:"查看分支 查看每个分支的最后提交 查看已(未)合并的分支",content:"# Git分支管理-查看分支\n\n\n# 查看分支\n\n$ git branch\n  iss53\n* master  # 带星号*表示当前所在分支\n  testing\n\n\n1\n2\n3\n4\n\n\ngit branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\n\n\n# 查看每个分支的最后提交\n\n$ git branch -v\n  iss53   93b412c fix javascript issue\n* master  7a98805 Merge branch 'iss53'\n  testing 782fd34 test\n\n\n1\n2\n3\n4\n\n\n\n# 查看已(未)合并的分支\n\n--merged 与 --no-merged 这两个选项可以查看哪些分支已经合并或未合并到 当前 分支。\n\n$ git branch --merged # 查看已合并分支列表\n  iss53\n* master\n\n\n1\n2\n3\n\n\n上面列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；\n\n$ git branch --no-merged # 查看未合并的分支列表\n  testing\n\n\n1\n2\n\n\n上面显示未合并的分支，尝试使用 git branch -d 命令删除它时会失败：\n\n$ git branch -d testing\nerror: The branch 'testing' is not fully merged.\nIf you are sure you want to delete it, run 'git branch -D testing'.\n\n\n1\n2\n3\n\n\n强制删除未合并的分支:\n\n$ git branch -D testing\n\n\n1\n\n\n# 查看指定分支的已(未)合并的分支\n\n上面描述的选项 --merged 和 --no-merged 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 当前 分支的分支。\n\n你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。 例如，尚未合并到 testing 分支的有哪些？\n\n$ git branch --no-merged testing\n  topicA\n  featureB\n\n\n1\n2\n3\n",normalizedContent:"# git分支管理-查看分支\n\n\n# 查看分支\n\n$ git branch\n  iss53\n* master  # 带星号*表示当前所在分支\n  testing\n\n\n1\n2\n3\n4\n\n\ngit branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\n\n\n# 查看每个分支的最后提交\n\n$ git branch -v\n  iss53   93b412c fix javascript issue\n* master  7a98805 merge branch 'iss53'\n  testing 782fd34 test\n\n\n1\n2\n3\n4\n\n\n\n# 查看已(未)合并的分支\n\n--merged 与 --no-merged 这两个选项可以查看哪些分支已经合并或未合并到 当前 分支。\n\n$ git branch --merged # 查看已合并分支列表\n  iss53\n* master\n\n\n1\n2\n3\n\n\n上面列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；\n\n$ git branch --no-merged # 查看未合并的分支列表\n  testing\n\n\n1\n2\n\n\n上面显示未合并的分支，尝试使用 git branch -d 命令删除它时会失败：\n\n$ git branch -d testing\nerror: the branch 'testing' is not fully merged.\nif you are sure you want to delete it, run 'git branch -d testing'.\n\n\n1\n2\n3\n\n\n强制删除未合并的分支:\n\n$ git branch -d testing\n\n\n1\n\n\n# 查看指定分支的已(未)合并的分支\n\n上面描述的选项 --merged 和 --no-merged 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 当前 分支的分支。\n\n你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。 例如，尚未合并到 testing 分支的有哪些？\n\n$ git branch --no-merged testing\n  topica\n  featureb\n\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git分支开发工作流",frontmatter:{title:"Git分支开发工作流",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/49ee30/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/50.Git%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81.html",relativePath:"《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.md",key:"v-42d161dc",path:"/pages/49ee30/",headers:[{level:3,title:"长期分支",slug:"长期分支",normalizedTitle:"长期分支",charIndex:32},{level:3,title:"主题分支 (短期分支)",slug:"主题分支-短期分支",normalizedTitle:"主题分支 (短期分支)",charIndex:625}],headersStr:"长期分支 主题分支 (短期分支)",content:"# Git分支开发工作流\n\n文档：Git分支开发工作流\n\n\n# 长期分支\n\n因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\n\n许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码，开发过程在dev分支，开发完成后并入test分支进行测试，通过测试的稳定代码才并入master分支中。\n\ndev和test分支不需要保持绝对稳定，但在test通过测试达到稳定状态，就可以被合并入master分支。\n\n事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支(master)的指针总是在提交历史中落后一大截，而前沿分支(dev或test)的指针往往比较靠前。\n\n你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。\n\n\n# 主题分支 (短期分支)\n\n主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。\n\n你已经在上一节中你创建的 iss53 和 hotfix 主题分支中看到过这种用法。 你在上一节用到的主题分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。\n\n考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：\n\n\n\n图1. 拥有多个主题分支的提交历史 ▲\n\n现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案。 另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：\n\n\n\n图2. 合并了 dumbidea 和 iss91v2 分支之后的提交历史 ▲\n\n我们将会在 分布式 Git 中向你揭示更多有关分支工作流的细节， 因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。\n\n请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。",normalizedContent:"# git分支开发工作流\n\n文档：git分支开发工作流\n\n\n# 长期分支\n\n因为 git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\n\n许多使用 git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码，开发过程在dev分支，开发完成后并入test分支进行测试，通过测试的稳定代码才并入master分支中。\n\ndev和test分支不需要保持绝对稳定，但在test通过测试达到稳定状态，就可以被合并入master分支。\n\n事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支(master)的指针总是在提交历史中落后一大截，而前沿分支(dev或test)的指针往往比较靠前。\n\n你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。\n\n\n# 主题分支 (短期分支)\n\n主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。\n\n你已经在上一节中你创建的 iss53 和 hotfix 主题分支中看到过这种用法。 你在上一节用到的主题分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。\n\n考虑这样一个例子，你在 master 分支上工作到 c1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 c4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 c10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：\n\n\n\n图1. 拥有多个主题分支的提交历史 ▲\n\n现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案。 另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 c5 和 c6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：\n\n\n\n图2. 合并了 dumbidea 和 iss91v2 分支之后的提交历史 ▲\n\n我们将会在 分布式 git 中向你揭示更多有关分支工作流的细节， 因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。\n\n请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 git 版本库中 —— 没有与服务器发生交互。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git工具-重置揭密",frontmatter:{title:"Git工具-重置揭密",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/d9e9c6/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/110.Git%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86.html",relativePath:"《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.md",key:"v-92c363a2",path:"/pages/d9e9c6/",headers:[{level:2,title:"三棵树",slug:"三棵树",normalizedTitle:"三棵树",charIndex:147},{level:3,title:"HEAD",slug:"head",normalizedTitle:"head",charIndex:348},{level:3,title:"索引",slug:"索引",normalizedTitle:"索引",charIndex:257},{level:3,title:"工作目录",slug:"工作目录",normalizedTitle:"工作目录",charIndex:1116},{level:2,title:"工作流程",slug:"工作流程",normalizedTitle:"工作流程",charIndex:1764},{level:2,title:"重置的作用",slug:"重置的作用",normalizedTitle:"重置的作用",charIndex:2573},{level:3,title:"第 1 步：移动 HEAD",slug:"第-1-步-移动-head",normalizedTitle:"第 1 步：移动 head",charIndex:2720},{level:3,title:"第 2 步：更新索引（--mixed）",slug:"第-2-步-更新索引-mixed",normalizedTitle:"第 2 步：更新索引（--mixed）",charIndex:3207},{level:3,title:"第 3 步：更新工作目录（--hard）",slug:"第-3-步-更新工作目录-hard",normalizedTitle:"第 3 步：更新工作目录（--hard）",charIndex:3507},{level:3,title:"回顾",slug:"回顾",normalizedTitle:"回顾",charIndex:3867},{level:2,title:"通过路径来重置",slug:"通过路径来重置",normalizedTitle:"通过路径来重置",charIndex:4002},{level:2,title:"压缩",slug:"压缩",normalizedTitle:"压缩",charIndex:4855},{level:2,title:"检出",slug:"检出",normalizedTitle:"检出",charIndex:1113},{level:3,title:"不带路径",slug:"不带路径",normalizedTitle:"不带路径",charIndex:5428},{level:3,title:"带路径",slug:"带路径",normalizedTitle:"带路径",charIndex:5429},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6348}],headersStr:"三棵树 HEAD 索引 工作目录 工作流程 重置的作用 第 1 步：移动 HEAD 第 2 步：更新索引（--mixed） 第 3 步：更新工作目录（--hard） 回顾 通过路径来重置 压缩 检出 不带路径 带路径 总结",content:"# Git 工具 - 重置揭密\n\n在继续了解更专业的工具前，我们先探讨一下 Git 的 reset 和 checkout 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\n\n\n# 三棵树\n\n理解 reset 和 checkout 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\n\nGit 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：\n\n树                   用途\nHEAD                上一次提交的快照，下一次提交的父结点\nIndex               预期的下一次提交的快照\nWorking Directory   沙盒\n\n\n# HEAD\n\nHEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。\n\n其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：\n\n$ git cat-file -p HEAD\ntree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\nauthor Scott Chacon  1301511835 -0700\ncommitter Scott Chacon  1301511835 -0700\n\ninitial commit\n\n$ git ls-tree -r HEAD\n100644 blob a906cb2a4a904a152...   README\n100644 blob 8f94139338f9404f2...   Rakefile\n040000 tree 99f1a6d12cb4b6f19...   lib\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nGit 的 cat-file 和 ls-tree 是底层命令，它们一般用于底层工作，在日常工作中并不使用。 不过它们能帮助我们了解到底发生了什么。\n\n\n# 索引\n\n索引是你的 预期的下一次提交。 我们也会将这个概念引用为 Git 的“暂存区”，这就是当你运行 git commit 时 Git 看起来的样子。\n\nGit 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。\n\n$ git ls-files -s\n100644 a906cb2a4a904a152e80877d4088654daad0c859 0\tREADME\n100644 8f94139338f9404f26296befa88755fc2598c289 0\tRakefile\n100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0\tlib/simplegit.rb\n\n\n1\n2\n3\n4\n\n\n再说一次，我们在这里又用到了 git ls-files 这个幕后的命令，它会显示出索引当前的样子。\n\n确切来说，索引在技术上并非树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。\n\n\n# 工作目录\n\n最后，你就有了自己的 工作目录（通常也叫 工作区）。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。\n\n$ tree\n.\n├── README\n├── Rakefile\n└── lib\n    └── simplegit.rb\n\n1 directory, 3 files\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 工作流程\n\n经典的 Git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。\n\n\n\n让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 git init，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的 master 分支。\n\n\n\n此时，只有工作目录有内容。\n\n现在我们想要提交这个文件，所以用 git add 来获取工作目录中的内容，并将其复制到索引中。\n\n\n\n接着运行 git commit，它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。\n\n\n\n此时如果我们运行 git status，会发现没有任何改动，因为现在三棵树完全相同。\n\n现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。\n\n\n\n如果现在运行 git status，我们会看到文件显示在 “Changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 git add 来将它暂存到索引中。\n\n\n\n此时，由于索引和 HEAD 不同，若运行 git status 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 git commit 来完成提交。\n\n\n\n现在运行 git status 会没有输出，因为三棵树又变得相同了。\n\n切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 HEAD 指向新的分支引用，将 索引 填充为该次提交的快照， 然后将 索引 的内容复制到 工作目录 中。\n\n\n# 重置的作用\n\n在以下情景中观察 reset 命令会更有意义。\n\n为了演示这些例子，假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看起来是这样的：\n\n\n\n让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。\n\n\n# 第 1 步：移动 HEAD\n\nreset 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 master 分支（例如，你正在 master 分支上）， 运行 git reset 9e5e6a4 将会使 master 指向 9e5e6a4。\n\n\n\n无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset --soft，它将仅仅停在那儿。\n\n现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了（见 修改最后一次提交）。\n\n\n# 第 2 步：更新索引（--mixed）\n\n注意，如果你现在运行 git status 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。\n\n接下来，reset 会用 HEAD 指向的当前快照的内容来更新索引。\n\n\n\n如果指定 --mixed 选项，reset 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 git reset HEAD~），这就是命令将会停止的地方。\n\n现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。\n\n\n# 第 3 步：更新工作目录（--hard）\n\nreset 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 --hard 选项，它将会继续这一步。\n\n\n\n现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、git add 和 git commit 命令 以及 工作目录中的所有工作。\n\n必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版本， 我们可以通过 reflog 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。\n\n\n# 回顾\n\nreset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：\n\n 1. 移动 HEAD 分支的指向 （若指定了 --soft，则到此停止）\n 2. 使索引看起来像 HEAD （若未指定 --hard，则到此停止）\n 3. 使工作目录看起来像索引\n\n\n# 通过路径来重置\n\n前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。\n\n现在，假如我们运行 git reset file.txt （这其实是 git reset --mixed HEAD file.txt 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 --soft 或 --hard），它会：\n\n 1. 移动 HEAD 分支的指向 （已跳过）\n 2. 让索引看起来像 HEAD （到此处停止）\n\n所以它本质上只是将 file.txt 从 HEAD 复制到索引中。\n\n\n\n它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 git add 所做的事，就会发现它们正好相反。\n\n\n\n这就是为什么 git status 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。）\n\n我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 git reset eb43bf file.txt 的命令即可。\n\n\n\n它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 git add 添加它， 然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 git commit，它就会记录一条“将该文件恢复到 v1 版本”的更改， 尽管我们并未在工作目录中真正地再次拥有它。\n\n还有一点同 git add 一样，就是 reset 命令也可以接受一个 --patch 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。\n\n\n# 压缩\n\n我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。\n\n假设你的一系列提交信息中有 “oops.”“WIP” 和 “forgot this file”， 聪明的你就能使用 reset 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。）\n\n假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。\n\n\n\n那么可以运行 git reset --soft HEAD~2 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）：\n\n\n\n然后只需再次运行 git commit：\n\n\n\n现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 file-a.txt 的提交， 接着第二个提交将 file-a.txt 修改成了 v3 版并增加了 file-b.txt。 包含 v2 版本的文件已经不在历史中了。\n\n\n# 检出\n\n最后，你大概还想知道 checkout 和 reset 之间的区别。 和 reset 一样，checkout 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。\n\n\n# 不带路径\n\n运行 git checkout [branch] 与运行 git reset --hard [branch] 非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。\n\n首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 reset --hard 则会不做检查就全面地替换所有东西。\n\n第二个重要的区别是 checkout 如何更新 HEAD。 reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。\n\n例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上（所以 HEAD 指向它）。 如果我们运行 git reset master，那么 develop 自身现在会和 master 指向同一个提交。 而如果我们运行 git checkout master 的话，develop 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 master。\n\n所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但_做法_是非常不同的。 reset 会移动 HEAD 分支的指向，而 checkout 则移动 HEAD 自身。\n\n\n\n\n# 带路径\n\n运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 HEAD。 它就像 git reset [branch] file 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 git reset --hard [branch] file（如果 reset 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 HEAD。\n\n此外，同 git reset 和 git add 一样，checkout 也接受一个 --patch 选项，允许你根据选择一块一块地恢复文件内容。\n\n\n# 总结\n\n希望你现在熟悉并理解了 reset 命令，不过关于它和 checkout 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。\n\n下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而 “HEAD” 则表示只移动了 HEAD 自身。 特别注意 WD Safe? 一列——如果它标记为 NO，那么运行该命令之前请考虑一下。\n\n                            HEAD   INDEX   WORKDIR   WD SAFE?\nCommit Level                                         \nreset --soft [commit]       REF    NO      NO        YES\nreset [commit]              REF    YES     NO        YES\nreset --hard [commit]       REF    YES     YES       NO\ncheckout <commit>           HEAD   YES     YES       YES\nFile Level                                           \nreset [commit] <paths>      NO     YES     NO        YES\ncheckout [commit] <paths>   NO     YES     YES       NO",normalizedContent:"# git 工具 - 重置揭密\n\n在继续了解更专业的工具前，我们先探讨一下 git 的 reset 和 checkout 命令。 在初遇的 git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\n\n\n# 三棵树\n\n理解 reset 和 checkout 的最简方法，就是以 git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\n\ngit 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：\n\n树                   用途\nhead                上一次提交的快照，下一次提交的父结点\nindex               预期的下一次提交的快照\nworking directory   沙盒\n\n\n# head\n\nhead 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 head 将是下一次提交的父结点。 通常，理解 head 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。\n\n其实，查看快照的样子很容易。 下例就显示了 head 快照实际的目录列表，以及其中每个文件的 sha-1 校验和：\n\n$ git cat-file -p head\ntree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\nauthor scott chacon  1301511835 -0700\ncommitter scott chacon  1301511835 -0700\n\ninitial commit\n\n$ git ls-tree -r head\n100644 blob a906cb2a4a904a152...   readme\n100644 blob 8f94139338f9404f2...   rakefile\n040000 tree 99f1a6d12cb4b6f19...   lib\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ngit 的 cat-file 和 ls-tree 是底层命令，它们一般用于底层工作，在日常工作中并不使用。 不过它们能帮助我们了解到底发生了什么。\n\n\n# 索引\n\n索引是你的 预期的下一次提交。 我们也会将这个概念引用为 git 的“暂存区”，这就是当你运行 git commit 时 git 看起来的样子。\n\ngit 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。\n\n$ git ls-files -s\n100644 a906cb2a4a904a152e80877d4088654daad0c859 0\treadme\n100644 8f94139338f9404f26296befa88755fc2598c289 0\trakefile\n100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0\tlib/simplegit.rb\n\n\n1\n2\n3\n4\n\n\n再说一次，我们在这里又用到了 git ls-files 这个幕后的命令，它会显示出索引当前的样子。\n\n确切来说，索引在技术上并非树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。\n\n\n# 工作目录\n\n最后，你就有了自己的 工作目录（通常也叫 工作区）。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。\n\n$ tree\n.\n├── readme\n├── rakefile\n└── lib\n    └── simplegit.rb\n\n1 directory, 3 files\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 工作流程\n\n经典的 git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。\n\n\n\n让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 git init，这会创建一个 git 仓库，其中的 head 引用指向未创建的 master 分支。\n\n\n\n此时，只有工作目录有内容。\n\n现在我们想要提交这个文件，所以用 git add 来获取工作目录中的内容，并将其复制到索引中。\n\n\n\n接着运行 git commit，它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。\n\n\n\n此时如果我们运行 git status，会发现没有任何改动，因为现在三棵树完全相同。\n\n现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。\n\n\n\n如果现在运行 git status，我们会看到文件显示在 “changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 git add 来将它暂存到索引中。\n\n\n\n此时，由于索引和 head 不同，若运行 git status 的话就会看到 “changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 git commit 来完成提交。\n\n\n\n现在运行 git status 会没有输出，因为三棵树又变得相同了。\n\n切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 head 指向新的分支引用，将 索引 填充为该次提交的快照， 然后将 索引 的内容复制到 工作目录 中。\n\n\n# 重置的作用\n\n在以下情景中观察 reset 命令会更有意义。\n\n为了演示这些例子，假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看起来是这样的：\n\n\n\n让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。\n\n\n# 第 1 步：移动 head\n\nreset 做的第一件事是移动 head 的指向。 这与改变 head 自身不同（checkout 所做的）；reset 移动 head 指向的分支。 这意味着如果 head 设置为 master 分支（例如，你正在 master 分支上）， 运行 git reset 9e5e6a4 将会使 master 指向 9e5e6a4。\n\n\n\n无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset --soft，它将仅仅停在那儿。\n\n现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，git 会创建一个新的提交，并移动 head 所指向的分支来使其指向该提交。 当你将它 reset 回 head~（head 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了（见 修改最后一次提交）。\n\n\n# 第 2 步：更新索引（--mixed）\n\n注意，如果你现在运行 git status 的话，就会看到新的 head 和以绿色标出的它和索引之间的区别。\n\n接下来，reset 会用 head 指向的当前快照的内容来更新索引。\n\n\n\n如果指定 --mixed 选项，reset 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 git reset head~），这就是命令将会停止的地方。\n\n现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。\n\n\n# 第 3 步：更新工作目录（--hard）\n\nreset 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 --hard 选项，它将会继续这一步。\n\n\n\n现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、git add 和 git commit 命令 以及 工作目录中的所有工作。\n\n必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 git 数据库中的一个提交内还留有该文件的 v3 版本， 我们可以通过 reflog 来找回它。但是若该文件还未提交，git 仍会覆盖它从而导致无法恢复。\n\n\n# 回顾\n\nreset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：\n\n 1. 移动 head 分支的指向 （若指定了 --soft，则到此停止）\n 2. 使索引看起来像 head （若未指定 --hard，则到此停止）\n 3. 使工作目录看起来像索引\n\n\n# 通过路径来重置\n\n前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 head 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。\n\n现在，假如我们运行 git reset file.txt （这其实是 git reset --mixed head file.txt 的简写形式，因为你既没有指定一个提交的 sha-1 或分支，也没有指定 --soft 或 --hard），它会：\n\n 1. 移动 head 分支的指向 （已跳过）\n 2. 让索引看起来像 head （到此处停止）\n\n所以它本质上只是将 file.txt 从 head 复制到索引中。\n\n\n\n它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 git add 所做的事，就会发现它们正好相反。\n\n\n\n这就是为什么 git status 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。）\n\n我们可以不让 git 从 head 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 git reset eb43bf file.txt 的命令即可。\n\n\n\n它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 git add 添加它， 然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 git commit，它就会记录一条“将该文件恢复到 v1 版本”的更改， 尽管我们并未在工作目录中真正地再次拥有它。\n\n还有一点同 git add 一样，就是 reset 命令也可以接受一个 --patch 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。\n\n\n# 压缩\n\n我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。\n\n假设你的一系列提交信息中有 “oops.”“wip” 和 “forgot this file”， 聪明的你就能使用 reset 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。）\n\n假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。\n\n\n\n那么可以运行 git reset --soft head~2 来将 head 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）：\n\n\n\n然后只需再次运行 git commit：\n\n\n\n现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 file-a.txt 的提交， 接着第二个提交将 file-a.txt 修改成了 v3 版并增加了 file-b.txt。 包含 v2 版本的文件已经不在历史中了。\n\n\n# 检出\n\n最后，你大概还想知道 checkout 和 reset 之间的区别。 和 reset 一样，checkout 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。\n\n\n# 不带路径\n\n运行 git checkout [branch] 与运行 git reset --hard [branch] 非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。\n\n首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 reset --hard 则会不做检查就全面地替换所有东西。\n\n第二个重要的区别是 checkout 如何更新 head。 reset 会移动 head 分支的指向，而 checkout 只会移动 head 自身来指向另一个分支。\n\n例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上（所以 head 指向它）。 如果我们运行 git reset master，那么 develop 自身现在会和 master 指向同一个提交。 而如果我们运行 git checkout master 的话，develop 不会移动，head 自身会移动。 现在 head 将会指向 master。\n\n所以，虽然在这两种情况下我们都移动 head 使其指向了提交 a，但_做法_是非常不同的。 reset 会移动 head 分支的指向，而 checkout 则移动 head 自身。\n\n\n\n\n# 带路径\n\n运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 head。 它就像 git reset [branch] file 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 git reset --hard [branch] file（如果 reset 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 head。\n\n此外，同 git reset 和 git add 一样，checkout 也接受一个 --patch 选项，允许你根据选择一块一块地恢复文件内容。\n\n\n# 总结\n\n希望你现在熟悉并理解了 reset 命令，不过关于它和 checkout 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。\n\n下面的速查表列出了命令对树的影响。 “head” 一列中的 “ref” 表示该命令移动了 head 指向的分支引用，而 “head” 则表示只移动了 head 自身。 特别注意 wd safe? 一列——如果它标记为 no，那么运行该命令之前请考虑一下。\n\n                            head   index   workdir   wd safe?\ncommit level                                         \nreset --soft [commit]       ref    no      no        yes\nreset [commit]              ref    yes     no        yes\nreset --hard [commit]       ref    yes     yes       no\ncheckout <commit>           head   yes     yes       yes\nfile level                                           \nreset [commit] <paths>      no     yes     no        yes\ncheckout [commit] <paths>   no     yes     yes       no",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git分支-远程分支",frontmatter:{title:"Git分支-远程分支",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/574d62/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/60.Git%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF.html",relativePath:"《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.md",key:"v-1d730a99",path:"/pages/574d62/",headers:[{level:3,title:"查看远程引用列表与信息",slug:"查看远程引用列表与信息",normalizedTitle:"查看远程引用列表与信息",charIndex:71},{level:3,title:"远程跟踪分支",slug:"远程跟踪分支",normalizedTitle:"远程跟踪分支",charIndex:184},{level:3,title:"推送",slug:"推送",normalizedTitle:"推送",charIndex:432},{level:3,title:"跟踪分支",slug:"跟踪分支",normalizedTitle:"跟踪分支",charIndex:186},{level:3,title:"查看跟踪分支",slug:"查看跟踪分支",normalizedTitle:"查看跟踪分支",charIndex:5263},{level:3,title:"拉取",slug:"拉取",normalizedTitle:"拉取",charIndex:605},{level:3,title:"删除远程分支",slug:"删除远程分支",normalizedTitle:"删除远程分支",charIndex:6361}],headersStr:"查看远程引用列表与信息 远程跟踪分支 推送 跟踪分支 查看跟踪分支 拉取 删除远程分支",content:"# Git分支-远程分支\n\n远程引用是对远程仓库的引用（指针），包括分支、标签等等。\n\n> 远程分支本质上也是一个指针，指向远程地址\n\n\n# 查看远程引用列表与信息\n\ngit ls-remote <remote> # 远程引用的完整列表\ngit remote show <remote> # 远程分支的更多信息\n\n\n1\n2\n\n\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\n\n\n# 远程跟踪分支\n\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\n\n它们以 <remote>/<branch> 的形式命名。 例如，如果你想要查看最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支， 然而在服务器上的分支会以 origin/iss53 来表示。\n\n这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。\n\n笔记：从远程克隆下来的仓库有一个叫origin/master的远程跟踪分支 和 一个本地的master分支\n\n> 笔记：“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。\n\n\n\n图1. 克隆之后的服务器与本地仓库 ▲\n\n如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到 git.ourcompany.com 并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。\n\n\n\n图2. 本地与远程的工作可以分叉 ▲\n\n如果要与给定的远程仓库同步数据，运行 git fetch <remote> 命令（在本例中为 git fetch origin）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com）， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。\n\n\n\n图3. git fetch 更新你的远程跟踪分支 ▲\n\n笔记: 本地的 master 分支 可能 和 远程跟踪分支 origin/master 分叉\n\n为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 Git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为完整 URL 的缩写。远程仓库名本质上是远程URL的缩写\n\n\n\n图4. 添加另一个远程仓库 ▲\n\n现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集， 所以 Git 并不会抓取数据而是会设置远程跟踪分支 teamone/master 指向 teamone 的 master 分支。\n\n\n\n图5. 远程跟踪分支 teamone/master ▲\n\n\n# 推送\n\n当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。\n\n如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push <remote> <branch>:\n\n$ git push origin serverfix\nCounting objects: 24, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (15/15), done.\nWriting objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.\nTotal 24 (delta 2), reused 0 (delta 0)\nTo https://github.com/schacon/simplegit\n * [new branch]      serverfix -> serverfix\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里有些工作被简化了。 Git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix， 那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 Git 内部原理 的 refs/heads/ 部分， 但是现在可以先把它放在儿。你也可以运行 git push origin serverfix:serverfix， 它会做同样的事——也就是说“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。\n\n# 重命名远程仓库上的分支名\n\n如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。\n\nNOTE   如何避免每次输入密码如果你正在使用 HTTPS URL 来推送，GIT 服务器会询问用户名与密码。\n       默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，你可以设置一个\n       “CREDENTIAL CACHE”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 GIT CONFIG\n       --GLOBAL CREDENTIAL.HELPER CACHE 来设置它。想要了解更多关于不同验证缓存的可用选项，查看\n       凭证存储。\n       \n\n下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：\n\n$ git fetch origin\nremote: Counting objects: 7, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 3 (delta 0)\nUnpacking objects: 100% (3/3), done.\nFrom https://github.com/schacon/simplegit\n * [new branch]      serverfix    -> origin/serverfix\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支——只有一个不可以修改的 origin/serverfix 指针。\n\n可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上：\n\n$ git checkout -b serverfix origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。\n\n\n# 跟踪分支\n\n从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。\n\n当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行 git checkout -b <branch> <remote>/<branch>。 这是一个十分常用的操作所以 Git 提供了 --track 快捷方式：\n\n$ git checkout --track origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：\n\n$ git checkout serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：\n\n$ git checkout -b sf origin/serverfix\nBranch sf set up to track remote branch serverfix from origin.\nSwitched to a new branch 'sf'\n\n\n1\n2\n3\n\n\n现在，本地分支 sf 会自动从 origin/serverfix 拉取。\n\n设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。\n\n$ git branch -u origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\n\n\n1\n2\n\n\nNOTE   上游快捷方式当设置好跟踪分支后，可以通过简写 @{UPSTREAM} 或 @{U} 来引用它的上游分支。 所以在\n       MASTER 分支时并且它正在跟踪 ORIGIN/MASTER 时，如果愿意的话可以使用 GIT MERGE @{U}\n       来取代 GIT MERGE ORIGIN/MASTER。\n       \n\n\n# 查看跟踪分支\n\n如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。\n\n$ git branch -vv\n  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets\n  master    1ae2a45 [origin/master] deploying index fix\n* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it\n  testing   5ea463a trying something new\n\n\n1\n2\n3\n4\n5\n\n\n这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。\n\n需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：\n\n$ git fetch --all; git branch -vv\n\n\n1\n\n\n\n# 拉取\n\n当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。\n\n由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。\n\n\n# 删除远程分支\n\n假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：\n\n$ git push origin --delete serverfix\nTo https://github.com/schacon/simplegit\n - [deleted]         serverfix\n\n\n1\n2\n3\n\n\n基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。",normalizedContent:"# git分支-远程分支\n\n远程引用是对远程仓库的引用（指针），包括分支、标签等等。\n\n> 远程分支本质上也是一个指针，指向远程地址\n\n\n# 查看远程引用列表与信息\n\ngit ls-remote <remote> # 远程引用的完整列表\ngit remote show <remote> # 远程分支的更多信息\n\n\n1\n2\n\n\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\n\n\n# 远程跟踪分支\n\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\n\n它们以 <remote>/<branch> 的形式命名。 例如，如果你想要查看最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支， 然而在服务器上的分支会以 origin/iss53 来表示。\n\n这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 git 服务器。 如果你从这里克隆，git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。\n\n笔记：从远程克隆下来的仓库有一个叫origin/master的远程跟踪分支 和 一个本地的master分支\n\n> 笔记：“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master” 一样，在 git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。\n\n\n\n图1. 克隆之后的服务器与本地仓库 ▲\n\n如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到 git.ourcompany.com 并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。\n\n\n\n图2. 本地与远程的工作可以分叉 ▲\n\n如果要与给定的远程仓库同步数据，运行 git fetch <remote> 命令（在本例中为 git fetch origin）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com）， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。\n\n\n\n图3. git fetch 更新你的远程跟踪分支 ▲\n\n笔记: 本地的 master 分支 可能 和 远程跟踪分支 origin/master 分叉\n\n为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为完整 url 的缩写。远程仓库名本质上是远程url的缩写\n\n\n\n图4. 添加另一个远程仓库 ▲\n\n现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集， 所以 git 并不会抓取数据而是会设置远程跟踪分支 teamone/master 指向 teamone 的 master 分支。\n\n\n\n图5. 远程跟踪分支 teamone/master ▲\n\n\n# 推送\n\n当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。\n\n如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push <remote> <branch>:\n\n$ git push origin serverfix\ncounting objects: 24, done.\ndelta compression using up to 8 threads.\ncompressing objects: 100% (15/15), done.\nwriting objects: 100% (24/24), 1.91 kib | 0 bytes/s, done.\ntotal 24 (delta 2), reused 0 (delta 0)\nto https://github.com/schacon/simplegit\n * [new branch]      serverfix -> serverfix\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里有些工作被简化了。 git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix， 那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 git 内部原理 的 refs/heads/ 部分， 但是现在可以先把它放在儿。你也可以运行 git push origin serverfix:serverfix， 它会做同样的事——也就是说“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。\n\n# 重命名远程仓库上的分支名\n\n如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。\n\nnote   如何避免每次输入密码如果你正在使用 https url 来推送，git 服务器会询问用户名与密码。\n       默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，你可以设置一个\n       “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config\n       --global credential.helper cache 来设置它。想要了解更多关于不同验证缓存的可用选项，查看\n       凭证存储。\n       \n\n下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：\n\n$ git fetch origin\nremote: counting objects: 7, done.\nremote: compressing objects: 100% (2/2), done.\nremote: total 3 (delta 0), reused 3 (delta 0)\nunpacking objects: 100% (3/3), done.\nfrom https://github.com/schacon/simplegit\n * [new branch]      serverfix    -> origin/serverfix\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支——只有一个不可以修改的 origin/serverfix 指针。\n\n可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上：\n\n$ git checkout -b serverfix origin/serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\nswitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。\n\n\n# 跟踪分支\n\n从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，git 能自动地识别去哪个服务器上抓取、合并到哪个分支。\n\n当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行 git checkout -b <branch> <remote>/<branch>。 这是一个十分常用的操作所以 git 提供了 --track 快捷方式：\n\n$ git checkout --track origin/serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\nswitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 git 就会为你创建一个跟踪分支：\n\n$ git checkout serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\nswitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：\n\n$ git checkout -b sf origin/serverfix\nbranch sf set up to track remote branch serverfix from origin.\nswitched to a new branch 'sf'\n\n\n1\n2\n3\n\n\n现在，本地分支 sf 会自动从 origin/serverfix 拉取。\n\n设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。\n\n$ git branch -u origin/serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\n\n\n1\n2\n\n\nnote   上游快捷方式当设置好跟踪分支后，可以通过简写 @{upstream} 或 @{u} 来引用它的上游分支。 所以在\n       master 分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u}\n       来取代 git merge origin/master。\n       \n\n\n# 查看跟踪分支\n\n如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。\n\n$ git branch -vv\n  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets\n  master    1ae2a45 [origin/master] deploying index fix\n* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it\n  testing   5ea463a trying something new\n\n\n1\n2\n3\n4\n5\n\n\n这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。\n\n需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：\n\n$ git fetch --all; git branch -vv\n\n\n1\n\n\n\n# 拉取\n\n当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。\n\n由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。\n\n\n# 删除远程分支\n\n假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：\n\n$ git push origin --delete serverfix\nto https://github.com/schacon/simplegit\n - [deleted]         serverfix\n\n\n1\n2\n3\n\n\n基本上这个命令做的只是从服务器上移除这个指针。 git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git工具-查看修订版本",frontmatter:{title:"Git工具-查看修订版本",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/c984d1/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/80.Git%E5%B7%A5%E5%85%B7-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC.html",relativePath:"《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.md",key:"v-34d42a50",path:"/pages/c984d1/",headers:[{level:2,title:"单个修订版本",slug:"单个修订版本",normalizedTitle:"单个修订版本",charIndex:91},{level:2,title:"简短的 SHA-1",slug:"简短的-sha-1",normalizedTitle:"简短的 sha-1",charIndex:181},{level:3,title:"查看给定SHA-1值的提交",slug:"查看给定sha-1值的提交",normalizedTitle:"查看给定sha-1值的提交",charIndex:956},{level:2,title:"分支引用",slug:"分支引用",normalizedTitle:"分支引用",charIndex:2177},{level:3,title:"查看最后一次提交",slug:"查看最后一次提交",normalizedTitle:"查看最后一次提交",charIndex:2252},{level:2,title:"引用日志",slug:"引用日志",normalizedTitle:"引用日志",charIndex:2696},{level:3,title:"HEAD的指向历史",slug:"head的指向历史",normalizedTitle:"head的指向历史",charIndex:2705},{level:2,title:"祖先引用",slug:"祖先引用",normalizedTitle:"祖先引用",charIndex:4613},{level:2,title:"提交区间",slug:"提交区间",normalizedTitle:"提交区间",charIndex:6634},{level:3,title:"双点",slug:"双点",normalizedTitle:"双点",charIndex:6735},{level:3,title:"多点",slug:"多点",normalizedTitle:"多点",charIndex:7606},{level:3,title:"三点",slug:"三点",normalizedTitle:"三点",charIndex:8032}],headersStr:"单个修订版本 简短的 SHA-1 查看给定SHA-1值的提交 分支引用 查看最后一次提交 引用日志 HEAD的指向历史 祖先引用 提交区间 双点 多点 三点",content:"# Git工具-查看修订版本\n\nGit 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\n\n修订版本指的是：提交\n\n\n# 单个修订版本\n\n你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\n\n\n# 简短的 SHA-1\n\nGit 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。\n\n例如，要查看你知道其中添加了某个功能的提交，首先运行 git log 命令来定位该提交：\n\n$ git log\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri Jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nMerge: 1c002dd... 35cfb2b...\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 查看给定SHA-1值的提交\n\n在本例中，假设你想要的提交其 SHA-1 以 1c002dd.... 开头， 那么你可以用如下几种 git show 的变体来检视该提交（假设简短的版本没有歧义）：\n\n$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n$ git show 1c002dd4b536e7479f\n$ git show 1c002d\n\n\n1\n2\n3\n\n\nGit 可以为 SHA-1 值生成出简短且唯一的缩写。 如果你在 git log 后加上 --abbrev-commit 参数，输出结果里就会显示简短且唯一的值； 默认使用七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数：\n\n$ git log --abbrev-commit --pretty=oneline\nca82a6d changed the version number\n085bb3b removed unnecessary test code\na11bef0 first commit\n\n\n1\n2\n3\n4\n\n\n通常 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的歧义。 例如，到 2019 年 2 月为止，Linux 内核这个相当大的 Git 项目， 其对象数据库中有超过 875,000 个提交，包含七百万个对象，也只需要前 12 个字符就能保证唯一性。\n\nNOTE   关于 SHA-1 的简短说明许多人觉得他们的仓库里有可能出现两个不同的对象其 SHA-1 值相同。\n       然后呢？如果你真的向仓库里提交了一个对象，它跟之前的某个 不同 对象的 SHA-1 值相同， GIT\n       会发现该对象的散列值已经存在于仓库里了，于是就会认为该对象被写入，然后直接使用它。\n       如果之后你想检出那个对象时，你将得到先前那个对象的数据。但是这种情况发生的概率十分渺小。 SHA-1 摘要长度是 20\n       字节，也就是 160 位。 2^80 个随机哈希对象才有 50% 的概率出现一次冲突 （计算冲突机率的公式是 P =\n       (N(N-1)/2) * (1/2^160)) ）。 2^80 是 1.2 X\n       10^24，也就是一亿亿亿，这是地球上沙粒总数的 1200 倍。举例说一下怎样才能产生一次 SHA-1 冲突。\n       如果地球上 65 亿个人类都在编程，每人每秒都在产生等价于整个 LINUX 内核历史（650 万个 GIT\n       对象）的代码， 并将之提交到一个巨大的 GIT 仓库里面，这样持续两年的时间才会产生足够的对象， 使其拥有 50%\n       的概率产生一次 SHA-1 对象冲突， 这比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。\n       \n\n\n# 分支引用\n\n引用特定提交的一种直接方法是，若它是一个分支的顶端的提交， 那么可以在任何需要引用该提交的 Git 命令中直接使用该分支的名称。\n\n\n# 查看最后一次提交\n\n例如，你想要查看一个分支的最后一次提交的对象，假设 topic1 分支指向提交 ca82a6d... ， 那么以下的命令是等价的：\n\n$ git show ca82a6dff817ec66f44342007202690a93763949\n$ git show topic1  # topic1是分支名\n\n\n1\n2\n\n\n如果你想知道某个分支指向哪个特定的 SHA-1，或者想看任何一个例子中被简写的 SHA-1， 你可以使用一个叫做 rev-parse 的 Git 探测工具。 你可以在 Git 内部原理 中查看更多关于探测工具的信息。 简单来说，rev-parse 是为了底层操作而不是日常操作设计的。 不过，有时你想看 Git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 rev-parse\n\n$ git rev-parse topic1\nca82a6dff817ec66f44342007202690a93763949\n\n\n1\n2\n\n\n\n# 引用日志\n\n\n# HEAD的指向历史\n\n当你在工作时， Git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。\n\n你可以使用 git reflog 来查看引用日志\n\n$ git reflog\n734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated\nd921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy.\n1c002dd HEAD@{2}: commit: added some blame and merge stuff\n1c36188 HEAD@{3}: rebase -i (squash): updating HEAD\n95df984 HEAD@{4}: commit: # This is a combination of two commits.\n1c36188 HEAD@{5}: rebase -i (squash): updating HEAD\n7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 你也可以通过 reflog 数据来获取之前的提交历史。 如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 @{n} 来引用 reflog 中输出的提交记录。\n\n$ git show HEAD@{5}\n\n\n1\n\n\n你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 master 分支在昨天的时候指向了哪个提交，你可以输入\n\n$ git show master@{yesterday}\n\n\n1\n\n\n就会显示昨天 master 分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。\n\n可以运行 git log -g 来查看类似于 git log 输出格式的引用日志信息：\n\n$ git log -g master\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nReflog: master@{0} (Scott Chacon <schacon@gmail.com>)\nReflog message: commit: fixed refs handling, added gc auto, updated\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri Jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nReflog: master@{1} (Scott Chacon <schacon@gmail.com>)\nReflog message: merge phedders/rdocs: Merge made by recursive.\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n值得注意的是，引用日志只存在于本地仓库，它只是一个记录你在 自己 的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同，而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 git show HEAD@{2.months.ago} 这条命令只有在你克隆了一个项目至少两个月时才会显示匹配的提交—— 如果你刚刚克隆了仓库，那么它将不会有任何结果返回。\n\nTIP   将引用日志想作 GIT 版的 SHELL 历史记录如果你有 UNIX 或者 LINUX 的背景，不妨将引用日志想作\n      GIT 版的 SHELL 历史记录， 重点在于仅与你和你的会话相关，而与他人无关。\n      \n\n\n# 祖先引用\n\n祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 ^（脱字符）， Git 会将其解析为该引用的上一个提交。 假设你的提交历史是：\n\n$ git log --pretty=format:'%h %s' --graph\n* 734713b fixed refs handling, added gc auto, updated tests\n*   d921970 Merge commit 'phedders/rdocs'\n|\\\n| * 35cfb2b Some rdoc changes\n* | 1c002dd added some blame and merge stuff\n|/\n* 1c36188 ignore *.gem\n* 9b29157 add open3_detach to gemspec file list\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n你可以使用 HEAD^ 来查看上一个提交，也就是 “HEAD 的父提交”：\n\n$ git show HEAD^\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nMerge: 1c002dd... 35cfb2b...\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNOTE   在 WINDOWS 上转义脱字符在 WINDOWS 的 CMD.EXE 中，^ 是一个特殊字符，因此需要区别对待。\n       你可以双写它或者将提交引用放在引号中：$ GIT SHOW HEAD^ # 在 WINDOWS 上无法工作 $ GIT\n       SHOW HEAD^^ # 可以 $ GIT SHOW \"HEAD^\" # 可以\n       \n\n你也可以在 ^ 后面添加一个数字来指明想要 哪一个 父提交——例如 d921970^2 代表 “d921970 的第二父提交” 这个语法只适用于合并的提交，因为合并提交会有多个父提交。 合并提交的第一父提交是你合并时所在分支（通常为 master），而第二父提交是你所合并的分支（例如 topic）：\n\n$ git show d921970^\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n$ git show d921970^2\ncommit 35cfb2b795a55793d7cc56a6cc2060b4bb732548\nAuthor: Paul Hedderly <paul+git@mjr.org>\nDate:   Wed Dec 10 22:22:03 2008 +0000\n\n    Some rdoc changes\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n另一种指明祖先提交的方法是 ~（波浪号）。 同样是指向第一父提交，因此 HEAD~ 和 HEAD^ 是等价的。 而区别在于你在后面加数字的时候。 HEAD~2 代表“第一父提交的第一父提交”，也就是“祖父提交”——Git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，HEAD~3 就是\n\n$ git show HEAD~3\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nAuthor: Tom Preston-Werner <tom@mojombo.com>\nDate:   Fri Nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n1\n2\n3\n4\n5\n6\n\n\n也可以写成 HEAD~~~，也是第一父提交的第一父提交的第一父提交：\n\n$ git show HEAD~~~\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nAuthor: Tom Preston-Werner <tom@mojombo.com>\nDate:   Fri Nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n1\n2\n3\n4\n5\n6\n\n\n你也可以组合使用这两个语法——你可以通过 HEAD~3^2 来取得之前引用的第二父提交（假设它是一个合并提交）。\n\n\n# 提交区间\n\n你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用， 你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题\n\n\n# 双点\n\n最常用的指明提交区间语法是双点。 这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 Example history for range selection.\n\n\n\nFigure 137. Example history for range selection.\n\n你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 master..experiment 来让 Git 显示这些提交。也就是“在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：\n\n$ git log master..experiment\nD\nC\n\n\n1\n2\n3\n\n\n反过来，如果你想查看在 master 分支中而不在 experiment 分支中的提交，你只要交换分支名即可。 experiment..master 会显示在 master 分支中而不在 experiment 分支中的提交：\n\n$ git log experiment..master\nF\nE\n\n\n1\n2\n3\n\n\n# 查看即将推送到远端的内容\n\n这可以让你保持 experiment 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：\n\n$ git log origin/master..HEAD\n\n\n1\n\n\n这个命令会输出在你当前分支中而不在远程 origin 中的提交。 如果你执行 git push 并且你的当前分支正在跟踪 origin/master，由 git log origin/master..HEAD 所输出的提交就是会被传输到远端服务器的提交。如果你留空了其中的一边， Git 会默认为 HEAD。 例如， git log origin/master.. 将会输出与之前例子相同的结果 —— Git 使用 HEAD 来代替留空的一边。\n\n\n# 多点\n\n双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订， 比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 Git 允许你在任意引用前加上 ^ 字符或者 --not 来指明你不希望提交被包含其中的分支。 因此下列三个命令是等价的：\n\n$ git log refA..refB\n$ git log ^refA refB\n$ git log refB --not refA\n\n\n1\n2\n3\n\n\n这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 refA 或 refB 包含的但是不被 refC 包含的提交，你可以使用以下任意一个命令：\n\n$ git log refA refB ^refC\n$ git log refA refB --not refC\n\n\n1\n2\n\n\n这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。\n\n\n# 三点\n\n最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用 之一 包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 master 或者 experiment 中包含的但不是两者共有的提交，你可以执行：\n\n$ git log master...experiment\nF\nE\nD\nC\n\n\n1\n2\n3\n4\n5\n\n\n这和通常 log 按日期排序的输出一样，仅仅给出了4个提交的信息。\n\n这种情形下，log 命令的一个常用参数是 --left-right，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。\n\n$ git log --left-right master...experiment\n< F\n< E\n> D\n> C\n\n\n1\n2\n3\n4\n5\n\n\n有了这些工具，你就可以十分方便地查看你 Git 仓库中的提交。",normalizedContent:"# git工具-查看修订版本\n\ngit 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\n\n修订版本指的是：提交\n\n\n# 单个修订版本\n\n你可以通过任意一个提交的 40 个字符的完整 sha-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\n\n\n# 简短的 sha-1\n\ngit 十分智能，你只需要提供 sha-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 sha-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 sha-1 开头。\n\n例如，要查看你知道其中添加了某个功能的提交，首先运行 git log 命令来定位该提交：\n\n$ git log\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nauthor: scott chacon <schacon@gmail.com>\ndate:   fri jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nmerge: 1c002dd... 35cfb2b...\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 15:08:43 2008 -0800\n\n    merge commit 'phedders/rdocs'\n\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 查看给定sha-1值的提交\n\n在本例中，假设你想要的提交其 sha-1 以 1c002dd.... 开头， 那么你可以用如下几种 git show 的变体来检视该提交（假设简短的版本没有歧义）：\n\n$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n$ git show 1c002dd4b536e7479f\n$ git show 1c002d\n\n\n1\n2\n3\n\n\ngit 可以为 sha-1 值生成出简短且唯一的缩写。 如果你在 git log 后加上 --abbrev-commit 参数，输出结果里就会显示简短且唯一的值； 默认使用七个字符，不过有时为了避免 sha-1 的歧义，会增加字符数：\n\n$ git log --abbrev-commit --pretty=oneline\nca82a6d changed the version number\n085bb3b removed unnecessary test code\na11bef0 first commit\n\n\n1\n2\n3\n4\n\n\n通常 8 到 10 个字符就已经足够在一个项目中避免 sha-1 的歧义。 例如，到 2019 年 2 月为止，linux 内核这个相当大的 git 项目， 其对象数据库中有超过 875,000 个提交，包含七百万个对象，也只需要前 12 个字符就能保证唯一性。\n\nnote   关于 sha-1 的简短说明许多人觉得他们的仓库里有可能出现两个不同的对象其 sha-1 值相同。\n       然后呢？如果你真的向仓库里提交了一个对象，它跟之前的某个 不同 对象的 sha-1 值相同， git\n       会发现该对象的散列值已经存在于仓库里了，于是就会认为该对象被写入，然后直接使用它。\n       如果之后你想检出那个对象时，你将得到先前那个对象的数据。但是这种情况发生的概率十分渺小。 sha-1 摘要长度是 20\n       字节，也就是 160 位。 2^80 个随机哈希对象才有 50% 的概率出现一次冲突 （计算冲突机率的公式是 p =\n       (n(n-1)/2) * (1/2^160)) ）。 2^80 是 1.2 x\n       10^24，也就是一亿亿亿，这是地球上沙粒总数的 1200 倍。举例说一下怎样才能产生一次 sha-1 冲突。\n       如果地球上 65 亿个人类都在编程，每人每秒都在产生等价于整个 linux 内核历史（650 万个 git\n       对象）的代码， 并将之提交到一个巨大的 git 仓库里面，这样持续两年的时间才会产生足够的对象， 使其拥有 50%\n       的概率产生一次 sha-1 对象冲突， 这比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。\n       \n\n\n# 分支引用\n\n引用特定提交的一种直接方法是，若它是一个分支的顶端的提交， 那么可以在任何需要引用该提交的 git 命令中直接使用该分支的名称。\n\n\n# 查看最后一次提交\n\n例如，你想要查看一个分支的最后一次提交的对象，假设 topic1 分支指向提交 ca82a6d... ， 那么以下的命令是等价的：\n\n$ git show ca82a6dff817ec66f44342007202690a93763949\n$ git show topic1  # topic1是分支名\n\n\n1\n2\n\n\n如果你想知道某个分支指向哪个特定的 sha-1，或者想看任何一个例子中被简写的 sha-1， 你可以使用一个叫做 rev-parse 的 git 探测工具。 你可以在 git 内部原理 中查看更多关于探测工具的信息。 简单来说，rev-parse 是为了底层操作而不是日常操作设计的。 不过，有时你想看 git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 rev-parse\n\n$ git rev-parse topic1\nca82a6dff817ec66f44342007202690a93763949\n\n\n1\n2\n\n\n\n# 引用日志\n\n\n# head的指向历史\n\n当你在工作时， git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 head 和分支引用所指向的历史。\n\n你可以使用 git reflog 来查看引用日志\n\n$ git reflog\n734713b head@{0}: commit: fixed refs handling, added gc auto, updated\nd921970 head@{1}: merge phedders/rdocs: merge made by the 'recursive' strategy.\n1c002dd head@{2}: commit: added some blame and merge stuff\n1c36188 head@{3}: rebase -i (squash): updating head\n95df984 head@{4}: commit: # this is a combination of two commits.\n1c36188 head@{5}: rebase -i (squash): updating head\n7e05da5 head@{6}: rebase -i (pick): updating head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n每当你的 head 所指向的位置发生了变化，git 就会将这个信息存储到引用日志这个历史记录里。 你也可以通过 reflog 数据来获取之前的提交历史。 如果你想查看仓库中 head 在五次前的所指向的提交，你可以使用 @{n} 来引用 reflog 中输出的提交记录。\n\n$ git show head@{5}\n\n\n1\n\n\n你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 master 分支在昨天的时候指向了哪个提交，你可以输入\n\n$ git show master@{yesterday}\n\n\n1\n\n\n就会显示昨天 master 分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。\n\n可以运行 git log -g 来查看类似于 git log 输出格式的引用日志信息：\n\n$ git log -g master\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nreflog: master@{0} (scott chacon <schacon@gmail.com>)\nreflog message: commit: fixed refs handling, added gc auto, updated\nauthor: scott chacon <schacon@gmail.com>\ndate:   fri jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nreflog: master@{1} (scott chacon <schacon@gmail.com>)\nreflog message: merge phedders/rdocs: merge made by recursive.\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 15:08:43 2008 -0800\n\n    merge commit 'phedders/rdocs'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n值得注意的是，引用日志只存在于本地仓库，它只是一个记录你在 自己 的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同，而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 git show head@{2.months.ago} 这条命令只有在你克隆了一个项目至少两个月时才会显示匹配的提交—— 如果你刚刚克隆了仓库，那么它将不会有任何结果返回。\n\ntip   将引用日志想作 git 版的 shell 历史记录如果你有 unix 或者 linux 的背景，不妨将引用日志想作\n      git 版的 shell 历史记录， 重点在于仅与你和你的会话相关，而与他人无关。\n      \n\n\n# 祖先引用\n\n祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 ^（脱字符）， git 会将其解析为该引用的上一个提交。 假设你的提交历史是：\n\n$ git log --pretty=format:'%h %s' --graph\n* 734713b fixed refs handling, added gc auto, updated tests\n*   d921970 merge commit 'phedders/rdocs'\n|\\\n| * 35cfb2b some rdoc changes\n* | 1c002dd added some blame and merge stuff\n|/\n* 1c36188 ignore *.gem\n* 9b29157 add open3_detach to gemspec file list\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n你可以使用 head^ 来查看上一个提交，也就是 “head 的父提交”：\n\n$ git show head^\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nmerge: 1c002dd... 35cfb2b...\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 15:08:43 2008 -0800\n\n    merge commit 'phedders/rdocs'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnote   在 windows 上转义脱字符在 windows 的 cmd.exe 中，^ 是一个特殊字符，因此需要区别对待。\n       你可以双写它或者将提交引用放在引号中：$ git show head^ # 在 windows 上无法工作 $ git\n       show head^^ # 可以 $ git show \"head^\" # 可以\n       \n\n你也可以在 ^ 后面添加一个数字来指明想要 哪一个 父提交——例如 d921970^2 代表 “d921970 的第二父提交” 这个语法只适用于合并的提交，因为合并提交会有多个父提交。 合并提交的第一父提交是你合并时所在分支（通常为 master），而第二父提交是你所合并的分支（例如 topic）：\n\n$ git show d921970^\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n$ git show d921970^2\ncommit 35cfb2b795a55793d7cc56a6cc2060b4bb732548\nauthor: paul hedderly <paul+git@mjr.org>\ndate:   wed dec 10 22:22:03 2008 +0000\n\n    some rdoc changes\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n另一种指明祖先提交的方法是 ~（波浪号）。 同样是指向第一父提交，因此 head~ 和 head^ 是等价的。 而区别在于你在后面加数字的时候。 head~2 代表“第一父提交的第一父提交”，也就是“祖父提交”——git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，head~3 就是\n\n$ git show head~3\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nauthor: tom preston-werner <tom@mojombo.com>\ndate:   fri nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n1\n2\n3\n4\n5\n6\n\n\n也可以写成 head~~~，也是第一父提交的第一父提交的第一父提交：\n\n$ git show head~~~\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nauthor: tom preston-werner <tom@mojombo.com>\ndate:   fri nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n1\n2\n3\n4\n5\n6\n\n\n你也可以组合使用这两个语法——你可以通过 head~3^2 来取得之前引用的第二父提交（假设它是一个合并提交）。\n\n\n# 提交区间\n\n你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用， 你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题\n\n\n# 双点\n\n最常用的指明提交区间语法是双点。 这种语法可以让 git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 example history for range selection.\n\n\n\nfigure 137. example history for range selection.\n\n你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 master..experiment 来让 git 显示这些提交。也就是“在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：\n\n$ git log master..experiment\nd\nc\n\n\n1\n2\n3\n\n\n反过来，如果你想查看在 master 分支中而不在 experiment 分支中的提交，你只要交换分支名即可。 experiment..master 会显示在 master 分支中而不在 experiment 分支中的提交：\n\n$ git log experiment..master\nf\ne\n\n\n1\n2\n3\n\n\n# 查看即将推送到远端的内容\n\n这可以让你保持 experiment 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：\n\n$ git log origin/master..head\n\n\n1\n\n\n这个命令会输出在你当前分支中而不在远程 origin 中的提交。 如果你执行 git push 并且你的当前分支正在跟踪 origin/master，由 git log origin/master..head 所输出的提交就是会被传输到远端服务器的提交。如果你留空了其中的一边， git 会默认为 head。 例如， git log origin/master.. 将会输出与之前例子相同的结果 —— git 使用 head 来代替留空的一边。\n\n\n# 多点\n\n双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订， 比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 git 允许你在任意引用前加上 ^ 字符或者 --not 来指明你不希望提交被包含其中的分支。 因此下列三个命令是等价的：\n\n$ git log refa..refb\n$ git log ^refa refb\n$ git log refb --not refa\n\n\n1\n2\n3\n\n\n这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 refa 或 refb 包含的但是不被 refc 包含的提交，你可以使用以下任意一个命令：\n\n$ git log refa refb ^refc\n$ git log refa refb --not refc\n\n\n1\n2\n\n\n这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。\n\n\n# 三点\n\n最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用 之一 包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 master 或者 experiment 中包含的但不是两者共有的提交，你可以执行：\n\n$ git log master...experiment\nf\ne\nd\nc\n\n\n1\n2\n3\n4\n5\n\n\n这和通常 log 按日期排序的输出一样，仅仅给出了4个提交的信息。\n\n这种情形下，log 命令的一个常用参数是 --left-right，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。\n\n$ git log --left-right master...experiment\n< f\n< e\n> d\n> c\n\n\n1\n2\n3\n4\n5\n\n\n有了这些工具，你就可以十分方便地查看你 git 仓库中的提交。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git分支-变基",frontmatter:{title:"Git分支-变基",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/3a3247/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/70.Git%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA.html",relativePath:"《Git》学习笔记/20.文档笔记/70.Git分支-变基.md",key:"v-546fd54a",path:"/pages/3a3247/",headers:[{level:2,title:"变基的基本操作",slug:"变基的基本操作",normalizedTitle:"变基的基本操作",charIndex:117},{level:3,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:312},{level:3,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:728},{level:3,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:1138},{level:3,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:1701},{level:2,title:"更有趣的变基例子",slug:"更有趣的变基例子",normalizedTitle:"更有趣的变基例子",charIndex:1727},{level:3,title:"更有趣的变基例子",slug:"更有趣的变基例子-2",normalizedTitle:"更有趣的变基例子",charIndex:1727},{level:3,title:"--onto选项",slug:"onto选项",normalizedTitle:"--onto选项",charIndex:2530},{level:3,title:"省去先切换到源分支的步骤",slug:"省去先切换到源分支的步骤",normalizedTitle:"省去先切换到源分支的步骤",charIndex:2762},{level:2,title:"变基的风险",slug:"变基的风险",normalizedTitle:"变基的风险",charIndex:3415},{level:3,title:"金科玉律",slug:"金科玉律",normalizedTitle:"金科玉律",charIndex:3425},{level:3,title:"变基的实质",slug:"变基的实质",normalizedTitle:"变基的实质",charIndex:3615},{level:2,title:"用变基解决变基",slug:"用变基解决变基",normalizedTitle:"用变基解决变基",charIndex:4412},{level:2,title:"变基 vs. 合并",slug:"变基-vs-合并",normalizedTitle:"变基 vs. 合并",charIndex:5550}],headersStr:"变基的基本操作 概念 原理 步骤 优点 更有趣的变基例子 更有趣的变基例子 --onto选项 省去先切换到源分支的步骤 变基的风险 金科玉律 变基的实质 用变基解决变基 变基 vs. 合并",content:"# Git分支-变基\n\n在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\n\n\n# 变基的基本操作\n\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\n\n\n\n图0. 分叉的提交历史 ▲\n\n之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。\n\n\n\n图1. 通过合并操作来整合分叉的历史 ▲\n\n\n# 概念\n\n变基就是：将某一分支上的所有修改复制到另一分支上\n\n除了merge，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在 Git 中，这种操作就叫做 变基（rebase）。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移到另一分支上，就好像“重新播放”一样。\n\n在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上：\n\n$ git checkout experiment\n$ git rebase master # 将experiment上的修改变基到master分支上（将experiment的提交移动到master上。）\nFirst, rewinding head to replay your work on top of it...\nApplying: added staged command\n\n\n1\n2\n3\n4\n\n\n它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）\n\n\n# 原理\n\n 1. 找到当前分支和目标分支的最近共同祖先\n\n 2. 对比当前分支相对于该共同祖先的历次提交\n\n 3. 提取相应的修改并存为临时文件\n\n 4. 将当前分支指向目标分支\n\n 5. 将之前临时文件的修改依序应用\n\n\n\n图2.将 C4 中的修改变基到 C3 上 ▲\n\n现在回到 master 分支，进行一次快进合并。\n\n$ git checkout master\n$ git merge experiment\n\n\n1\n2\n\n\n\n\n图3.master 分支的快进合并 ▲\n\n\n# 步骤\n\n先检出源分支，将源分支的修改变基到目标分支。切回目标分支，进行一次快进合并\n\n# 示意：\ngit checkout <源分支>\ngit (源分支的修改)rebase(到) <目标分支>\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n1\n2\n3\n4\n5\n\n\n此时，C4' 指向的快照就和 the merge example 中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是 变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。\n\n一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n\n请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。\n\n\n# 优点\n\n变基的优点： 使提交记录更加整洁。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了主题分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了主题分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。\n\n\n\n图4.从一个主题分支里再分出一个主题分支的提交历史 ▲\n\n假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 git rebase 命令的 --onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：\n\n$ git rebase --onto master server client\n\n\n1\n\n\n以上命令的意思是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”。这理解起来有一点复杂，不过效果非常酷。\n\n\n# --onto选项\n\n选中C分支中的但不在B分支里的修改，应用到A分支。\n\n\n\n图5.截取主题分支上的另一个主题分支，然后变基到其他分支 ▲\n\n现在可以快进合并 master 分支了。（如图 快进合并 master 分支，使之包含来自 client 分支的修改）：\n\n$ git checkout master\n$ git merge client\n\n\n1\n2\n\n\n\n\n图6.快进合并 `master` 分支，使之包含来自 `client` 分支的修改 ▲\n\n\n# 省去先切换到源分支的步骤\n\ngit rebase <目标(当前)分支> <源分支> # 将源分支变基到目标分支。执行此命令后会自动切换到源分支\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n1\n2\n3\n\n\n注意：使用这个方法要确保源分支上的代码是最新的。\n\n接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase <basebranch> <topicbranch> 命令可以直接将主题分支 （即本例中的 server）变基到目标分支（即 master）上。 这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。\n\n$ git rebase master server\n\n\n1\n\n\n如图 将 server 中的修改变基到 master 上 所示，server 中的代码被“续”到了 master 后面。\n\n\n\n图7.将 `server` 中的修改变基到 `master` 上 ▲\n\n然后就可以快进合并主分支 master 了：\n\n$ git checkout master\n$ git merge server\n\n\n1\n2\n\n\n至此，client 和 server 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 最终的提交历史 中的样子：\n\n$ git branch -d client\n$ git branch -d server\n\n\n1\n2\n\n\n\n\n图8. 最终的提交历史 ▲\n\n\n# 变基的风险\n\n\n# 金科玉律\n\n呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：\n\n如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。\n\n如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\n\n提示\n\n例如：几个人同时在一个主题分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。\n\n让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：\n\n\n\n图9. 克隆一个仓库，然后在它的基础上进行了一些开发 ▲\n\n然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：\n\n\n\n图10. 抓取别人的提交，合并到自己的开发分支 ▲\n\n接下来，这个人又决定把合并操作回滚，改用变基；继而又用 git push --force 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。\n\n\n\n图11. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 ▲\n\n结果就是你们两人的处境都十分尴尬。 如果你执行 git pull 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\n\n\n\n图12. 你将相同的内容又合并了一次，生成了一个新的提交 ▲\n\n此时如果你执行 git log 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 C4 和 C6，因为之前就是他把这两个提交通过变基丢弃的。\n\n\n# 用变基解决变基\n\n如果你 真的 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。\n\n实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。\n\n如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。\n\n举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情境，如果我们不是执行合并，而是执行 git rebase teamone/master, Git 将会：\n\n * 检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）\n * 检查其中哪些提交不是合并操作的结果（C2，C3，C4）\n * 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4'）\n * 把查到的这些提交应用在 teamone/master 上面\n\n从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果，如图 在一个被变基然后强制推送的分支上再次执行变基 所示。\n\n\n\n图13. 在一个被变基然后强制推送的分支上再次执行变基 ▲\n\n要想上述方案有效，还需要对方在变基时确保 C4' 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。\n\n在本例中另一种简单的方法是使用 git pull --rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 git fetch，再 git rebase teamone/master。\n\n如果你习惯使用 git pull ，同时又希望默认使用选项 --rebase，你可以执行这条语句 git config --global pull.rebase true 来更改 pull.rebase 的默认配置。\n\n如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。\n\n如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull --rebase 命令，这样尽管不能避免伤痛，但能有所缓解。\n\n\n# 变基 vs. 合并\n\n至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。\n\n有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。\n\n另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。\n\n现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。\n\n总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。",normalizedContent:"# git分支-变基\n\n在 git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\n\n\n# 变基的基本操作\n\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\n\n\n\n图0. 分叉的提交历史 ▲\n\n之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（c3 和 c4）以及二者最近的共同祖先（c2）进行三方合并，合并的结果是生成一个新的快照（并提交）。\n\n\n\n图1. 通过合并操作来整合分叉的历史 ▲\n\n\n# 概念\n\n变基就是：将某一分支上的所有修改复制到另一分支上\n\n除了merge，还有一种方法：你可以提取在 c4 中引入的补丁和修改，然后在 c3 的基础上应用一次。 在 git 中，这种操作就叫做 变基（rebase）。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移到另一分支上，就好像“重新播放”一样。\n\n在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上：\n\n$ git checkout experiment\n$ git rebase master # 将experiment上的修改变基到master分支上（将experiment的提交移动到master上。）\nfirst, rewinding head to replay your work on top of it...\napplying: added staged command\n\n\n1\n2\n3\n4\n\n\n它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 c2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 c3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）\n\n\n# 原理\n\n 1. 找到当前分支和目标分支的最近共同祖先\n\n 2. 对比当前分支相对于该共同祖先的历次提交\n\n 3. 提取相应的修改并存为临时文件\n\n 4. 将当前分支指向目标分支\n\n 5. 将之前临时文件的修改依序应用\n\n\n\n图2.将 c4 中的修改变基到 c3 上 ▲\n\n现在回到 master 分支，进行一次快进合并。\n\n$ git checkout master\n$ git merge experiment\n\n\n1\n2\n\n\n\n\n图3.master 分支的快进合并 ▲\n\n\n# 步骤\n\n先检出源分支，将源分支的修改变基到目标分支。切回目标分支，进行一次快进合并\n\n# 示意：\ngit checkout <源分支>\ngit (源分支的修改)rebase(到) <目标分支>\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n1\n2\n3\n4\n5\n\n\n此时，c4' 指向的快照就和 the merge example 中 c5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是 变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。\n\n一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n\n请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。\n\n\n# 优点\n\n变基的优点： 使提交记录更加整洁。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 c3 和 c4。 然后从 c3 上创建了主题分支 client，为客户端添加了一些功能，提交了 c8 和 c9。 最后，你回到 server 分支，又提交了 c10。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 c3 和 c4。 然后从 c3 上创建了主题分支 client，为客户端添加了一些功能，提交了 c8 和 c9。 最后，你回到 server 分支，又提交了 c10。\n\n\n\n图4.从一个主题分支里再分出一个主题分支的提交历史 ▲\n\n假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 git rebase 命令的 --onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 c8 和 c9），将它们在 master 分支上重放：\n\n$ git rebase --onto master server client\n\n\n1\n\n\n以上命令的意思是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”。这理解起来有一点复杂，不过效果非常酷。\n\n\n# --onto选项\n\n选中c分支中的但不在b分支里的修改，应用到a分支。\n\n\n\n图5.截取主题分支上的另一个主题分支，然后变基到其他分支 ▲\n\n现在可以快进合并 master 分支了。（如图 快进合并 master 分支，使之包含来自 client 分支的修改）：\n\n$ git checkout master\n$ git merge client\n\n\n1\n2\n\n\n\n\n图6.快进合并 `master` 分支，使之包含来自 `client` 分支的修改 ▲\n\n\n# 省去先切换到源分支的步骤\n\ngit rebase <目标(当前)分支> <源分支> # 将源分支变基到目标分支。执行此命令后会自动切换到源分支\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n1\n2\n3\n\n\n注意：使用这个方法要确保源分支上的代码是最新的。\n\n接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase <basebranch> <topicbranch> 命令可以直接将主题分支 （即本例中的 server）变基到目标分支（即 master）上。 这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。\n\n$ git rebase master server\n\n\n1\n\n\n如图 将 server 中的修改变基到 master 上 所示，server 中的代码被“续”到了 master 后面。\n\n\n\n图7.将 `server` 中的修改变基到 `master` 上 ▲\n\n然后就可以快进合并主分支 master 了：\n\n$ git checkout master\n$ git merge server\n\n\n1\n2\n\n\n至此，client 和 server 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 最终的提交历史 中的样子：\n\n$ git branch -d client\n$ git branch -d server\n\n\n1\n2\n\n\n\n\n图8. 最终的提交历史 ▲\n\n\n# 变基的风险\n\n\n# 金科玉律\n\n呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：\n\n如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。\n\n如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\n\n提示\n\n例如：几个人同时在一个主题分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。\n\n让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：\n\n\n\n图9. 克隆一个仓库，然后在它的基础上进行了一些开发 ▲\n\n然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：\n\n\n\n图10. 抓取别人的提交，合并到自己的开发分支 ▲\n\n接下来，这个人又决定把合并操作回滚，改用变基；继而又用 git push --force 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。\n\n\n\n图11. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 ▲\n\n结果就是你们两人的处境都十分尴尬。 如果你执行 git pull 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\n\n\n\n图12. 你将相同的内容又合并了一次，生成了一个新的提交 ▲\n\n此时如果你执行 git log 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 c4 和 c6，因为之前就是他把这两个提交通过变基丢弃的。\n\n\n# 用变基解决变基\n\n如果你 真的 遭遇了类似的处境，git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。\n\n实际上，git 除了对整个提交计算 sha-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。\n\n如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。\n\n举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情境，如果我们不是执行合并，而是执行 git rebase teamone/master, git 将会：\n\n * 检查哪些提交是我们的分支上独有的（c2，c3，c4，c6，c7）\n * 检查其中哪些提交不是合并操作的结果（c2，c3，c4）\n * 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 c2 和 c3，因为 c4 其实就是 c4'）\n * 把查到的这些提交应用在 teamone/master 上面\n\n从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果，如图 在一个被变基然后强制推送的分支上再次执行变基 所示。\n\n\n\n图13. 在一个被变基然后强制推送的分支上再次执行变基 ▲\n\n要想上述方案有效，还需要对方在变基时确保 c4' 和 c4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 c4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。\n\n在本例中另一种简单的方法是使用 git pull --rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 git fetch，再 git rebase teamone/master。\n\n如果你习惯使用 git pull ，同时又希望默认使用选项 --rebase，你可以执行这条语句 git config --global pull.rebase true 来更改 pull.rebase 的默认配置。\n\n如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。\n\n如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull --rebase 命令，这样尽管不能避免伤痛，但能有所缓解。\n\n\n# 变基 vs. 合并\n\n至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。\n\n有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。\n\n另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。\n\n现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。\n\n总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Git工具-交互式暂存",frontmatter:{title:"Git工具-交互式暂存",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/76d859/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/90.Git%E5%B7%A5%E5%85%B7-%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98.html",relativePath:"《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.md",key:"v-03537083",path:"/pages/76d859/",headers:[{level:2,title:"暂存与取消暂存文件",slug:"暂存与取消暂存文件",normalizedTitle:"暂存与取消暂存文件",charIndex:751},{level:2,title:"暂存补丁",slug:"暂存补丁",normalizedTitle:"暂存补丁",charIndex:3468}],headersStr:"暂存与取消暂存文件 暂存补丁",content:'# Git工具-交互式暂存\n\n本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 --interactive 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\n\n$ git add -i\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以看到这个命令以和平时非常不同的视图显示了暂存区——基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。\n\n在这块区域后是“Commands”命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。\n\n\n# 暂存与取消暂存文件\n\n如果在 What now> 提示符后键入 u 或 2（更新），它会问你想要暂存哪个文件：\n\nWhat now> u\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nUpdate>>\n\n\n1\n2\n3\n4\n5\n6\n\n\n要暂存 TODO 和 index.html 文件，可以输入数字：\n\nUpdate>> 1,2\n           staged     unstaged path\n* 1:    unchanged        +0/-1 TODO\n* 2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nUpdate>>\n\n\n1\n2\n3\n4\n5\n6\n\n\n每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 Update>> 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：\n\nUpdate>>\nupdated 2 paths\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> s\n           staged     unstaged path\n  1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 r 或 3（撤消）选项：\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> r\n           staged     unstaged path\n  1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nRevert>> 1\n           staged     unstaged path\n* 1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nRevert>> [enter]\nreverted one path\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> s\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果想要查看已暂存内容的区别，可以使用 d 或 6（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff --cached 非常相似：\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> d\n           staged     unstaged path\n  1:        +1/-1      nothing index.html\nReview diff>> 1\ndiff --git a/index.html b/index.html\nindex 4d07108..4335f49 100644\n--- a/index.html\n+++ b/index.html\n@@ -16,7 +16,7 @@ Date Finder\n\n <p id="out">...</p>\n\n-<div id="footer">contact : support@github.com</div>\n+<div id="footer">contact : email.support@github.com</div>\n\n <script type="text/javascript">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。\n\n\n# 暂存补丁\n\nGit 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 在和上一节一样的交互式提示符中，输入 p 或 5（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：\n\ndiff --git a/lib/simplegit.rb b/lib/simplegit.rb\nindex dd5ecc4..57399e0 100644\n--- a/lib/simplegit.rb\n+++ b/lib/simplegit.rb\n@@ -22,7 +22,7 @@ class SimpleGit\n   end\n\n   def log(treeish = \'master\')\n-    command("git log -n 25 #{treeish}")\n+    command("git log -n 30 #{treeish}")\n   end\n\n   def blame(path)\nStage this hunk [y,n,a,d,/,j,J,g,e,?]?\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这时有很多选项。 输入 ? 显示所有可以使用的命令列表：\n\nStage this hunk [y,n,a,d,/,j,J,g,e,?]? ?\ny - stage this hunk\nn - do not stage this hunk\na - stage this and all the remaining hunks in the file\nd - do not stage this hunk nor any of the remaining hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nJ - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nK - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\n? - print help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块， 当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：\n\nWhat now> 1\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:        +1/-1      nothing index.html\n  3:        +1/-1        +4/-0 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n\n\nsimplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。\n\n也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 git add -p 或 git add --patch 来启动同样的脚本。\n\n更进一步地，可以使用 git reset --patch 命令的补丁模式来部分重置文件， 通过 git checkout --patch 命令来部分检出文件与 git stash save --patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。',normalizedContent:'# git工具-交互式暂存\n\n本节中的几个交互式 git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 --interactive 选项，git 将会进入一个交互式终端模式，显示类似下面的东西：\n\n$ git add -i\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以看到这个命令以和平时非常不同的视图显示了暂存区——基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。\n\n在这块区域后是“commands”命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。\n\n\n# 暂存与取消暂存文件\n\n如果在 what now> 提示符后键入 u 或 2（更新），它会问你想要暂存哪个文件：\n\nwhat now> u\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nupdate>>\n\n\n1\n2\n3\n4\n5\n6\n\n\n要暂存 todo 和 index.html 文件，可以输入数字：\n\nupdate>> 1,2\n           staged     unstaged path\n* 1:    unchanged        +0/-1 todo\n* 2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nupdate>>\n\n\n1\n2\n3\n4\n5\n6\n\n\n每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 update>> 提示符后不输入任何东西并直接按回车，git 将会暂存之前选择的文件：\n\nupdate>>\nupdated 2 paths\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> s\n           staged     unstaged path\n  1:        +0/-1      nothing todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n现在可以看到 todo 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 todo 文件，使用 r 或 3（撤消）选项：\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> r\n           staged     unstaged path\n  1:        +0/-1      nothing todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nrevert>> 1\n           staged     unstaged path\n* 1:        +0/-1      nothing todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nrevert>> [enter]\nreverted one path\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n再次查看 git 状态，可以看到已经取消暂存 todo 文件：\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> s\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果想要查看已暂存内容的区别，可以使用 d 或 6（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff --cached 非常相似：\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> d\n           staged     unstaged path\n  1:        +1/-1      nothing index.html\nreview diff>> 1\ndiff --git a/index.html b/index.html\nindex 4d07108..4335f49 100644\n--- a/index.html\n+++ b/index.html\n@@ -16,7 +16,7 @@ date finder\n\n <p id="out">...</p>\n\n-<div id="footer">contact : support@github.com</div>\n+<div id="footer">contact : email.support@github.com</div>\n\n <script type="text/javascript">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。\n\n\n# 暂存补丁\n\ngit 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，git 会帮你轻松地完成。 在和上一节一样的交互式提示符中，输入 p 或 5（补丁）。 git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：\n\ndiff --git a/lib/simplegit.rb b/lib/simplegit.rb\nindex dd5ecc4..57399e0 100644\n--- a/lib/simplegit.rb\n+++ b/lib/simplegit.rb\n@@ -22,7 +22,7 @@ class simplegit\n   end\n\n   def log(treeish = \'master\')\n-    command("git log -n 25 #{treeish}")\n+    command("git log -n 30 #{treeish}")\n   end\n\n   def blame(path)\nstage this hunk [y,n,a,d,/,j,j,g,e,?]?\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这时有很多选项。 输入 ? 显示所有可以使用的命令列表：\n\nstage this hunk [y,n,a,d,/,j,j,g,e,?]? ?\ny - stage this hunk\nn - do not stage this hunk\na - stage this and all the remaining hunks in the file\nd - do not stage this hunk nor any of the remaining hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nj - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nk - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\n? - print help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块， 当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：\n\nwhat now> 1\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:        +1/-1      nothing index.html\n  3:        +1/-1        +4/-0 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n\n\nsimplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。\n\n也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 git add -p 或 git add --patch 来启动同样的脚本。\n\n更进一步地，可以使用 git reset --patch 命令的补丁模式来部分重置文件， 通过 git checkout --patch 命令来部分检出文件与 git stash save --patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。',charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Promise 对象",frontmatter:{title:"Promise 对象",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/2810ae8985e9bd52",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/16.Promise%20%E5%AF%B9%E8%B1%A1.html",relativePath:"《ES6 教程》笔记/16.Promise 对象.md",key:"v-51ad7edb",path:"/pages/2810ae8985e9bd52/",headers:[{level:2,title:"Promise 的含义",slug:"promise-的含义",normalizedTitle:"promise 的含义",charIndex:17},{level:2,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:983},{level:2,title:"Promise.prototype.then()",slug:"promise-prototype-then",normalizedTitle:"promise.prototype.then()",charIndex:5345},{level:2,title:"Promise.prototype.catch()",slug:"promise-prototype-catch",normalizedTitle:"promise.prototype.catch()",charIndex:6481},{level:2,title:"Promise.prototype.finally()",slug:"promise-prototype-finally",normalizedTitle:"promise.prototype.finally()",charIndex:11971},{level:2,title:"Promise.all()",slug:"promise-all",normalizedTitle:"promise.all()",charIndex:13396},{level:2,title:"Promise.race()",slug:"promise-race",normalizedTitle:"promise.race()",charIndex:15679},{level:2,title:"Promise.allSettled()",slug:"promise-allsettled",normalizedTitle:"promise.allsettled()",charIndex:16366},{level:2,title:"Promise.any()",slug:"promise-any",normalizedTitle:"promise.any()",charIndex:18215},{level:2,title:"Promise.resolve()",slug:"promise-resolve",normalizedTitle:"promise.resolve()",charIndex:10831},{level:2,title:"Promise.reject()",slug:"promise-reject",normalizedTitle:"promise.reject()",charIndex:21651},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:22310},{level:3,title:"加载图片",slug:"加载图片",normalizedTitle:"加载图片",charIndex:2470},{level:3,title:"Generator 函数与 Promise 的结合",slug:"generator-函数与-promise-的结合",normalizedTitle:"generator 函数与 promise 的结合",charIndex:22601},{level:2,title:"Promise.try()",slug:"promise-try",normalizedTitle:"promise.try()",charIndex:23393}],excerpt:'<h1 id="promise-对象"><a class="header-anchor" href="#promise-对象">#</a> Promise 对象</h1>\n<h2 id="promise-的含义"><a class="header-anchor" href="#promise-的含义">#</a> Promise 的含义</h2>\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\n',headersStr:"Promise 的含义 基本用法 Promise.prototype.then() Promise.prototype.catch() Promise.prototype.finally() Promise.all() Promise.race() Promise.allSettled() Promise.any() Promise.resolve() Promise.reject() 应用 加载图片 Generator 函数与 Promise 的结合 Promise.try()",content:"# Promise 对象\n\n\n# Promise 的含义\n\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\nPromise对象有以下两个特点。\n\n（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。\n\n有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。\n\nPromise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。\n\n\n# 基本用法\n\nES6 规定，Promise对象是一个构造函数，用来生成Promise实例。\n\n下面代码创造了一个Promise实例。\n\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\nresolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\nPromise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。\n\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n\n\n1\n2\n3\n4\n5\n\n\nthen方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。\n\n下面是一个Promise对象的简单例子。\n\nfunction timeout(ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, ms, 'done');\n  });\n}\n\ntimeout(100).then((value) => {\n  console.log(value);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。\n\nPromise 新建后就会立即执行。\n\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('resolved.');\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// resolved\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。\n\n下面是异步加载图片的例子。\n\nfunction loadImageAsync(url) {\n  return new Promise(function(resolve, reject) {\n    const image = new Image();\n\n    image.onload = function() {\n      resolve(image);\n    };\n\n    image.onerror = function() {\n      reject(new Error('Could not load image at ' + url));\n    };\n\n    image.src = url;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。\n\n下面是一个用Promise对象实现的 Ajax 操作的例子。\n\nconst getJSON = function(url) {\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n  });\n\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。\n\n如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。\n\nconst p1 = new Promise(function (resolve, reject) {\n  // ...\n});\n\nconst p2 = new Promise(function (resolve, reject) {\n  // ...\n  resolve(p1);\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。\n\n注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。\n\nconst p1 = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('fail')), 3000)\n})\n\nconst p2 = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// Error: fail\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。\n\n注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。\n\nnew Promise((resolve, reject) => {\n  resolve(1);\n  console.log(2);\n}).then(r => {\n  console.log(r);\n});\n// 2\n// 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。\n\n一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。\n\nnew Promise((resolve, reject) => {\n  return resolve(1);\n  // 后面的语句不会执行\n  console.log(2);\n})\n\n\n1\n2\n3\n4\n5\n\n\n\n# Promise.prototype.then()\n\nPromise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。\n\nthen方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n\ngetJSON(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) { // 这里的post是前面一个then返回的参数\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n\n\n上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。\n\n采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。\n\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function (comments) {\n  console.log(\"resolved: \", comments);\n}, function (err){\n  console.log(\"rejected: \", err);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。\n\n如果采用箭头函数，上面的代码可以写得更简洁。\n\ngetJSON(\"/post/1.json\").then(\n  post => getJSON(post.commentURL)\n).then(\n  comments => console.log(\"resolved: \", comments),\n  err => console.log(\"rejected: \", err)\n);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Promise.prototype.catch()\n\nPromise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。\n\ngetJSON('/posts.json').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。\n\np.then((val) => console.log('fulfilled:', val))\n  .catch((err) => console.log('rejected', err));\n\n// 等同于\np.then((val) => console.log('fulfilled:', val))\n  .then(null, (err) => console.log(\"rejected:\", err));\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面是一个例子。\n\nconst promise = new Promise(function(resolve, reject) {\n  throw new Error('test');\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n// Error: test\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。\n\n// 写法一\nconst promise = new Promise(function(resolve, reject) {\n  try {\n    throw new Error('test');\n  } catch(e) {\n    reject(e);\n  }\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n\n// 写法二\nconst promise = new Promise(function(resolve, reject) {\n  reject(new Error('test'));\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。\n\n如果 Promise 状态已经变成resolved，再抛出错误是无效的。\n\nconst promise = new Promise(function(resolve, reject) {\n  resolve('ok');\n  throw new Error('test');\n});\npromise\n  .then(function(value) { console.log(value) })\n  .catch(function(error) { console.log(error) });\n// ok\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。\n\nPromise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。\n\ngetJSON('/post/1.json').then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个Promise产生的错误\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，一共有三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。\n\n一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。\n\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。\n\n跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。\n\nconst someAsyncThing = function() {\n  return new Promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeAsyncThing().then(function() {\n  console.log('everything is great');\n});\n\nsetTimeout(() => { console.log(123) }, 2000);\n// Uncaught (in promise) ReferenceError: x is not defined // 报错却不退出进程\n// 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，someAsyncThing函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。\n\n这个脚本放在服务器执行，退出码就是0（即表示执行成功）。不过，Node 有一个unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。\n\nprocess.on('unhandledRejection', function (err, p) {\n  throw err;\n});\n\n\n1\n2\n3\n\n\n上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。\n\n注意，Node 有计划在未来废除unhandledRejection事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。\n\n再看下面的例子。\n\nconst promise = new Promise(function (resolve, reject) {\n  resolve('ok');\n  setTimeout(function () { throw new Error('test') }, 0)\n});\npromise.then(function (value) { console.log(value) });\n// ok\n// Uncaught Error: test\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。\n\n一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。\n\nconst someAsyncThing = function() {\n  return new Promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeAsyncThing()\n.catch(function(error) {\n  console.log('oh no', error);\n})\n.then(function() {\n  console.log('carry on');\n});\n// oh no [ReferenceError: x is not defined]\n// carry on\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。\n\nPromise.resolve()\n.catch(function(error) {\n  console.log('oh no', error);\n})\n.then(function() {\n  console.log('carry on');\n});\n// carry on\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。\n\ncatch方法之中，还能再抛出错误。\n\nconst someAsyncThing = function() {\n  return new Promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeAsyncThing().then(function() {\n  return someOtherAsyncThing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为 y 没有声明\n  y + 2;\n}).then(function() {\n  console.log('carry on');\n});\n// oh no [ReferenceError: x is not defined]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。\n\nsomeAsyncThing().then(function() {\n  return someOtherAsyncThing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为y没有声明\n  y + 2;\n}).catch(function(error) {\n  console.log('carry on', error);\n});\n// oh no [ReferenceError: x is not defined]\n// carry on [ReferenceError: y is not defined]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，第二个catch方法用来捕获前一个catch方法抛出的错误。\n\n\n# Promise.prototype.finally()\n\nfinally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\n\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n\n\n1\n2\n3\n4\n\n\n上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。\n\n下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。\n\nserver.listen(port)\n  .then(function () {\n    // ...\n  })\n  .finally(server.stop);\n\n\n1\n2\n3\n4\n5\n\n\nfinally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。\n\nfinally本质上是then方法的特例。\n\npromise\n.finally(() => {\n  // 语句\n});\n\n// 等同于\npromise\n.then(\n  result => {\n    // 语句\n    return result;\n  },\n  error => {\n    // 语句\n    throw error;\n  }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。\n\n它的实现也很简单。\n\nPromise.prototype.finally = function (callback) {\n  let P = this.constructor;\n  return this.then(\n    value  => P.resolve(callback()).then(() => value),\n    reason => P.resolve(callback()).then(() => { throw reason })\n  );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。\n\n从上面的实现还可以看到，finally方法总是会返回原来的值。\n\n// resolve 的值是 undefined\nPromise.resolve(2).then(() => {}, () => {})\n\n// resolve 的值是 2\nPromise.resolve(2).finally(() => {})\n\n// reject 的值是 undefined\nPromise.reject(3).then(() => {}, () => {})\n\n// reject 的值是 3\nPromise.reject(3).finally(() => {})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Promise.all()\n\nPromise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。\n\nconst p = Promise.all([p1, p2, p3]);\n\n\n1\n\n\n上面代码中，Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。\n\np的状态由p1、p2、p3决定，分成两种情况。\n\n（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n\n（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\n\n下面是一个具体的例子。\n\n// 生成一个Promise对象的数组\nconst promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n  return getJSON('/post/' + id + \".json\");\n});\n\nPromise.all(promises).then(function (posts) {\n  // ...\n}).catch(function(reason){\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。\n\n下面是另一个例子。\n\nconst databasePromise = connectDatabase();\n\nconst booksPromise = databasePromise\n  .then(findAllBooks);\n\nconst userPromise = databasePromise\n  .then(getCurrentUser);\n\nPromise.all([\n  booksPromise,\n  userPromise\n])\n.then(([books, user]) => pickTopRecommendations(books, user));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommendations这个回调函数。\n\n注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。\n\nconst p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result)\n.catch(e => e);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result)\n.catch(e => e);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// [\"hello\", Error: 报错了]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。\n\n如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。\n\nconst p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// Error: 报错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Promise.race()\n\nPromise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。\n\nconst p = Promise.race([p1, p2, p3]);\n\n\n1\n\n\n上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。\n\nPromise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。\n\n下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。\n\nconst p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。\n\n\n# Promise.allSettled()\n\nPromise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 ES2020 引入。\n\nconst promises = [\n  fetch('/api-1'),\n  fetch('/api-2'),\n  fetch('/api-3'),\n];\n\nawait Promise.allSettled(promises);\nremoveLoadingIndicator();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。\n\n**该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。**状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例。\n\nconst resolved = Promise.resolve(42);\nconst rejected = Promise.reject(-1);\n\nconst allSettledPromise = Promise.allSettled([resolved, rejected]);\n\nallSettledPromise.then(function (results) {\n  console.log(results);\n});\n// [\n//    { status: 'fulfilled', value: 42 },\n//    { status: 'rejected', reason: -1 }\n// ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，Promise.allSettled()的返回值allSettledPromise，状态只可能变成fulfilled。它的监听函数接收到的参数是数组results。该数组的每个成员都是一个对象，对应传入Promise.allSettled()的两个 Promise 实例。每个对象都有status属性，该属性的值只可能是字符串fulfilled或字符串rejected。fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。\n\n下面是返回值用法的例子。\n\nconst promises = [ fetch('index.html'), fetch('https://does-not-exist/') ];\nconst results = await Promise.allSettled(promises);\n\n// 过滤出成功的请求\nconst successfulPromises = results.filter(p => p.status === 'fulfilled');\n\n// 过滤出失败的请求，并输出原因\nconst errors = results\n  .filter(p => p.status === 'rejected')\n  .map(p => p.reason);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。Promise.all()方法无法做到这一点。\n\nconst urls = [ /* ... */ ];\nconst requests = urls.map(x => fetch(x));\n\ntry {\n  await Promise.all(requests);\n  console.log('所有请求都成功。');\n} catch {\n  console.log('至少一个请求失败，其他请求可能还没结束。');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，Promise.all()无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了Promise.allSettled()，这就很容易了。\n\n\n# Promise.any()\n\n**Promise.any()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。**该方法目前是一个第三阶段的提案 。\n\nPromise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。\n\nconst promises = [\n  fetch('/endpoint-a').then(() => 'a'),\n  fetch('/endpoint-b').then(() => 'b'),\n  fetch('/endpoint-c').then(() => 'c'),\n];\ntry {\n  const first = await Promise.any(promises);\n  console.log(first);\n} catch (error) {\n  console.log(error);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，Promise.any()方法的参数数组包含三个 Promise 操作。其中只要有一个变成fulfilled，Promise.any()返回的 Promise 对象就变成fulfilled。如果所有三个操作都变成rejected，那么就会await命令就会抛出错误。\n\nPromise.any()抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误。下面是 AggregateError 的实现示例。\n\nnew AggregateError() extends Array -> AggregateError\n\nconst err = new AggregateError();\nerr.push(new Error(\"first error\"));\nerr.push(new Error(\"second error\"));\nthrow err;\n\n\n1\n2\n3\n4\n5\n6\n\n\n捕捉错误时，如果不用try...catch结构和 await 命令，可以像下面这样写。\n\nPromise.any(promises).then(\n  (first) => {\n    // Any of the promises was fulfilled.\n  },\n  (error) => {\n    // All of the promises were rejected.\n  }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面是一个例子。\n\nvar resolved = Promise.resolve(42);\nvar rejected = Promise.reject(-1);\nvar alsoRejected = Promise.reject(Infinity);\n\nPromise.any([resolved, rejected, alsoRejected]).then(function (result) {\n  console.log(result); // 42\n});\n\nPromise.any([rejected, alsoRejected]).catch(function (results) {\n  console.log(results); // [-1, Infinity]\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Promise.resolve()\n\n有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。\n\nconst jsPromise = Promise.resolve($.ajax('/whatever.json'));\n\n\n1\n\n\n上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。\n\nPromise.resolve()等价于下面的写法。\n\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n\n\n1\n2\n3\n\n\nPromise.resolve方法的参数分成四种情况。\n\n（1）参数是一个 Promise 实例\n\n如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。\n\n（2）参数是一个thenable对象\n\nthenable对象指的是具有then方法的对象，比如下面这个对象。\n\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\nPromise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。\n\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\nlet p1 = Promise.resolve(thenable);\np1.then(function(value) {\n  console.log(value);  // 42\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。\n\n（3）参数不是具有then方法的对象，或根本就不是对象\n\n如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。\n\nconst p = Promise.resolve('Hello');\n\np.then(function (s){\n  console.log(s)\n});\n// Hello\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。\n\n（4）不带有任何参数\n\nPromise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。\n\n所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。\n\nconst p = Promise.resolve();\n\np.then(function () {\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n\n\n上面代码的变量p就是一个 Promise 对象。\n\n需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。\n\nsetTimeout(function () {\n  console.log('three');\n}, 0);\n\nPromise.resolve().then(function () {\n  console.log('two');\n});\n\nconsole.log('one');\n\n// one\n// two\n// three\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。\n\n\n# Promise.reject()\n\nPromise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。\n\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n// 出错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。\n\n注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。\n\nconst thenable = {\n  then(resolve, reject) {\n    reject('出错了');\n  }\n};\n\nPromise.reject(thenable)\n.catch(e => {\n  console.log(e === thenable)\n})\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。\n\n\n# 应用\n\n\n# 加载图片\n\n我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。\n\nconst preloadImage = function (path) {\n  return new Promise(function (resolve, reject) {\n    const image = new Image();\n    image.onload  = resolve;\n    image.onerror = reject;\n    image.src = path;\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Generator 函数与 Promise 的结合\n\n使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。\n\nfunction getFoo () {\n  return new Promise(function (resolve, reject){\n    resolve('foo');\n  });\n}\n\nconst g = function* () {\n  try {\n    const foo = yield getFoo();\n    console.log(foo);\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nfunction run (generator) {\n  const it = generator();\n\n  function go(result) {\n    if (result.done) return result.value;\n\n    return result.value.then(function (value) {\n      return go(it.next(value));\n    }, function (error) {\n      return go(it.throw(error));\n    });\n  }\n\n  go(it.next());\n}\n\nrun(g);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。\n\n\n# Promise.try()\n\n实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。\n\nPromise.resolve().then(f)\n\n\n1\n\n\n上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。\n\nconst f = () => console.log('now');\nPromise.resolve().then(f);\nconsole.log('next');\n// next\n// now\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。\n\n那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。\n\nconst f = () => console.log('now');\n(async () => f())();\nconsole.log('next');\n// now\n// next\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。\n\n(async () => f())()\n.then(...)\n\n\n1\n2\n\n\n需要注意的是，async () => f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。\n\n(async () => f())()\n.then(...)\n.catch(...)\n\n\n1\n2\n3\n\n\n第二种写法是使用new Promise()。\n\nconst f = () => console.log('now');\n(\n  () => new Promise(\n    resolve => resolve(f())\n  )\n)();\nconsole.log('next');\n// now\n// next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。\n\n鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。\n\nconst f = () => console.log('now');\nPromise.try(f);\nconsole.log('next');\n// now\n// next\n\n\n1\n2\n3\n4\n5\n\n\n事实上，Promise.try存在已久，Promise 库Bluebird、Q和when，早就提供了这个方法。\n\n由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。\n\nfunction getUsername(userId) {\n  return database.users.get({id: userId})\n  .then(function(user) {\n    return user.name;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。\n\ndatabase.users.get({id: userId})\n.then(...)\n.catch(...)\n\n\n1\n2\n3\n\n\n但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。\n\ntry {\n  database.users.get({id: userId})\n  .then(...)\n  .catch(...)\n} catch (e) {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。\n\nPromise.try(() => database.users.get({id: userId}))\n  .then(...)\n  .catch(...)\n\n\n1\n2\n3\n\n\n事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。",normalizedContent:"# promise 对象\n\n\n# promise 的含义\n\npromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，es6 将其写进了语言标准，统一了用法，原生提供了promise对象。 所谓promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，promise 是一个对象，从它可以获取异步操作的消息。promise 提供统一的 api，各种异步操作都可以用同样的方法进行处理。\n\npromise对象有以下两个特点。\n\n（1）对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。\n\n有了promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，promise对象提供统一的接口，使得控制异步操作更加容易。\n\npromise也有一些缺点。首先，无法取消promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n如果某些事件不断地反复发生，一般来说，使用 stream 模式是比部署promise更好的选择。\n\n\n# 基本用法\n\nes6 规定，promise对象是一个构造函数，用来生成promise实例。\n\n下面代码创造了一个promise实例。\n\nconst promise = new promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\npromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 javascript 引擎提供，不用自己部署。\n\nresolve函数的作用是，将promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\npromise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。\n\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n\n\n1\n2\n3\n4\n5\n\n\nthen方法可以接受两个回调函数作为参数。第一个回调函数是promise对象的状态变为resolved时调用，第二个回调函数是promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受promise对象传出的值作为参数。\n\n下面是一个promise对象的简单例子。\n\nfunction timeout(ms) {\n  return new promise((resolve, reject) => {\n    settimeout(resolve, ms, 'done');\n  });\n}\n\ntimeout(100).then((value) => {\n  console.log(value);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，timeout方法返回一个promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，promise实例的状态变为resolved，就会触发then方法绑定的回调函数。\n\npromise 新建后就会立即执行。\n\nlet promise = new promise(function(resolve, reject) {\n  console.log('promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('resolved.');\n});\n\nconsole.log('hi!');\n\n// promise\n// hi!\n// resolved\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，promise 新建后立即执行，所以首先输出的是promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。\n\n下面是异步加载图片的例子。\n\nfunction loadimageasync(url) {\n  return new promise(function(resolve, reject) {\n    const image = new image();\n\n    image.onload = function() {\n      resolve(image);\n    };\n\n    image.onerror = function() {\n      reject(new error('could not load image at ' + url));\n    };\n\n    image.src = url;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，使用promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。\n\n下面是一个用promise对象实现的 ajax 操作的例子。\n\nconst getjson = function(url) {\n  const promise = new promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readystate !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new error(this.statustext));\n      }\n    };\n    const client = new xmlhttprequest();\n    client.open(\"get\", url);\n    client.onreadystatechange = handler;\n    client.responsetype = \"json\";\n    client.setrequestheader(\"accept\", \"application/json\");\n    client.send();\n\n  });\n\n  return promise;\n};\n\ngetjson(\"/posts.json\").then(function(json) {\n  console.log('contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面代码中，getjson是对 xmlhttprequest 对象的封装，用于发出一个针对 json 数据的 http 请求，并且返回一个promise对象。需要注意的是，在getjson内部，resolve函数和reject函数调用时，都带有参数。\n\n如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 promise 实例，比如像下面这样。\n\nconst p1 = new promise(function (resolve, reject) {\n  // ...\n});\n\nconst p2 = new promise(function (resolve, reject) {\n  // ...\n  resolve(p1);\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，p1和p2都是 promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。\n\n注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。\n\nconst p1 = new promise(function (resolve, reject) {\n  settimeout(() => reject(new error('fail')), 3000)\n})\n\nconst p2 = new promise(function (resolve, reject) {\n  settimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// error: fail\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，p1是一个 promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。\n\n注意，调用resolve或reject并不会终结 promise 的参数函数的执行。\n\nnew promise((resolve, reject) => {\n  resolve(1);\n  console.log(2);\n}).then(r => {\n  console.log(r);\n});\n// 2\n// 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。\n\n一般来说，调用resolve或reject以后，promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。\n\nnew promise((resolve, reject) => {\n  return resolve(1);\n  // 后面的语句不会执行\n  console.log(2);\n})\n\n\n1\n2\n3\n4\n5\n\n\n\n# promise.prototype.then()\n\npromise 实例具有then方法，也就是说，then方法是定义在原型对象promise.prototype上的。它的作用是为 promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。\n\nthen方法返回的是一个新的promise实例（注意，不是原来那个promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n\ngetjson(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) { // 这里的post是前面一个then返回的参数\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n\n\n上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。\n\n采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个promise对象（即有异步操作），这时后一个回调函数，就会等待该promise对象的状态发生变化，才会被调用。\n\ngetjson(\"/post/1.json\").then(function(post) {\n  return getjson(post.commenturl);\n}).then(function (comments) {\n  console.log(\"resolved: \", comments);\n}, function (err){\n  console.log(\"rejected: \", err);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，第一个then方法指定的回调函数，返回的是另一个promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。\n\n如果采用箭头函数，上面的代码可以写得更简洁。\n\ngetjson(\"/post/1.json\").then(\n  post => getjson(post.commenturl)\n).then(\n  comments => console.log(\"resolved: \", comments),\n  err => console.log(\"rejected: \", err)\n);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# promise.prototype.catch()\n\npromise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。\n\ngetjson('/posts.json').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getjson 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，getjson方法返回一个 promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。\n\np.then((val) => console.log('fulfilled:', val))\n  .catch((err) => console.log('rejected', err));\n\n// 等同于\np.then((val) => console.log('fulfilled:', val))\n  .then(null, (err) => console.log(\"rejected:\", err));\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面是一个例子。\n\nconst promise = new promise(function(resolve, reject) {\n  throw new error('test');\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n// error: test\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。\n\n// 写法一\nconst promise = new promise(function(resolve, reject) {\n  try {\n    throw new error('test');\n  } catch(e) {\n    reject(e);\n  }\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n\n// 写法二\nconst promise = new promise(function(resolve, reject) {\n  reject(new error('test'));\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。\n\n如果 promise 状态已经变成resolved，再抛出错误是无效的。\n\nconst promise = new promise(function(resolve, reject) {\n  resolve('ok');\n  throw new error('test');\n});\npromise\n  .then(function(value) { console.log(value) })\n  .catch(function(error) { console.log(error) });\n// ok\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 promise 的状态一旦改变，就永久保持该状态，不会再变了。\n\npromise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。\n\ngetjson('/post/1.json').then(function(post) {\n  return getjson(post.commenturl);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个promise产生的错误\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，一共有三个 promise 对象：一个由getjson产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。\n\n一般来说，不要在then方法里面定义 reject 状态的回调函数（即then的第二个参数），总是使用catch方法。\n\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。\n\n跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。\n\nconst someasyncthing = function() {\n  return new promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeasyncthing().then(function() {\n  console.log('everything is great');\n});\n\nsettimeout(() => { console.log(123) }, 2000);\n// uncaught (in promise) referenceerror: x is not defined // 报错却不退出进程\n// 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，someasyncthing函数产生的 promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示referenceerror: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。这就是说，promise 内部的错误不会影响到 promise 外部的代码，通俗的说法就是“promise 会吃掉错误”。\n\n这个脚本放在服务器执行，退出码就是0（即表示执行成功）。不过，node 有一个unhandledrejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。\n\nprocess.on('unhandledrejection', function (err, p) {\n  throw err;\n});\n\n\n1\n2\n3\n\n\n上面代码中，unhandledrejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 promise 实例，它可以用来了解发生错误的环境信息。\n\n注意，node 有计划在未来废除unhandledrejection事件。如果 promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。\n\n再看下面的例子。\n\nconst promise = new promise(function (resolve, reject) {\n  resolve('ok');\n  settimeout(function () { throw new error('test') }, 0)\n});\npromise.then(function (value) { console.log(value) });\n// ok\n// uncaught error: test\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，promise 的运行已经结束了，所以这个错误是在 promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。\n\n一般总是建议，promise 对象后面要跟catch方法，这样可以处理 promise 内部发生的错误。catch方法返回的还是一个 promise 对象，因此后面还可以接着调用then方法。\n\nconst someasyncthing = function() {\n  return new promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeasyncthing()\n.catch(function(error) {\n  console.log('oh no', error);\n})\n.then(function() {\n  console.log('carry on');\n});\n// oh no [referenceerror: x is not defined]\n// carry on\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。\n\npromise.resolve()\n.catch(function(error) {\n  console.log('oh no', error);\n})\n.then(function() {\n  console.log('carry on');\n});\n// carry on\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。\n\ncatch方法之中，还能再抛出错误。\n\nconst someasyncthing = function() {\n  return new promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeasyncthing().then(function() {\n  return someotherasyncthing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为 y 没有声明\n  y + 2;\n}).then(function() {\n  console.log('carry on');\n});\n// oh no [referenceerror: x is not defined]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。\n\nsomeasyncthing().then(function() {\n  return someotherasyncthing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为y没有声明\n  y + 2;\n}).catch(function(error) {\n  console.log('carry on', error);\n});\n// oh no [referenceerror: x is not defined]\n// carry on [referenceerror: y is not defined]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，第二个catch方法用来捕获前一个catch方法抛出的错误。\n\n\n# promise.prototype.finally()\n\nfinally方法用于指定不管 promise 对象最后状态如何，都会执行的操作。该方法是 es2018 引入标准的。\n\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n\n\n1\n2\n3\n4\n\n\n上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。\n\n下面是一个例子，服务器使用 promise 处理请求，然后使用finally方法关掉服务器。\n\nserver.listen(port)\n  .then(function () {\n    // ...\n  })\n  .finally(server.stop);\n\n\n1\n2\n3\n4\n5\n\n\nfinally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 promise 的执行结果。\n\nfinally本质上是then方法的特例。\n\npromise\n.finally(() => {\n  // 语句\n});\n\n// 等同于\npromise\n.then(\n  result => {\n    // 语句\n    return result;\n  },\n  error => {\n    // 语句\n    throw error;\n  }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。\n\n它的实现也很简单。\n\npromise.prototype.finally = function (callback) {\n  let p = this.constructor;\n  return this.then(\n    value  => p.resolve(callback()).then(() => value),\n    reason => p.resolve(callback()).then(() => { throw reason })\n  );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，不管前面的 promise 是fulfilled还是rejected，都会执行回调函数callback。\n\n从上面的实现还可以看到，finally方法总是会返回原来的值。\n\n// resolve 的值是 undefined\npromise.resolve(2).then(() => {}, () => {})\n\n// resolve 的值是 2\npromise.resolve(2).finally(() => {})\n\n// reject 的值是 undefined\npromise.reject(3).then(() => {}, () => {})\n\n// reject 的值是 3\npromise.reject(3).finally(() => {})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# promise.all()\n\npromise.all()方法用于将多个 promise 实例，包装成一个新的 promise 实例。\n\nconst p = promise.all([p1, p2, p3]);\n\n\n1\n\n\n上面代码中，promise.all()方法接受一个数组作为参数，p1、p2、p3都是 promise 实例，如果不是，就会先调用下面讲到的promise.resolve方法，将参数转为 promise 实例，再进一步处理。另外，promise.all()方法的参数可以不是数组，但必须具有 iterator 接口，且返回的每个成员都是 promise 实例。\n\np的状态由p1、p2、p3决定，分成两种情况。\n\n（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n\n（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\n\n下面是一个具体的例子。\n\n// 生成一个promise对象的数组\nconst promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n  return getjson('/post/' + id + \".json\");\n});\n\npromise.all(promises).then(function (posts) {\n  // ...\n}).catch(function(reason){\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，promises是包含 6 个 promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用promise.all方法后面的回调函数。\n\n下面是另一个例子。\n\nconst databasepromise = connectdatabase();\n\nconst bookspromise = databasepromise\n  .then(findallbooks);\n\nconst userpromise = databasepromise\n  .then(getcurrentuser);\n\npromise.all([\n  bookspromise,\n  userpromise\n])\n.then(([books, user]) => picktoprecommendations(books, user));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，bookspromise和userpromise是两个异步操作，只有等到它们的结果都返回了，才会触发picktoprecommendations这个回调函数。\n\n注意，如果作为参数的 promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发promise.all()的catch方法。\n\nconst p1 = new promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result)\n.catch(e => e);\n\nconst p2 = new promise((resolve, reject) => {\n  throw new error('报错了');\n})\n.then(result => result)\n.catch(e => e);\n\npromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// [\"hello\", error: 报错了]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。\n\n如果p2没有自己的catch方法，就会调用promise.all()的catch方法。\n\nconst p1 = new promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result);\n\nconst p2 = new promise((resolve, reject) => {\n  throw new error('报错了');\n})\n.then(result => result);\n\npromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// error: 报错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# promise.race()\n\npromise.race()方法同样是将多个 promise 实例，包装成一个新的 promise 实例。\n\nconst p = promise.race([p1, p2, p3]);\n\n\n1\n\n\n上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 promise 实例的返回值，就传递给p的回调函数。\n\npromise.race()方法的参数与promise.all()方法一样，如果不是 promise 实例，就会先调用下面讲到的promise.resolve()方法，将参数转为 promise 实例，再进一步处理。\n\n下面是一个例子，如果指定时间内没有获得结果，就将 promise 的状态变为reject，否则变为resolve。\n\nconst p = promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new promise(function (resolve, reject) {\n    settimeout(() => reject(new error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。\n\n\n# promise.allsettled()\n\npromise.allsettled()方法接受一组 promise 实例作为参数，包装成一个新的 promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 es2020 引入。\n\nconst promises = [\n  fetch('/api-1'),\n  fetch('/api-2'),\n  fetch('/api-3'),\n];\n\nawait promise.allsettled(promises);\nremoveloadingindicator();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。\n\n**该方法返回的新的 promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。**状态变成fulfilled后，promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入promise.allsettled()的 promise 实例。\n\nconst resolved = promise.resolve(42);\nconst rejected = promise.reject(-1);\n\nconst allsettledpromise = promise.allsettled([resolved, rejected]);\n\nallsettledpromise.then(function (results) {\n  console.log(results);\n});\n// [\n//    { status: 'fulfilled', value: 42 },\n//    { status: 'rejected', reason: -1 }\n// ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，promise.allsettled()的返回值allsettledpromise，状态只可能变成fulfilled。它的监听函数接收到的参数是数组results。该数组的每个成员都是一个对象，对应传入promise.allsettled()的两个 promise 实例。每个对象都有status属性，该属性的值只可能是字符串fulfilled或字符串rejected。fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。\n\n下面是返回值用法的例子。\n\nconst promises = [ fetch('index.html'), fetch('https://does-not-exist/') ];\nconst results = await promise.allsettled(promises);\n\n// 过滤出成功的请求\nconst successfulpromises = results.filter(p => p.status === 'fulfilled');\n\n// 过滤出失败的请求，并输出原因\nconst errors = results\n  .filter(p => p.status === 'rejected')\n  .map(p => p.reason);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，promise.allsettled()方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。promise.all()方法无法做到这一点。\n\nconst urls = [ /* ... */ ];\nconst requests = urls.map(x => fetch(x));\n\ntry {\n  await promise.all(requests);\n  console.log('所有请求都成功。');\n} catch {\n  console.log('至少一个请求失败，其他请求可能还没结束。');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，promise.all()无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了promise.allsettled()，这就很容易了。\n\n\n# promise.any()\n\n**promise.any()方法接受一组 promise 实例作为参数，包装成一个新的 promise 实例。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。**该方法目前是一个第三阶段的提案 。\n\npromise.any()跟promise.race()方法很像，只有一点不同，就是不会因为某个 promise 变成rejected状态而结束。\n\nconst promises = [\n  fetch('/endpoint-a').then(() => 'a'),\n  fetch('/endpoint-b').then(() => 'b'),\n  fetch('/endpoint-c').then(() => 'c'),\n];\ntry {\n  const first = await promise.any(promises);\n  console.log(first);\n} catch (error) {\n  console.log(error);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，promise.any()方法的参数数组包含三个 promise 操作。其中只要有一个变成fulfilled，promise.any()返回的 promise 对象就变成fulfilled。如果所有三个操作都变成rejected，那么就会await命令就会抛出错误。\n\npromise.any()抛出的错误，不是一个一般的错误，而是一个 aggregateerror 实例。它相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误。下面是 aggregateerror 的实现示例。\n\nnew aggregateerror() extends array -> aggregateerror\n\nconst err = new aggregateerror();\nerr.push(new error(\"first error\"));\nerr.push(new error(\"second error\"));\nthrow err;\n\n\n1\n2\n3\n4\n5\n6\n\n\n捕捉错误时，如果不用try...catch结构和 await 命令，可以像下面这样写。\n\npromise.any(promises).then(\n  (first) => {\n    // any of the promises was fulfilled.\n  },\n  (error) => {\n    // all of the promises were rejected.\n  }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面是一个例子。\n\nvar resolved = promise.resolve(42);\nvar rejected = promise.reject(-1);\nvar alsorejected = promise.reject(infinity);\n\npromise.any([resolved, rejected, alsorejected]).then(function (result) {\n  console.log(result); // 42\n});\n\npromise.any([rejected, alsorejected]).catch(function (results) {\n  console.log(results); // [-1, infinity]\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# promise.resolve()\n\n有时需要将现有对象转为 promise 对象，promise.resolve()方法就起到这个作用。\n\nconst jspromise = promise.resolve($.ajax('/whatever.json'));\n\n\n1\n\n\n上面代码将 jquery 生成的deferred对象，转为一个新的 promise 对象。\n\npromise.resolve()等价于下面的写法。\n\npromise.resolve('foo')\n// 等价于\nnew promise(resolve => resolve('foo'))\n\n\n1\n2\n3\n\n\npromise.resolve方法的参数分成四种情况。\n\n（1）参数是一个 promise 实例\n\n如果参数是 promise 实例，那么promise.resolve将不做任何修改、原封不动地返回这个实例。\n\n（2）参数是一个thenable对象\n\nthenable对象指的是具有then方法的对象，比如下面这个对象。\n\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\npromise.resolve方法会将这个对象转为 promise 对象，然后就立即执行thenable对象的then方法。\n\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\nlet p1 = promise.resolve(thenable);\np1.then(function(value) {\n  console.log(value);  // 42\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。\n\n（3）参数不是具有then方法的对象，或根本就不是对象\n\n如果参数是一个原始值，或者是一个不具有then方法的对象，则promise.resolve方法返回一个新的 promise 对象，状态为resolved。\n\nconst p = promise.resolve('hello');\n\np.then(function (s){\n  console.log(s)\n});\n// hello\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码生成一个新的 promise 对象的实例p。由于字符串hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。promise.resolve方法的参数，会同时传给回调函数。\n\n（4）不带有任何参数\n\npromise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 promise 对象。\n\n所以，如果希望得到一个 promise 对象，比较方便的方法就是直接调用promise.resolve()方法。\n\nconst p = promise.resolve();\n\np.then(function () {\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n\n\n上面代码的变量p就是一个 promise 对象。\n\n需要注意的是，立即resolve()的 promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。\n\nsettimeout(function () {\n  console.log('three');\n}, 0);\n\npromise.resolve().then(function () {\n  console.log('two');\n});\n\nconsole.log('one');\n\n// one\n// two\n// three\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，settimeout(fn, 0)在下一轮“事件循环”开始时执行，promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。\n\n\n# promise.reject()\n\npromise.reject(reason)方法也会返回一个新的 promise 实例，该实例的状态为rejected。\n\nconst p = promise.reject('出错了');\n// 等同于\nconst p = new promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n// 出错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码生成一个 promise 对象的实例p，状态为rejected，回调函数会立即执行。\n\n注意，promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与promise.resolve方法不一致。\n\nconst thenable = {\n  then(resolve, reject) {\n    reject('出错了');\n  }\n};\n\npromise.reject(thenable)\n.catch(e => {\n  console.log(e === thenable)\n})\n// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。\n\n\n# 应用\n\n\n# 加载图片\n\n我们可以将图片的加载写成一个promise，一旦加载完成，promise的状态就发生变化。\n\nconst preloadimage = function (path) {\n  return new promise(function (resolve, reject) {\n    const image = new image();\n    image.onload  = resolve;\n    image.onerror = reject;\n    image.src = path;\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# generator 函数与 promise 的结合\n\n使用 generator 函数管理流程，遇到异步操作的时候，通常返回一个promise对象。\n\nfunction getfoo () {\n  return new promise(function (resolve, reject){\n    resolve('foo');\n  });\n}\n\nconst g = function* () {\n  try {\n    const foo = yield getfoo();\n    console.log(foo);\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nfunction run (generator) {\n  const it = generator();\n\n  function go(result) {\n    if (result.done) return result.value;\n\n    return result.value.then(function (value) {\n      return go(it.next(value));\n    }, function (error) {\n      return go(it.throw(error));\n    });\n  }\n\n  go(it.next());\n}\n\nrun(g);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面代码的 generator 函数g之中，有一个异步操作getfoo，它返回的就是一个promise对象。函数run用来处理这个promise对象，并调用下一个next方法。\n\n\n# promise.try()\n\n实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。\n\npromise.resolve().then(f)\n\n\n1\n\n\n上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。\n\nconst f = () => console.log('now');\npromise.resolve().then(f);\nconsole.log('next');\n// next\n// now\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，函数f是同步的，但是用 promise 包装了以后，就变成异步执行了。\n\n那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 api 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。\n\nconst f = () => console.log('now');\n(async () => f())();\nconsole.log('next');\n// now\n// next\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。\n\n(async () => f())()\n.then(...)\n\n\n1\n2\n\n\n需要注意的是，async () => f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。\n\n(async () => f())()\n.then(...)\n.catch(...)\n\n\n1\n2\n3\n\n\n第二种写法是使用new promise()。\n\nconst f = () => console.log('now');\n(\n  () => new promise(\n    resolve => resolve(f())\n  )\n)();\nconsole.log('next');\n// now\n// next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码也是使用立即执行的匿名函数，执行new promise()。这种情况下，同步函数也是同步执行的。\n\n鉴于这是一个很常见的需求，所以现在有一个提案，提供promise.try方法替代上面的写法。\n\nconst f = () => console.log('now');\npromise.try(f);\nconsole.log('next');\n// now\n// next\n\n\n1\n2\n3\n4\n5\n\n\n事实上，promise.try存在已久，promise 库bluebird、q和when，早就提供了这个方法。\n\n由于promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。\n\nfunction getusername(userid) {\n  return database.users.get({id: userid})\n  .then(function(user) {\n    return user.name;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，database.users.get()返回一个 promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。\n\ndatabase.users.get({id: userid})\n.then(...)\n.catch(...)\n\n\n1\n2\n3\n\n\n但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。\n\ntry {\n  database.users.get({id: userid})\n  .then(...)\n  .catch(...)\n} catch (e) {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。\n\npromise.try(() => database.users.get({id: userid}))\n  .then(...)\n  .catch(...)\n\n\n1\n2\n3\n\n\n事实上，promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3},{title:"Iterator 和 for-of 循环",frontmatter:{title:"Iterator 和 for-of 循环",date:"2020-02-09T16:00:29.000Z",permalink:"/pages/48df907ad3570f3d",author:"阮一峰",categories:["《ES6 教程》笔记"],tags:["ES6"]},regularPath:"/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/17.Iterator%20%E5%92%8C%20for-of%20%E5%BE%AA%E7%8E%AF.html",relativePath:"《ES6 教程》笔记/17.Iterator 和 for-of 循环.md",key:"v-584aa1ec",path:"/pages/48df907ad3570f3d/",headers:[{level:2,title:"Iterator（遍历器）的概念",slug:"iterator-遍历器-的概念",normalizedTitle:"iterator（遍历器）的概念",charIndex:29},{level:2,title:"默认 Iterator 接口",slug:"默认-iterator-接口",normalizedTitle:"默认 iterator 接口",charIndex:2535},{level:2,title:"调用 Iterator 接口的场合",slug:"调用-iterator-接口的场合",normalizedTitle:"调用 iterator 接口的场合",charIndex:7665},{level:2,title:"字符串的 Iterator 接口",slug:"字符串的-iterator-接口",normalizedTitle:"字符串的 iterator 接口",charIndex:8984},{level:2,title:"Iterator 接口与 Generator 函数",slug:"iterator-接口与-generator-函数",normalizedTitle:"iterator 接口与 generator 函数",charIndex:9908},{level:2,title:"遍历器对象的 return()，throw()",slug:"遍历器对象的-return-throw",normalizedTitle:"遍历器对象的 return()，throw()",charIndex:10406},{level:2,title:"for...of 循环",slug:"for-of-循环",normalizedTitle:"for...of 循环",charIndex:13},{level:3,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:76},{level:3,title:"Set 和 Map 结构",slug:"set-和-map-结构",normalizedTitle:"set 和 map 结构",charIndex:11619},{level:3,title:"计算生成的数据结构",slug:"计算生成的数据结构",normalizedTitle:"计算生成的数据结构",charIndex:13812},{level:3,title:"类似数组的对象",slug:"类似数组的对象",normalizedTitle:"类似数组的对象",charIndex:6199},{level:3,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:86},{level:3,title:"与其他遍历语法的比较",slug:"与其他遍历语法的比较",normalizedTitle:"与其他遍历语法的比较",charIndex:15951}],excerpt:'<h1 id="iterator-和-for-of-循环"><a class="header-anchor" href="#iterator-和-for-of-循环">#</a> Iterator 和 for...of 循环</h1>\n<h2 id="iterator-遍历器-的概念"><a class="header-anchor" href="#iterator-遍历器-的概念">#</a> Iterator（遍历器）的概念</h2>\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\n',headersStr:"Iterator（遍历器）的概念 默认 Iterator 接口 调用 Iterator 接口的场合 字符串的 Iterator 接口 Iterator 接口与 Generator 函数 遍历器对象的 return()，throw() for...of 循环 数组 Set 和 Map 结构 计算生成的数据结构 类似数组的对象 对象 与其他遍历语法的比较",content:"# Iterator 和 for...of 循环\n\n\n# Iterator（遍历器）的概念\n\nJavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\n\nIterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。\n\nIterator 的遍历过程是这样的。\n\n（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n\n（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n\n（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n\n（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。\n\n每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n\n下面是一个模拟next方法返回值的例子。\n\nvar it = makeIterator(['a', 'b']);\n\nit.next() // { value: \"a\", done: false }\nit.next() // { value: \"b\", done: false }\nit.next() // { value: undefined, done: true }\n\nfunction makeIterator(array) {\n  var nextIndex = 0;\n  return {\n    next: function() {\n      return nextIndex < array.length ?\n        {value: array[nextIndex++], done: false} :\n        {value: undefined, done: true};\n    }\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码定义了一个makeIterator函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组['a', 'b']执行这个函数，就会返回该数组的遍历器对象（即指针对象）it。\n\n指针对象的next方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用next方法，指针就会指向数组的下一个成员。第一次调用，指向a；第二次调用，指向b。\n\nnext方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。\n\n总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。\n\n对于遍历器对象来说，done: false和value: undefined属性都是可以省略的，因此上面的makeIterator函数可以简写成下面的形式。\n\nfunction makeIterator(array) {\n  var nextIndex = 0;\n  return {\n    next: function() {\n      return nextIndex < array.length ?\n        {value: array[nextIndex++]} :\n        {done: true};\n    }\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。\n\nvar it = idMaker();\n\nit.next().value // 0\nit.next().value // 1\nit.next().value // 2\n// ...\n\nfunction idMaker() {\n  var index = 0;\n\n  return {\n    next: function() {\n      return {value: index++, done: false};\n    }\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面的例子中，遍历器生成函数idMaker，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。\n\n如果使用 TypeScript 的写法，遍历器接口（Iterable）、指针对象（Iterator）和next方法返回值的规格可以描述如下。\n\ninterface Iterable {\n  [Symbol.iterator]() : Iterator,\n}\n\ninterface Iterator {\n  next(value?: any) : IterationResult,\n}\n\ninterface IterationResult {\n  value: any,\n  done: boolean,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 默认 Iterator 接口\n\nIterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环（详见下文）。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。\n\n一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。\n\nES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。\n\nconst obj = {\n  [Symbol.iterator] : function () {\n    return {\n      next: function () {\n        return {\n          value: 1,\n          done: true\n        };\n      }\n    };\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，对象obj是可遍历的（iterable），因为具有Symbol.iterator属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。\n\nES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被for...of循环遍历。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。\n\n原生具备 Iterator 接口的数据结构如下。\n\n * Array\n * Map\n * Set\n * String\n * TypedArray\n * 函数的 arguments 对象\n * NodeList 对象\n\n下面的例子是数组的Symbol.iterator属性。\n\nlet arr = ['a', 'b', 'c'];\nlet iter = arr[Symbol.iterator]();\n\niter.next() // { value: 'a', done: false }\niter.next() // { value: 'b', done: false }\niter.next() // { value: 'c', done: false }\niter.next() // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。\n\n对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，for...of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for...of循环遍历。\n\n对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。\n\n一个对象如果要具备可被for...of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。\n\nclass RangeIterator {\n  constructor(start, stop) {\n    this.value = start;\n    this.stop = stop;\n  }\n\n  [Symbol.iterator]() { return this; }\n\n  next() {\n    var value = this.value;\n    if (value < this.stop) {\n      this.value++;\n      return {done: false, value: value};\n    }\n    return {done: true, value: undefined};\n  }\n}\n\nfunction range(start, stop) {\n  return new RangeIterator(start, stop);\n}\n\nfor (var value of range(0, 3)) {\n  console.log(value); // 0, 1, 2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n上面代码是一个类部署 Iterator 接口的写法。Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象。\n\n下面是通过遍历器实现指针结构的例子。\n\nfunction Obj(value) {\n  this.value = value;\n  this.next = null;\n}\n\nObj.prototype[Symbol.iterator] = function() {\n  var iterator = { next: next };\n\n  var current = this;\n\n  function next() {\n    if (current) {\n      var value = current.value;\n      current = current.next;\n      return { done: false, value: value };\n    } else {\n      return { done: true };\n    }\n  }\n  return iterator;\n}\n\nvar one = new Obj(1);\nvar two = new Obj(2);\nvar three = new Obj(3);\n\none.next = two;\ntwo.next = three;\n\nfor (var i of one){\n  console.log(i); // 1, 2, 3\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面代码首先在构造函数的原型链上部署Symbol.iterator方法，调用该方法会返回遍历器对象iterator，调用该对象的next方法，在返回一个值的同时，自动将内部指针移到下一个实例。\n\n下面是另一个为对象添加 Iterator 接口的例子。\n\nlet obj = {\n  data: [ 'hello', 'world' ],\n  [Symbol.iterator]() {\n    const self = this;\n    let index = 0;\n    return {\n      next() {\n        if (index < self.data.length) {\n          return {\n            value: self.data[index++],\n            done: false\n          };\n        } else {\n          return { value: undefined, done: true };\n        }\n      }\n    };\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n对于类似数组的对象（存在数值键名和length属性），部署 Iterator 接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的 Iterator 接口。\n\nNodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];\n// 或者\nNodeList.prototype[Symbol.iterator] = [][Symbol.iterator];\n\n[...document.querySelectorAll('div')] // 可以执行了\n\n\n1\n2\n3\n4\n5\n\n\nNodeList 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的Symbol.iterator属性，可以看到没有任何影响。\n\n下面是另一个类似数组的对象调用数组的Symbol.iterator方法的例子。\n\nlet iterable = {\n  0: 'a',\n  1: 'b',\n  2: 'c',\n  length: 3,\n  [Symbol.iterator]: Array.prototype[Symbol.iterator]\n};\nfor (let item of iterable) {\n  console.log(item); // 'a', 'b', 'c'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意，普通对象部署数组的Symbol.iterator方法，并无效果。\n\nlet iterable = {\n  a: 'a',\n  b: 'b',\n  c: 'c',\n  length: 3,\n  [Symbol.iterator]: Array.prototype[Symbol.iterator]\n};\nfor (let item of iterable) {\n  console.log(item); // undefined, undefined, undefined\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果Symbol.iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。\n\nvar obj = {};\n\nobj[Symbol.iterator] = () => 1;\n\n[...obj] // TypeError: [] is not a function\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，变量obj的Symbol.iterator方法对应的不是遍历器生成函数，因此报错。\n\n有了遍历器接口，数据结构就可以用for...of循环遍历（详见下文），也可以使用while循环遍历。\n\nvar $iterator = ITERABLE[Symbol.iterator]();\nvar $result = $iterator.next();\nwhile (!$result.done) {\n  var x = $result.value;\n  // ...\n  $result = $iterator.next();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，ITERABLE代表某种可遍历的数据结构，$iterator是它的遍历器对象。遍历器对象每次移动指针（next方法），都检查一下返回值的done属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（next方法），不断循环。\n\n\n# 调用 Iterator 接口的场合\n\n有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合。\n\n（1）解构赋值\n\n对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。\n\nlet set = new Set().add('a').add('b').add('c');\n\nlet [x,y] = set;\n// x='a'; y='b'\n\nlet [first, ...rest] = set;\n// first='a'; rest=['b','c'];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（2）扩展运算符\n\n扩展运算符（...）也会调用默认的 Iterator 接口。\n\n// 例一\nvar str = 'hello';\n[...str] //  ['h','e','l','l','o']\n\n// 例二\nlet arr = ['b', 'c'];\n['a', ...arr, 'd']\n// ['a', 'b', 'c', 'd']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码的扩展运算符内部就调用 Iterator 接口。\n\n实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。\n\nlet arr = [...iterable];\n\n\n1\n\n\n（3）yield*\n\nyield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\n\nlet generator = function* () {\n  yield 1;\n  yield* [2,3,4];\n  yield 5;\n};\n\nvar iterator = generator();\n\niterator.next() // { value: 1, done: false }\niterator.next() // { value: 2, done: false }\niterator.next() // { value: 3, done: false }\niterator.next() // { value: 4, done: false }\niterator.next() // { value: 5, done: false }\niterator.next() // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n（4）其他场合\n\n由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。\n\n * for...of\n * Array.from()\n * Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）\n * Promise.all()\n * Promise.race()\n\n\n# 字符串的 Iterator 接口\n\n字符串是一个类似数组的对象，也原生具有 Iterator 接口。\n\nvar someString = \"hi\";\ntypeof someString[Symbol.iterator]\n// \"function\"\n\nvar iterator = someString[Symbol.iterator]();\n\niterator.next()  // { value: \"h\", done: false }\niterator.next()  // { value: \"i\", done: false }\niterator.next()  // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，调用Symbol.iterator方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。\n\n可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的。\n\nvar str = new String(\"hi\");\n\n[...str] // [\"h\", \"i\"]\n\nstr[Symbol.iterator] = function() {\n  return {\n    next: function() {\n      if (this._first) {\n        this._first = false;\n        return { value: \"bye\", done: false };\n      } else {\n        return { done: true };\n      }\n    },\n    _first: true\n  };\n};\n\n[...str] // [\"bye\"]\nstr // \"hi\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n上面代码中，字符串 str 的Symbol.iterator方法被修改了，所以扩展运算符（...）返回的值变成了bye，而字符串本身还是hi。\n\n\n# Iterator 接口与 Generator 函数\n\nSymbol.iterator方法的最简单实现，还是使用下一章要介绍的 Generator 函数。\n\nlet myIterable = {\n  [Symbol.iterator]: function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n  }\n}\n[...myIterable] // [1, 2, 3]\n\n// 或者采用下面的简洁写法\n\nlet obj = {\n  * [Symbol.iterator]() {\n    yield 'hello';\n    yield 'world';\n  }\n};\n\nfor (let x of obj) {\n  console.log(x);\n}\n// \"hello\"\n// \"world\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n上面代码中，Symbol.iterator方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。\n\n\n# 遍历器对象的 return()，throw()\n\n遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。\n\nreturn方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。\n\nfunction readLinesSync(file) {\n  return {\n    [Symbol.iterator]() {\n      return {\n        next() {\n          return { done: false };\n        },\n        return() {\n          file.close();\n          return { done: true };\n        }\n      };\n    },\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。下面的两种情况，都会触发执行return方法。\n\n// 情况一\nfor (let line of readLinesSync(fileName)) {\n  console.log(line);\n  break;\n}\n\n// 情况二\nfor (let line of readLinesSync(fileName)) {\n  console.log(line);\n  throw new Error();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，情况一输出文件的第一行以后，就会执行return方法，关闭这个文件；情况二会在执行return方法关闭文件之后，再抛出错误。\n\n注意，return方法必须返回一个对象，这是 Generator 规格决定的。\n\nthrow方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。请参阅《Generator 函数》一章。\n\n\n# for...of 循环\n\nES6 借鉴 C++、Java、C# 和 Python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。\n\n一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。\n\nfor...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。\n\n\n# 数组\n\n数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for...of循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。\n\nconst arr = ['red', 'green', 'blue'];\n\nfor(let v of arr) {\n  console.log(v); // red green blue\n}\n\nconst obj = {};\nobj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);\n\nfor(let v of obj) {\n  console.log(v); // red green blue\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，空对象obj部署了数组arr的Symbol.iterator属性，结果obj的for...of循环，产生了与arr完全一样的结果。\n\nfor...of循环可以代替数组实例的forEach方法。\n\nconst arr = ['red', 'green', 'blue'];\n\narr.forEach(function (element, index) {\n  console.log(element); // red green blue\n  console.log(index);   // 0 1 2\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\nJavaScript 原有的**for...in循环，只能获得对象的键名**，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。\n\nvar arr = ['a', 'b', 'c', 'd'];\n\nfor (let a in arr) {\n  console.log(a); // 0 1 2 3\n}\n\nfor (let a of arr) {\n  console.log(a); // a b c d\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码表明，for...in循环读取键名，for...of循环读取键值。如果要通过for...of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法（参见《数组的扩展》一章）。\n\nfor...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。\n\nlet arr = [3, 5, 7];\narr.foo = 'hello';\n\nfor (let i in arr) {\n  console.log(i); // \"0\", \"1\", \"2\", \"foo\"\n}\n\nfor (let i of arr) {\n  console.log(i); //  \"3\", \"5\", \"7\"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，for...of循环不会返回数组arr的foo属性。\n\n\n# Set 和 Map 结构\n\nSet 和 Map 结构也原生具有 Iterator 接口，可以直接使用for...of循环。\n\nvar engines = new Set([\"Gecko\", \"Trident\", \"Webkit\", \"Webkit\"]);\nfor (var e of engines) {\n  console.log(e);\n}\n// Gecko\n// Trident\n// Webkit\n\nvar es6 = new Map();\nes6.set(\"edition\", 6);\nes6.set(\"committee\", \"TC39\");\nes6.set(\"standard\", \"ECMA-262\");\nfor (var [name, value] of es6) {\n  console.log(name + \": \" + value);\n}\n// edition: 6\n// committee: TC39\n// standard: ECMA-262\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。\n\nlet map = new Map().set('a', 1).set('b', 2);\nfor (let pair of map) {\n  console.log(pair);\n}\n// ['a', 1]\n// ['b', 2]\n\nfor (let [key, value] of map) {\n  console.log(key + ' : ' + value);\n}\n// a : 1\n// b : 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 计算生成的数据结构\n\n有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。\n\n * entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。\n * keys() 返回一个遍历器对象，用来遍历所有的键名。\n * values() 返回一个遍历器对象，用来遍历所有的键值。\n\n这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。\n\nlet arr = ['a', 'b', 'c'];\nfor (let pair of arr.entries()) {\n  console.log(pair);\n}\n// [0, 'a']\n// [1, 'b']\n// [2, 'c']\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 类似数组的对象\n\n类似数组的对象包括好几类。下面是for...of循环用于字符串、DOM NodeList 对象、arguments对象的例子。\n\n// 字符串\nlet str = \"hello\";\n\nfor (let s of str) {\n  console.log(s); // h e l l o\n}\n\n// DOM NodeList对象\nlet paras = document.querySelectorAll(\"p\");\n\nfor (let p of paras) {\n  p.classList.add(\"test\");\n}\n\n// arguments对象\nfunction printArgs() {\n  for (let x of arguments) {\n    console.log(x);\n  }\n}\nprintArgs('a', 'b');\n// 'a'\n// 'b'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n对于字符串来说，for...of循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。\n\nfor (let x of 'a\\uD83D\\uDC0A') {\n  console.log(x);\n}\n// 'a'\n// '\\uD83D\\uDC0A'\n\n\n1\n2\n3\n4\n5\n\n\n并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。\n\nlet arrayLike = { length: 2, 0: 'a', 1: 'b' };\n\n// 报错\nfor (let x of arrayLike) {\n  console.log(x);\n}\n\n// 正确\nfor (let x of Array.from(arrayLike)) {\n  console.log(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 对象\n\n对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名。\n\nlet es6 = {\n  edition: 6,\n  committee: \"TC39\",\n  standard: \"ECMA-262\"\n};\n\nfor (let e in es6) {\n  console.log(e);\n}\n// edition\n// committee\n// standard\n\nfor (let e of es6) {\n  console.log(e);\n}\n// TypeError: es6[Symbol.iterator] is not a function\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码表示，对于普通的对象，for...in循环可以遍历键名，for...of循环会报错。\n\n一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。\n\nfor (var key of Object.keys(someObject)) {\n  console.log(key + ': ' + someObject[key]);\n}\n\n\n1\n2\n3\n\n\n另一个方法是使用 Generator 函数将对象重新包装一下。\n\nfunction* entries(obj) {\n  for (let key of Object.keys(obj)) {\n    yield [key, obj[key]];\n  }\n}\n\nfor (let [key, value] of entries(obj)) {\n  console.log(key, '->', value);\n}\n// a -> 1\n// b -> 2\n// c -> 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 与其他遍历语法的比较\n\n以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是for循环。\n\nfor (var index = 0; index < myArray.length; index++) {\n  console.log(myArray[index]);\n}\n\n\n1\n2\n3\n\n\n这种写法比较麻烦，因此数组提供内置的forEach方法。\n\nmyArray.forEach(function (value) {\n  console.log(value);\n});\n\n\n1\n2\n3\n\n\n这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。\n\nfor...in循环可以遍历数组的键名。\n\nfor (var index in myArray) {\n  console.log(myArray[index]);\n}\n\n\n1\n2\n3\n\n\nfor...in循环有几个缺点。\n\n * 数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。\n * for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。\n * 某些情况下，for...in循环会以任意顺序遍历键名。\n\n总之，for...in循环主要是为遍历对象而设计的，不适用于遍历数组。\n\nfor...of循环相比上面几种做法，有一些显著的优点。\n\nfor (let value of myArray) {\n  console.log(value);\n}\n\n\n1\n2\n3\n\n * 有着同for...in一样的简洁语法，但是没有for...in那些缺点。\n * 不同于forEach方法，它可以与break、continue和return配合使用。\n * 提供了遍历所有数据结构的统一操作接口。\n\n下面是一个使用 break 语句，跳出for...of循环的例子。\n\nfor (var n of fibonacci) {\n  if (n > 1000)\n    break;\n  console.log(n);\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用break语句跳出for...of循环。",normalizedContent:"# iterator 和 for...of 循环\n\n\n# iterator（遍历器）的概念\n\njavascript 原有的表示“集合”的数据结构，主要是数组（array）和对象（object），es6 又添加了map和set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是map，map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\n\niterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 es6 创造了一种新的遍历命令for...of循环，iterator 接口主要供for...of消费。\n\niterator 的遍历过程是这样的。\n\n（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n\n（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n\n（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n\n（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。\n\n每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n\n下面是一个模拟next方法返回值的例子。\n\nvar it = makeiterator(['a', 'b']);\n\nit.next() // { value: \"a\", done: false }\nit.next() // { value: \"b\", done: false }\nit.next() // { value: undefined, done: true }\n\nfunction makeiterator(array) {\n  var nextindex = 0;\n  return {\n    next: function() {\n      return nextindex < array.length ?\n        {value: array[nextindex++], done: false} :\n        {value: undefined, done: true};\n    }\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码定义了一个makeiterator函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组['a', 'b']执行这个函数，就会返回该数组的遍历器对象（即指针对象）it。\n\n指针对象的next方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用next方法，指针就会指向数组的下一个成员。第一次调用，指向a；第二次调用，指向b。\n\nnext方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。\n\n总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。\n\n对于遍历器对象来说，done: false和value: undefined属性都是可以省略的，因此上面的makeiterator函数可以简写成下面的形式。\n\nfunction makeiterator(array) {\n  var nextindex = 0;\n  return {\n    next: function() {\n      return nextindex < array.length ?\n        {value: array[nextindex++]} :\n        {done: true};\n    }\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n由于 iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。\n\nvar it = idmaker();\n\nit.next().value // 0\nit.next().value // 1\nit.next().value // 2\n// ...\n\nfunction idmaker() {\n  var index = 0;\n\n  return {\n    next: function() {\n      return {value: index++, done: false};\n    }\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面的例子中，遍历器生成函数idmaker，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。\n\n如果使用 typescript 的写法，遍历器接口（iterable）、指针对象（iterator）和next方法返回值的规格可以描述如下。\n\ninterface iterable {\n  [symbol.iterator]() : iterator,\n}\n\ninterface iterator {\n  next(value?: any) : iterationresult,\n}\n\ninterface iterationresult {\n  value: any,\n  done: boolean,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 默认 iterator 接口\n\niterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环（详见下文）。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 iterator 接口。\n\n一种数据结构只要部署了 iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。\n\nes6 规定，默认的 iterator 接口部署在数据结构的symbol.iterator属性，或者说，一个数据结构只要具有symbol.iterator属性，就可以认为是“可遍历的”（iterable）。symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名symbol.iterator，它是一个表达式，返回symbol对象的iterator属性，这是一个预定义好的、类型为 symbol 的特殊值，所以要放在方括号内（参见《symbol》一章）。\n\nconst obj = {\n  [symbol.iterator] : function () {\n    return {\n      next: function () {\n        return {\n          value: 1,\n          done: true\n        };\n      }\n    };\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，对象obj是可遍历的（iterable），因为具有symbol.iterator属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。\n\nes6 的有些数据结构原生具备 iterator 接口（比如数组），即不用任何处理，就可以被for...of循环遍历。原因在于，这些数据结构原生部署了symbol.iterator属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。\n\n原生具备 iterator 接口的数据结构如下。\n\n * array\n * map\n * set\n * string\n * typedarray\n * 函数的 arguments 对象\n * nodelist 对象\n\n下面的例子是数组的symbol.iterator属性。\n\nlet arr = ['a', 'b', 'c'];\nlet iter = arr[symbol.iterator]();\n\niter.next() // { value: 'a', done: false }\niter.next() // { value: 'b', done: false }\niter.next() // { value: 'c', done: false }\niter.next() // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，变量arr是一个数组，原生就具有遍历器接口，部署在arr的symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。\n\n对于原生部署 iterator 接口的数据结构，不用自己写遍历器生成函数，for...of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 iterator 接口，都需要自己在symbol.iterator属性上面部署，这样才会被for...of循环遍历。\n\n对象（object）之所以没有默认部署 iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 map 结构使用，es5 没有 map 结构，而 es6 原生提供了。\n\n一个对象如果要具备可被for...of循环调用的 iterator 接口，就必须在symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。\n\nclass rangeiterator {\n  constructor(start, stop) {\n    this.value = start;\n    this.stop = stop;\n  }\n\n  [symbol.iterator]() { return this; }\n\n  next() {\n    var value = this.value;\n    if (value < this.stop) {\n      this.value++;\n      return {done: false, value: value};\n    }\n    return {done: true, value: undefined};\n  }\n}\n\nfunction range(start, stop) {\n  return new rangeiterator(start, stop);\n}\n\nfor (var value of range(0, 3)) {\n  console.log(value); // 0, 1, 2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n上面代码是一个类部署 iterator 接口的写法。symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象。\n\n下面是通过遍历器实现指针结构的例子。\n\nfunction obj(value) {\n  this.value = value;\n  this.next = null;\n}\n\nobj.prototype[symbol.iterator] = function() {\n  var iterator = { next: next };\n\n  var current = this;\n\n  function next() {\n    if (current) {\n      var value = current.value;\n      current = current.next;\n      return { done: false, value: value };\n    } else {\n      return { done: true };\n    }\n  }\n  return iterator;\n}\n\nvar one = new obj(1);\nvar two = new obj(2);\nvar three = new obj(3);\n\none.next = two;\ntwo.next = three;\n\nfor (var i of one){\n  console.log(i); // 1, 2, 3\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面代码首先在构造函数的原型链上部署symbol.iterator方法，调用该方法会返回遍历器对象iterator，调用该对象的next方法，在返回一个值的同时，自动将内部指针移到下一个实例。\n\n下面是另一个为对象添加 iterator 接口的例子。\n\nlet obj = {\n  data: [ 'hello', 'world' ],\n  [symbol.iterator]() {\n    const self = this;\n    let index = 0;\n    return {\n      next() {\n        if (index < self.data.length) {\n          return {\n            value: self.data[index++],\n            done: false\n          };\n        } else {\n          return { value: undefined, done: true };\n        }\n      }\n    };\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n对于类似数组的对象（存在数值键名和length属性），部署 iterator 接口，有一个简便方法，就是symbol.iterator方法直接引用数组的 iterator 接口。\n\nnodelist.prototype[symbol.iterator] = array.prototype[symbol.iterator];\n// 或者\nnodelist.prototype[symbol.iterator] = [][symbol.iterator];\n\n[...document.queryselectorall('div')] // 可以执行了\n\n\n1\n2\n3\n4\n5\n\n\nnodelist 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的symbol.iterator属性，可以看到没有任何影响。\n\n下面是另一个类似数组的对象调用数组的symbol.iterator方法的例子。\n\nlet iterable = {\n  0: 'a',\n  1: 'b',\n  2: 'c',\n  length: 3,\n  [symbol.iterator]: array.prototype[symbol.iterator]\n};\nfor (let item of iterable) {\n  console.log(item); // 'a', 'b', 'c'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意，普通对象部署数组的symbol.iterator方法，并无效果。\n\nlet iterable = {\n  a: 'a',\n  b: 'b',\n  c: 'c',\n  length: 3,\n  [symbol.iterator]: array.prototype[symbol.iterator]\n};\nfor (let item of iterable) {\n  console.log(item); // undefined, undefined, undefined\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果symbol.iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。\n\nvar obj = {};\n\nobj[symbol.iterator] = () => 1;\n\n[...obj] // typeerror: [] is not a function\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，变量obj的symbol.iterator方法对应的不是遍历器生成函数，因此报错。\n\n有了遍历器接口，数据结构就可以用for...of循环遍历（详见下文），也可以使用while循环遍历。\n\nvar $iterator = iterable[symbol.iterator]();\nvar $result = $iterator.next();\nwhile (!$result.done) {\n  var x = $result.value;\n  // ...\n  $result = $iterator.next();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，iterable代表某种可遍历的数据结构，$iterator是它的遍历器对象。遍历器对象每次移动指针（next方法），都检查一下返回值的done属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（next方法），不断循环。\n\n\n# 调用 iterator 接口的场合\n\n有一些场合会默认调用 iterator 接口（即symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合。\n\n（1）解构赋值\n\n对数组和 set 结构进行解构赋值时，会默认调用symbol.iterator方法。\n\nlet set = new set().add('a').add('b').add('c');\n\nlet [x,y] = set;\n// x='a'; y='b'\n\nlet [first, ...rest] = set;\n// first='a'; rest=['b','c'];\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（2）扩展运算符\n\n扩展运算符（...）也会调用默认的 iterator 接口。\n\n// 例一\nvar str = 'hello';\n[...str] //  ['h','e','l','l','o']\n\n// 例二\nlet arr = ['b', 'c'];\n['a', ...arr, 'd']\n// ['a', 'b', 'c', 'd']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码的扩展运算符内部就调用 iterator 接口。\n\n实际上，这提供了一种简便机制，可以将任何部署了 iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 iterator 接口，就可以对它使用扩展运算符，将其转为数组。\n\nlet arr = [...iterable];\n\n\n1\n\n\n（3）yield*\n\nyield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\n\nlet generator = function* () {\n  yield 1;\n  yield* [2,3,4];\n  yield 5;\n};\n\nvar iterator = generator();\n\niterator.next() // { value: 1, done: false }\niterator.next() // { value: 2, done: false }\niterator.next() // { value: 3, done: false }\niterator.next() // { value: 4, done: false }\niterator.next() // { value: 5, done: false }\niterator.next() // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n（4）其他场合\n\n由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。\n\n * for...of\n * array.from()\n * map(), set(), weakmap(), weakset()（比如new map([['a',1],['b',2]])）\n * promise.all()\n * promise.race()\n\n\n# 字符串的 iterator 接口\n\n字符串是一个类似数组的对象，也原生具有 iterator 接口。\n\nvar somestring = \"hi\";\ntypeof somestring[symbol.iterator]\n// \"function\"\n\nvar iterator = somestring[symbol.iterator]();\n\niterator.next()  // { value: \"h\", done: false }\niterator.next()  // { value: \"i\", done: false }\niterator.next()  // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中，调用symbol.iterator方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。\n\n可以覆盖原生的symbol.iterator方法，达到修改遍历器行为的目的。\n\nvar str = new string(\"hi\");\n\n[...str] // [\"h\", \"i\"]\n\nstr[symbol.iterator] = function() {\n  return {\n    next: function() {\n      if (this._first) {\n        this._first = false;\n        return { value: \"bye\", done: false };\n      } else {\n        return { done: true };\n      }\n    },\n    _first: true\n  };\n};\n\n[...str] // [\"bye\"]\nstr // \"hi\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n上面代码中，字符串 str 的symbol.iterator方法被修改了，所以扩展运算符（...）返回的值变成了bye，而字符串本身还是hi。\n\n\n# iterator 接口与 generator 函数\n\nsymbol.iterator方法的最简单实现，还是使用下一章要介绍的 generator 函数。\n\nlet myiterable = {\n  [symbol.iterator]: function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n  }\n}\n[...myiterable] // [1, 2, 3]\n\n// 或者采用下面的简洁写法\n\nlet obj = {\n  * [symbol.iterator]() {\n    yield 'hello';\n    yield 'world';\n  }\n};\n\nfor (let x of obj) {\n  console.log(x);\n}\n// \"hello\"\n// \"world\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n上面代码中，symbol.iterator方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。\n\n\n# 遍历器对象的 return()，throw()\n\n遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。\n\nreturn方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。\n\nfunction readlinessync(file) {\n  return {\n    [symbol.iterator]() {\n      return {\n        next() {\n          return { done: false };\n        },\n        return() {\n          file.close();\n          return { done: true };\n        }\n      };\n    },\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面代码中，函数readlinessync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。下面的两种情况，都会触发执行return方法。\n\n// 情况一\nfor (let line of readlinessync(filename)) {\n  console.log(line);\n  break;\n}\n\n// 情况二\nfor (let line of readlinessync(filename)) {\n  console.log(line);\n  throw new error();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，情况一输出文件的第一行以后，就会执行return方法，关闭这个文件；情况二会在执行return方法关闭文件之后，再抛出错误。\n\n注意，return方法必须返回一个对象，这是 generator 规格决定的。\n\nthrow方法主要是配合 generator 函数使用，一般的遍历器对象用不到这个方法。请参阅《generator 函数》一章。\n\n\n# for...of 循环\n\nes6 借鉴 c++、java、c# 和 python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。\n\n一个数据结构只要部署了symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的symbol.iterator方法。\n\nfor...of循环可以使用的范围包括数组、set 和 map 结构、某些类似数组的对象（比如arguments对象、dom nodelist 对象）、后文的 generator 对象，以及字符串。\n\n\n# 数组\n\n数组原生具备iterator接口（即默认部署了symbol.iterator属性），for...of循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。\n\nconst arr = ['red', 'green', 'blue'];\n\nfor(let v of arr) {\n  console.log(v); // red green blue\n}\n\nconst obj = {};\nobj[symbol.iterator] = arr[symbol.iterator].bind(arr);\n\nfor(let v of obj) {\n  console.log(v); // red green blue\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，空对象obj部署了数组arr的symbol.iterator属性，结果obj的for...of循环，产生了与arr完全一样的结果。\n\nfor...of循环可以代替数组实例的foreach方法。\n\nconst arr = ['red', 'green', 'blue'];\n\narr.foreach(function (element, index) {\n  console.log(element); // red green blue\n  console.log(index);   // 0 1 2\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\njavascript 原有的**for...in循环，只能获得对象的键名**，不能直接获取键值。es6 提供for...of循环，允许遍历获得键值。\n\nvar arr = ['a', 'b', 'c', 'd'];\n\nfor (let a in arr) {\n  console.log(a); // 0 1 2 3\n}\n\nfor (let a of arr) {\n  console.log(a); // a b c d\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码表明，for...in循环读取键名，for...of循环读取键值。如果要通过for...of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法（参见《数组的扩展》一章）。\n\nfor...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。\n\nlet arr = [3, 5, 7];\narr.foo = 'hello';\n\nfor (let i in arr) {\n  console.log(i); // \"0\", \"1\", \"2\", \"foo\"\n}\n\nfor (let i of arr) {\n  console.log(i); //  \"3\", \"5\", \"7\"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，for...of循环不会返回数组arr的foo属性。\n\n\n# set 和 map 结构\n\nset 和 map 结构也原生具有 iterator 接口，可以直接使用for...of循环。\n\nvar engines = new set([\"gecko\", \"trident\", \"webkit\", \"webkit\"]);\nfor (var e of engines) {\n  console.log(e);\n}\n// gecko\n// trident\n// webkit\n\nvar es6 = new map();\nes6.set(\"edition\", 6);\nes6.set(\"committee\", \"tc39\");\nes6.set(\"standard\", \"ecma-262\");\nfor (var [name, value] of es6) {\n  console.log(name + \": \" + value);\n}\n// edition: 6\n// committee: tc39\n// standard: ecma-262\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面代码演示了如何遍历 set 结构和 map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，set 结构遍历时，返回的是一个值，而 map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 map 成员的键名和键值。\n\nlet map = new map().set('a', 1).set('b', 2);\nfor (let pair of map) {\n  console.log(pair);\n}\n// ['a', 1]\n// ['b', 2]\n\nfor (let [key, value] of map) {\n  console.log(key + ' : ' + value);\n}\n// a : 1\n// b : 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 计算生成的数据结构\n\n有些数据结构是在现有数据结构的基础上，计算生成的。比如，es6 的数组、set、map 都部署了以下三个方法，调用后都返回遍历器对象。\n\n * entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 set，键名与键值相同。map 结构的 iterator 接口，默认就是调用entries方法。\n * keys() 返回一个遍历器对象，用来遍历所有的键名。\n * values() 返回一个遍历器对象，用来遍历所有的键值。\n\n这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。\n\nlet arr = ['a', 'b', 'c'];\nfor (let pair of arr.entries()) {\n  console.log(pair);\n}\n// [0, 'a']\n// [1, 'b']\n// [2, 'c']\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 类似数组的对象\n\n类似数组的对象包括好几类。下面是for...of循环用于字符串、dom nodelist 对象、arguments对象的例子。\n\n// 字符串\nlet str = \"hello\";\n\nfor (let s of str) {\n  console.log(s); // h e l l o\n}\n\n// dom nodelist对象\nlet paras = document.queryselectorall(\"p\");\n\nfor (let p of paras) {\n  p.classlist.add(\"test\");\n}\n\n// arguments对象\nfunction printargs() {\n  for (let x of arguments) {\n    console.log(x);\n  }\n}\nprintargs('a', 'b');\n// 'a'\n// 'b'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n对于字符串来说，for...of循环还有一个特点，就是会正确识别 32 位 utf-16 字符。\n\nfor (let x of 'a\\ud83d\\udc0a') {\n  console.log(x);\n}\n// 'a'\n// '\\ud83d\\udc0a'\n\n\n1\n2\n3\n4\n5\n\n\n并不是所有类似数组的对象都具有 iterator 接口，一个简便的解决方法，就是使用array.from方法将其转为数组。\n\nlet arraylike = { length: 2, 0: 'a', 1: 'b' };\n\n// 报错\nfor (let x of arraylike) {\n  console.log(x);\n}\n\n// 正确\nfor (let x of array.from(arraylike)) {\n  console.log(x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 对象\n\n对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 iterator 接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名。\n\nlet es6 = {\n  edition: 6,\n  committee: \"tc39\",\n  standard: \"ecma-262\"\n};\n\nfor (let e in es6) {\n  console.log(e);\n}\n// edition\n// committee\n// standard\n\nfor (let e of es6) {\n  console.log(e);\n}\n// typeerror: es6[symbol.iterator] is not a function\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码表示，对于普通的对象，for...in循环可以遍历键名，for...of循环会报错。\n\n一种解决方法是，使用object.keys方法将对象的键名生成一个数组，然后遍历这个数组。\n\nfor (var key of object.keys(someobject)) {\n  console.log(key + ': ' + someobject[key]);\n}\n\n\n1\n2\n3\n\n\n另一个方法是使用 generator 函数将对象重新包装一下。\n\nfunction* entries(obj) {\n  for (let key of object.keys(obj)) {\n    yield [key, obj[key]];\n  }\n}\n\nfor (let [key, value] of entries(obj)) {\n  console.log(key, '->', value);\n}\n// a -> 1\n// b -> 2\n// c -> 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 与其他遍历语法的比较\n\n以数组为例，javascript 提供多种遍历语法。最原始的写法就是for循环。\n\nfor (var index = 0; index < myarray.length; index++) {\n  console.log(myarray[index]);\n}\n\n\n1\n2\n3\n\n\n这种写法比较麻烦，因此数组提供内置的foreach方法。\n\nmyarray.foreach(function (value) {\n  console.log(value);\n});\n\n\n1\n2\n3\n\n\n这种写法的问题在于，无法中途跳出foreach循环，break命令或return命令都不能奏效。\n\nfor...in循环可以遍历数组的键名。\n\nfor (var index in myarray) {\n  console.log(myarray[index]);\n}\n\n\n1\n2\n3\n\n\nfor...in循环有几个缺点。\n\n * 数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。\n * for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。\n * 某些情况下，for...in循环会以任意顺序遍历键名。\n\n总之，for...in循环主要是为遍历对象而设计的，不适用于遍历数组。\n\nfor...of循环相比上面几种做法，有一些显著的优点。\n\nfor (let value of myarray) {\n  console.log(value);\n}\n\n\n1\n2\n3\n\n * 有着同for...in一样的简洁语法，但是没有for...in那些缺点。\n * 不同于foreach方法，它可以与break、continue和return配合使用。\n * 提供了遍历所有数据结构的统一操作接口。\n\n下面是一个使用 break 语句，跳出for...of循环的例子。\n\nfor (var n of fibonacci) {\n  if (n > 1000)\n    break;\n  console.log(n);\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用break语句跳出for...of循环。",charsets:{cjk:!0},lastUpdated:"2022/02/04, 14:06:01",lastUpdatedTimestamp:1643983561e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"Java",items:[{text:"Java基础",link:"/java/"},{text:"Java高级",items:[{text:"Java并发",link:"/note/es6/"},{text:"Java虚拟机",link:"/note/es6/"},{text:"JDK新特性",link:"/note/es6/"}]},{text:"Java Web",link:"/note/es6/"},{text:"数据结构与算法",link:"/note/es6/"},{text:"计算机网络",link:"/note/es6/"}]},{text:"框架",items:[{text:"Spring",link:"/back-end/"},{text:"Spring MVC",link:"/back-end/"},{text:"Spring Boot",link:"/back-end/"},{text:"Spring Cloud",link:"/back-end/"},{text:"Spring Cloud Alibaba",link:"/back-end/"},{text:"Spring Security",link:"/pages/c55839/"},{text:"Mybatis",link:"/back-end/"},{text:"Mybatis Plus",link:"/back-end/"},{text:"Mysql",link:"/back-end/"},{text:"Redis",link:"/back-end/"},{text:"Zookeeper",link:"/back-end/"},{text:"Dubbo",link:"/back-end/"},{text:"Kafka",link:"/back-end/"},{text:"Apollo",link:"/back-end/"},{text:"大数据",link:"/back-end/",items:[{text:"Hbase",link:"/pages/261b24/"},{text:"Spark",link:"/pages/c55839/"},{text:"ClickHouse",link:"/note/git/"}]}]},{text:"前端",link:"/front-end/",items:[{text:"HTML",link:"/back-end/"},{text:"Javascript",link:"/back-end/"},{text:"CSS",link:"/back-end/"},{text:"ES6",link:"/back-end/"},{text:"Nodejs",link:"/back-end/"},{text:"Webpack",link:"/back-end/"},{text:"Vue",link:"/back-end/",items:[{text:"Vue Router",link:"/pages/8309a5b876fc95e3/"},{text:"Vuex",link:"/pages/0a83b083bdf257cb/"},{text:"ES6",link:"/note/es6/"}]}]},{text:"架构",link:"/design/",items:[{text:"设计模式",link:"/back-end/"}]},{text:"运维",link:"/operation/",items:[{text:"Linux",link:"/back-end/"},{text:"Shell脚本",link:"/back-end/"},{text:"Docker",link:"/back-end/"},{text:"Kubernetes",link:"/back-end/"}]},{text:"工具",link:"/tools/",items:[{text:"Maven",link:"/back-end/"},{text:"SVN",link:"/back-end/"},{text:"Git",link:"/back-end/"},{text:"Idea",link:"/back-end/"},{text:"Windows",link:"/back-end/"}]},{text:"面试",link:"/interview/",items:[{text:"数据结构与算法",link:"/back-end/"},{text:"Java",link:"/pages/bbda94/"},{text:"框架",link:"/back-end/"},{text:"分布式",link:"/back-end/"}]},{text:"更多",link:"/technology/",items:[{text:"技术文档",link:"/pages/9a7ee40fc232253e/"},{text:"GitHub技巧",link:"/pages/4c778760be26d8b3/"},{text:"Nodejs",link:"/pages/117708e0af7f0bd9/"},{text:"博客搭建",link:"/pages/41f87d890d0a02af/"}]},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]}],sidebarDepth:2,logo:"/img/logo.png",repo:"xugaoyi/vuepress-theme-vdoing",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",sidebar:{"/00.目录页/":[["50.面试.md","面试","/interview"]],catalogue:{"面试":"/interview","《ES6 教程》笔记":"/note/es6/"},"/05.Java/":[{title:"Java基础",collapsable:!0,children:[["05.Java基础/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/8a3d2e/"]]},{title:"Java并发",collapsable:!0,children:[["10.Java并发/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/616956/"]]},{title:"Java虚拟机",collapsable:!0,children:[["15.Java虚拟机/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/14d613/"]]},{title:"JDK新特性",collapsable:!0,children:[["20.JDK新特性/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/101235/"]]},{title:"Java Web",collapsable:!0,children:[["25.Java Web/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/b9843d/"]]},{title:"数据结构和算法",collapsable:!0,children:[["30.数据结构和算法/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/48f257/"]]},{title:"计算机网络",collapsable:!0,children:[["35.计算机网络/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/f9d65e/"]]}],"/10.框架/":[{title:"Spring",collapsable:!0,children:[["05.Spring/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/d4d364/"]]},{title:"Spring MVC",collapsable:!0,children:[["10.Spring MVC/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/72f279/"]]},{title:"Spring Boot",collapsable:!0,children:[["15.Spring Boot/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/815499/"]]},{title:"Spring Cloud",collapsable:!0,children:[["20.Spring Cloud/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/82b6d4/"]]},{title:"Spring Cloud Alibaba",collapsable:!0,children:[["21.Spring Cloud Alibaba/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/075df8/"]]},{title:"Spring Security",collapsable:!0,children:[["25.Spring Security/01.【老徐】Spring Security(一) —— Architecture Overview.md","【老徐】Spring Security(一) —— Architecture Overview","/pages/c55839/"],["25.Spring Security/02.【老徐】Spring Security(二) —— Guides.md","【老徐】Spring Security(二) —— Guides","/pages/188a19/"],["25.Spring Security/03.【老徐】Spring Security(三) —— 核心配置解读.md","【老徐】Spring Security(三) —— 核心配置解读","/pages/9327fd/"],["25.Spring Security/04.【老徐】Spring Security(四) —— 核心过滤器源码分析.md","【老徐】Spring Security(四) —— 核心过滤器源码分析","/pages/bb2ce5/"],["25.Spring Security/05.【老徐】Spring Security(五) —— 动手实现一个 IP_Login.md","【老徐】Spring Security(五) —— 动手实现一个 IP_Login","/pages/754b42/"],["25.Spring Security/06.【老徐】从零开始的 Spring Security OAuth2（一）.md","【老徐】从零开始的 Spring Security OAuth2（一）","/pages/79202c/"],["25.Spring Security/07.【老徐】从零开始的 Spring Security OAuth2（二）.md","【老徐】从零开始的 Spring Security OAuth2（二）","/pages/3e6453/"],["25.Spring Security/08.【老徐】从零开始的 Spring Security OAuth2（三）.md","【老徐】从零开始的 Spring Security OAuth2（三）","/pages/202614/"],["25.Spring Security/09.【老徐】该如何设计你的 PasswordEncoder.md","【老徐】该如何设计你的 PasswordEncoder","/pages/9be0a1/"],["25.Spring Security/10.Spring Security 入门篇.md","Spring Security 入门篇","/pages/605664/"]]},{title:"Mybatis",collapsable:!0,children:[["30.Mybatis/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/d07b16/"]]},{title:"Mybatis Plus",collapsable:!0,children:[["35.Mybatis Plus/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/d35a9e/"]]},{title:"Redis",collapsable:!0,children:[["40.Redis/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/b8166d/"],["40.Redis/20.布隆过滤器.md","布隆过滤器","/pages/d09904/"]]},{title:"Mysql",collapsable:!0,children:[{title:"SQL",collapsable:!0,children:[["45.Mysql/05.SQL/05.EXISTS（NOT EXISTS ） 语句.md","EXISTS（NOT EXISTS ） 语句","/pages/ee8f7b/"]]}]},{title:"Zookeeper",collapsable:!0,children:[["50.Zookeeper/10.实例详解ZooKeeper ZAB协议、分布式锁与领导选举.md","实例详解ZooKeeper ZAB协议、分布式锁与领导选举","/pages/bc1a45/"]]},{title:"Dubbo",collapsable:!0,children:[["55.Dubbo/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/017da3/"]]},{title:"Kafka",collapsable:!0,children:[["60.Kafka/01.Kafka单机版安装.md","Kafka单机版安装","/pages/e5e3af/"],["60.Kafka/10.kafka命令整理.md","kafka命令整理","/pages/bc987c/"],["60.Kafka/20.kafka客户端示例代码.md","kafka客户端示例代码","/pages/4975ea/"]]},{title:"Apollo",collapsable:!0,children:[["65.Apollo/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/fb3719/"]]},{title:"大数据",collapsable:!0,children:[{title:"Hbase",collapsable:!0,children:[["70.大数据/05.Hbase/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/7f0c55/"]]},{title:"Spark",collapsable:!0,children:[["70.大数据/10.Spark/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/466af9/"]]},{title:"ClickHouse",collapsable:!0,children:[["70.大数据/15.ClickHouse/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/d96f04/"]]}]}],"/100.其他/":[{title:"技术文档",collapsable:!0,children:[["01.技术文档/01.Git使用手册.md","Git使用手册","/pages/9a7ee40fc232253e"],["01.技术文档/02.Markdown使用教程.md","Markdown使用教程","/pages/ad247c4332211551"],["01.技术文档/03.npm常用命令.md","npm常用命令","/pages/61f2f95fd7da14fd"],["01.技术文档/10.npm packageJson属性详解.md","npm packageJson属性详解","/pages/dec4f3f00e71a312"],["01.技术文档/15.yaml语言教程.md","yaml语言教程","/pages/4e8444e2d534d14f"]]},{title:"GitHub技巧",collapsable:!0,children:[["02.GitHub技巧/01.GitHub高级搜索技巧.md","GitHub高级搜索技巧","/pages/4c778760be26d8b3"],["02.GitHub技巧/02.GitHub Actions 实现自动部署静态博客.md","GitHub Actions 实现自动部署静态博客","/pages/6b9d359ec5aa5019"],["02.GitHub技巧/03.GitHub Actions 定时运行代码：每天定时百度链接推送.md","GitHub Actions 定时运行代码：每天定时百度链接推送","/pages/f44d2f9ad04ab8d3"],["02.GitHub技巧/10.GitHub加速下载项目的方法.md","GitHub加速下载项目的方法","/pages/95331c6a9613faf8"]]},{title:"Nodejs",collapsable:!0,children:[["03.Nodejs/01.nodejs递归读取所有文件.md","nodejs递归读取所有文件","/pages/117708e0af7f0bd9"]]},{title:"博客搭建",collapsable:!0,children:[["04.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.md","解决百度无法收录搭建在GitHub上的个人博客的问题","/pages/41f87d890d0a02af"],["04.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.md","使用Gitalk实现静态博客无后台评论系统","/pages/1da0bf9a988eafe5"],["04.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.md","GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床","/pages/a5f73af5185fdf0a"],["04.博客搭建/10.vdoing主题效果图.md","vdoing主题效果图","/pages/d557b9a89a215d2e"]]}],"/15.前端/":[{title:"HTML",collapsable:!0,children:[["05.HTML/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/f1cf70/"]]},{title:"JavaScript",collapsable:!0,children:[["10.JavaScript/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/b0cbfe/"]]},{title:"CSS",collapsable:!0,children:[["15.CSS/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/1b9d03/"]]},{title:"ES6",collapsable:!0,children:[["20.ES6/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/f94942/"]]},{title:"Nodejs",collapsable:!0,children:[["25.Nodejs/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/6397c2/"]]},{title:"Webpack",collapsable:!0,children:[["30.Webpack/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/3a3093/"]]},{title:"Vue",collapsable:!0,children:[{title:"Vue Router",collapsable:!0,children:[["35.Vue/05.Vue Router/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/45f613/"]]},{title:"Vuex",collapsable:!0,children:[["35.Vue/10.Vuex/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/8b11e8/"]]}]},{title:"学习笔记",collapsable:!0,children:[["40.学习笔记/10.《ES6 教程》笔记.md","《ES6 教程》笔记","/note/es6/"]]}],"/20.架构/":[{title:"设计模式",collapsable:!0,children:[["05.设计模式/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/1cbc1f/"]]}],"/25.运维/":[{title:"Linux",collapsable:!0,children:[["05.Linux/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/be47c5/"]]},{title:"Shell脚本",collapsable:!0,children:[["10.Shell脚本/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/48ee28/"]]},{title:"Tomcat",collapsable:!0,children:[["40.Tomcat/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/c0a158/"]]},{title:"Nginx",collapsable:!0,children:[["45.Nginx/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/22279f/"]]},{title:"Docker",collapsable:!0,children:[["50.Docker/01.Docker 初级篇.md","Docker 初级篇","/pages/261b24/"],["50.Docker/02.Docker 中级篇.md","Docker 中级篇","/pages/5ca863/"],["50.Docker/03.Docker 高级实践篇.md","Docker 高级实践篇","/pages/a24e91/"],["50.Docker/04.Docker 网络模式和容器间通信.md","Docker 网络模式和容器间通信","/pages/8a7664/"],["50.Docker/05.Docker 搭建 Redis Cluster 集群.md","Docker 搭建 Redis Cluster 集群","/pages/457953/"]]},{title:"kubernetes",collapsable:!0,children:[["60.kubernetes/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/1b1528/"]]}],"/30.工具/":[{title:"maven",collapsable:!0,children:[["05.maven/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/2c13c2/"]]},{title:"svn",collapsable:!0,children:[["10.svn/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/2ec465/"]]},{title:"git",collapsable:!0,children:[["15.git/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/657a34/"]]},{title:"idea",collapsable:!0,children:[["20.idea/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/891624/"]]},{title:"windows",collapsable:!0,children:[["25.windows/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/df2d8d/"]]}],"/35.面试/":[{title:"Java",collapsable:!0,children:[{title:"Java基础",collapsable:!0,children:[["05.Java/05.Java基础/05.Java 基础.md","Java 基础","/pages/bbda94/"],["05.Java/05.Java基础/10.Java 容器.md","Java 容器","/pages/17acab/"],["05.Java/05.Java基础/15.Java IO.md","Java IO","/pages/5859c4/"],["05.Java/05.Java基础/30.JDK 动态代理.md","JDK 动态代理","/pages/e5ea78/"]]}]},{title:"Java Web",collapsable:!0,children:[["10.Java Web/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/14fc4f/"]]},{title:"框架原理",collapsable:!0,children:[["15.框架原理/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/1ca50c/"]]},{title:"数据库",collapsable:!0,children:[["20.数据库/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/6678f4/"]]},{title:"设计模式",collapsable:!0,children:[["25.设计模式/10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/ddeaf7/"]]},{title:"计算机基础",collapsable:!0,children:[["30.计算机基础/10.IO 模型.md","IO 模型","/pages/bc7c50/"]]}],"/40.更多/":[["10.Redis高级客户端Lettuce详解.md","Redis高级客户端Lettuce详解","/pages/bdd0da/"]],"/《ES6 教程》笔记/":[["01.ECMAScript 6 简介.md","ECMAScript 6 简介","/pages/f344d070a1031ef7"],["02.let 和 const 命令.md","let 和 const 命令","/pages/c1edd70a6b7c7872"],["03.变量的解构赋值.md","变量的解构赋值","/pages/b1ab10a62f7564da"],["04.字符串的扩展.md","字符串的扩展","/pages/ca89eca8adeba5f4"],["05.字符串的新增方法.md","字符串的新增方法","/pages/a650b4a0ebfc9350"],["06.正则的扩展.md","正则的扩展","/pages/0473261a6ab0ee8c"],["07.数值的扩展.md","数值的扩展","/pages/5dfea9a0f2d1a392"],["08.函数的扩展.md","函数的扩展","/pages/8ed309d668b20264"],["09.数组的扩展.md","数组的扩展","/pages/e34009d60d8bc4b2"],["10.对象的扩展.md","对象的扩展","/pages/b5e3e0a0ff6e9c25"],["11.对象的新增方法.md","对象的新增方法","/pages/e85e68947502cf90"],["12.Symbol.md","Symbol","/pages/02c86eb2792f3262"],["13.Set 和 Map 数据结构.md","Set 和 Map 数据结构","/pages/0c21dae358fca16b"],["14.Proxy.md","Proxy","/pages/f56ec2ab97d60483"],["15.Reflect.md","Reflect","/pages/74de3e45e4491e95"],["16.Promise 对象.md","Promise 对象","/pages/2810ae8985e9bd52"],["17.Iterator 和 for-of 循环.md","Iterator 和 for-of 循环","/pages/48df907ad3570f3d"],["18.Generator 函数的语法.md","Generator 函数的语法","/pages/718b48ed9ce0adce"],["19.Generator 函数的异步应用.md","Generator 函数的异步应用","/pages/75af7031eb66847b"],["20.async 函数.md","async 函数","/pages/3777253e65bac487"],["21.Class 的基本语法.md","Class 的基本语法","/pages/e831e1593c82bbe0"],["22.Class 的继承.md","Class 的继承","/pages/83f8c3a0cd87dd83"],["23.Module 的语法.md","Module 的语法","/pages/efe2fb04eb8ac5fb"],["24.Module 的加载实现.md","Module 的加载实现","/pages/a79ca2e64ceae213"],["25.编程风格.md","编程风格","/pages/984bf549204bb266"],["26.读懂 ECMAScript 规格.md","读懂 ECMAScript 规格","/pages/32c35f7651d6e58e"],["27.异步遍历器.md","异步遍历器","/pages/16121351be68691b"],["28.ArrayBuffer.md","ArrayBuffer","/pages/a2ba314746bfdbdd"],["29.最新提案.md","最新提案","/pages/7188882b8d65af1b"],["30.装饰器.md","装饰器","/pages/e97bc1e5626b082c"],["31.函数式编程.md","函数式编程","/pages/1cf50330655efc69"],["32.Mixin.md","Mixin","/pages/6a8e2dc558da1b39"],["33.SIMD.md","SIMD","/pages/8e8f80f69b775a56"],["34.参考链接.md","参考链接","/pages/ea6f3b870f6dab69"]],"/《Git》学习笔记/":[{title:"手册",collapsable:!0,children:[["10.手册/00.常用Git命令清单.md","常用Git命令清单","/pages/8292d8/"],["10.手册/03.Git变基合并.md","Git变基合并","/pages/c10281/"],["10.手册/06.Git命令思维导图.md","Git命令思维导图","/pages/4cbc21/"],["10.手册/07.湖南科大计算机网络.md","湖南科大计算机网络","/pages/4bdb82/"]]},{title:"文档笔记",collapsable:!0,children:[["20.文档笔记/10.Git基础与命令.md","Git基础与命令","/pages/635088/"],["20.文档笔记/20.Git分支-分支原理.md","Git分支-分支原理","/pages/4bef1a/"],["20.文档笔记/30.Git分支的新建与合并-分支操作.md","Git分支的新建与合并-分支操作","/pages/ea5a8c/"],["20.文档笔记/40.Git分支管理-查看分支.md","Git分支管理-查看分支","/pages/a399b3/"],["20.文档笔记/50.Git分支开发工作流.md","Git分支开发工作流","/pages/49ee30/"],["20.文档笔记/60.Git分支-远程分支.md","Git分支-远程分支","/pages/574d62/"],["20.文档笔记/70.Git分支-变基.md","Git分支-变基","/pages/3a3247/"],["20.文档笔记/80.Git工具-查看修订版本.md","Git工具-查看修订版本","/pages/c984d1/"],["20.文档笔记/90.Git工具-交互式暂存.md","Git工具-交互式暂存","/pages/76d859/"],["20.文档笔记/100.Git工具-重写历史.md","Git工具-重写历史","/pages/1832fe/"],["20.文档笔记/110.Git工具-重置揭密.md","Git工具-重置揭密","/pages/d9e9c6/"]]}]},author:{name:"xugaoyi",link:"https://github.com/xugaoyi"},blogger:{avatar:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg",name:"Evan Xu",slogan:"前端界的小学生"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:894072666@qq.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/xugaoyi"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2019,copyrightInfo:'Evan Xu | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a>'},htmlModules:{homeSidebarB:'<div style="padding: 0.95rem">\n    <p style="\n      color: var(--textColor);\n      opacity: 0.9;\n      font-size: 20px;\n      font-weight: bold;\n      margin: 0 0 8px 0;\n    ">公众号</p>\n    <img src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/blog/扫码_搜索联合传播样式-标准色版.1wp8gd1mhjhc.jpg"  style="width:100%;" />\n    <p>\n    有趣研究社，这里有<a href="https://game.xugaoyi.com" arget="_blank" > FC在线模拟器(小霸王) <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，还有更多好玩的等着你去探索~\n    </br></br>\n    关注公众号，回复[<b>前端资源</b>]，可获取 <a href="https://game.xugaoyi.com" arget="_blank" >前端学习资源<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>\n    </p>\n    </div>'}},locales:{"/":{lang:"zh-CN",title:"Evan's blog",description:"web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。",path:"/"}}},ll=(t(155),t(212),t(143),t(222)),cl=t(223),ul=(t(374),t(236),t(43));var dl={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var e=n.frontmatter,t=e.pageComponent,r=e.article,o=e.home;return!(t||!1===r||!0===o)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,e){var t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(ul.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(ul.a)(n,e)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,e){return Object(ul.a)(n,e)})),n;var n},$groupPosts:function(){return function(n){for(var e={},t={},r=function(r,o){var a=n[r].frontmatter,i=a.categories,s=a.tags;"array"===Object(ul.n)(i)&&i.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[r]))})),"array"===Object(ul.n)(s)&&s.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[r]))}))},o=0,a=n.length;o<a;o++)r(o);return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var e=[],t=[];for(var r in n.categories)e.push({key:r,length:n.categories[r].length});for(var o in n.tags)t.push({key:o,length:n.tags[o].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Mo.component(ll.default),Mo.component(cl.default);function pl(n){return n.toString().padStart(2,"0")}t(378);Mo.component("Badge",(function(){return Promise.all([t.e(0),t.e(3)]).then(t.bind(null,626))})),Mo.component("CodeBlock",(function(){return Promise.resolve().then(t.bind(null,222))})),Mo.component("CodeGroup",(function(){return Promise.resolve().then(t.bind(null,223))}));t(379);var ml,fl,hl=t(50),gl=(t(382),t(137),t(221)),bl=t.n(gl),yl=t(102);"valine"===(fl="gitalk")?t.e(148).then(t.t.bind(null,480,7)).then((function(n){return n.default})):"gitalk"===fl&&Promise.all([t.e(0),t.e(147)]).then(t.t.bind(null,481,7)).then((function(){return t.e(146).then(t.t.bind(null,482,7))})).then((function(n){return ml=n.default}));function vl(n,e){var t={};return Reflect.ownKeys(n).forEach((function(r){if("string"==typeof n[r])try{t[r]=bl.a.render(n[r],e)}catch(e){console.warn('Comment config option error at key named "'.concat(r,'"')),console.warn("More info: ".concat(e.message)),t[r]=n[r]}else t[r]=n[r]})),t}console.log('How to use "'.concat("gitalk",'" in ').concat(yl.name,"@v").concat(yl.version,":"),yl.homepage);var xl={render:function(n,e){var t=document.createElement("div");t.id=e,document.querySelector("main.page").appendChild(t),new ml(vl({clientID:"a6e1355287947096b88b",clientSecret:"f0e77d070fabfcd5af95bebb82b2d574d7248d71",repo:"blog-gitalk-comment",owner:"xugaoyi",admin:["xugaoyi"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear:function(n){var e=document.querySelector("#".concat(n));return e&&e.remove(),!0}},wl=null;function kl(n){return xl.clear("vuepress-plugin-comment")}function Sl(n){return!1!==n.comment&&!1!==n.comments}function jl(n){if(clearTimeout(wl),document.querySelector("main.page"))return xl.render(n,"vuepress-plugin-comment");wl=setTimeout((function(){return jl(n)}),200)}var El={mounted:function(){var n=this;wl=setTimeout((function(){var e=Object(hl.a)({to:{},from:{}},n.$frontmatter);kl()&&Sl(e)&&jl(e)}),1e3),this.$router.afterEach((function(e,t){if(!e||!t||e.path!==t.path){var r=Object(hl.a)({to:e,from:t},n.$frontmatter);kl()&&Sl(r)&&jl(r)}}))}},Al=Object(ol.a)(El,(function(){var n=this.$createElement;return(this._self._c||n)("div")}),[],!1,null,null,null).exports,Il=[function(n){n.Vue,n.options,n.router,n.siteData},function(n){var e=n.Vue,t=(n.options,n.router,n.siteData);t.pages.map((function(n){var e=n.frontmatter,r=e.date,o=e.author;"string"==typeof r&&"Z"===r.charAt(r.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(pl(n.getUTCMonth()+1),"-").concat(pl(n.getUTCDate())," ").concat(pl(n.getUTCHours()),":").concat(pl(n.getUTCMinutes()),":").concat(pl(n.getUTCSeconds()))}(r)),o?n.author=o:t.themeConfig.author&&(n.author=t.themeConfig.author)})),e.mixin(dl)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(n){n.router;"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},function(n){var e=n.router;"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),e.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},function(n){n.Vue.component("Comment",Al)}],Tl=["Comment"];t(215);function zl(n,e){return(zl=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(216);function _l(n){return(_l=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function Cl(n,e){if(e&&("object"===Ai(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function Pl(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=_l(n);if(e){var o=_l(this).constructor;t=Reflect.construct(r,arguments,o)}else t=r.apply(this,arguments);return Cl(this,t)}}var Ol=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&zl(n,e)}(t,n);var e=Pl(t);function t(){return cs(this,t),e.apply(this,arguments)}return ds(t)}(function(){function n(){cs(this,n),this.store=new Mo({data:{state:{}}})}return ds(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){Mo.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(Ol.prototype,{getPageAsyncComponent:$i,getLayoutAsyncComponent:Gi,getAsyncComponent:Ui,getVueComponent:Hi});var Ml={install:function(n){var e=new Ol;n.$vuepress=e,n.prototype.$vuepress=e}};function Dl(n){n.beforeEach((function(e,t,r){if(Rl(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var o=e.path.replace(/\/$/,"")+".html";Rl(n,o)?r(o):r()}else r();else{var a=e.path+"/",i=e.path+".html";Rl(n,i)?r(i):Rl(n,a)?r(a):r()}}))}function Rl(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var Bl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return Wi("pageKey",e),Mo.component(e)||Mo.component(e,$i(e)),Mo.component(e)?n(e):n("")}},Ll={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,r=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},r()[t.slotKey])}},Nl={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Fl=(t(387),t(388),Object(ol.a)(Nl,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function ql(){return(ql=Object(r.a)(regeneratorRuntime.mark((function n(e){var t,r,o,a;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:sl.routerBase||sl.base,Dl(r=new ji({base:t,mode:"history",fallback:!1,routes:il,scrollBehavior:function(n,e,t){return t||(n.hash?!Mo.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),o={},n.prev=4,n.next=7,Promise.all(Il.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Mo,options:o,router:r,siteData:sl,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return a=new Mo(Object.assign(o,{router:r,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Tl.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:a,router:r});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Mo.config.productionTip=!1,Mo.use(ji),Mo.use(Ml),Mo.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Mo;Ei(e),t.$vuepress.$set("siteData",e);var r=n(t.$vuepress.$get("siteData")),o=new r,a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(o)),i={};return Object.keys(a).reduce((function(n,e){return e.startsWith("$")&&(n[e]=a[e].get),n}),i),{computed:i}}((function(n){return function(){function e(){cs(this,e)}return ds(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,r=void 0===t?{}:t;for(var o in r)"/"===o?e=r[o]:0===this.$page.path.indexOf(o)&&(n=r[o]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),sl)),Mo.component("Content",Bl),Mo.component("ContentSlotsDistributor",Ll),Mo.component("OutboundLink",Fl),Mo.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,r=e.children;if(t._isMounted)return r;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Mo.component("Layout",Gi("Layout")),Mo.component("NotFound",Gi("NotFound")),Mo.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"d10d15c"},function(n){return ql.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);