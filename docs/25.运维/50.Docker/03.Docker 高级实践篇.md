---
title: Docker 高级实践篇
date: 2022-02-03 00:03:52
permalink: /pages/a24e91/
categories:
  - 后端
  - Docker
tags:
  - 
---
# Docker部署软件实战



## Docker安装Nginx

```shell
# 1. 搜索镜像 docker search, 建议去docker hub搜索，可以看到帮助文档
# 2. 下载镜像 docker pull
# 3. 运行测试
[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
centos              latest              0d120b6ccaa8        32 hours ago        215MB
nginx               latest              08393e824c32        7 days ago          132MB

# -d 后台运行
# -name 给容器命名
# -p 宿主机端口：容器内部端口
[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d --name nginx01 -p 3344:80 nginx	# 后台方式启动启动镜像
fe9dc33a83294b1b240b1ebb0db9cb16bda880737db2c8a5c0a512fc819850e0
[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
fe9dc33a8329        nginx               "/docker-entrypoint.…"   4 seconds ago       Up 4 seconds        0.0.0.0:3344->80/tcp   nginx01
[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# curl localhost:3344	# 本地访问测试
# 进入容器
[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker exec -it nginx01 /bin/bash
root@fe9dc33a8329:/# whereis nginx
nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx
root@fe9dc33a8329:/# cd /etc/nginx/
root@fe9dc33a8329:/etc/nginx# ls
conf.d		koi-utf  mime.types  nginx.conf   uwsgi_params
fastcgi_params	koi-win  modules     scgi_params  win-utf
```



**端口暴露原理图**

![img](https://img-blog.csdnimg.cn/20200812111035666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70)



## Docker安装Tomcat

```shell
# 官方的使用
# docker run -it --rm 一般用来测试，用完就删
docker run -it --rm tomcat:9.0

# 下载再启动
docker pull tomcat
# 启动运行
docker run -d -p 3344:8080 --name tomcat01 tomcat
# 进入容器
docker exec -it tomcat01 /bin/bash
```



## Docker部署es + kibana·

```shell
# es 暴露的端口很多
# es 十分的耗内存
# es 的数据一般需要放置到安全目录！ 挂载
# --net somenetwork	网络配置

# 启动elasticsearch， docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2

[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2
a920894a940b354d3c867079efada13d96cf9138712c76c8dea58fabd9c7e96f

# 启动了linux就卡主了，docker stats 查看cpu状态

# 测试一下es成功了
[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# curl localhost:9200
{
  "name" : "a920894a940b",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "bxE1TJMEThKgwmk7Aa3fHQ",
  "version" : {
    "number" : "7.6.2",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",
    "build_date" : "2020-03-26T06:34:37.794943Z",
    "build_snapshot" : false,
    "lucene_version" : "8.4.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}


# 增加内存限制，修改配置文件 -e 环境配置修改
docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2
```



## 可视化

- portainer

```shell
docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
# 测试
[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# curl localhost:8088
<!DOCTYPE html><html lang="en" ng-app="portainer">
# 外网访问 http://ip:8088
```



![img](https://img-blog.csdnimg.cn/20200812143512159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70)



- Rancher(CI/CD再用)



# 容器数据卷



## Docker的理解回顾



数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！`需求：数据可以持久化`



MySQL，容器删了，删库跑路！`需求：MySQL数据可以存储在本地！`



容器之间可以有一个数据共享技术！Docker容器中产生的数据，同步到本地！



这就是卷技术，目录的挂载，将我们容器内的目录挂载到Linux目录上面！



**总结：** 容器的持久化和同步操作！容器间数据也是可以共享的！



## 使用数据卷

直接使用命令来挂载 -v

```shell
# 匿名挂载和具名挂载的目录都默认在/var/lib/docker/volumn目录下
1. docker run -it -v 容器目录   # 匿名挂载
2. docker run -it -v 卷名:容器目录  # 匿名挂载
3. docker run -it -v 主机目录:容器目录 # 指定路径挂载

[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -it -v /home/ceshi:/home centos /bin/bash
```

![img](https://img-blog.csdnimg.cn/20200812165141715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



**测试文件的同步**（在主机上改动，观察容器变化）

![img](https://img-blog.csdnimg.cn/2020081216585980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



**注意：设置容器数据卷挂载后，容器目录和挂载的主机目录保持实时同步！**



## 实战：安装MySQL



思考：MySQL的数据持久化的问题！

```shell
# 获取镜像
[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker pull mysql:5.7

# 运行容器， 需要做数据挂载！ 
# 安装启动mysql，需要配置密码（注意）
# 官方测试， docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag

# 启动我们的
-d		# 后台运行
-p		# 端口映射
-v		# 卷挂载
-e		# 环境配置
--name	# 容器的名字
[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d -p 3344:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7
9552bf4eb2b69a2ccd344b5ba5965da4d97b19f2e1a78626ac1f2f8d276fc2ba

# 启动成功之后，我们在本地使用navicat链接测试一下
# navicat链接到服务器的3344 --- 3344 和 容器的3306映射，这个时候我们就可以连接上mysql喽！

# 在本地测试创建一个数据库，查看下我们的路径是否ok！
```

![img](https://img-blog.csdnimg.cn/20200812174632321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)

## 匿名和具名挂载（容器卷）



```shell
# 匿名挂载
-v 容器内路径
docker run -d -P --name nginx01 -v /etc/nginx nginx		# -P 随机指定端口

# 查看所有volume的情况
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker volume ls
DRIVER              VOLUME NAME
local               561b81a03506f31d45ada3f9fb7bd8d7c9b5e0f826c877221a17e45d4c80e096
local               36083fb6ca083005094cbd49572a0bffeec6daadfbc5ce772909bb00be760882

# 这里发现，这种情况就是匿名挂载，我们在-v 后面只写了容器内的路径，没有写容器外的路径！

# 具名挂载
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx
26da1ec7d4994c76e80134d24d82403a254a4e1d84ec65d5f286000105c3da17
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES
26da1ec7d499        nginx               "/docker-entrypoint.…"   3 seconds ago       Up 2 seconds        0.0.0.0:32769->80/tcp   nginx02
486de1da03cb        nginx               "/docker-entrypoint.…"   3 minutes ago       Up 3 minutes        0.0.0.0:32768->80/tcp   nginx01
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker volume ls
DRIVER              VOLUME NAME
local               561b81a03506f31d45ada3f9fb7bd8d7c9b5e0f826c877221a17e45d4c80e096
local               36083fb6ca083005094cbd49572a0bffeec6daadfbc5ce772909bb00be760882
local               juming-nginx

# 通过 -v 卷名:容器内的路径
# 查看一下这个卷
# docker volume inspect juming-nginx

[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker volume inspect juming-nginx
[
  {
      "CreatedAt": "2020-08-12T18:15:21+08:00",
      "Driver": "local",
      "Labels": null,
      "Mountpoint": "/var/lib/docker/volumes/juming-nginx/_data",
      "Name": "juming-nginx",
      "Options": null,
      "Scope": "local"
  }
]
```



**拓展**

```shell
# 通过 -v 容器内路径[:ro|:rw] 改变读写权限 
# ro readonly 只读	
# rw readwrite 可读可写
docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx
docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx
# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内容无法操作
```



# 初始Dockerfile

```shell
# 创建一个dockerfile文件， 名字可以随机
# 文件的内容 指定（大写）参数

FROM centos

# 匿名挂载
VOLUME ["volume01", "volume02"]

CMD echo "----end----"
CMD /bin/bash
```



![img](https://img-blog.csdnimg.cn/20200813102153118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



**启动自己的容器**

![img](https://img-blog.csdnimg.cn/20200813103117628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



**docker inspect 容器id**

![img](https://img-blog.csdnimg.cn/20200813103859654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名:容器内路径！



## 数据卷容器

多个mysql同步数据！

![img](https://img-blog.csdnimg.cn/20200813115602683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



```shell
# 启动3个容器，通过我们刚才自己写的镜像启动
```



![img](https://img-blog.csdnimg.cn/20200813120430844.png#pic_center)



![img](https://img-blog.csdnimg.cn/20200813121031935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



多个mysql实现数据共享

```shell
[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d -p 3344:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7
[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d -p 3344:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7
[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d -p 3344:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql03 --volumes-from mysql01 mysql:5.7
```



![img](https://cdn.nlark.com/yuque/0/2021/png/2651282/1636630506231-74ab3968-e944-48df-9139-17628cbbb32e.png)

```bash
docker inspect centos01
[{
	"Type": "volume",
	"Name": "7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca",
	"Source": "/var/lib/docker/volumes/7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca/_data",
	"Destination": "volume02",
	"Driver": "local",
	"Mode": "",
	"RW": true,
	"Propagation": ""
}, {
	"Type": "volume",
	"Name": "27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4",
	"Source": "/var/lib/docker/volumes/27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4/_data",
	"Destination": "volume01",
	"Driver": "local",
	"Mode": "",
	"RW": true,
	"Propagation": ""
}]

docker inspect centos02 
"Mounts": [{
	"Type": "volume",
	"Name": "27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4",
	"Source": "/var/lib/docker/volumes/27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4/_data",
	"Destination": "volume01",
	"Driver": "local",
	"Mode": "",
	"RW": true,
	"Propagation": ""
}, {
	"Type": "volume",
	"Name": "7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca",
	"Source": "/var/lib/docker/volumes/7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca/_data",
	"Destination": "volume02",
	"Driver": "local",
	"Mode": "",
	"RW": true,
	"Propagation": ""
}]

docker inspect centos03 
"Mounts": [{
	"Type": "volume",
	"Name": "7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca",
	"Source": "/var/lib/docker/volumes/7895bf2c2184d440f4be4c539313055ce35f70606728aad7bb73dd46cf4dcfca/_data",
	"Destination": "volume02",
	"Driver": "local",
	"Mode": "",
	"RW": true,
	"Propagation": ""
}, {
	"Type": "volume",
	"Name": "27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4",
	"Source": "/var/lib/docker/volumes/27e5f3ac52359984ddb695cb2bd1c375fb218e8ff6257044294e78bb63af36f4/_data",
	"Destination": "volume01",
	"Driver": "local",
	"Mode": "",
	"RW": true,
	"Propagation": ""
}]
```



**通过查看centos01、02、03的数据卷挂载情况，可以发现，数据卷容器的实现原理其实就是把其他继承数据卷容器的数据卷映射到相同的外部挂载点，这样这个外部挂载点有目录文件变更，就会同步到数据卷容器以及其他继承关系的容器中**



## DockerFile



## DockerFile的构建过程



**基础知识：**

1. 每个保留关键字（指令）都是必须大写字母
2. 执行从上到下顺序执行

3. `#` 表示注释
4. 每个指令都会创建提交一个新的镜像层，并提交！



![img](https://img-blog.csdnimg.cn/20200813142333870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



dockerFile是面向开发的， 我们以后要发布项目， 做镜像， 就需要编写dockefile文件， 这个文件十分简单！



## DockerFile指令说明



![img](https://cdn.nlark.com/yuque/0/2021/png/2651282/1636631425891-b81d4b54-03fd-4ee1-ace0-7d900351dc54.png)



## 创建一个自己的Centos



```shell
# 1. 编写Dockerfile的文件
[root@localhost dockfile]# cat mydockerfile-centos 
FROM centos
MAINTAINER xiaofan<594042358@qq.com>

ENV MYPATH /usr/local
WORKDIR $MYPATH		# 镜像的工作目录

RUN yum -y install vim \
	&& yum -y install net-tools

EXPOSE 80

CMD echo $MYPATH
CMD echo "---end---"
CMD /bin/bash

# 2. 通过这个文件构建镜像
# 命令 docker build -f <Dockerfile文件路径> -t 镜像名:[tag] <构建上下文路径>

[root@localhost dockfile]# docker build -f mydockerfile-centos -t mycentos:0.1 .

Successfully built d2d9f0ea8cb2
Successfully tagged mycentos:0.1
```



![img](https://img-blog.csdnimg.cn/20200813152240210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



我们可以列出本地进行的变更历史

![img](https://img-blog.csdnimg.cn/20200813152814641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



### CMD 和ENTRYPOINT区别

CMD			

- 指定这个容器启动的时候要运行的命令
- 当同时存在ENTRYPOINT时，会被当作ENTRYPOINT声明command的参数（可变参数）
- 会被docker run 后指定的command覆盖

ENTRYPOINT	

- 指定这个容器启动的时候要运行的命令
- 当同时存在CMD时，会把CMD声明command当作参数（可变参数）
- 会被docker run --entrypoint 后指定的command覆盖



#### 只包含CMD

```shell
[root@localhost dockfile]# cat dockfile
FROM centos
CMD ["ls", "-a"]

[root@localhost dockfile]# docker build -f dockerfile -t centos:v1 .

# 3. run运行， 发现我们的ls -a 命令生效
[root@localhost dockfile]# docker run ebe6a52bb125
.
..
.dockerenv
bin
dev
etc
home
lib
lib64

# 想追加一个命令 -l 变成 ls -al
[root@localhost dockfile]# docker run ebe6a52bb125 -l
docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused "exec: \"-l\": executable file not found in $PATH": unknown.
[root@localhost dockfile]# docker run ebe6a52bb125 ls -l

# cmd的情况下 -l替换了CMD["ls", "-a"]命令， -l不是命令，所以报错了
```



#### 只包含ENTRYPOINT

```bash
[root@localhost dockfile]# cat dockerfile 
FROM centos
ENTRYPOINT ["ls", "-a"]


[root@localhost dockfile]# docker build -f dockerfile -t centos:v1 .

# 3. run运行 发现我们的ls -a 命令同样生效
[root@localhost dockfile]# docker run centos:v1
.
..
.dockerenv
bin
dev
etc
home
lib

# 4. 我们的追加命令， 是直接拼接到ENTRYPOINT命令的后面的！
[root@localhost dockfile]# docker run centos:v1 -l
total 56
drwxr-xr-x  1 root root 4096 Aug 13 07:52 .
drwxr-xr-x  1 root root 4096 Aug 13 07:52 ..
-rwxr-xr-x  1 root root    0 Aug 13 07:52 .dockerenv
lrwxrwxrwx  1 root root    7 May 11  2019 bin -> usr/bin
drwxr-xr-x  5 root root  340 Aug 13 07:52 dev
drwxr-xr-x  1 root root 4096 Aug 13 07:52 etc
drwxr-xr-x  2 root root 4096 May 11  2019 home
lrwxrwxrwx  1 root root    7 May 11  2019 lib -> usr/lib
lrwxrwxrwx  1 root root    9 May 11  2019 lib64 -> usr/lib64
drwx------  2 root root 4096 Aug  9 21:40 lost+found
```



#### 同时包含CMD和ENTRYPOINT

```bash
[root@localhost dockfile]# cat dockerfile 
FROM centos:latest
MAINTAINER ZHAOXING<779292642@qq.com>

ENV MYPATH /usr/local
WORKDIR $MYPATH

CMD ["-a"]
ENTRYPOINT ["ls"]

[root@localhost dockfile]# docker build -f dockerfile -t centos:v1 .

# 执行命令：ls -a
# CMD声明的command会当作ENTRYPOINT声明的command的参数
[root@localhost dockfile]# docker run centos:v1
.
..
bin
etc
games
include
lib
lib64
libexec
sbin
share
src

# 覆盖CMD声明的command
[root@localhost dockfile]# docker run centos:v1 -l
total 0
drwxr-xr-x. 2 root root  6 Nov  3  2020 bin
drwxr-xr-x. 2 root root  6 Nov  3  2020 etc
drwxr-xr-x. 2 root root  6 Nov  3  2020 games
drwxr-xr-x. 2 root root  6 Nov  3  2020 include
drwxr-xr-x. 2 root root  6 Nov  3  2020 lib
drwxr-xr-x. 3 root root 16 Sep 15 14:17 lib64
drwxr-xr-x. 2 root root  6 Nov  3  2020 libexec
drwxr-xr-x. 2 root root  6 Nov  3  2020 sbin
drwxr-xr-x. 5 root root 46 Sep 15 14:17 share
drwxr-xr-x. 2 root root  6 Nov  3  2020 src
[root@localhost dockfile]# docker run centos:v1 -al
total 8
drwxr-xr-x. 12 root root 4096 Sep 15 14:17 .
drwxr-xr-x. 12 root root 4096 Sep 15 14:17 ..
drwxr-xr-x.  2 root root    6 Nov  3  2020 bin
drwxr-xr-x.  2 root root    6 Nov  3  2020 etc
drwxr-xr-x.  2 root root    6 Nov  3  2020 games
drwxr-xr-x.  2 root root    6 Nov  3  2020 include
drwxr-xr-x.  2 root root    6 Nov  3  2020 lib
drwxr-xr-x.  3 root root   16 Sep 15 14:17 lib64
drwxr-xr-x.  2 root root    6 Nov  3  2020 libexec
drwxr-xr-x.  2 root root    6 Nov  3  2020 sbin
drwxr-xr-x.  5 root root   46 Sep 15 14:17 share
drwxr-xr-x.  2 root root    6 Nov  3  2020 src


# 覆盖ENTRYPOINT声明的command（此时CMD声明的command失效）
[root@localhost dockfile]# docker run --entrypoint ls 3a
bin
etc
games
include
lib
lib64
libexec
sbin
share
src

# 同时覆盖ENTRYPOINT和CMD声明的command
[root@localhost dockfile]# docker run --entrypoint ls 3a -a
.
..
bin
etc
games
include
lib
lib64
libexec
sbin
share
src
[root@localhost dockfile]# docker run --entrypoint ls 3a -al
total 8
drwxr-xr-x. 12 root root 4096 Sep 15 14:17 .
drwxr-xr-x. 12 root root 4096 Sep 15 14:17 ..
drwxr-xr-x.  2 root root    6 Nov  3  2020 bin
drwxr-xr-x.  2 root root    6 Nov  3  2020 etc
drwxr-xr-x.  2 root root    6 Nov  3  2020 games
drwxr-xr-x.  2 root root    6 Nov  3  2020 include
drwxr-xr-x.  2 root root    6 Nov  3  2020 lib
drwxr-xr-x.  3 root root   16 Sep 15 14:17 lib64
drwxr-xr-x.  2 root root    6 Nov  3  2020 libexec
drwxr-xr-x.  2 root root    6 Nov  3  2020 sbin
drwxr-xr-x.  5 root root   46 Sep 15 14:17 share
drwxr-xr-x.  2 root root    6 Nov  3  2020 src
```











# Dockerfile制作Tomcat镜像



## 制作Tomcat镜像

1. 准备镜像文件 tomcat压缩包，jdk的压缩包！

![img](https://img-blog.csdnimg.cn/20200813164403261.png)



2. 编写Dockerfile文件, build默认在构建上下文寻找名称为Dockfile的文件，就不需要-f 指定了！

```shell
[root@iZ2zeg4ytp0whqtmxbsqiiZ tomcat]# cat Dockerfile 
FROM centos
MAINTAINER xiaofan<594042358@qq.com>
COPY readme.txt /usr/local/readme.txt
# ADD 会自动解压
ADD jdk-8u73-linux-x64.tar.gz /usr/local/
ADD apache-tomcat-9.0.37.tar.gz /usr/local/
RUN yum -y install vim
ENV MYPATH /usr/local
WORKDIR $MYPATH
ENV JAVA_HOME /usr/local/jdk1.8.0_73
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.37
ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.37
ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin
EXPOSE 8080
CMD /usr/local/apache-tomcat-9.0.37/bin/startup.sh && tail -F /usr/local/apache-tomcat-9.0.37/bin/logs/catalina.out
```



3. 构建镜像

```shell
# docker build -t diytomcat .
```



4. 启动镜像

```shell
docker run -d -p 3344:8080 \
--name xiaofantomcat1 \
-v /home/xiaofan/build/tomcat/test:/usr/local/apache-tomcat-9.0.37/webapps/test \
-v /home/xiaofan/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.37/logs 
diytomcat
```



5. 访问测试



​	在本地编写web.xml和index.jsp进行测试

![img](https://img-blog.csdnimg.cn/20200813180242294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



```shell
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.4" 
    xmlns="http://java.sun.com/xml/ns/j2ee" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee 
        http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">
        
</web-app>
```



```shell
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>hello. xiaofan</title>
</head>
<body>
Hello World!<br/>
<%
System.out.println("-----my test web logs------");
%>
</body>
</html>
```



发现：项目部署成功， 可以直接访问ok！

![img](https://img-blog.csdnimg.cn/20200813175909845.png#pic_center)



## 发布自己的镜像到Docker Hub



1.  [Dockker Hub](https://hub.docker.com/) 注册自己的账号！
    ![img](https://img-blog.csdnimg.cn/20200813182851607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center) 
2.  确定这个账号可以登录 

![img](https://img-blog.csdnimg.cn/20200813183151439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



3. 在我们的服务器上提交自己的镜像

```shell
# push到我们的服务器上
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker push diytomcat
The push refers to repository [docker.io/library/diytomcat]
2eaca873a720: Preparing 
1b38cc4085a8: Preparing 
088ebb58d264: Preparing 
c06785a2723d: Preparing 
291f6e44771a: Preparing 
denied: requested access to the resource is denied	# 拒绝

# push镜像的问题？
The push refers to repository [docker.io/1314520007/diytomcat]
An image does not exist locally with the tag: 1314520007/diytomcat

# 解决，增加一个tag
docker tag diytomcat 1314520007/tomcat:1.0
```



![img](https://img-blog.csdnimg.cn/20200813184137474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



## 发布到阿里云镜像服务上

1. 登录阿里云
2. 找到容器镜像服务

3. 创建命名空间



![img](https://img-blog.csdnimg.cn/20200813190111625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



4. 创建镜像仓库



![img](https://img-blog.csdnimg.cn/20200813190303741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



5. 点击仓库名称，参考官方文档即可



![img](https://img-blog.csdnimg.cn/20200813191526549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



## 总结

![img](https://img-blog.csdnimg.cn/20200813194116511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)





# Docker网络



## 连接 Docker0

**测试**

![img](https://img-blog.csdnimg.cn/20200814091723905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



**三个网络**

```shell
# 问题： docker是如何处理容器网络访问的？

# [root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P --name tomcat01 tomcat

# 查看容器内部的网络地址 ip addr
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat01 ip addr， 发现容器启动的时候得到一个eth0@if115 ip地址，docker分配的！
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
114: eth0@if115: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever

# 思考： linux 能不能ping通容器？
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.077 ms
64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.069 ms
64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.075 ms

# linux 可以 ping 通docker容器内部！
```



**原理**

> 我们每启动一个docker容器， docker就会给docker容器分配一个ip， 我们只要安装了docker，就会有一个网卡 docker0桥接模式，使用的技术是veth-pair技术！



再次测试 ip addr

![img](https://img-blog.csdnimg.cn/20200814092954929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



再启动一个容器测试， 发现又多了一对网卡

![img](https://img-blog.csdnimg.cn/20200814093432884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



```shell
# 我们发现这个容器带来网卡，都是一对对的
# veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连
# 正因为有这个特性，veth-pair充当一个桥梁， 连接各种虚拟网络设备
# OpenStac， Docker容器之间的链接，OVS的链接， 都是使用veth-pair技术
```



我们测试一下tomcat01和tomcat02之间是否可以ping通！
![img](https://img-blog.csdnimg.cn/2020081409492726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center) 



结论：容器与容器之间是可以相互ping通的！



绘制一个网络模型图

![img](https://img-blog.csdnimg.cn/20200814101617604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



结论：tomcat01和tomcat02是共用的一个路由器，docker0

所有容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用IP



小结

Docker使用的是Linux的桥接，宿主机中是一个Docker容器的网桥docker0.



![img](https://img-blog.csdnimg.cn/20200814102155735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



Docker中的所有的网络接口都是虚拟的，虚拟的转发效率高！（内网传递文件！）



只要容器删除，对应的网桥一对就没有了！

![img](https://img-blog.csdnimg.cn/20200814103808900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



## -- link



**解决通过docker0联通时通过容器名访问**



思考一个场景，我们编写了一个微服务，database url =ip； 项目不重启，数据ip换掉了，我们希望可以处理这个问题，可以按名字来进行访问容器



```shell
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat02 ping tomcat01
ping: tomcat01: Name or service not known

# 如何可以解决呢？
# 通过--link即可以解决网络连通问题
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P  --name tomcat03 --link tomcat02 tomcat
3a2bcaba804c5980d94d168457c436fbd139820be2ee77246888f1744e6bb473
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES
3a2bcaba804c        tomcat              "catalina.sh run"   4 seconds ago       Up 3 seconds        0.0.0.0:32772->8080/tcp   tomcat03
f22ed47ed1be        tomcat              "catalina.sh run"   57 minutes ago      Up 57 minutes       0.0.0.0:32771->8080/tcp   tomcat02
9d97f93401a0        tomcat              "catalina.sh run"   About an hour ago   Up About an hour    0.0.0.0:32770->8080/tcp   tomcat01
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat03 ping tomcat02
PING tomcat02 (172.17.0.3) 56(84) bytes of data.
64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.129 ms
64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.100 ms
64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.110 ms
64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.107 ms

# 反向可以ping通吗？
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat02 ping tomcat03
ping: tomcat03: Name or service not known
```



探究：inspect！



![img](https://img-blog.csdnimg.cn/20200814104403761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



其实这个tomcat03就是在本地配置了tomcat02的配置？



```shell
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat03 cat /etc/hosts
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
172.17.0.3	tomcat02 f22ed47ed1be
172.17.0.4	3a2bcaba804c
```



本质探究：--link 就是我们在hosts配置中增加了一个172.17.0.3	tomcat02 f22ed47ed1be



我们现在玩Docker已经不建议使用--link了！



自定义网络！不使用Docker0！



Docker0的问题：它不支持容器名链接访问！



## 自定义网络



查看所有的docker网络



![img](https://img-blog.csdnimg.cn/20200814105640929.png#pic_center)



**网络模式**

- bridge： 桥接模式，桥接 docker 默认，自己创建的也是用brdge模式

- none： 不配置网络

- host： 和宿主机共享网络

- container：容器网络连通！（用的少， 局限很大）




**测试**

```shell
# 我们直接启动的命令默认有一个 --net bridge，而这个就是我们的docker0
docker run -d -P --name tomcat01 tomcat
docker run -d -P --name tomcat01 --net bridge tomcat

# docker0特点，默认，容器名不能访问， --link可以打通连接！
# 我们可以自定义一个网络！
# --driver bridge
# --subnet 192.168.0.0/16 可以支持255*255个网络 192.168.0.2 ~ 192.168.255.254
# --gateway 192.168.0.1
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
26a5afdf4805d7ee0a660b82244929a4226470d99a179355558dca35a2b983ec
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
30d601788862        bridge              bridge              local
226019b14d91        host                host                local
26a5afdf4805        mynet               bridge              local
7496c014f74b        none                null                local
```



我们自己创建的网络就ok了！



![img](https://img-blog.csdnimg.cn/20200814112009570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



在自己创建的网络里面启动两个容器



```shell
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P --name tomcat-net-01 --net mynet tomcat
0e85ebe6279fd23379d39b27b5f47c1e18f23ba7838637802973bf6449e22f5c
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -d -P --name tomcat-net-02 --net mynet tomcat
c6e462809ccdcebb51a4078b1ac8fdec33f1112e9e416406b606d0c9fb6f21b5
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network inspect mynet
[
    {
        "Name": "mynet",
        "Id": "26a5afdf4805d7ee0a660b82244929a4226470d99a179355558dca35a2b983ec",
        "Created": "2020-08-14T11:12:40.553433163+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "192.168.0.0/16",
                    "Gateway": "192.168.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "0e85ebe6279fd23379d39b27b5f47c1e18f23ba7838637802973bf6449e22f5c": {
                "Name": "tomcat-net-01",
                "EndpointID": "576ce5c0f5860a5aab5e487a805da9d72f41a409c460f983c0bd341dd75d83ac",
                "MacAddress": "02:42:c0:a8:00:02",
                "IPv4Address": "192.168.0.2/16",
                "IPv6Address": ""
            },
            "c6e462809ccdcebb51a4078b1ac8fdec33f1112e9e416406b606d0c9fb6f21b5": {
                "Name": "tomcat-net-02",
                "EndpointID": "81ecbc4fe26e49855fe374f2d7c00d517b11107cc91a174d383ff6be37d25a30",
                "MacAddress": "02:42:c0:a8:00:03",
                "IPv4Address": "192.168.0.3/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]

# 再次ping连接
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat-net-01 ping 192.168.0.3
PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.
64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.113 ms
64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.093 ms
^C
--- 192.168.0.3 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
rtt min/avg/max/mdev = 0.093/0.103/0.113/0.010 ms
# 现在不使用 --link也可以ping名字了！
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat-net-01 ping tomcat-net-02
PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.068 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.096 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.094 ms
```



我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络



好处：

> redis - 不同的集群使用不同的网络，保证集群是安全和健康的
>
> mysql - 不同的集群使用不同的网络，保证集群是安全和健康的
>



## 网络连通（不同网络之间）



![img](https://img-blog.csdnimg.cn/20200814114621170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



测试打通tomcat01 和mynet



![img](https://img-blog.csdnimg.cn/2020081411482318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



```shell
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network connect  mynet tomcat01

# 连通之后就是讲tomcat01放到了mynet网络下
# 一个容器两个ip地址：
# 阿里云服务器，公网ip，私网ip
```



![img](https://img-blog.csdnimg.cn/20200814115317846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



![img](https://img-blog.csdnimg.cn/20200814115404720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



```shell
# 连通ok
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat01 ping tomcat-net-01
PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.
64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.100 ms
64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.085 ms
^C
--- tomcat-net-01 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1000ms
rtt min/avg/max/mdev = 0.085/0.092/0.100/0.012 ms
# 依旧无法连通，没有connect
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it tomcat02 ping tomcat-net-01
ping: tomcat-net-01: Name or service not known
```



结论：假设要跨网络操作别人，就要使用docker network connect连通.....!



## 实战：部署redis



![img](https://img-blog.csdnimg.cn/20200814124440671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



### 实战一（bridge网络 + docker）

> 这种方案 spring boot 项目连接redis集群时有问题：redis节点之间通信有问题，还是使用的自定义网段分配的地址

```shell
# 创建网卡
docker network create redis --subnet 172.38.0.0/16

# 通过脚本创建六个redis配置
for port in $(seq 1 6); \
do \
mkdir -p /home/software/redis/node-${port}/conf
touch /home/software/redis/node-${port}/conf/redis.conf
cat << EOF >/home/software/redis/node-${port}/conf/redis.conf
port 6379
bind 0.0.0.0
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
cluster-announce-ip 172.38.0.1${port}
cluster-announce-port 6379
cluster-announce-bus-port 16379
appendonly yes
EOF
done
# 创建结点1
docker run -p 6371:6379 -p 16371:16379 --name redis-1 \
-v /home/software/redis/node-1/data:/data \
-v /home/software/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf

#创建结点2
docker run -p 6372:6379 -p 16372:16379 --name redis-2 \
-v /home/software/redis/node-2/data:/data \
-v /home/software/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
#创建结点3
docker run -p 6373:6379 -p 16373:16379 --name redis-3 \
-v /home/software/redis/node-3/data:/data \
-v /home/software/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
#创建结点4
docker run -p 6374:6379 -p 16374:16379 --name redis-4 \
-v /home/software/redis/node-4/data:/data \
-v /home/software/redis/node-4/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
#创建结点5
docker run -p 6375:6379 -p 16375:16379 --name redis-5 \
-v /home/software/redis/node-5/data:/data \
-v /home/software/redis/node-5/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
#创建结点6
docker run -p 6376:6379 -p 16376:16379 --name redis-6 \
-v /home/software/redis/node-6/data:/data \
-v /home/software/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf

# 创建集群
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker exec -it redis-1 /bin/sh
/data # ls
appendonly.aof  nodes.conf
/data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1
>>> Performing hash slots allocation on 6 nodes...
Master[0] -> Slots 0 - 5460
Master[1] -> Slots 5461 - 10922
Master[2] -> Slots 10923 - 16383
Adding replica 172.38.0.15:6379 to 172.38.0.11:6379
Adding replica 172.38.0.16:6379 to 172.38.0.12:6379
Adding replica 172.38.0.14:6379 to 172.38.0.13:6379
M: 541b7d237b641ac2ffc94d17c6ab96b18b26a638 172.38.0.11:6379
   slots:[0-5460] (5461 slots) master
M: a89c1f1245b264e4a402a3cf99766bcb6138dbca 172.38.0.12:6379
   slots:[5461-10922] (5462 slots) master
M: 259e804d6df74e67a72e4206d7db691a300c775e 172.38.0.13:6379
   slots:[10923-16383] (5461 slots) master
S: 9b19170eea3ea1b92c58ad18c0b5522633a9e271 172.38.0.14:6379
   replicates 259e804d6df74e67a72e4206d7db691a300c775e
S: 061a9d38f22910aaf0ba1dbd21bf1d8f57bcb7d5 172.38.0.15:6379
   replicates 541b7d237b641ac2ffc94d17c6ab96b18b26a638
S: 7a16b9bbb0615ec95fc978fa62fc054df60536f0 172.38.0.16:6379
   replicates a89c1f1245b264e4a402a3cf99766bcb6138dbca
Can I set the above configuration? (type 'yes' to accept): yes
>>> Nodes configuration updated
>>> Assign a different config epoch to each node
>>> Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join
...
>>> Performing Cluster Check (using node 172.38.0.11:6379)
M: 541b7d237b641ac2ffc94d17c6ab96b18b26a638 172.38.0.11:6379
   slots:[0-5460] (5461 slots) master
   1 additional replica(s)
M: a89c1f1245b264e4a402a3cf99766bcb6138dbca 172.38.0.12:6379
   slots:[5461-10922] (5462 slots) master
   1 additional replica(s)
S: 7a16b9bbb0615ec95fc978fa62fc054df60536f0 172.38.0.16:6379
   slots: (0 slots) slave
   replicates a89c1f1245b264e4a402a3cf99766bcb6138dbca
S: 061a9d38f22910aaf0ba1dbd21bf1d8f57bcb7d5 172.38.0.15:6379
   slots: (0 slots) slave
   replicates 541b7d237b641ac2ffc94d17c6ab96b18b26a638
M: 259e804d6df74e67a72e4206d7db691a300c775e 172.38.0.13:6379
   slots:[10923-16383] (5461 slots) master
   1 additional replica(s)
S: 9b19170eea3ea1b92c58ad18c0b5522633a9e271 172.38.0.14:6379
   slots: (0 slots) slave
   replicates 259e804d6df74e67a72e4206d7db691a300c775e
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
```

### 实战二（host网络 + docker-compose）



docker搭建redis集群完成！



![img](https://img-blog.csdnimg.cn/20200814140307648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



## SpringBoot微服务打包Docker镜像

- 打包应用
- 编写Dockerfile

```shell
FROM java:8

COPY *.jar /app.jar

CMD ["--server.port=8080"]

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "/app.jar"]
```

- 构建镜像 

```shell
# 上传jar包和Dockerfile到Linux
[root@iZ2zeg4ytp0whqtmxbsqiiZ idea]# ll
total 16140
-rw-r--r-- 1 root root 16519871 Aug 14 17:38 demo-0.0.1-SNAPSHOT.jar
-rw-r--r-- 1 root root      122 Aug 14 17:38 Dockerfile

# 构建镜像
[root@iZ2zeg4ytp0whqtmxbsqiiZ idea]# docker build -t myapp:V1 .
Sending build context to Docker daemon  16.52MB
Step 1/5 : FROM java:8
8: Pulling from library/java
5040bd298390: Pull complete 
fce5728aad85: Pull complete 
76610ec20bf5: Pull complete 
60170fec2151: Pull complete 
e98f73de8f0d: Pull complete 
11f7af24ed9c: Pull complete 
49e2d6393f32: Pull complete 
bb9cdec9c7f3: Pull complete 
Digest: sha256:c1ff613e8ba25833d2e1940da0940c3824f03f802c449f3d1815a66b7f8c0e9d
Status: Downloaded newer image for java:8
 ---> d23bdf5b1b1b
Step 2/5 : COPY *.jar /app.jar
 ---> d4de8837ebf9
Step 3/5 : CMD ["--server.port=8080"]
 ---> Running in e3abc66303f0
Removing intermediate container e3abc66303f0
 ---> 131bb3917fea
Step 4/5 : EXPOSE 8080
 ---> Running in fa2f25977db7
Removing intermediate container fa2f25977db7
 ---> d98147377951
Step 5/5 : ENTRYPOINT ["java", "-jar", "/app.jar"]
 ---> Running in e1885e23773b
Removing intermediate container e1885e23773b
 ---> afb6b5f28a32
Successfully built afb6b5f28a32
Successfully tagged xiaofan666:latest

# 查看镜像
[root@iZ2zeg4ytp0whqtmxbsqiiZ idea]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
myapp               v1                  afb6b5f28a32        14 seconds ago      660MB
tomcat              latest              2ae23eb477aa        8 days ago          647MB
redis               5.0.9-alpine3.11    3661c84ee9d0        3 months ago        29.8MB
java                8                   d23bdf5b1b1b        3 years ago         643MB

# 运行容器
[root@iZ2zeg4ytp0whqtmxbsqiiZ idea]# docker run -d -P --name my-springboot-web myapp:v1
fd9a353a80bfd61f6930c16cd92204532bfd734e003f3f9983b5128a27b0375e
# 查看运行起来的容器端口（因为我们启动的时候没有指定）
[root@iZ2zeg4ytp0whqtmxbsqiiZ idea]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                     NAMES
fd9a353a80bf        xiaofan666          "java -jar /app.jar …"   9 seconds ago       Up 8 seconds        0.0.0.0:32779->8080/tcp   xiaofan-springboot-web
# 本地访问1
[root@iZ2zeg4ytp0whqtmxbsqiiZ idea]# curl localhost:32779/hello
hello, world
```



# Docker Compose



## 安装



**下载docker-compose命令**

```bash
# 官网提供 （没有下载成功）
curl -L "https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
# 国内地址
curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
```



**分配可执行权限**

```shell
chmod +x /usr/local/bin/docker-compose
```



![img](https://img-blog.csdnimg.cn/20200814210859399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)





## yaml规则

https://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples



## 实战：自己编写微服务上线

- 编写项目微服务 
- Dockerfile构建镜像  

```shell
FROM java:8

COPY *.jar /app.jar

CMD ["--server.port=8080"]

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "/app.jar"]
```

- docker-compose.yml编排项目  

```yaml
version '3.8'
services:
  myapp:
    build: .
    image: myapp:v1
    depends_on:
      - redis
    ports:
      - "8080:8080"

  redis:
    image: "library/redis:alpine"
```

- 丢到服务器运行 docker-compose up 

```shell
docker-compose down			# 关闭容器
docker-compose up --build 	# 重新构建
```



![img](https://img-blog.csdnimg.cn/20200815164213233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center)



![img](https://img-blog.csdnimg.cn/20200815163905484.png#pic_center)

